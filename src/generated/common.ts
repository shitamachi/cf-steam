// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "common.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CAppBootstrapData
 */
export interface CAppBootstrapData {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional bool hidden = 2
     */
    hidden?: boolean;
    /**
     * @generated from protobuf field: repeated string user_tag = 3
     */
    userTag: string[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CAppOverview
 */
export interface CAppOverview {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string display_name = 2
     */
    displayName?: string;
    /**
     * @generated from protobuf field: optional bool visible_in_game_list = 4
     */
    visibleInGameList?: boolean;
    /**
     * @generated from protobuf field: optional bool subscribed_to = 5
     */
    subscribedTo?: boolean;
    /**
     * @generated from protobuf field: optional string sort_as = 6
     */
    sortAs?: string;
    /**
     * @generated from protobuf field: optional int32 app_type = 7
     */
    appType?: number;
    /**
     * @generated from protobuf field: optional uint32 mru_index = 13
     */
    mruIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 rt_recent_activity_time = 14 [default = 0]
     */
    rtRecentActivityTime?: number;
    /**
     * @generated from protobuf field: optional uint32 minutes_playtime_forever = 16 [default = 0]
     */
    minutesPlaytimeForever?: number;
    /**
     * @generated from protobuf field: optional uint32 minutes_playtime_last_two_weeks = 17 [default = 0]
     */
    minutesPlaytimeLastTwoWeeks?: number;
    /**
     * @generated from protobuf field: optional uint32 rt_last_time_played = 18 [default = 0]
     */
    rtLastTimePlayed?: number;
    /**
     * @generated from protobuf field: repeated uint32 store_tag = 19
     */
    storeTag: number[];
    /**
     * @generated from protobuf field: repeated CAppOverview_AppAssociation association = 20
     */
    association: CAppOverview_AppAssociation[];
    /**
     * @generated from protobuf field: repeated uint32 store_category = 23
     */
    storeCategory: number[];
    /**
     * @generated from protobuf field: optional uint32 rt_original_release_date = 25 [default = 0]
     */
    rtOriginalReleaseDate?: number;
    /**
     * @generated from protobuf field: optional uint32 rt_steam_release_date = 26 [default = 0]
     */
    rtSteamReleaseDate?: number;
    /**
     * @generated from protobuf field: optional string icon_hash = 27
     */
    iconHash?: string;
    /**
     * @generated from protobuf field: optional string logo_hash = 30
     */
    logoHash?: string;
    /**
     * @generated from protobuf field: optional int32 controller_support = 31
     */
    controllerSupport?: number;
    /**
     * optional int32 xbox_controller_support = 31 [(.description) = "enum"];
     *
     * @generated from protobuf field: optional bool vr_supported = 32
     */
    vrSupported?: boolean;
    /**
     * @generated from protobuf field: optional uint32 metacritic_score = 36
     */
    metacriticScore?: number;
    /**
     * @generated from protobuf field: optional uint64 size_on_disk = 37
     */
    sizeOnDisk?: bigint;
    /**
     * @generated from protobuf field: optional bool third_party_mod = 38
     */
    thirdPartyMod?: boolean;
    /**
     * @generated from protobuf field: optional string icon_data = 39
     */
    iconData?: string;
    /**
     * @generated from protobuf field: optional string icon_data_format = 40
     */
    iconDataFormat?: string;
    /**
     * @generated from protobuf field: optional string gameid = 41
     */
    gameid?: string;
    /**
     * @generated from protobuf field: optional string library_capsule_filename = 42
     */
    libraryCapsuleFilename?: string;
    /**
     * @generated from protobuf field: repeated CAppOverview_PerClientData per_client_data = 43
     */
    perClientData: CAppOverview_PerClientData[];
    /**
     * @generated from protobuf field: optional uint64 most_available_clientid = 44 [default = 0]
     */
    mostAvailableClientid?: bigint;
    /**
     * @generated from protobuf field: optional uint64 selected_clientid = 45 [default = 0]
     */
    selectedClientid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 rt_store_asset_mtime = 46
     */
    rtStoreAssetMtime?: number;
    /**
     * @generated from protobuf field: optional uint32 rt_custom_image_mtime = 47
     */
    rtCustomImageMtime?: number;
    /**
     * @generated from protobuf field: optional uint32 optional_parent_app_id = 48
     */
    optionalParentAppId?: number;
    /**
     * @generated from protobuf field: optional uint32 owner_account_id = 49
     */
    ownerAccountId?: number;
    /**
     * @generated from protobuf field: optional bool compat_mapping_enabled = 50
     */
    compatMappingEnabled?: boolean;
    /**
     * @generated from protobuf field: optional uint32 compat_mapping_priority = 51
     */
    compatMappingPriority?: number;
    /**
     * @generated from protobuf field: optional string compat_mapping_tool_name = 52
     */
    compatMappingToolName?: string;
    /**
     * @generated from protobuf field: optional uint32 review_score_with_bombs = 53 [default = 0]
     */
    reviewScoreWithBombs?: number;
    /**
     * @generated from protobuf field: optional uint32 review_percentage_with_bombs = 54 [default = 0]
     */
    reviewPercentageWithBombs?: number;
    /**
     * @generated from protobuf field: optional uint32 review_score_without_bombs = 55 [default = 0]
     */
    reviewScoreWithoutBombs?: number;
    /**
     * @generated from protobuf field: optional uint32 review_percentage_without_bombs = 56 [default = 0]
     */
    reviewPercentageWithoutBombs?: number;
    /**
     * @generated from protobuf field: optional string library_id = 57
     */
    libraryId?: string;
    /**
     * @generated from protobuf field: optional bool vr_only = 58
     */
    vrOnly?: boolean;
    /**
     * @generated from protobuf field: optional uint32 mastersub_appid = 59
     */
    mastersubAppid?: number;
    /**
     * @generated from protobuf field: optional string mastersub_includedwith_logo = 60
     */
    mastersubIncludedwithLogo?: string;
    /**
     * @generated from protobuf field: optional uint32 compat_allowlist_setting = 61 [default = 0]
     */
    compatAllowlistSetting?: number;
    /**
     * @generated from protobuf field: optional string site_license_site_name = 62
     */
    siteLicenseSiteName?: string;
    /**
     * @generated from protobuf field: optional uint32 shortcut_override_appid = 63
     */
    shortcutOverrideAppid?: number;
    /**
     * @generated from protobuf field: optional uint32 rt_last_time_locally_played = 65
     */
    rtLastTimeLocallyPlayed?: number;
    /**
     * @generated from protobuf field: optional uint32 rt_purchased_time = 66
     */
    rtPurchasedTime?: number;
    /**
     * @generated from protobuf field: optional string header_filename = 67
     */
    headerFilename?: string;
    /**
     * @generated from protobuf field: optional uint32 local_cache_version = 68
     */
    localCacheVersion?: number;
    /**
     * @generated from protobuf field: optional uint32 number_of_copies = 72 [default = 1]
     */
    numberOfCopies?: number;
    /**
     * @generated from protobuf field: optional uint32 steam_hw_compat_category_packed = 73 [default = 0]
     */
    steamHwCompatCategoryPacked?: number;
    /**
     * @generated from protobuf field: optional string album_cover_hash = 74
     */
    albumCoverHash?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CAppOverview_AppAssociation
 */
export interface CAppOverview_AppAssociation {
    /**
     * @generated from protobuf field: optional int32 type = 1
     */
    type?: number;
    /**
     * @generated from protobuf field: optional string name = 2
     */
    name?: string;
}
/**
 * @generated from protobuf message CAppOverview_Change
 */
export interface CAppOverview_Change {
    /**
     * @generated from protobuf field: repeated CAppOverview app_overview = 1
     */
    appOverview: CAppOverview[];
    /**
     * @generated from protobuf field: repeated uint32 removed_appid = 2
     */
    removedAppid: number[];
    /**
     * @generated from protobuf field: optional bool full_update = 3
     */
    fullUpdate?: boolean;
    /**
     * @generated from protobuf field: optional bool update_complete = 4
     */
    updateComplete?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CAppOverview_PerClientData
 */
export interface CAppOverview_PerClientData {
    /**
     * @generated from protobuf field: optional uint64 clientid = 1 [default = 0]
     */
    clientid?: bigint;
    /**
     * @generated from protobuf field: optional string client_name = 2
     */
    clientName?: string;
    /**
     * @generated from protobuf field: optional int32 display_status = 3
     */
    displayStatus?: number;
    /**
     * @generated from protobuf field: optional uint32 status_percentage = 4
     */
    statusPercentage?: number;
    /**
     * @generated from protobuf field: optional string active_beta = 5
     */
    activeBeta?: string;
    /**
     * @generated from protobuf field: optional bool installed = 6
     */
    installed?: boolean;
    /**
     * @generated from protobuf field: optional uint64 bytes_downloaded = 7 [default = 0]
     */
    bytesDownloaded?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes_total = 8 [default = 0]
     */
    bytesTotal?: bigint;
    /**
     * @generated from protobuf field: optional bool streaming_to_local_client = 9
     */
    streamingToLocalClient?: boolean;
    /**
     * @generated from protobuf field: optional bool is_available_on_current_platform = 10
     */
    isAvailableOnCurrentPlatform?: boolean;
    /**
     * @generated from protobuf field: optional bool is_invalid_os_type = 11
     */
    isInvalidOsType?: boolean;
    /**
     * @generated from protobuf field: optional uint32 playtime_left = 12
     */
    playtimeLeft?: number;
    /**
     * @generated from protobuf field: optional bool update_available_but_disabled_by_app = 14
     */
    updateAvailableButDisabledByApp?: boolean;
}
/**
 * Used by: AccountCart, Checkout
 *
 * @generated from protobuf message CartAmount
 */
export interface CartAmount {
    /**
     * @generated from protobuf field: optional int64 amount_in_cents = 1
     */
    amountInCents?: bigint;
    /**
     * @generated from protobuf field: optional int32 currency_code = 2
     */
    currencyCode?: number;
    /**
     * @generated from protobuf field: optional string formatted_amount = 3
     */
    formattedAmount?: string;
}
/**
 * Used by: AccountCart, Checkout
 *
 * @generated from protobuf message CartCoupon
 */
export interface CartCoupon {
    /**
     * @generated from protobuf field: optional uint32 couponid = 1
     */
    couponid?: number;
    /**
     * @generated from protobuf field: optional uint64 gidcoupon = 2
     */
    gidcoupon?: bigint;
    /**
     * @generated from protobuf field: optional string title = 5
     */
    title?: string;
    /**
     * @generated from protobuf field: optional string coupon_description = 6
     */
    couponDescription?: string;
    /**
     * @generated from protobuf field: optional string large_icon_url = 7
     */
    largeIconUrl?: string;
    /**
     * @generated from protobuf field: optional int32 discount_pct = 8
     */
    discountPct?: number;
}
/**
 * Used by: AccountCart, Checkout
 *
 * @generated from protobuf message CartGiftInfo
 */
export interface CartGiftInfo {
    /**
     * @generated from protobuf field: optional int32 accountid_giftee = 1
     */
    accountidGiftee?: number;
    /**
     * @generated from protobuf field: optional CartGiftMessage gift_message = 2
     */
    giftMessage?: CartGiftMessage;
    /**
     * @generated from protobuf field: optional int32 time_scheduled_send = 3
     */
    timeScheduledSend?: number;
}
/**
 * Used by: AccountCart, Checkout
 *
 * @generated from protobuf message CartGiftMessage
 */
export interface CartGiftMessage {
    /**
     * @generated from protobuf field: optional string gifteename = 1
     */
    gifteename?: string;
    /**
     * @generated from protobuf field: optional string message = 2
     */
    message?: string;
    /**
     * @generated from protobuf field: optional string sentiment = 3
     */
    sentiment?: string;
    /**
     * @generated from protobuf field: optional string signature = 4
     */
    signature?: string;
}
/**
 * @generated from protobuf message CBilling_Address
 */
export interface CBilling_Address {
    /**
     * @generated from protobuf field: optional string first_name = 1
     */
    firstName?: string;
    /**
     * @generated from protobuf field: optional string last_name = 2
     */
    lastName?: string;
    /**
     * @generated from protobuf field: optional string address1 = 3
     */
    address1?: string;
    /**
     * @generated from protobuf field: optional string address2 = 4
     */
    address2?: string;
    /**
     * @generated from protobuf field: optional string city = 5
     */
    city?: string;
    /**
     * @generated from protobuf field: optional string us_state = 6
     */
    usState?: string;
    /**
     * @generated from protobuf field: optional string country_code = 7
     */
    countryCode?: string;
    /**
     * @generated from protobuf field: optional string postcode = 8
     */
    postcode?: string;
    /**
     * @generated from protobuf field: optional int32 zip_plus4 = 9
     */
    zipPlus4?: number;
    /**
     * @generated from protobuf field: optional string phone = 10
     */
    phone?: string;
}
/**
 * Used by: ChatRoom, ChatRoomClient, ClanChatRooms
 *
 * @generated from protobuf message CChatPartyBeacon
 */
export interface CChatPartyBeacon {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid_owner = 2
     */
    steamidOwner?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 beacon_id = 3
     */
    beaconId?: bigint;
    /**
     * @generated from protobuf field: optional string game_metadata = 4
     */
    gameMetadata?: string;
}
/**
 * Used by: ChatRoom, ChatRoomClient, ClanChatRooms
 *
 * @generated from protobuf message CChatRoleActions
 */
export interface CChatRoleActions {
    /**
     * @generated from protobuf field: optional uint64 role_id = 1
     */
    roleId?: bigint;
    /**
     * @generated from protobuf field: optional bool can_create_rename_delete_channel = 2
     */
    canCreateRenameDeleteChannel?: boolean;
    /**
     * @generated from protobuf field: optional bool can_kick = 3
     */
    canKick?: boolean;
    /**
     * @generated from protobuf field: optional bool can_ban = 4
     */
    canBan?: boolean;
    /**
     * @generated from protobuf field: optional bool can_invite = 5
     */
    canInvite?: boolean;
    /**
     * @generated from protobuf field: optional bool can_change_tagline_avatar_name = 6
     */
    canChangeTaglineAvatarName?: boolean;
    /**
     * @generated from protobuf field: optional bool can_chat = 7
     */
    canChat?: boolean;
    /**
     * @generated from protobuf field: optional bool can_view_history = 8
     */
    canViewHistory?: boolean;
    /**
     * @generated from protobuf field: optional bool can_change_group_roles = 9
     */
    canChangeGroupRoles?: boolean;
    /**
     * @generated from protobuf field: optional bool can_change_user_roles = 10
     */
    canChangeUserRoles?: boolean;
    /**
     * @generated from protobuf field: optional bool can_mention_all = 11
     */
    canMentionAll?: boolean;
    /**
     * @generated from protobuf field: optional bool can_set_watching_broadcast = 12
     */
    canSetWatchingBroadcast?: boolean;
}
/**
 * Used by: ChatRoom, ChatRoomClient, ClanChatRooms
 *
 * @generated from protobuf message CChatRoom_GetChatRoomGroupSummary_Response
 */
export interface CChatRoom_GetChatRoomGroupSummary_Response {
    /**
     * @generated from protobuf field: optional uint64 chat_group_id = 1
     */
    chatGroupId?: bigint;
    /**
     * @generated from protobuf field: optional string chat_group_name = 2
     */
    chatGroupName?: string;
    /**
     * @generated from protobuf field: optional uint32 active_member_count = 3
     */
    activeMemberCount?: number;
    /**
     * @generated from protobuf field: optional uint32 active_voice_member_count = 4
     */
    activeVoiceMemberCount?: number;
    /**
     * @generated from protobuf field: optional uint64 default_chat_id = 5
     */
    defaultChatId?: bigint;
    /**
     * @generated from protobuf field: repeated CChatRoomState chat_rooms = 6
     */
    chatRooms: CChatRoomState[];
    /**
     * @generated from protobuf field: optional uint32 clanid = 7
     */
    clanid?: number;
    /**
     * @generated from protobuf field: optional string chat_group_tagline = 8
     */
    chatGroupTagline?: string;
    /**
     * @generated from protobuf field: optional uint32 accountid_owner = 9
     */
    accountidOwner?: number;
    /**
     * @generated from protobuf field: repeated uint32 top_members = 10
     */
    topMembers: number[];
    /**
     * @generated from protobuf field: optional bytes chat_group_avatar_sha = 11
     */
    chatGroupAvatarSha?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 rank = 12
     */
    rank?: number;
    /**
     * @generated from protobuf field: optional uint64 default_role_id = 13
     */
    defaultRoleId?: bigint;
    /**
     * @generated from protobuf field: repeated uint64 role_ids = 14
     */
    roleIds: bigint[];
    /**
     * @generated from protobuf field: repeated CChatRoleActions role_actions = 15
     */
    roleActions: CChatRoleActions[];
    /**
     * @generated from protobuf field: optional uint32 watching_broadcast_accountid = 16
     */
    watchingBroadcastAccountid?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 17
     */
    appid?: number;
    /**
     * @generated from protobuf field: repeated CChatPartyBeacon party_beacons = 18
     */
    partyBeacons: CChatPartyBeacon[];
    /**
     * @generated from protobuf field: optional uint64 watching_broadcast_channel_id = 19
     */
    watchingBroadcastChannelId?: bigint;
    /**
     * @generated from protobuf field: optional uint64 active_minigame_id = 20
     */
    activeMinigameId?: bigint;
    /**
     * @generated from protobuf field: optional string avatar_ugc_url = 21
     */
    avatarUgcUrl?: string;
    /**
     * @generated from protobuf field: optional bool disabled = 22
     */
    disabled?: boolean;
}
/**
 * Used by: ChatRoom, ChatRoomClient, ClanChatRooms
 *
 * @generated from protobuf message CChatRoomState
 */
export interface CChatRoomState {
    /**
     * @generated from protobuf field: optional uint64 chat_id = 1
     */
    chatId?: bigint;
    /**
     * @generated from protobuf field: optional string chat_name = 2
     */
    chatName?: string;
    /**
     * @generated from protobuf field: optional bool voice_allowed = 3
     */
    voiceAllowed?: boolean;
    /**
     * @generated from protobuf field: repeated uint32 members_in_voice = 4
     */
    membersInVoice: number[];
    /**
     * @generated from protobuf field: optional uint32 time_last_message = 5
     */
    timeLastMessage?: number;
    /**
     * @generated from protobuf field: optional uint32 sort_order = 6
     */
    sortOrder?: number;
    /**
     * @generated from protobuf field: optional string last_message = 7
     */
    lastMessage?: string;
    /**
     * @generated from protobuf field: optional uint32 accountid_last_message = 8
     */
    accountidLastMessage?: number;
}
/**
 * @generated from protobuf message CClanEventData
 */
export interface CClanEventData {
    /**
     * @generated from protobuf field: optional fixed64 gid = 1
     */
    gid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 clan_steamid = 2
     */
    clanSteamid?: bigint;
    /**
     * @generated from protobuf field: optional string event_name = 3
     */
    eventName?: string;
    /**
     * @generated from protobuf field: optional int32 event_type = 4
     */
    eventType?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 5
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string server_address = 6
     */
    serverAddress?: string;
    /**
     * @generated from protobuf field: optional string server_password = 7
     */
    serverPassword?: string;
    /**
     * @generated from protobuf field: optional uint32 rtime32_start_time = 8
     */
    rtime32StartTime?: number;
    /**
     * @generated from protobuf field: optional uint32 rtime32_end_time = 9
     */
    rtime32EndTime?: number;
    /**
     * @generated from protobuf field: optional int32 comment_count = 10
     */
    commentCount?: number;
    /**
     * @generated from protobuf field: optional fixed64 creator_steamid = 11
     */
    creatorSteamid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 last_update_steamid = 12
     */
    lastUpdateSteamid?: bigint;
    /**
     * @generated from protobuf field: optional string event_notes = 13
     */
    eventNotes?: string;
    /**
     * @generated from protobuf field: optional string jsondata = 14
     */
    jsondata?: string;
    /**
     * @generated from protobuf field: optional CCommunity_ClanAnnouncementInfo announcement_body = 15
     */
    announcementBody?: CCommunity_ClanAnnouncementInfo;
    /**
     * @generated from protobuf field: optional bool published = 16
     */
    published?: boolean;
    /**
     * @generated from protobuf field: optional bool hidden = 17
     */
    hidden?: boolean;
    /**
     * @generated from protobuf field: optional uint32 rtime32_visibility_start = 18
     */
    rtime32VisibilityStart?: number;
    /**
     * @generated from protobuf field: optional uint32 rtime32_visibility_end = 19
     */
    rtime32VisibilityEnd?: number;
    /**
     * @generated from protobuf field: optional uint32 broadcaster_accountid = 20
     */
    broadcasterAccountid?: number;
    /**
     * @generated from protobuf field: optional uint32 follower_count = 21
     */
    followerCount?: number;
    /**
     * @generated from protobuf field: optional uint32 ignore_count = 22
     */
    ignoreCount?: number;
    /**
     * @generated from protobuf field: optional fixed64 forum_topic_id = 23
     */
    forumTopicId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 rtime32_last_modified = 24
     */
    rtime32LastModified?: number;
    /**
     * @generated from protobuf field: optional fixed64 news_post_gid = 25
     */
    newsPostGid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 rtime_mod_reviewed = 26
     */
    rtimeModReviewed?: number;
    /**
     * @generated from protobuf field: optional uint32 featured_app_tagid = 27
     */
    featuredAppTagid?: number;
    /**
     * @generated from protobuf field: repeated uint32 referenced_appids = 28
     */
    referencedAppids: number[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_AppInterfaceCreation
 */
export interface CClientMetrics_AppInterfaceCreation {
    /**
     * @generated from protobuf field: optional string raw_version = 1
     */
    rawVersion?: string;
    /**
     * @generated from protobuf field: optional string requested_interface_type = 2
     */
    requestedInterfaceType?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_AppInterfaceMethodCounts
 */
export interface CClientMetrics_AppInterfaceMethodCounts {
    /**
     * @generated from protobuf field: optional string interface_name = 1
     */
    interfaceName?: string;
    /**
     * @generated from protobuf field: optional string method_name = 2
     */
    methodName?: string;
    /**
     * @generated from protobuf field: optional uint32 call_count = 3
     */
    callCount?: number;
}
/**
 * @generated from protobuf message CClientMetrics_AppInterfaceStats_Notification
 */
export interface CClientMetrics_AppInterfaceStats_Notification {
    /**
     * @generated from protobuf field: optional uint64 game_id = 1
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: repeated CClientMetrics_AppInterfaceCreation interfaces_created = 2
     */
    interfacesCreated: CClientMetrics_AppInterfaceCreation[];
    /**
     * @generated from protobuf field: repeated CClientMetrics_AppInterfaceMethodCounts methods_called = 3
     */
    methodsCalled: CClientMetrics_AppInterfaceMethodCounts[];
    /**
     * @generated from protobuf field: optional uint32 session_length_seconds = 4
     */
    sessionLengthSeconds?: number;
}
/**
 * @generated from protobuf message CClientMetrics_ClientBootstrap_Notification
 */
export interface CClientMetrics_ClientBootstrap_Notification {
    /**
     * @generated from protobuf field: optional CClientMetrics_ClientBootstrap_Summary summary = 1
     */
    summary?: CClientMetrics_ClientBootstrap_Summary;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_ClientBootstrap_RequestInfo
 */
export interface CClientMetrics_ClientBootstrap_RequestInfo {
    /**
     * @generated from protobuf field: optional string original_hostname = 1
     */
    originalHostname?: string;
    /**
     * @generated from protobuf field: optional string actual_hostname = 2
     */
    actualHostname?: string;
    /**
     * @generated from protobuf field: optional string path = 3
     */
    path?: string;
    /**
     * @generated from protobuf field: optional string base_name = 4
     */
    baseName?: string;
    /**
     * @generated from protobuf field: optional bool success = 5
     */
    success?: boolean;
    /**
     * @generated from protobuf field: optional uint32 status_code = 6
     */
    statusCode?: number;
    /**
     * @generated from protobuf field: optional string address_of_request_url = 7
     */
    addressOfRequestUrl?: string;
    /**
     * @generated from protobuf field: optional uint32 response_time_ms = 8
     */
    responseTimeMs?: number;
    /**
     * @generated from protobuf field: optional uint64 bytes_received = 9
     */
    bytesReceived?: bigint;
    /**
     * @generated from protobuf field: optional uint32 num_retries = 10
     */
    numRetries?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_ClientBootstrap_Summary
 */
export interface CClientMetrics_ClientBootstrap_Summary {
    /**
     * @generated from protobuf field: optional uint32 launcher_type = 1
     */
    launcherType?: number;
    /**
     * @generated from protobuf field: optional uint32 steam_realm = 2
     */
    steamRealm?: number;
    /**
     * @generated from protobuf field: optional string beta_name = 3
     */
    betaName?: string;
    /**
     * @generated from protobuf field: optional bool download_completed = 4
     */
    downloadCompleted?: boolean;
    /**
     * @generated from protobuf field: optional uint32 total_time_ms = 6
     */
    totalTimeMs?: number;
    /**
     * @generated from protobuf field: repeated CClientMetrics_ClientBootstrap_RequestInfo manifest_requests = 7
     */
    manifestRequests: CClientMetrics_ClientBootstrap_RequestInfo[];
    /**
     * @generated from protobuf field: repeated CClientMetrics_ClientBootstrap_RequestInfo package_requests = 8
     */
    packageRequests: CClientMetrics_ClientBootstrap_RequestInfo[];
}
/**
 * @generated from protobuf message CClientMetrics_ClipRange_Notification
 */
export interface CClientMetrics_ClipRange_Notification {
    /**
     * @generated from protobuf field: optional int32 original_range_method = 1
     */
    originalRangeMethod?: number;
    /**
     * @generated from protobuf field: optional CClientMetrics_ClipRange_Notification_RelativeRangeEdge start = 2
     */
    start?: CClientMetrics_ClipRange_Notification_RelativeRangeEdge;
    /**
     * @generated from protobuf field: optional CClientMetrics_ClipRange_Notification_RelativeRangeEdge end = 3
     */
    end?: CClientMetrics_ClipRange_Notification_RelativeRangeEdge;
    /**
     * @generated from protobuf field: optional float seconds = 4
     */
    seconds?: number;
    /**
     * @generated from protobuf field: optional fixed64 gameid = 5
     */
    gameid?: bigint;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_ClipRange_Notification_RelativeRangeEdge
 */
export interface CClientMetrics_ClipRange_Notification_RelativeRangeEdge {
    /**
     * @generated from protobuf field: optional int32 original_range_method = 1
     */
    originalRangeMethod?: number;
    /**
     * @generated from protobuf field: optional int32 latest_range_method = 2
     */
    latestRangeMethod?: number;
    /**
     * @generated from protobuf field: optional int32 delta_ms = 3
     */
    deltaMs?: number;
}
/**
 * @generated from protobuf message CClientMetrics_ClipShare_Notification
 */
export interface CClientMetrics_ClipShare_Notification {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 share_method = 2
     */
    shareMethod?: number;
    /**
     * @generated from protobuf field: optional float seconds = 3
     */
    seconds?: number;
    /**
     * @generated from protobuf field: optional uint64 bytes = 4
     */
    bytes?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 gameid = 5
     */
    gameid?: bigint;
}
/**
 * @generated from protobuf message CClientMetrics_CloudAppSyncStats_Notification
 */
export interface CClientMetrics_CloudAppSyncStats_Notification {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 platform_type = 2
     */
    platformType?: number;
    /**
     * @generated from protobuf field: optional bool preload = 3
     */
    preload?: boolean;
    /**
     * @generated from protobuf field: optional bool blocking_app_launch = 4
     */
    blockingAppLaunch?: boolean;
    /**
     * @generated from protobuf field: optional uint32 files_uploaded = 5
     */
    filesUploaded?: number;
    /**
     * @generated from protobuf field: optional uint32 files_downloaded = 6
     */
    filesDownloaded?: number;
    /**
     * @generated from protobuf field: optional uint32 files_deleted = 7
     */
    filesDeleted?: number;
    /**
     * @generated from protobuf field: optional uint64 bytes_uploaded = 8
     */
    bytesUploaded?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes_downloaded = 9
     */
    bytesDownloaded?: bigint;
    /**
     * @generated from protobuf field: optional uint64 microsec_total = 10
     */
    microsecTotal?: bigint;
    /**
     * @generated from protobuf field: optional uint64 microsec_init_caches = 11
     */
    microsecInitCaches?: bigint;
    /**
     * @generated from protobuf field: optional uint64 microsec_validate_state = 12
     */
    microsecValidateState?: bigint;
    /**
     * @generated from protobuf field: optional uint64 microsec_ac_launch = 13
     */
    microsecAcLaunch?: bigint;
    /**
     * @generated from protobuf field: optional uint64 microsec_ac_prep_user_files = 14
     */
    microsecAcPrepUserFiles?: bigint;
    /**
     * @generated from protobuf field: optional uint64 microsec_ac_exit = 15
     */
    microsecAcExit?: bigint;
    /**
     * @generated from protobuf field: optional uint64 microsec_build_sync_list = 16
     */
    microsecBuildSyncList?: bigint;
    /**
     * @generated from protobuf field: optional uint64 microsec_delete_files = 17
     */
    microsecDeleteFiles?: bigint;
    /**
     * @generated from protobuf field: optional uint64 microsec_download_files = 18
     */
    microsecDownloadFiles?: bigint;
    /**
     * @generated from protobuf field: optional uint64 microsec_upload_files = 19
     */
    microsecUploadFiles?: bigint;
    /**
     * @generated from protobuf field: optional uint32 hardware_type = 20
     */
    hardwareType?: number;
    /**
     * @generated from protobuf field: optional uint32 files_managed = 21
     */
    filesManaged?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_ContentDownloadResponse_Counts
 */
export interface CClientMetrics_ContentDownloadResponse_Counts {
    /**
     * @generated from protobuf field: optional uint32 class_100 = 1
     */
    class100?: number;
    /**
     * @generated from protobuf field: optional uint32 class_200 = 2
     */
    class200?: number;
    /**
     * @generated from protobuf field: optional uint32 class_300 = 3
     */
    class300?: number;
    /**
     * @generated from protobuf field: optional uint32 class_400 = 4
     */
    class400?: number;
    /**
     * @generated from protobuf field: optional uint32 class_500 = 5
     */
    class500?: number;
    /**
     * @generated from protobuf field: optional uint32 no_response = 6
     */
    noResponse?: number;
    /**
     * @generated from protobuf field: optional uint32 class_unknown = 7
     */
    classUnknown?: number;
}
/**
 * @generated from protobuf message CClientMetrics_ContentDownloadResponse_Counts_Notification
 */
export interface CClientMetrics_ContentDownloadResponse_Counts_Notification {
    /**
     * @generated from protobuf field: optional uint32 cell_id = 1
     */
    cellId?: number;
    /**
     * @generated from protobuf field: optional CClientMetrics_ContentDownloadResponse_Hosts data = 2
     */
    data?: CClientMetrics_ContentDownloadResponse_Hosts;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_ContentDownloadResponse_HostCounts
 */
export interface CClientMetrics_ContentDownloadResponse_HostCounts {
    /**
     * @generated from protobuf field: optional string hostname = 1
     */
    hostname?: string;
    /**
     * @generated from protobuf field: optional uint32 source_type = 2
     */
    sourceType?: number;
    /**
     * @generated from protobuf field: optional CClientMetrics_ContentDownloadResponse_Counts counts = 3
     */
    counts?: CClientMetrics_ContentDownloadResponse_Counts;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_ContentDownloadResponse_Hosts
 */
export interface CClientMetrics_ContentDownloadResponse_Hosts {
    /**
     * @generated from protobuf field: repeated CClientMetrics_ContentDownloadResponse_HostCounts hosts = 1
     */
    hosts: CClientMetrics_ContentDownloadResponse_HostCounts[];
}
/**
 * @generated from protobuf message CClientMetrics_ContentValidation_Notification
 */
export interface CClientMetrics_ContentValidation_Notification {
    /**
     * @generated from protobuf field: optional int32 validation_result = 1
     */
    validationResult?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional bool staged_files = 3
     */
    stagedFiles?: boolean;
    /**
     * @generated from protobuf field: optional bool user_initiated = 4
     */
    userInitiated?: boolean;
    /**
     * @generated from protobuf field: optional bool early_out = 5
     */
    earlyOut?: boolean;
    /**
     * @generated from protobuf field: optional uint32 chunks_scanned = 6
     */
    chunksScanned?: number;
    /**
     * @generated from protobuf field: optional uint32 chunks_corrupt = 7
     */
    chunksCorrupt?: number;
    /**
     * @generated from protobuf field: optional uint64 bytes_scanned = 8
     */
    bytesScanned?: bigint;
    /**
     * @generated from protobuf field: optional uint64 chunk_bytes_corrupt = 9
     */
    chunkBytesCorrupt?: bigint;
    /**
     * @generated from protobuf field: optional uint64 total_file_size_corrupt = 10
     */
    totalFileSizeCorrupt?: bigint;
}
/**
 * @generated from protobuf message CClientMetrics_DownloadRates_Notification
 */
export interface CClientMetrics_DownloadRates_Notification {
    /**
     * @generated from protobuf field: optional uint32 cell_id = 1
     */
    cellId?: number;
    /**
     * @generated from protobuf field: repeated CClientMetrics_DownloadRates_Notification_StatsInfo stats = 2
     */
    stats: CClientMetrics_DownloadRates_Notification_StatsInfo[];
    /**
     * @generated from protobuf field: optional uint32 throttling_kbps = 3
     */
    throttlingKbps?: number;
    /**
     * @generated from protobuf field: optional uint32 os_type = 4
     */
    osType?: number;
    /**
     * @generated from protobuf field: optional uint32 device_type = 5
     */
    deviceType?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_DownloadRates_Notification_StatsInfo
 */
export interface CClientMetrics_DownloadRates_Notification_StatsInfo {
    /**
     * @generated from protobuf field: optional uint32 source_type = 1
     */
    sourceType?: number;
    /**
     * @generated from protobuf field: optional uint32 source_id = 2
     */
    sourceId?: number;
    /**
     * @generated from protobuf field: optional uint64 bytes = 3
     */
    bytes?: bigint;
    /**
     * @generated from protobuf field: optional string host_name = 4
     */
    hostName?: string;
    /**
     * @generated from protobuf field: optional uint64 microseconds = 5
     */
    microseconds?: bigint;
    /**
     * @generated from protobuf field: optional bool used_ipv6 = 6
     */
    usedIpv6?: boolean;
    /**
     * @generated from protobuf field: optional bool proxied = 7
     */
    proxied?: boolean;
    /**
     * @generated from protobuf field: optional bool used_http2 = 8
     */
    usedHttp2?: boolean;
    /**
     * @generated from protobuf field: optional uint32 cache_hits = 9
     */
    cacheHits?: number;
    /**
     * @generated from protobuf field: optional uint32 cache_misses = 10
     */
    cacheMisses?: number;
    /**
     * @generated from protobuf field: optional uint64 hit_bytes = 11
     */
    hitBytes?: bigint;
    /**
     * @generated from protobuf field: optional uint64 miss_bytes = 12
     */
    missBytes?: bigint;
}
/**
 * @generated from protobuf message CClientMetrics_EndGameRecording_Notification
 */
export interface CClientMetrics_EndGameRecording_Notification {
    /**
     * @generated from protobuf field: optional int32 recording_type = 1
     */
    recordingType?: number;
    /**
     * @generated from protobuf field: optional float seconds = 2
     */
    seconds?: number;
    /**
     * @generated from protobuf field: optional uint64 bytes = 3
     */
    bytes?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 gameid = 4
     */
    gameid?: bigint;
    /**
     * @generated from protobuf field: optional bool instant_clip = 5
     */
    instantClip?: boolean;
}
/**
 * @generated from protobuf message CClientMetrics_GamePerformance_Notification
 */
export interface CClientMetrics_GamePerformance_Notification {
    /**
     * @generated from protobuf field: repeated CClientMetrics_GamePerformance_Notification_FrameRateReport reports = 1
     */
    reports: CClientMetrics_GamePerformance_Notification_FrameRateReport[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_GamePerformance_Notification_FrameRateReport
 */
export interface CClientMetrics_GamePerformance_Notification_FrameRateReport {
    /**
     * @generated from protobuf field: optional fixed64 gameid = 1
     */
    gameid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 frame_rate = 2
     */
    frameRate?: number;
    /**
     * @generated from protobuf field: optional string manufacturer = 3
     */
    manufacturer?: string;
    /**
     * @generated from protobuf field: optional string model = 4
     */
    model?: string;
    /**
     * @generated from protobuf field: optional string dx_video_card = 5
     */
    dxVideoCard?: string;
    /**
     * @generated from protobuf field: optional int32 dx_vendorid = 6
     */
    dxVendorid?: number;
    /**
     * @generated from protobuf field: optional int32 dx_deviceid = 7
     */
    dxDeviceid?: number;
    /**
     * @generated from protobuf field: optional uint32 num_gpu = 8
     */
    numGpu?: number;
    /**
     * @generated from protobuf field: optional uint64 system_ram = 9
     */
    systemRam?: bigint;
    /**
     * @generated from protobuf field: optional int32 session_seconds = 10
     */
    sessionSeconds?: number;
}
/**
 * @generated from protobuf message CClientMetrics_IPv6Connectivity_Notification
 */
export interface CClientMetrics_IPv6Connectivity_Notification {
    /**
     * @generated from protobuf field: optional uint32 cell_id = 1
     */
    cellId?: number;
    /**
     * @generated from protobuf field: repeated CClientMetrics_IPv6Connectivity_Result results = 2
     */
    results: CClientMetrics_IPv6Connectivity_Result[];
    /**
     * @generated from protobuf field: optional bool private_ip_is_rfc6598 = 3
     */
    privateIpIsRfc6598?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_IPv6Connectivity_Result
 */
export interface CClientMetrics_IPv6Connectivity_Result {
    /**
     * @generated from protobuf field: optional uint32 protocol_tested = 1
     */
    protocolTested?: number;
    /**
     * @generated from protobuf field: optional uint32 connectivity_state = 2
     */
    connectivityState?: number;
}
/**
 * @generated from protobuf message CClientMetrics_SteamPipeWorkStats_Notification
 */
export interface CClientMetrics_SteamPipeWorkStats_Notification {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 depotid = 2
     */
    depotid?: number;
    /**
     * @generated from protobuf field: optional int32 work_type = 3
     */
    workType?: number;
    /**
     * @generated from protobuf field: repeated CClientMetrics_SteamPipeWorkStats_Operation operations = 4
     */
    operations: CClientMetrics_SteamPipeWorkStats_Operation[];
    /**
     * @generated from protobuf field: optional uint32 hardware_type = 5
     */
    hardwareType?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CClientMetrics_SteamPipeWorkStats_Operation
 */
export interface CClientMetrics_SteamPipeWorkStats_Operation {
    /**
     * @generated from protobuf field: optional int32 type = 1
     */
    type?: number;
    /**
     * @generated from protobuf field: optional uint32 num_ops = 2
     */
    numOps?: number;
    /**
     * @generated from protobuf field: optional uint64 num_bytes = 3
     */
    numBytes?: bigint;
    /**
     * @generated from protobuf field: optional uint64 busy_time_ms = 4
     */
    busyTimeMs?: bigint;
    /**
     * @generated from protobuf field: optional uint64 idle_time_ms = 5
     */
    idleTimeMs?: bigint;
    /**
     * @generated from protobuf field: optional uint64 sum_run_time_ms = 6
     */
    sumRunTimeMs?: bigint;
    /**
     * @generated from protobuf field: optional uint64 sum_wait_time_ms = 7
     */
    sumWaitTimeMs?: bigint;
}
/**
 * @generated from protobuf message CClientNotificationAchievement
 */
export interface CClientNotificationAchievement {
    /**
     * @generated from protobuf field: optional string achievement_id = 1
     */
    achievementId?: string;
    /**
     * @generated from protobuf field: optional uint32 appid = 2
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string name = 3
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string description = 4
     */
    description?: string;
    /**
     * @generated from protobuf field: optional string image_url = 5
     */
    imageUrl?: string;
    /**
     * @generated from protobuf field: optional bool achieved = 6
     */
    achieved?: boolean;
    /**
     * @generated from protobuf field: optional uint32 rtime_unlocked = 7
     */
    rtimeUnlocked?: number;
    /**
     * @generated from protobuf field: optional float min_progress = 8
     */
    minProgress?: number;
    /**
     * @generated from protobuf field: optional float current_progress = 9
     */
    currentProgress?: number;
    /**
     * @generated from protobuf field: optional float max_progress = 10
     */
    maxProgress?: number;
    /**
     * @generated from protobuf field: optional float global_achieved_pct = 11
     */
    globalAchievedPct?: number;
}
/**
 * @generated from protobuf message CClientNotificationBatteryTemperature
 */
export interface CClientNotificationBatteryTemperature {
    /**
     * @generated from protobuf field: optional uint32 temperature = 1
     */
    temperature?: number;
    /**
     * @generated from protobuf field: optional string notification_type = 2
     */
    notificationType?: string;
}
/**
 * @generated from protobuf message CClientNotificationBroadcastAvailableToWatch
 */
export interface CClientNotificationBroadcastAvailableToWatch {
    /**
     * @generated from protobuf field: optional int32 broadcast_permission = 1
     */
    broadcastPermission?: number;
}
/**
 * @generated from protobuf message CClientNotificationCannotReadControllerGuideButton
 */
export interface CClientNotificationCannotReadControllerGuideButton {
    /**
     * @generated from protobuf field: optional int32 controller_index = 1
     */
    controllerIndex?: number;
}
/**
 * @generated from protobuf message CClientNotificationClaimSteamDeckRewards
 */
export interface CClientNotificationClaimSteamDeckRewards {
}
/**
 * @generated from protobuf message CClientNotificationCloudSyncConflict
 */
export interface CClientNotificationCloudSyncConflict {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
}
/**
 * @generated from protobuf message CClientNotificationCloudSyncFailure
 */
export interface CClientNotificationCloudSyncFailure {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
}
/**
 * @generated from protobuf message CClientNotificationDockUnsupportedFirmware
 */
export interface CClientNotificationDockUnsupportedFirmware {
}
/**
 * @generated from protobuf message CClientNotificationDownloadCompleted
 */
export interface CClientNotificationDownloadCompleted {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 dlc_appid = 2
     */
    dlcAppid?: number;
}
/**
 * @generated from protobuf message CClientNotificationFamilySharingStopPlaying
 */
export interface CClientNotificationFamilySharingStopPlaying {
    /**
     * @generated from protobuf field: optional uint32 accountid_owner = 1
     */
    accountidOwner?: number;
    /**
     * @generated from protobuf field: optional uint32 seconds_remaining = 2
     */
    secondsRemaining?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 3
     */
    appid?: number;
}
/**
 * @generated from protobuf message CClientNotificationFriendInGame
 */
export interface CClientNotificationFriendInGame {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string game_name = 2
     */
    gameName?: string;
}
/**
 * @generated from protobuf message CClientNotificationFriendInviteRollup
 */
export interface CClientNotificationFriendInviteRollup {
    /**
     * @generated from protobuf field: optional uint32 new_invite_count = 1
     */
    newInviteCount?: number;
}
/**
 * @generated from protobuf message CClientNotificationFriendMessage
 */
export interface CClientNotificationFriendMessage {
    /**
     * @generated from protobuf field: optional string tag = 1
     */
    tag?: string;
    /**
     * @generated from protobuf field: optional string steamid = 2
     */
    steamid?: string;
    /**
     * @generated from protobuf field: optional string title = 3
     */
    title?: string;
    /**
     * @generated from protobuf field: optional string body = 4
     */
    body?: string;
    /**
     * @generated from protobuf field: optional string icon = 5
     */
    icon?: string;
    /**
     * @generated from protobuf field: optional uint32 notificationid = 6
     */
    notificationid?: number;
    /**
     * @generated from protobuf field: optional string response_steamurl = 7
     */
    responseSteamurl?: string;
}
/**
 * @generated from protobuf message CClientNotificationFriendOnline
 */
export interface CClientNotificationFriendOnline {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CClientNotificationGameRecordingError
 */
export interface CClientNotificationGameRecordingError {
    /**
     * @generated from protobuf field: optional fixed64 game_id = 1
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional int32 error_type = 2
     */
    errorType?: number;
}
/**
 * @generated from protobuf message CClientNotificationGameRecordingInstantClip
 */
export interface CClientNotificationGameRecordingInstantClip {
    /**
     * @generated from protobuf field: optional fixed64 game_id = 1
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional string clip_id = 2
     */
    clipId?: string;
    /**
     * @generated from protobuf field: optional float duration_secs = 3
     */
    durationSecs?: number;
}
/**
 * @generated from protobuf message CClientNotificationGameRecordingStart
 */
export interface CClientNotificationGameRecordingStart {
    /**
     * @generated from protobuf field: optional fixed64 game_id = 1
     */
    gameId?: bigint;
}
/**
 * @generated from protobuf message CClientNotificationGameRecordingStop
 */
export interface CClientNotificationGameRecordingStop {
    /**
     * @generated from protobuf field: optional fixed64 game_id = 1
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional string clip_id = 2
     */
    clipId?: string;
    /**
     * @generated from protobuf field: optional float duration_secs = 3
     */
    durationSecs?: number;
}
/**
 * @generated from protobuf message CClientNotificationGameRecordingUserMarkerAdded
 */
export interface CClientNotificationGameRecordingUserMarkerAdded {
    /**
     * @generated from protobuf field: optional fixed64 game_id = 1
     */
    gameId?: bigint;
}
/**
 * @generated from protobuf message CClientNotificationGroupChatMessage
 */
export interface CClientNotificationGroupChatMessage {
    /**
     * @generated from protobuf field: optional string tag = 1
     */
    tag?: string;
    /**
     * @generated from protobuf field: optional string steamid_sender = 2
     */
    steamidSender?: string;
    /**
     * @generated from protobuf field: optional string chat_group_id = 3
     */
    chatGroupId?: string;
    /**
     * @generated from protobuf field: optional string chat_id = 4
     */
    chatId?: string;
    /**
     * @generated from protobuf field: optional string title = 5
     */
    title?: string;
    /**
     * @generated from protobuf field: optional string body = 6
     */
    body?: string;
    /**
     * @generated from protobuf field: optional string rawbody = 7
     */
    rawbody?: string;
    /**
     * @generated from protobuf field: optional string icon = 8
     */
    icon?: string;
    /**
     * @generated from protobuf field: optional uint32 notificationid = 9
     */
    notificationid?: number;
}
/**
 * @generated from protobuf message CClientNotificationHardwareSurveyPending
 */
export interface CClientNotificationHardwareSurveyPending {
}
/**
 * @generated from protobuf message CClientNotificationIncomingVoiceChat
 */
export interface CClientNotificationIncomingVoiceChat {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CClientNotificationItemAnnouncement
 */
export interface CClientNotificationItemAnnouncement {
    /**
     * @generated from protobuf field: optional uint32 new_item_count = 1
     */
    newItemCount?: number;
    /**
     * @generated from protobuf field: optional bool new_backpack_items = 2
     */
    newBackpackItems?: boolean;
}
/**
 * @generated from protobuf message CClientNotificationLoginRefresh
 */
export interface CClientNotificationLoginRefresh {
}
/**
 * @generated from protobuf message CClientNotificationLowBattery
 */
export interface CClientNotificationLowBattery {
    /**
     * @generated from protobuf field: optional float pct_remaining = 1
     */
    pctRemaining?: number;
}
/**
 * @generated from protobuf message CClientNotificationLowDiskSpace
 */
export interface CClientNotificationLowDiskSpace {
    /**
     * @generated from protobuf field: optional uint32 folder_index = 1
     */
    folderIndex?: number;
}
/**
 * @generated from protobuf message CClientNotificationOverlaySplashScreen
 */
export interface CClientNotificationOverlaySplashScreen {
}
/**
 * @generated from protobuf message CClientNotificationPlaytimeWarning
 */
export interface CClientNotificationPlaytimeWarning {
    /**
     * @generated from protobuf field: optional string type = 1
     */
    type?: string;
    /**
     * @generated from protobuf field: optional uint32 playtime_remaining = 2
     */
    playtimeRemaining?: number;
}
/**
 * @generated from protobuf message CClientNotificationRemoteClientConnection
 */
export interface CClientNotificationRemoteClientConnection {
    /**
     * @generated from protobuf field: optional string machine = 1
     */
    machine?: string;
    /**
     * @generated from protobuf field: optional bool connected = 2
     */
    connected?: boolean;
}
/**
 * @generated from protobuf message CClientNotificationRemoteClientStartStream
 */
export interface CClientNotificationRemoteClientStartStream {
    /**
     * @generated from protobuf field: optional string machine = 1
     */
    machine?: string;
    /**
     * @generated from protobuf field: optional string game_name = 2
     */
    gameName?: string;
}
/**
 * @generated from protobuf message CClientNotificationScreenshot
 */
export interface CClientNotificationScreenshot {
    /**
     * @generated from protobuf field: optional string screenshot_handle = 1
     */
    screenshotHandle?: string;
    /**
     * @generated from protobuf field: optional string description = 2
     */
    description?: string;
    /**
     * @generated from protobuf field: optional string local_url = 3
     */
    localUrl?: string;
}
/**
 * @generated from protobuf message CClientNotificationSteamInputActionSetChanged
 */
export interface CClientNotificationSteamInputActionSetChanged {
    /**
     * @generated from protobuf field: optional int32 controller_index = 1
     */
    controllerIndex?: number;
    /**
     * @generated from protobuf field: optional string action_set_name = 2
     */
    actionSetName?: string;
}
/**
 * @generated from protobuf message CClientNotificationStreamingClientConnection
 */
export interface CClientNotificationStreamingClientConnection {
    /**
     * @generated from protobuf field: optional string hostname = 1
     */
    hostname?: string;
    /**
     * @generated from protobuf field: optional string machine = 2
     */
    machine?: string;
    /**
     * @generated from protobuf field: optional bool connected = 3
     */
    connected?: boolean;
}
/**
 * @generated from protobuf message CClientNotificationSystemUpdate
 */
export interface CClientNotificationSystemUpdate {
    /**
     * @generated from protobuf field: optional int32 type = 1
     */
    type?: number;
}
/**
 * @generated from protobuf message CClientNotificationTimedTrialRemaining
 */
export interface CClientNotificationTimedTrialRemaining {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string icon = 2
     */
    icon?: string;
    /**
     * @generated from protobuf field: optional bool offline = 3
     */
    offline?: boolean;
    /**
     * @generated from protobuf field: optional uint32 allowed_seconds = 4
     */
    allowedSeconds?: number;
    /**
     * @generated from protobuf field: optional uint32 played_seconds = 5
     */
    playedSeconds?: number;
}
/**
 * @generated from protobuf message CClientNotificationTimerExpired
 */
export interface CClientNotificationTimerExpired {
}
/**
 * @generated from protobuf message CCloud_AppExitSyncDone_Notification
 */
export interface CCloud_AppExitSyncDone_Notification {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint64 client_id = 2
     */
    clientId?: bigint;
    /**
     * @generated from protobuf field: optional bool uploads_completed = 3
     */
    uploadsCompleted?: boolean;
    /**
     * @generated from protobuf field: optional bool uploads_required = 4
     */
    uploadsRequired?: boolean;
}
/**
 * Used by: Cloud, common.proto
 *
 * @generated from protobuf message CCloud_PendingRemoteOperation
 */
export interface CCloud_PendingRemoteOperation {
    /**
     * @generated from protobuf field: optional int32 operation = 1
     */
    operation?: number;
    /**
     * @generated from protobuf field: optional string machine_name = 2
     */
    machineName?: string;
    /**
     * @generated from protobuf field: optional uint64 client_id = 3
     */
    clientId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 time_last_updated = 4
     */
    timeLastUpdated?: number;
    /**
     * @generated from protobuf field: optional int32 os_type = 5
     */
    osType?: number;
    /**
     * @generated from protobuf field: optional int32 device_type = 6
     */
    deviceType?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CCommunity_ClanAnnouncementInfo
 */
export interface CCommunity_ClanAnnouncementInfo {
    /**
     * @generated from protobuf field: optional uint64 gid = 1
     */
    gid?: bigint;
    /**
     * @generated from protobuf field: optional uint64 clanid = 2
     */
    clanid?: bigint;
    /**
     * @generated from protobuf field: optional uint64 posterid = 3
     */
    posterid?: bigint;
    /**
     * @generated from protobuf field: optional string headline = 4
     */
    headline?: string;
    /**
     * @generated from protobuf field: optional uint32 posttime = 5
     */
    posttime?: number;
    /**
     * @generated from protobuf field: optional uint32 updatetime = 6
     */
    updatetime?: number;
    /**
     * @generated from protobuf field: optional string body = 7
     */
    body?: string;
    /**
     * @generated from protobuf field: optional int32 commentcount = 8
     */
    commentcount?: number;
    /**
     * @generated from protobuf field: repeated string tags = 9
     */
    tags: string[];
    /**
     * @generated from protobuf field: optional int32 language = 10
     */
    language?: number;
    /**
     * @generated from protobuf field: optional bool hidden = 11
     */
    hidden?: boolean;
    /**
     * @generated from protobuf field: optional fixed64 forum_topic_id = 12
     */
    forumTopicId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 event_gid = 13
     */
    eventGid?: bigint;
    /**
     * @generated from protobuf field: optional int32 voteupcount = 14
     */
    voteupcount?: number;
    /**
     * @generated from protobuf field: optional int32 votedowncount = 15
     */
    votedowncount?: number;
}
/**
 * @generated from protobuf message CCuratorPreferences
 */
export interface CCuratorPreferences {
    /**
     * @generated from protobuf field: optional uint32 supported_languages = 1
     */
    supportedLanguages?: number;
    /**
     * @generated from protobuf field: optional bool platform_windows = 2
     */
    platformWindows?: boolean;
    /**
     * @generated from protobuf field: optional bool platform_mac = 3
     */
    platformMac?: boolean;
    /**
     * @generated from protobuf field: optional bool platform_linux = 4
     */
    platformLinux?: boolean;
    /**
     * @generated from protobuf field: optional bool vr_content = 5
     */
    vrContent?: boolean;
    /**
     * @generated from protobuf field: optional bool adult_content_violence = 6
     */
    adultContentViolence?: boolean;
    /**
     * @generated from protobuf field: optional bool adult_content_sex = 7
     */
    adultContentSex?: boolean;
    /**
     * @generated from protobuf field: optional uint32 timestamp_updated = 8
     */
    timestampUpdated?: number;
    /**
     * @generated from protobuf field: repeated uint32 tagids_curated = 9
     */
    tagidsCurated: number[];
    /**
     * @generated from protobuf field: repeated uint32 tagids_filtered = 10
     */
    tagidsFiltered: number[];
    /**
     * @generated from protobuf field: optional string website_title = 11
     */
    websiteTitle?: string;
    /**
     * @generated from protobuf field: optional string website_url = 12
     */
    websiteUrl?: string;
    /**
     * @generated from protobuf field: optional string discussion_url = 13
     */
    discussionUrl?: string;
    /**
     * @generated from protobuf field: optional bool show_broadcast = 14
     */
    showBroadcast?: boolean;
}
/**
 * @generated from protobuf message CGameNetworkingUI_AppSummary
 */
export interface CGameNetworkingUI_AppSummary {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional bool ip_was_shared_with_friend = 10
     */
    ipWasSharedWithFriend?: boolean;
    /**
     * @generated from protobuf field: optional bool ip_was_shared_with_nonfriend = 11
     */
    ipWasSharedWithNonfriend?: boolean;
    /**
     * @generated from protobuf field: optional uint32 active_connections = 20
     */
    activeConnections?: number;
    /**
     * @generated from protobuf field: optional CGameNetworkingUI_ConnectionSummary main_cxn = 30
     */
    mainCxn?: CGameNetworkingUI_ConnectionSummary;
}
/**
 * @generated from protobuf message CGameNetworkingUI_ConnectionState
 */
export interface CGameNetworkingUI_ConnectionState {
    /**
     * @generated from protobuf field: optional string connection_key = 1
     */
    connectionKey?: string;
    /**
     * @generated from protobuf field: optional uint32 appid = 2
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional fixed32 connection_id_local = 3
     */
    connectionIdLocal?: number;
    /**
     * @generated from protobuf field: optional string identity_local = 4
     */
    identityLocal?: string;
    /**
     * @generated from protobuf field: optional string identity_remote = 5
     */
    identityRemote?: string;
    /**
     * @generated from protobuf field: optional uint32 connection_state = 10
     */
    connectionState?: number;
    /**
     * @generated from protobuf field: optional uint32 start_time = 12
     */
    startTime?: number;
    /**
     * @generated from protobuf field: optional uint32 close_time = 13
     */
    closeTime?: number;
    /**
     * @generated from protobuf field: optional uint32 close_reason = 14
     */
    closeReason?: number;
    /**
     * @generated from protobuf field: optional string close_message = 15
     */
    closeMessage?: string;
    /**
     * @generated from protobuf field: optional string status_loc_token = 16
     */
    statusLocToken?: string;
    /**
     * @generated from protobuf field: optional uint32 transport_kind = 20
     */
    transportKind?: number;
    /**
     * @generated from protobuf field: optional string sdrpopid_local = 21
     */
    sdrpopidLocal?: string;
    /**
     * @generated from protobuf field: optional string sdrpopid_remote = 22
     */
    sdrpopidRemote?: string;
    /**
     * @generated from protobuf field: optional string address_remote = 23
     */
    addressRemote?: string;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramP2PRoutingSummary p2p_routing = 24
     */
    p2PRouting?: CMsgSteamDatagramP2PRoutingSummary;
    /**
     * @generated from protobuf field: optional uint32 ping_interior = 25
     */
    pingInterior?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_remote_front = 26
     */
    pingRemoteFront?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_default_internet_route = 27
     */
    pingDefaultInternetRoute?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality e2e_quality_local = 30
     */
    e2EQualityLocal?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality e2e_quality_remote = 31
     */
    e2EQualityRemote?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional uint64 e2e_quality_remote_instantaneous_time = 32
     */
    e2EQualityRemoteInstantaneousTime?: bigint;
    /**
     * @generated from protobuf field: optional uint64 e2e_quality_remote_lifetime_time = 33
     */
    e2EQualityRemoteLifetimeTime?: bigint;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality front_quality_local = 40
     */
    frontQualityLocal?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality front_quality_remote = 41
     */
    frontQualityRemote?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional uint64 front_quality_remote_instantaneous_time = 42
     */
    frontQualityRemoteInstantaneousTime?: bigint;
    /**
     * @generated from protobuf field: optional uint64 front_quality_remote_lifetime_time = 43
     */
    frontQualityRemoteLifetimeTime?: bigint;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CGameNetworkingUI_ConnectionSummary
 */
export interface CGameNetworkingUI_ConnectionSummary {
    /**
     * @generated from protobuf field: optional uint32 transport_kind = 1
     */
    transportKind?: number;
    /**
     * @generated from protobuf field: optional string sdrpop_local = 2
     */
    sdrpopLocal?: string;
    /**
     * @generated from protobuf field: optional string sdrpop_remote = 3
     */
    sdrpopRemote?: string;
    /**
     * @generated from protobuf field: optional uint32 ping_ms = 4
     */
    pingMs?: number;
    /**
     * @generated from protobuf field: optional float packet_loss = 5
     */
    packetLoss?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_default_internet_route = 6
     */
    pingDefaultInternetRoute?: number;
    /**
     * @generated from protobuf field: optional bool ip_was_shared = 7
     */
    ipWasShared?: boolean;
    /**
     * @generated from protobuf field: optional uint32 connection_state = 8
     */
    connectionState?: number;
}
/**
 * @generated from protobuf message CGameRecording_AudioSessionsChanged_Notification
 */
export interface CGameRecording_AudioSessionsChanged_Notification {
    /**
     * @generated from protobuf field: repeated CGameRecording_AudioSessionsChanged_Notification_Session sessions = 1
     */
    sessions: CGameRecording_AudioSessionsChanged_Notification_Session[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CGameRecording_AudioSessionsChanged_Notification_Session
 */
export interface CGameRecording_AudioSessionsChanged_Notification_Session {
    /**
     * @generated from protobuf field: optional string id = 1
     */
    id?: string;
    /**
     * @generated from protobuf field: optional string name = 2
     */
    name?: string;
    /**
     * @generated from protobuf field: optional bool is_system = 3
     */
    isSystem?: boolean;
    /**
     * @generated from protobuf field: optional bool is_muted = 4
     */
    isMuted?: boolean;
    /**
     * @generated from protobuf field: optional bool is_active = 5
     */
    isActive?: boolean;
    /**
     * @generated from protobuf field: optional bool is_captured = 6
     */
    isCaptured?: boolean;
    /**
     * @generated from protobuf field: optional float recent_peak = 7
     */
    recentPeak?: number;
    /**
     * @generated from protobuf field: optional bool is_game = 8
     */
    isGame?: boolean;
    /**
     * @generated from protobuf field: optional bool is_steam = 9
     */
    isSteam?: boolean;
    /**
     * @generated from protobuf field: optional bool is_saved = 10
     */
    isSaved?: boolean;
}
/**
 * @generated from protobuf message CLibraryBootstrapData
 */
export interface CLibraryBootstrapData {
    /**
     * @generated from protobuf field: repeated CAppBootstrapData app_data = 1
     */
    appData: CAppBootstrapData[];
}
/**
 * @generated from protobuf message CLocalizationToken
 */
export interface CLocalizationToken {
    /**
     * @generated from protobuf field: optional uint32 language = 1
     */
    language?: number;
    /**
     * @generated from protobuf field: optional string localized_string = 2
     */
    localizedString?: string;
}
/**
 * @generated from protobuf message CMsgAchievementChange
 */
export interface CMsgAchievementChange {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
}
/**
 * @generated from protobuf message CMsgAMUnlockHEVC
 */
export interface CMsgAMUnlockHEVC {
}
/**
 * @generated from protobuf message CMsgAMUnlockHEVCResponse
 */
export interface CMsgAMUnlockHEVCResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgAMUnlockStreaming
 */
export interface CMsgAMUnlockStreaming {
}
/**
 * @generated from protobuf message CMsgAMUnlockStreamingResponse
 */
export interface CMsgAMUnlockStreamingResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional bytes encryption_key = 2
     */
    encryptionKey?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgAppRights
 */
export interface CMsgAppRights {
    /**
     * @generated from protobuf field: optional bool edit_info = 1
     */
    editInfo?: boolean;
    /**
     * @generated from protobuf field: optional bool publish = 2
     */
    publish?: boolean;
    /**
     * @generated from protobuf field: optional bool view_error_data = 3
     */
    viewErrorData?: boolean;
    /**
     * @generated from protobuf field: optional bool download = 4
     */
    download?: boolean;
    /**
     * @generated from protobuf field: optional bool upload_cdkeys = 5
     */
    uploadCdkeys?: boolean;
    /**
     * @generated from protobuf field: optional bool generate_cdkeys = 6
     */
    generateCdkeys?: boolean;
    /**
     * @generated from protobuf field: optional bool view_financials = 7
     */
    viewFinancials?: boolean;
    /**
     * @generated from protobuf field: optional bool manage_ceg = 8
     */
    manageCeg?: boolean;
    /**
     * @generated from protobuf field: optional bool manage_signing = 9
     */
    manageSigning?: boolean;
    /**
     * @generated from protobuf field: optional bool manage_cdkeys = 10
     */
    manageCdkeys?: boolean;
    /**
     * @generated from protobuf field: optional bool edit_marketing = 11
     */
    editMarketing?: boolean;
    /**
     * @generated from protobuf field: optional bool economy_support = 12
     */
    economySupport?: boolean;
    /**
     * @generated from protobuf field: optional bool economy_support_supervisor = 13
     */
    economySupportSupervisor?: boolean;
    /**
     * @generated from protobuf field: optional bool manage_pricing = 14
     */
    managePricing?: boolean;
    /**
     * @generated from protobuf field: optional bool broadcast_live = 15
     */
    broadcastLive?: boolean;
    /**
     * @generated from protobuf field: optional bool view_marketing_traffic = 16
     */
    viewMarketingTraffic?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgAuthTicket
 */
export interface CMsgAuthTicket {
    /**
     * @generated from protobuf field: optional uint32 estate = 1
     */
    estate?: number;
    /**
     * @generated from protobuf field: optional uint32 eresult = 2 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid = 3
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 gameid = 4
     */
    gameid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 h_steam_pipe = 5
     */
    hSteamPipe?: number;
    /**
     * @generated from protobuf field: optional uint32 ticket_crc = 6
     */
    ticketCrc?: number;
    /**
     * @generated from protobuf field: optional bytes ticket = 7
     */
    ticket?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes server_secret = 8
     */
    serverSecret?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 ticket_type = 9
     */
    ticketType?: number;
}
/**
 * @generated from protobuf message CMsgBadgeCraftedNotification
 */
export interface CMsgBadgeCraftedNotification {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 badge_level = 2
     */
    badgeLevel?: number;
}
/**
 * @generated from protobuf message CMsgClientAccountInfo
 */
export interface CMsgClientAccountInfo {
    /**
     * @generated from protobuf field: optional string persona_name = 1
     */
    personaName?: string;
    /**
     * @generated from protobuf field: optional string ip_country = 2
     */
    ipCountry?: string;
    /**
     * @generated from protobuf field: optional int32 count_authed_computers = 5
     */
    countAuthedComputers?: number;
    /**
     * @generated from protobuf field: optional uint32 account_flags = 7
     */
    accountFlags?: number;
    /**
     * @generated from protobuf field: optional uint64 facebook_id = 8
     */
    facebookId?: bigint;
    /**
     * @generated from protobuf field: optional string facebook_name = 9
     */
    facebookName?: string;
    /**
     * @generated from protobuf field: optional bool steamguard_notify_newmachines = 14
     */
    steamguardNotifyNewmachines?: boolean;
    /**
     * @generated from protobuf field: optional string steamguard_machine_name_user_chosen = 15
     */
    steamguardMachineNameUserChosen?: string;
    /**
     * @generated from protobuf field: optional bool is_phone_verified = 16
     */
    isPhoneVerified?: boolean;
    /**
     * @generated from protobuf field: optional uint32 two_factor_state = 17
     */
    twoFactorState?: number;
    /**
     * @generated from protobuf field: optional bool is_phone_identifying = 18
     */
    isPhoneIdentifying?: boolean;
    /**
     * @generated from protobuf field: optional bool is_phone_needing_reverify = 19
     */
    isPhoneNeedingReverify?: boolean;
}
/**
 * @generated from protobuf message CMsgClientActivateOEMLicense
 */
export interface CMsgClientActivateOEMLicense {
    /**
     * @generated from protobuf field: optional string bios_manufacturer = 1
     */
    biosManufacturer?: string;
    /**
     * @generated from protobuf field: optional string bios_serialnumber = 2
     */
    biosSerialnumber?: string;
    /**
     * @generated from protobuf field: optional bytes license_file = 3
     */
    licenseFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional string mainboard_manufacturer = 4
     */
    mainboardManufacturer?: string;
    /**
     * @generated from protobuf field: optional string mainboard_product = 5
     */
    mainboardProduct?: string;
    /**
     * @generated from protobuf field: optional string mainboard_serialnumber = 6
     */
    mainboardSerialnumber?: string;
}
/**
 * @generated from protobuf message CMsgClientAddFriend
 */
export interface CMsgClientAddFriend {
    /**
     * @generated from protobuf field: optional fixed64 steamid_to_add = 1
     */
    steamidToAdd?: bigint;
    /**
     * @generated from protobuf field: optional string accountname_or_email_to_add = 2
     */
    accountnameOrEmailToAdd?: string;
}
/**
 * @generated from protobuf message CMsgClientAddFriendResponse
 */
export interface CMsgClientAddFriendResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_added = 2
     */
    steamIdAdded?: bigint;
    /**
     * @generated from protobuf field: optional string persona_name_added = 3
     */
    personaNameAdded?: string;
}
/**
 * @generated from protobuf message CMsgClientAddFriendToGroup
 */
export interface CMsgClientAddFriendToGroup {
    /**
     * @generated from protobuf field: optional int32 groupid = 1
     */
    groupid?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamiduser = 2
     */
    steamiduser?: bigint;
}
/**
 * @generated from protobuf message CMsgClientAddFriendToGroupResponse
 */
export interface CMsgClientAddFriendToGroupResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientAMGetClanOfficers
 */
export interface CMsgClientAMGetClanOfficers {
    /**
     * @generated from protobuf field: optional fixed64 steamid_clan = 1
     */
    steamidClan?: bigint;
}
/**
 * @generated from protobuf message CMsgClientAMGetClanOfficersResponse
 */
export interface CMsgClientAMGetClanOfficersResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid_clan = 2
     */
    steamidClan?: bigint;
    /**
     * @generated from protobuf field: optional int32 officer_count = 3
     */
    officerCount?: number;
}
/**
 * @generated from protobuf message CMsgClientAMGetPersonaNameHistory
 */
export interface CMsgClientAMGetPersonaNameHistory {
    /**
     * @generated from protobuf field: optional int32 id_count = 1
     */
    idCount?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientAMGetPersonaNameHistory_IdInstance Ids = 2
     */
    ids: CMsgClientAMGetPersonaNameHistory_IdInstance[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientAMGetPersonaNameHistory_IdInstance
 */
export interface CMsgClientAMGetPersonaNameHistory_IdInstance {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CMsgClientAMGetPersonaNameHistoryResponse
 */
export interface CMsgClientAMGetPersonaNameHistoryResponse {
    /**
     * @generated from protobuf field: repeated CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance responses = 2
     */
    responses: CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance
 */
export interface CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid = 2
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: repeated CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance names = 3
     */
    names: CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance
 */
export interface CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    /**
     * @generated from protobuf field: optional fixed32 name_since = 1
     */
    nameSince?: number;
    /**
     * @generated from protobuf field: optional string name = 2
     */
    name?: string;
}
/**
 * @generated from protobuf message CMsgClientAppInfoChanges
 */
export interface CMsgClientAppInfoChanges {
    /**
     * @generated from protobuf field: optional uint32 current_change_number = 1
     */
    currentChangeNumber?: number;
    /**
     * @generated from protobuf field: optional bool force_full_update = 2
     */
    forceFullUpdate?: boolean;
    /**
     * @generated from protobuf field: repeated uint32 appIDs = 3
     */
    appIDs: number[];
}
/**
 * @generated from protobuf message CMsgClientAppInfoRequest
 */
export interface CMsgClientAppInfoRequest {
    /**
     * @generated from protobuf field: repeated CMsgClientAppInfoRequest_App apps = 1
     */
    apps: CMsgClientAppInfoRequest_App[];
    /**
     * @generated from protobuf field: optional bool supports_batches = 2 [default = false]
     */
    supportsBatches?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientAppInfoRequest_App
 */
export interface CMsgClientAppInfoRequest_App {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 section_flags = 2
     */
    sectionFlags?: number;
    /**
     * @generated from protobuf field: repeated uint32 section_CRC = 3
     */
    sectionCRC: number[];
}
/**
 * @generated from protobuf message CMsgClientAppInfoResponse
 */
export interface CMsgClientAppInfoResponse {
    /**
     * @generated from protobuf field: repeated CMsgClientAppInfoResponse_App apps = 1
     */
    apps: CMsgClientAppInfoResponse_App[];
    /**
     * @generated from protobuf field: repeated uint32 apps_unknown = 2
     */
    appsUnknown: number[];
    /**
     * @generated from protobuf field: optional uint32 apps_pending = 3
     */
    appsPending?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientAppInfoResponse_App
 */
export interface CMsgClientAppInfoResponse_App {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 change_number = 2
     */
    changeNumber?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientAppInfoResponse_App_Section sections = 3
     */
    sections: CMsgClientAppInfoResponse_App_Section[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientAppInfoResponse_App_Section
 */
export interface CMsgClientAppInfoResponse_App_Section {
    /**
     * @generated from protobuf field: optional uint32 section_id = 1
     */
    sectionId?: number;
    /**
     * @generated from protobuf field: optional bytes section_kv = 2
     */
    sectionKv?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientAppInfoUpdate
 */
export interface CMsgClientAppInfoUpdate {
    /**
     * @generated from protobuf field: optional uint32 last_changenumber = 1
     */
    lastChangenumber?: number;
    /**
     * @generated from protobuf field: optional bool send_changelist = 2
     */
    sendChangelist?: boolean;
}
/**
 * @generated from protobuf message CMsgClientAuthList
 */
export interface CMsgClientAuthList {
    /**
     * @generated from protobuf field: optional uint32 tokens_left = 1
     */
    tokensLeft?: number;
    /**
     * @generated from protobuf field: optional uint32 last_request_seq = 2
     */
    lastRequestSeq?: number;
    /**
     * @generated from protobuf field: optional uint32 last_request_seq_from_server = 3
     */
    lastRequestSeqFromServer?: number;
    /**
     * @generated from protobuf field: repeated CMsgAuthTicket tickets = 4
     */
    tickets: CMsgAuthTicket[];
    /**
     * @generated from protobuf field: repeated uint32 app_ids = 5
     */
    appIds: number[];
    /**
     * @generated from protobuf field: optional uint32 message_sequence = 6
     */
    messageSequence?: number;
}
/**
 * @generated from protobuf message CMsgClientAuthListAck
 */
export interface CMsgClientAuthListAck {
    /**
     * @generated from protobuf field: repeated uint32 ticket_crc = 1
     */
    ticketCrc: number[];
    /**
     * @generated from protobuf field: repeated uint32 app_ids = 2
     */
    appIds: number[];
    /**
     * @generated from protobuf field: optional uint32 message_sequence = 3
     */
    messageSequence?: number;
}
/**
 * @generated from protobuf message CMsgClientAuthorizeLocalDevice
 */
export interface CMsgClientAuthorizeLocalDevice {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 owner_account_id = 2
     */
    ownerAccountId?: number;
    /**
     * @generated from protobuf field: optional uint64 authed_device_token = 3
     */
    authedDeviceToken?: bigint;
}
/**
 * @generated from protobuf message CMsgClientAuthorizeLocalDeviceNotification
 */
export interface CMsgClientAuthorizeLocalDeviceNotification {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 owner_account_id = 2
     */
    ownerAccountId?: number;
    /**
     * @generated from protobuf field: optional uint64 local_device_token = 3
     */
    localDeviceToken?: bigint;
}
/**
 * @generated from protobuf message CMsgClientAuthorizeLocalDeviceRequest
 */
export interface CMsgClientAuthorizeLocalDeviceRequest {
    /**
     * @generated from protobuf field: optional string device_description = 1
     */
    deviceDescription?: string;
    /**
     * @generated from protobuf field: optional uint32 owner_account_id = 2
     */
    ownerAccountId?: number;
    /**
     * @generated from protobuf field: optional uint64 local_device_token = 3
     */
    localDeviceToken?: bigint;
}
/**
 * @generated from protobuf message CMsgClientChallengeRequest
 */
export interface CMsgClientChallengeRequest {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CMsgClientChallengeResponse
 */
export interface CMsgClientChallengeResponse {
    /**
     * @generated from protobuf field: optional fixed64 challenge = 1
     */
    challenge?: bigint;
}
/**
 * @generated from protobuf message CMsgClientChangeStatus
 */
export interface CMsgClientChangeStatus {
    /**
     * @generated from protobuf field: optional uint32 persona_state = 1
     */
    personaState?: number;
    /**
     * @generated from protobuf field: optional string player_name = 2
     */
    playerName?: string;
    /**
     * @generated from protobuf field: optional bool is_auto_generated_name = 3
     */
    isAutoGeneratedName?: boolean;
    /**
     * @generated from protobuf field: optional bool high_priority = 4
     */
    highPriority?: boolean;
    /**
     * @generated from protobuf field: optional bool persona_set_by_user = 5
     */
    personaSetByUser?: boolean;
    /**
     * @generated from protobuf field: optional uint32 persona_state_flags = 6 [default = 0]
     */
    personaStateFlags?: number;
    /**
     * @generated from protobuf field: optional bool need_persona_response = 7
     */
    needPersonaResponse?: boolean;
    /**
     * @generated from protobuf field: optional bool is_client_idle = 8
     */
    isClientIdle?: boolean;
}
/**
 * @generated from protobuf message CMsgClientChatGetFriendMessageHistory
 */
export interface CMsgClientChatGetFriendMessageHistory {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CMsgClientChatGetFriendMessageHistoryForOfflineMessages
 */
export interface CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
}
/**
 * @generated from protobuf message CMsgClientChatGetFriendMessageHistoryResponse
 */
export interface CMsgClientChatGetFriendMessageHistoryResponse {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 success = 2
     */
    success?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage messages = 3
     */
    messages: CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage
 */
export interface CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
    /**
     * @generated from protobuf field: optional uint32 accountid = 1
     */
    accountid?: number;
    /**
     * @generated from protobuf field: optional uint32 timestamp = 2
     */
    timestamp?: number;
    /**
     * @generated from protobuf field: optional string message = 3
     */
    message?: string;
    /**
     * @generated from protobuf field: optional bool unread = 4
     */
    unread?: boolean;
}
/**
 * @generated from protobuf message CMsgClientChatInvite
 */
export interface CMsgClientChatInvite {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_invited = 1
     */
    steamIdInvited?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_chat = 2
     */
    steamIdChat?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_patron = 3
     */
    steamIdPatron?: bigint;
    /**
     * @generated from protobuf field: optional int32 chatroom_type = 4
     */
    chatroomType?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_friend_chat = 5
     */
    steamIdFriendChat?: bigint;
    /**
     * @generated from protobuf field: optional string chat_name = 6
     */
    chatName?: string;
    /**
     * @generated from protobuf field: optional fixed64 game_id = 7
     */
    gameId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientCheckAppBetaPassword
 */
export interface CMsgClientCheckAppBetaPassword {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string betapassword = 2
     */
    betapassword?: string;
}
/**
 * @generated from protobuf message CMsgClientCheckAppBetaPasswordResponse
 */
export interface CMsgClientCheckAppBetaPasswordResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientCheckAppBetaPasswordResponse_BetaPassword betapasswords = 4
     */
    betapasswords: CMsgClientCheckAppBetaPasswordResponse_BetaPassword[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientCheckAppBetaPasswordResponse_BetaPassword
 */
export interface CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
    /**
     * @generated from protobuf field: optional string betaname = 1
     */
    betaname?: string;
    /**
     * @generated from protobuf field: optional string betapassword = 2
     */
    betapassword?: string;
}
/**
 * @generated from protobuf message CMsgClientCheckFileSignature
 */
export interface CMsgClientCheckFileSignature {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
}
/**
 * @generated from protobuf message CMsgClientCheckFileSignatureResponse
 */
export interface CMsgClientCheckFileSignatureResponse {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 pid = 2
     */
    pid?: number;
    /**
     * @generated from protobuf field: optional uint32 eresult = 3
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional string filename = 4
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional uint32 esignatureresult = 5
     */
    esignatureresult?: number;
    /**
     * @generated from protobuf field: optional bytes sha_file = 6
     */
    shaFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes signatureheader = 7
     */
    signatureheader?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 filesize = 8
     */
    filesize?: number;
    /**
     * @generated from protobuf field: optional uint32 getlasterror = 9
     */
    getlasterror?: number;
    /**
     * @generated from protobuf field: optional uint32 evalvesignaturecheckdetail = 10
     */
    evalvesignaturecheckdetail?: number;
}
/**
 * @generated from protobuf message CMsgClientClanState
 */
export interface CMsgClientClanState {
    /**
     * @generated from protobuf field: optional fixed64 steamid_clan = 1
     */
    steamidClan?: bigint;
    /**
     * @generated from protobuf field: optional uint32 clan_account_flags = 3
     */
    clanAccountFlags?: number;
    /**
     * @generated from protobuf field: optional CMsgClientClanState_NameInfo name_info = 4
     */
    nameInfo?: CMsgClientClanState_NameInfo;
    /**
     * @generated from protobuf field: optional CMsgClientClanState_UserCounts user_counts = 5
     */
    userCounts?: CMsgClientClanState_UserCounts;
    /**
     * @generated from protobuf field: repeated CMsgClientClanState_Event events = 6
     */
    events: CMsgClientClanState_Event[];
    /**
     * @generated from protobuf field: repeated CMsgClientClanState_Event announcements = 7
     */
    announcements: CMsgClientClanState_Event[];
    /**
     * @generated from protobuf field: optional bool chat_room_private = 8
     */
    chatRoomPrivate?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientClanState_Event
 */
export interface CMsgClientClanState_Event {
    /**
     * @generated from protobuf field: optional fixed64 gid = 1
     */
    gid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 event_time = 2
     */
    eventTime?: number;
    /**
     * @generated from protobuf field: optional string headline = 3
     */
    headline?: string;
    /**
     * @generated from protobuf field: optional fixed64 game_id = 4
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional bool just_posted = 5
     */
    justPosted?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientClanState_NameInfo
 */
export interface CMsgClientClanState_NameInfo {
    /**
     * @generated from protobuf field: optional string clan_name = 1
     */
    clanName?: string;
    /**
     * @generated from protobuf field: optional bytes sha_avatar = 2
     */
    shaAvatar?: Uint8Array;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientClanState_UserCounts
 */
export interface CMsgClientClanState_UserCounts {
    /**
     * @generated from protobuf field: optional uint32 members = 1
     */
    members?: number;
    /**
     * @generated from protobuf field: optional uint32 online = 2
     */
    online?: number;
    /**
     * @generated from protobuf field: optional uint32 chatting = 3
     */
    chatting?: number;
    /**
     * @generated from protobuf field: optional uint32 in_game = 4
     */
    inGame?: number;
    /**
     * @generated from protobuf field: optional uint32 chat_room_members = 5
     */
    chatRoomMembers?: number;
}
/**
 * @generated from protobuf message CMsgClientCMList
 */
export interface CMsgClientCMList {
    /**
     * @generated from protobuf field: repeated uint32 cm_addresses = 1
     */
    cmAddresses: number[];
    /**
     * @generated from protobuf field: repeated uint32 cm_ports = 2
     */
    cmPorts: number[];
    /**
     * @generated from protobuf field: repeated string cm_websocket_addresses = 3
     */
    cmWebsocketAddresses: string[];
    /**
     * @generated from protobuf field: optional uint32 percent_default_to_websocket = 4
     */
    percentDefaultToWebsocket?: number;
}
/**
 * @generated from protobuf message CMsgClientCommentNotifications
 */
export interface CMsgClientCommentNotifications {
    /**
     * @generated from protobuf field: optional uint32 count_new_comments = 1
     */
    countNewComments?: number;
    /**
     * @generated from protobuf field: optional uint32 count_new_comments_owner = 2
     */
    countNewCommentsOwner?: number;
    /**
     * @generated from protobuf field: optional uint32 count_new_comments_subscriptions = 3
     */
    countNewCommentsSubscriptions?: number;
}
/**
 * @generated from protobuf message CMsgClientConnectionStats
 */
export interface CMsgClientConnectionStats {
    /**
     * @generated from protobuf field: optional CMsgClientConnectionStats_Stats_Logon stats_logon = 1
     */
    statsLogon?: CMsgClientConnectionStats_Stats_Logon;
    /**
     * @generated from protobuf field: optional CMsgClientConnectionStats_Stats_VConn stats_vconn = 2
     */
    statsVconn?: CMsgClientConnectionStats_Stats_VConn;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientConnectionStats_Stats_Logon
 */
export interface CMsgClientConnectionStats_Stats_Logon {
    /**
     * @generated from protobuf field: optional int32 connect_attempts = 1
     */
    connectAttempts?: number;
    /**
     * @generated from protobuf field: optional int32 connect_successes = 2
     */
    connectSuccesses?: number;
    /**
     * @generated from protobuf field: optional int32 connect_failures = 3
     */
    connectFailures?: number;
    /**
     * @generated from protobuf field: optional int32 connections_dropped = 4
     */
    connectionsDropped?: number;
    /**
     * @generated from protobuf field: optional uint32 seconds_running = 5
     */
    secondsRunning?: number;
    /**
     * @generated from protobuf field: optional uint32 msec_tologonthistime = 6
     */
    msecTologonthistime?: number;
    /**
     * @generated from protobuf field: optional uint32 count_bad_cms = 7
     */
    countBadCms?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientConnectionStats_Stats_UDP
 */
export interface CMsgClientConnectionStats_Stats_UDP {
    /**
     * @generated from protobuf field: optional uint64 pkts_sent = 1
     */
    pktsSent?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes_sent = 2
     */
    bytesSent?: bigint;
    /**
     * @generated from protobuf field: optional uint64 pkts_recv = 3
     */
    pktsRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 pkts_processed = 4
     */
    pktsProcessed?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes_recv = 5
     */
    bytesRecv?: bigint;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientConnectionStats_Stats_VConn
 */
export interface CMsgClientConnectionStats_Stats_VConn {
    /**
     * @generated from protobuf field: optional uint32 connections_udp = 1
     */
    connectionsUdp?: number;
    /**
     * @generated from protobuf field: optional uint32 connections_tcp = 2
     */
    connectionsTcp?: number;
    /**
     * @generated from protobuf field: optional CMsgClientConnectionStats_Stats_UDP stats_udp = 3
     */
    statsUdp?: CMsgClientConnectionStats_Stats_UDP;
    /**
     * @generated from protobuf field: optional uint64 pkts_abandoned = 4
     */
    pktsAbandoned?: bigint;
    /**
     * @generated from protobuf field: optional uint64 conn_req_received = 5
     */
    connReqReceived?: bigint;
    /**
     * @generated from protobuf field: optional uint64 pkts_resent = 6
     */
    pktsResent?: bigint;
    /**
     * @generated from protobuf field: optional uint64 msgs_sent = 7
     */
    msgsSent?: bigint;
    /**
     * @generated from protobuf field: optional uint64 msgs_sent_failed = 8
     */
    msgsSentFailed?: bigint;
    /**
     * @generated from protobuf field: optional uint64 msgs_recv = 9
     */
    msgsRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 datagrams_sent = 10
     */
    datagramsSent?: bigint;
    /**
     * @generated from protobuf field: optional uint64 datagrams_recv = 11
     */
    datagramsRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bad_pkts_recv = 12
     */
    badPktsRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 unknown_conn_pkts_recv = 13
     */
    unknownConnPktsRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 missed_pkts_recv = 14
     */
    missedPktsRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 dup_pkts_recv = 15
     */
    dupPktsRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 failed_connect_challenges = 16
     */
    failedConnectChallenges?: bigint;
    /**
     * @generated from protobuf field: optional uint32 micro_sec_avg_latency = 17
     */
    microSecAvgLatency?: number;
    /**
     * @generated from protobuf field: optional uint32 micro_sec_min_latency = 18
     */
    microSecMinLatency?: number;
    /**
     * @generated from protobuf field: optional uint32 micro_sec_max_latency = 19
     */
    microSecMaxLatency?: number;
    /**
     * @generated from protobuf field: optional uint32 mem_pool_msg_in_use = 20
     */
    memPoolMsgInUse?: number;
}
/**
 * @generated from protobuf message CMsgClientCreateFriendsGroup
 */
export interface CMsgClientCreateFriendsGroup {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string groupname = 2
     */
    groupname?: string;
    /**
     * @generated from protobuf field: repeated fixed64 steamid_friends = 3
     */
    steamidFriends: bigint[];
}
/**
 * @generated from protobuf message CMsgClientCreateFriendsGroupResponse
 */
export interface CMsgClientCreateFriendsGroupResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 groupid = 2
     */
    groupid?: number;
}
/**
 * @generated from protobuf message CMsgClientDeauthorizeDevice
 */
export interface CMsgClientDeauthorizeDevice {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 deauthorization_account_id = 2
     */
    deauthorizationAccountId?: number;
}
/**
 * @generated from protobuf message CMsgClientDeauthorizeDeviceRequest
 */
export interface CMsgClientDeauthorizeDeviceRequest {
    /**
     * @generated from protobuf field: optional uint32 deauthorization_account_id = 1
     */
    deauthorizationAccountId?: number;
    /**
     * @generated from protobuf field: optional uint64 deauthorization_device_token = 2
     */
    deauthorizationDeviceToken?: bigint;
}
/**
 * @generated from protobuf message CMsgClientDeleteFriendsGroup
 */
export interface CMsgClientDeleteFriendsGroup {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional int32 groupid = 2
     */
    groupid?: number;
}
/**
 * @generated from protobuf message CMsgClientDeleteFriendsGroupResponse
 */
export interface CMsgClientDeleteFriendsGroupResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientDeregisterWithServer
 */
export interface CMsgClientDeregisterWithServer {
    /**
     * @generated from protobuf field: optional uint32 eservertype = 1
     */
    eservertype?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
}
/**
 * @generated from protobuf message CMsgClientDPCheckSpecialSurvey
 */
export interface CMsgClientDPCheckSpecialSurvey {
    /**
     * @generated from protobuf field: optional uint32 survey_id = 1
     */
    surveyId?: number;
}
/**
 * @generated from protobuf message CMsgClientDPCheckSpecialSurveyResponse
 */
export interface CMsgClientDPCheckSpecialSurveyResponse {
    /**
     * @generated from protobuf field: optional uint32 eResult = 1 [default = 2]
     */
    eResult?: number;
    /**
     * @generated from protobuf field: optional uint32 state = 2
     */
    state?: number;
    /**
     * @generated from protobuf field: optional string name = 3
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string custom_url = 4
     */
    customUrl?: string;
    /**
     * @generated from protobuf field: optional bool include_software = 5
     */
    includeSoftware?: boolean;
    /**
     * @generated from protobuf field: optional bytes token = 6
     */
    token?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientDPContentStatsReport
 */
export interface CMsgClientDPContentStatsReport {
    /**
     * @generated from protobuf field: optional fixed64 stats_machine_id = 1
     */
    statsMachineId?: bigint;
    /**
     * @generated from protobuf field: optional string country_code = 2
     */
    countryCode?: string;
    /**
     * @generated from protobuf field: optional int32 os_type = 3
     */
    osType?: number;
    /**
     * @generated from protobuf field: optional int32 language = 4
     */
    language?: number;
    /**
     * @generated from protobuf field: optional uint32 num_install_folders = 5
     */
    numInstallFolders?: number;
    /**
     * @generated from protobuf field: optional uint32 num_installed_games = 6
     */
    numInstalledGames?: number;
    /**
     * @generated from protobuf field: optional uint64 size_installed_games = 7
     */
    sizeInstalledGames?: bigint;
}
/**
 * @generated from protobuf message CMsgClientDPSendSpecialSurveyResponse
 */
export interface CMsgClientDPSendSpecialSurveyResponse {
    /**
     * @generated from protobuf field: optional uint32 survey_id = 1
     */
    surveyId?: number;
    /**
     * @generated from protobuf field: optional bytes data = 2
     */
    data?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientDPSendSpecialSurveyResponseReply
 */
export interface CMsgClientDPSendSpecialSurveyResponseReply {
    /**
     * @generated from protobuf field: optional uint32 eResult = 1 [default = 2]
     */
    eResult?: number;
    /**
     * @generated from protobuf field: optional bytes token = 2
     */
    token?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientEmailAddrInfo
 */
export interface CMsgClientEmailAddrInfo {
    /**
     * @generated from protobuf field: optional string email_address = 1
     */
    emailAddress?: string;
    /**
     * @generated from protobuf field: optional bool email_is_validated = 2
     */
    emailIsValidated?: boolean;
    /**
     * @generated from protobuf field: optional bool email_validation_changed = 3
     */
    emailValidationChanged?: boolean;
    /**
     * @generated from protobuf field: optional bool credential_change_requires_code = 4
     */
    credentialChangeRequiresCode?: boolean;
    /**
     * @generated from protobuf field: optional bool password_or_secretqa_change_requires_code = 5
     */
    passwordOrSecretqaChangeRequiresCode?: boolean;
    /**
     * @generated from protobuf field: optional bool remind_user_about_email = 6
     */
    remindUserAboutEmail?: boolean;
}
/**
 * @generated from protobuf message CMsgClientEmoticonList
 */
export interface CMsgClientEmoticonList {
    /**
     * @generated from protobuf field: repeated CMsgClientEmoticonList_Emoticon emoticons = 1
     */
    emoticons: CMsgClientEmoticonList_Emoticon[];
    /**
     * @generated from protobuf field: repeated CMsgClientEmoticonList_Sticker stickers = 2
     */
    stickers: CMsgClientEmoticonList_Sticker[];
    /**
     * @generated from protobuf field: repeated CMsgClientEmoticonList_Effect effects = 3
     */
    effects: CMsgClientEmoticonList_Effect[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientEmoticonList_Effect
 */
export interface CMsgClientEmoticonList_Effect {
    /**
     * @generated from protobuf field: optional string name = 1
     */
    name?: string;
    /**
     * @generated from protobuf field: optional int32 count = 2
     */
    count?: number;
    /**
     * @generated from protobuf field: optional uint32 time_received = 3
     */
    timeReceived?: number;
    /**
     * @generated from protobuf field: optional bool infinite_use = 4
     */
    infiniteUse?: boolean;
    /**
     * @generated from protobuf field: optional uint32 appid = 5
     */
    appid?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientEmoticonList_Emoticon
 */
export interface CMsgClientEmoticonList_Emoticon {
    /**
     * @generated from protobuf field: optional string name = 1
     */
    name?: string;
    /**
     * @generated from protobuf field: optional int32 count = 2
     */
    count?: number;
    /**
     * @generated from protobuf field: optional uint32 time_last_used = 3
     */
    timeLastUsed?: number;
    /**
     * @generated from protobuf field: optional uint32 use_count = 4
     */
    useCount?: number;
    /**
     * @generated from protobuf field: optional uint32 time_received = 5
     */
    timeReceived?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 6
     */
    appid?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientEmoticonList_Sticker
 */
export interface CMsgClientEmoticonList_Sticker {
    /**
     * @generated from protobuf field: optional string name = 1
     */
    name?: string;
    /**
     * @generated from protobuf field: optional int32 count = 2
     */
    count?: number;
    /**
     * @generated from protobuf field: optional uint32 time_received = 3
     */
    timeReceived?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 4
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 time_last_used = 5
     */
    timeLastUsed?: number;
    /**
     * @generated from protobuf field: optional uint32 use_count = 6
     */
    useCount?: number;
}
/**
 * @generated from protobuf message CMsgClientFriendMsg
 */
export interface CMsgClientFriendMsg {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional int32 chat_entry_type = 2
     */
    chatEntryType?: number;
    /**
     * @generated from protobuf field: optional bytes message = 3
     */
    message?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed32 rtime32_server_timestamp = 4
     */
    rtime32ServerTimestamp?: number;
    /**
     * @generated from protobuf field: optional bool echo_to_sender = 5
     */
    echoToSender?: boolean;
}
/**
 * @generated from protobuf message CMsgClientFriendMsgIncoming
 */
export interface CMsgClientFriendMsgIncoming {
    /**
     * @generated from protobuf field: optional fixed64 steamid_from = 1
     */
    steamidFrom?: bigint;
    /**
     * @generated from protobuf field: optional int32 chat_entry_type = 2
     */
    chatEntryType?: number;
    /**
     * @generated from protobuf field: optional bool from_limited_account = 3
     */
    fromLimitedAccount?: boolean;
    /**
     * @generated from protobuf field: optional bytes message = 4
     */
    message?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed32 rtime32_server_timestamp = 5
     */
    rtime32ServerTimestamp?: number;
}
/**
 * @generated from protobuf message CMsgClientFriendProfileInfo
 */
export interface CMsgClientFriendProfileInfo {
    /**
     * @generated from protobuf field: optional fixed64 steamid_friend = 1
     */
    steamidFriend?: bigint;
}
/**
 * @generated from protobuf message CMsgClientFriendProfileInfoResponse
 */
export interface CMsgClientFriendProfileInfoResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid_friend = 2
     */
    steamidFriend?: bigint;
    /**
     * @generated from protobuf field: optional uint32 time_created = 3
     */
    timeCreated?: number;
    /**
     * @generated from protobuf field: optional string real_name = 4
     */
    realName?: string;
    /**
     * @generated from protobuf field: optional string city_name = 5
     */
    cityName?: string;
    /**
     * @generated from protobuf field: optional string state_name = 6
     */
    stateName?: string;
    /**
     * @generated from protobuf field: optional string country_name = 7
     */
    countryName?: string;
    /**
     * @generated from protobuf field: optional string headline = 8
     */
    headline?: string;
    /**
     * @generated from protobuf field: optional string summary = 9
     */
    summary?: string;
}
/**
 * @generated from protobuf message CMsgClientFriendsGroupsList
 */
export interface CMsgClientFriendsGroupsList {
    /**
     * @generated from protobuf field: optional bool bremoval = 1
     */
    bremoval?: boolean;
    /**
     * @generated from protobuf field: optional bool bincremental = 2
     */
    bincremental?: boolean;
    /**
     * @generated from protobuf field: repeated CMsgClientFriendsGroupsList_FriendGroup friendGroups = 3
     */
    friendGroups: CMsgClientFriendsGroupsList_FriendGroup[];
    /**
     * @generated from protobuf field: repeated CMsgClientFriendsGroupsList_FriendGroupsMembership memberships = 4
     */
    memberships: CMsgClientFriendsGroupsList_FriendGroupsMembership[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientFriendsGroupsList_FriendGroup
 */
export interface CMsgClientFriendsGroupsList_FriendGroup {
    /**
     * @generated from protobuf field: optional int32 nGroupID = 1
     */
    nGroupID?: number;
    /**
     * @generated from protobuf field: optional string strGroupName = 2
     */
    strGroupName?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientFriendsGroupsList_FriendGroupsMembership
 */
export interface CMsgClientFriendsGroupsList_FriendGroupsMembership {
    /**
     * @generated from protobuf field: optional fixed64 ulSteamID = 1
     */
    ulSteamID?: bigint;
    /**
     * @generated from protobuf field: optional int32 nGroupID = 2
     */
    nGroupID?: number;
}
/**
 * @generated from protobuf message CMsgClientFriendUserStatusPublished
 */
export interface CMsgClientFriendUserStatusPublished {
    /**
     * @generated from protobuf field: optional fixed64 friend_steamid = 1
     */
    friendSteamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 appid = 2
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string status_text = 3
     */
    statusText?: string;
}
/**
 * @generated from protobuf message CMsgClientFSGetFriendsSteamLevels
 */
export interface CMsgClientFSGetFriendsSteamLevels {
    /**
     * @generated from protobuf field: repeated uint32 accountids = 1
     */
    accountids: number[];
}
/**
 * @generated from protobuf message CMsgClientFSGetFriendsSteamLevelsResponse
 */
export interface CMsgClientFSGetFriendsSteamLevelsResponse {
    /**
     * @generated from protobuf field: repeated CMsgClientFSGetFriendsSteamLevelsResponse_Friend friends = 1
     */
    friends: CMsgClientFSGetFriendsSteamLevelsResponse_Friend[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientFSGetFriendsSteamLevelsResponse_Friend
 */
export interface CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
    /**
     * @generated from protobuf field: optional uint32 accountid = 1
     */
    accountid?: number;
    /**
     * @generated from protobuf field: optional uint32 level = 2
     */
    level?: number;
}
/**
 * @generated from protobuf message CMsgClientGameConnectTokens
 */
export interface CMsgClientGameConnectTokens {
    /**
     * @generated from protobuf field: optional uint32 max_tokens_to_keep = 1 [default = 10]
     */
    maxTokensToKeep?: number;
    /**
     * @generated from protobuf field: repeated bytes tokens = 2
     */
    tokens: Uint8Array[];
}
/**
 * @generated from protobuf message CMsgClientGamesPlayed
 */
export interface CMsgClientGamesPlayed {
    /**
     * @generated from protobuf field: repeated CMsgClientGamesPlayed_GamePlayed games_played = 1
     */
    gamesPlayed: CMsgClientGamesPlayed_GamePlayed[];
    /**
     * @generated from protobuf field: optional uint32 client_os_type = 2
     */
    clientOsType?: number;
    /**
     * @generated from protobuf field: optional uint32 cloud_gaming_platform = 3
     */
    cloudGamingPlatform?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientGamesPlayed_GamePlayed
 */
export interface CMsgClientGamesPlayed_GamePlayed {
    /**
     * @generated from protobuf field: optional uint64 steam_id_gs = 1
     */
    steamIdGs?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 game_id = 2
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 deprecated_game_ip_address = 3
     */
    deprecatedGameIpAddress?: number;
    /**
     * @generated from protobuf field: optional uint32 game_port = 4
     */
    gamePort?: number;
    /**
     * @generated from protobuf field: optional bool is_secure = 5
     */
    isSecure?: boolean;
    /**
     * @generated from protobuf field: optional bytes token = 6
     */
    token?: Uint8Array;
    /**
     * @generated from protobuf field: optional string game_extra_info = 7
     */
    gameExtraInfo?: string;
    /**
     * @generated from protobuf field: optional bytes game_data_blob = 8
     */
    gameDataBlob?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 process_id = 9
     */
    processId?: number;
    /**
     * @generated from protobuf field: optional uint32 streaming_provider_id = 10
     */
    streamingProviderId?: number;
    /**
     * @generated from protobuf field: optional uint32 game_flags = 11
     */
    gameFlags?: number;
    /**
     * @generated from protobuf field: optional uint32 owner_id = 12
     */
    ownerId?: number;
    /**
     * @generated from protobuf field: optional string vr_hmd_vendor = 13
     */
    vrHmdVendor?: string;
    /**
     * @generated from protobuf field: optional string vr_hmd_model = 14
     */
    vrHmdModel?: string;
    /**
     * @generated from protobuf field: optional uint32 launch_option_type = 15 [default = 0]
     */
    launchOptionType?: number;
    /**
     * @generated from protobuf field: optional int32 primary_controller_type = 16 [default = -1]
     */
    primaryControllerType?: number;
    /**
     * @generated from protobuf field: optional string primary_steam_controller_serial = 17 [default = ""]
     */
    primarySteamControllerSerial?: string;
    /**
     * @generated from protobuf field: optional uint32 total_steam_controller_count = 18 [default = 0]
     */
    totalSteamControllerCount?: number;
    /**
     * @generated from protobuf field: optional uint32 total_non_steam_controller_count = 19 [default = 0]
     */
    totalNonSteamControllerCount?: number;
    /**
     * @generated from protobuf field: optional uint64 controller_workshop_file_id = 20 [default = 0]
     */
    controllerWorkshopFileId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 launch_source = 21 [default = 0]
     */
    launchSource?: number;
    /**
     * @generated from protobuf field: optional uint32 vr_hmd_runtime = 22
     */
    vrHmdRuntime?: number;
    /**
     * @generated from protobuf field: optional CMsgIPAddress game_ip_address = 23
     */
    gameIpAddress?: CMsgIPAddress;
    /**
     * @generated from protobuf field: optional uint32 controller_connection_type = 24 [default = 0]
     */
    controllerConnectionType?: number;
}
/**
 * @generated from protobuf message CMsgClientGetAppOwnershipTicket
 */
export interface CMsgClientGetAppOwnershipTicket {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
}
/**
 * @generated from protobuf message CMsgClientGetAppOwnershipTicketResponse
 */
export interface CMsgClientGetAppOwnershipTicketResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional bytes ticket = 3
     */
    ticket?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientGetAuthorizedDevices
 */
export interface CMsgClientGetAuthorizedDevices {
}
/**
 * @generated from protobuf message CMsgClientGetAuthorizedDevicesResponse
 */
export interface CMsgClientGetAuthorizedDevicesResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice authorized_device = 2
     */
    authorizedDevice: CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice
 */
export interface CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
    /**
     * @generated from protobuf field: optional uint64 auth_device_token = 1
     */
    authDeviceToken?: bigint;
    /**
     * @generated from protobuf field: optional string device_name = 2
     */
    deviceName?: string;
    /**
     * @generated from protobuf field: optional uint32 last_access_time = 3
     */
    lastAccessTime?: number;
    /**
     * @generated from protobuf field: optional uint32 borrower_id = 4
     */
    borrowerId?: number;
    /**
     * @generated from protobuf field: optional bool is_pending = 5
     */
    isPending?: boolean;
    /**
     * @generated from protobuf field: optional uint32 app_played = 6
     */
    appPlayed?: number;
}
/**
 * @generated from protobuf message CMsgClientGetCDNAuthToken
 */
export interface CMsgClientGetCDNAuthToken {
    /**
     * @generated from protobuf field: optional uint32 depot_id = 1
     */
    depotId?: number;
    /**
     * @generated from protobuf field: optional string host_name = 2
     */
    hostName?: string;
    /**
     * @generated from protobuf field: optional uint32 app_id = 3
     */
    appId?: number;
}
/**
 * @generated from protobuf message CMsgClientGetCDNAuthTokenResponse
 */
export interface CMsgClientGetCDNAuthTokenResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional string token = 2
     */
    token?: string;
    /**
     * @generated from protobuf field: optional uint32 expiration_time = 3
     */
    expirationTime?: number;
}
/**
 * @generated from protobuf message CMsgClientGetClanActivityCounts
 */
export interface CMsgClientGetClanActivityCounts {
    /**
     * @generated from protobuf field: repeated uint64 steamid_clans = 1
     */
    steamidClans: bigint[];
}
/**
 * @generated from protobuf message CMsgClientGetClanActivityCountsResponse
 */
export interface CMsgClientGetClanActivityCountsResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientGetClientAppList
 */
export interface CMsgClientGetClientAppList {
    /**
     * @generated from protobuf field: optional bool media = 1
     */
    media?: boolean;
    /**
     * @generated from protobuf field: optional bool tools = 2
     */
    tools?: boolean;
    /**
     * @generated from protobuf field: optional bool games = 3
     */
    games?: boolean;
    /**
     * @generated from protobuf field: optional bool only_installed = 4
     */
    onlyInstalled?: boolean;
    /**
     * @generated from protobuf field: optional bool only_changing = 5
     */
    onlyChanging?: boolean;
    /**
     * @generated from protobuf field: optional bool comics = 6
     */
    comics?: boolean;
}
/**
 * @generated from protobuf message CMsgClientGetClientAppListResponse
 */
export interface CMsgClientGetClientAppListResponse {
    /**
     * @generated from protobuf field: repeated CMsgClientGetClientAppListResponse_App apps = 1
     */
    apps: CMsgClientGetClientAppListResponse_App[];
    /**
     * @generated from protobuf field: optional uint64 bytes_available = 2
     */
    bytesAvailable?: bigint;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientGetClientAppListResponse_App
 */
export interface CMsgClientGetClientAppListResponse_App {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string category = 2
     */
    category?: string;
    /**
     * @generated from protobuf field: optional bool favorite = 3
     */
    favorite?: boolean;
    /**
     * @generated from protobuf field: optional bool installed = 4
     */
    installed?: boolean;
    /**
     * @generated from protobuf field: optional bool auto_update = 5
     */
    autoUpdate?: boolean;
    /**
     * @generated from protobuf field: optional uint64 bytes_downloaded = 6
     */
    bytesDownloaded?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes_needed = 7
     */
    bytesNeeded?: bigint;
    /**
     * @generated from protobuf field: optional uint32 bytes_download_rate = 8
     */
    bytesDownloadRate?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientGetClientAppListResponse_App_DLC dlcs = 9
     */
    dlcs: CMsgClientGetClientAppListResponse_App_DLC[];
    /**
     * @generated from protobuf field: optional string app_type = 10
     */
    appType?: string;
    /**
     * @generated from protobuf field: optional bool download_paused = 11
     */
    downloadPaused?: boolean;
    /**
     * @generated from protobuf field: optional uint32 num_downloading = 12
     */
    numDownloading?: number;
    /**
     * @generated from protobuf field: optional uint32 num_paused = 13
     */
    numPaused?: number;
    /**
     * @generated from protobuf field: optional bool changing = 14
     */
    changing?: boolean;
    /**
     * @generated from protobuf field: optional bool available_on_platform = 15
     */
    availableOnPlatform?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientGetClientAppListResponse_App_DLC
 */
export interface CMsgClientGetClientAppListResponse_App_DLC {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional bool installed = 2
     */
    installed?: boolean;
}
/**
 * @generated from protobuf message CMsgClientGetClientDetails
 */
export interface CMsgClientGetClientDetails {
}
/**
 * @generated from protobuf message CMsgClientGetClientDetailsResponse
 */
export interface CMsgClientGetClientDetailsResponse {
    /**
     * @generated from protobuf field: optional uint32 package_version = 1
     */
    packageVersion?: number;
    /**
     * @generated from protobuf field: optional string os = 2
     */
    os?: string;
    /**
     * @generated from protobuf field: optional string machine_name = 3
     */
    machineName?: string;
    /**
     * @generated from protobuf field: optional string ip_public = 4
     */
    ipPublic?: string;
    /**
     * @generated from protobuf field: optional string ip_private = 5
     */
    ipPrivate?: string;
    /**
     * @generated from protobuf field: repeated CMsgClientGetClientDetailsResponse_Game games_running = 6
     */
    gamesRunning: CMsgClientGetClientDetailsResponse_Game[];
    /**
     * @generated from protobuf field: optional uint64 bytes_available = 7
     */
    bytesAvailable?: bigint;
    /**
     * @generated from protobuf field: optional uint32 protocol_version = 8
     */
    protocolVersion?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientGetClientDetailsResponse_Game
 */
export interface CMsgClientGetClientDetailsResponse_Game {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string extra_info = 2
     */
    extraInfo?: string;
    /**
     * @generated from protobuf field: optional uint32 time_running_sec = 3
     */
    timeRunningSec?: number;
}
/**
 * @generated from protobuf message CMsgClientGetDepotDecryptionKey
 */
export interface CMsgClientGetDepotDecryptionKey {
    /**
     * @generated from protobuf field: optional uint32 depot_id = 1
     */
    depotId?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
}
/**
 * @generated from protobuf message CMsgClientGetDepotDecryptionKeyResponse
 */
export interface CMsgClientGetDepotDecryptionKeyResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 depot_id = 2
     */
    depotId?: number;
    /**
     * @generated from protobuf field: optional bytes depot_encryption_key = 3
     */
    depotEncryptionKey?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientGetEmoticonList
 */
export interface CMsgClientGetEmoticonList {
}
/**
 * @generated from protobuf message CMsgClientGetUserStats
 */
export interface CMsgClientGetUserStats {
    /**
     * @generated from protobuf field: optional fixed64 game_id = 1
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 crc_stats = 2
     */
    crcStats?: number;
    /**
     * @generated from protobuf field: optional int32 schema_local_version = 3
     */
    schemaLocalVersion?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_for_user = 4
     */
    steamIdForUser?: bigint;
}
/**
 * @generated from protobuf message CMsgClientGetUserStatsResponse
 */
export interface CMsgClientGetUserStatsResponse {
    /**
     * @generated from protobuf field: optional fixed64 game_id = 1
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional int32 eresult = 2 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 crc_stats = 3
     */
    crcStats?: number;
    /**
     * @generated from protobuf field: optional bytes schema = 4
     */
    schema?: Uint8Array;
    /**
     * @generated from protobuf field: repeated CMsgClientGetUserStatsResponse_Stats stats = 5
     */
    stats: CMsgClientGetUserStatsResponse_Stats[];
    /**
     * @generated from protobuf field: repeated CMsgClientGetUserStatsResponse_Achievement_Blocks achievement_blocks = 6
     */
    achievementBlocks: CMsgClientGetUserStatsResponse_Achievement_Blocks[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientGetUserStatsResponse_Achievement_Blocks
 */
export interface CMsgClientGetUserStatsResponse_Achievement_Blocks {
    /**
     * @generated from protobuf field: optional uint32 achievement_id = 1
     */
    achievementId?: number;
    /**
     * @generated from protobuf field: repeated fixed32 unlock_time = 2
     */
    unlockTime: number[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientGetUserStatsResponse_Stats
 */
export interface CMsgClientGetUserStatsResponse_Stats {
    /**
     * @generated from protobuf field: optional uint32 stat_id = 1
     */
    statId?: number;
    /**
     * @generated from protobuf field: optional uint32 stat_value = 2
     */
    statValue?: number;
}
/**
 * @generated from protobuf message CMsgClientGMSServerQuery
 */
export interface CMsgClientGMSServerQuery {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 geo_location_ip = 2
     */
    geoLocationIp?: number;
    /**
     * @generated from protobuf field: optional uint32 region_code = 3
     */
    regionCode?: number;
    /**
     * @generated from protobuf field: optional string filter_text = 4
     */
    filterText?: string;
    /**
     * @generated from protobuf field: optional uint32 max_servers = 5
     */
    maxServers?: number;
}
/**
 * @generated from protobuf message CMsgClientHeartBeat
 */
export interface CMsgClientHeartBeat {
    /**
     * @generated from protobuf field: optional bool send_reply = 1
     */
    sendReply?: boolean;
}
/**
 * @generated from protobuf message CMsgClientHideFriend
 */
export interface CMsgClientHideFriend {
    /**
     * @generated from protobuf field: optional fixed64 friendid = 1
     */
    friendid?: bigint;
    /**
     * @generated from protobuf field: optional bool hide = 2
     */
    hide?: boolean;
}
/**
 * @generated from protobuf message CMsgClientInstallClientApp
 */
export interface CMsgClientInstallClientApp {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
}
/**
 * @generated from protobuf message CMsgClientInstallClientAppResponse
 */
export interface CMsgClientInstallClientAppResponse {
    /**
     * @generated from protobuf field: optional uint32 result = 1
     */
    result?: number;
}
/**
 * @generated from protobuf message CMsgClientInviteToGame
 */
export interface CMsgClientInviteToGame {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_dest = 1
     */
    steamIdDest?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_src = 2
     */
    steamIdSrc?: bigint;
    /**
     * @generated from protobuf field: optional string connect_string = 3
     */
    connectString?: string;
    /**
     * @generated from protobuf field: optional string remote_play = 4
     */
    remotePlay?: string;
}
/**
 * @generated from protobuf message CMsgClientIsLimitedAccount
 */
export interface CMsgClientIsLimitedAccount {
    /**
     * @generated from protobuf field: optional bool bis_limited_account = 1
     */
    bisLimitedAccount?: boolean;
    /**
     * @generated from protobuf field: optional bool bis_community_banned = 2
     */
    bisCommunityBanned?: boolean;
    /**
     * @generated from protobuf field: optional bool bis_locked_account = 3
     */
    bisLockedAccount?: boolean;
    /**
     * @generated from protobuf field: optional bool bis_limited_account_allowed_to_invite_friends = 4
     */
    bisLimitedAccountAllowedToInviteFriends?: boolean;
}
/**
 * @generated from protobuf message CMsgClientItemAnnouncements
 */
export interface CMsgClientItemAnnouncements {
    /**
     * @generated from protobuf field: optional uint32 count_new_items = 1
     */
    countNewItems?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientItemAnnouncements_UnseenItem unseen_items = 2
     */
    unseenItems: CMsgClientItemAnnouncements_UnseenItem[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientItemAnnouncements_UnseenItem
 */
export interface CMsgClientItemAnnouncements_UnseenItem {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint64 context_id = 2
     */
    contextId?: bigint;
    /**
     * @generated from protobuf field: optional uint64 asset_id = 3
     */
    assetId?: bigint;
    /**
     * @generated from protobuf field: optional uint64 amount = 4
     */
    amount?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 rtime32_gained = 5
     */
    rtime32Gained?: number;
    /**
     * @generated from protobuf field: optional uint32 source_appid = 6
     */
    sourceAppid?: number;
}
/**
 * @generated from protobuf message CMsgClientKickPlayingSession
 */
export interface CMsgClientKickPlayingSession {
    /**
     * @generated from protobuf field: optional bool only_stop_game = 1
     */
    onlyStopGame?: boolean;
}
/**
 * @generated from protobuf message CMsgClientLBSFindOrCreateLB
 */
export interface CMsgClientLBSFindOrCreateLB {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_sort_method = 2
     */
    leaderboardSortMethod?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_display_type = 3
     */
    leaderboardDisplayType?: number;
    /**
     * @generated from protobuf field: optional bool create_if_not_found = 4
     */
    createIfNotFound?: boolean;
    /**
     * @generated from protobuf field: optional string leaderboard_name = 5
     */
    leaderboardName?: string;
}
/**
 * @generated from protobuf message CMsgClientLBSFindOrCreateLBResponse
 */
export interface CMsgClientLBSFindOrCreateLBResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_id = 2
     */
    leaderboardId?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_entry_count = 3
     */
    leaderboardEntryCount?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_sort_method = 4 [default = 0]
     */
    leaderboardSortMethod?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_display_type = 5 [default = 0]
     */
    leaderboardDisplayType?: number;
    /**
     * @generated from protobuf field: optional string leaderboard_name = 6
     */
    leaderboardName?: string;
}
/**
 * @generated from protobuf message CMsgClientLBSGetLBEntries
 */
export interface CMsgClientLBSGetLBEntries {
    /**
     * @generated from protobuf field: optional int32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_id = 2
     */
    leaderboardId?: number;
    /**
     * @generated from protobuf field: optional int32 range_start = 3
     */
    rangeStart?: number;
    /**
     * @generated from protobuf field: optional int32 range_end = 4
     */
    rangeEnd?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_data_request = 5
     */
    leaderboardDataRequest?: number;
    /**
     * @generated from protobuf field: repeated fixed64 steamids = 6
     */
    steamids: bigint[];
}
/**
 * @generated from protobuf message CMsgClientLBSGetLBEntriesResponse
 */
export interface CMsgClientLBSGetLBEntriesResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_entry_count = 2
     */
    leaderboardEntryCount?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientLBSGetLBEntriesResponse_Entry entries = 3
     */
    entries: CMsgClientLBSGetLBEntriesResponse_Entry[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientLBSGetLBEntriesResponse_Entry
 */
export interface CMsgClientLBSGetLBEntriesResponse_Entry {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_user = 1
     */
    steamIdUser?: bigint;
    /**
     * @generated from protobuf field: optional int32 global_rank = 2
     */
    globalRank?: number;
    /**
     * @generated from protobuf field: optional int32 score = 3
     */
    score?: number;
    /**
     * @generated from protobuf field: optional bytes details = 4
     */
    details?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 ugc_id = 5
     */
    ugcId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientLBSSetScore
 */
export interface CMsgClientLBSSetScore {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_id = 2
     */
    leaderboardId?: number;
    /**
     * @generated from protobuf field: optional int32 score = 3
     */
    score?: number;
    /**
     * @generated from protobuf field: optional bytes details = 4
     */
    details?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 upload_score_method = 5
     */
    uploadScoreMethod?: number;
}
/**
 * @generated from protobuf message CMsgClientLBSSetScoreResponse
 */
export interface CMsgClientLBSSetScoreResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_entry_count = 2
     */
    leaderboardEntryCount?: number;
    /**
     * @generated from protobuf field: optional bool score_changed = 3
     */
    scoreChanged?: boolean;
    /**
     * @generated from protobuf field: optional int32 global_rank_previous = 4
     */
    globalRankPrevious?: number;
    /**
     * @generated from protobuf field: optional int32 global_rank_new = 5
     */
    globalRankNew?: number;
}
/**
 * @generated from protobuf message CMsgClientLBSSetUGC
 */
export interface CMsgClientLBSSetUGC {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional int32 leaderboard_id = 2
     */
    leaderboardId?: number;
    /**
     * @generated from protobuf field: optional fixed64 ugc_id = 3
     */
    ugcId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientLBSSetUGCResponse
 */
export interface CMsgClientLBSSetUGCResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientLicenseList
 */
export interface CMsgClientLicenseList {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientLicenseList_License licenses = 2
     */
    licenses: CMsgClientLicenseList_License[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientLicenseList_License
 */
export interface CMsgClientLicenseList_License {
    /**
     * @generated from protobuf field: optional uint32 package_id = 1
     */
    packageId?: number;
    /**
     * @generated from protobuf field: optional fixed32 time_created = 2
     */
    timeCreated?: number;
    /**
     * @generated from protobuf field: optional fixed32 time_next_process = 3
     */
    timeNextProcess?: number;
    /**
     * @generated from protobuf field: optional int32 minute_limit = 4
     */
    minuteLimit?: number;
    /**
     * @generated from protobuf field: optional int32 minutes_used = 5
     */
    minutesUsed?: number;
    /**
     * @generated from protobuf field: optional uint32 payment_method = 6
     */
    paymentMethod?: number;
    /**
     * @generated from protobuf field: optional uint32 flags = 7
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional string purchase_country_code = 8
     */
    purchaseCountryCode?: string;
    /**
     * @generated from protobuf field: optional uint32 license_type = 9
     */
    licenseType?: number;
    /**
     * @generated from protobuf field: optional int32 territory_code = 10
     */
    territoryCode?: number;
    /**
     * @generated from protobuf field: optional int32 change_number = 11
     */
    changeNumber?: number;
    /**
     * @generated from protobuf field: optional uint32 owner_id = 12
     */
    ownerId?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_period = 13
     */
    initialPeriod?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_time_unit = 14
     */
    initialTimeUnit?: number;
    /**
     * @generated from protobuf field: optional uint32 renewal_period = 15
     */
    renewalPeriod?: number;
    /**
     * @generated from protobuf field: optional uint32 renewal_time_unit = 16
     */
    renewalTimeUnit?: number;
    /**
     * @generated from protobuf field: optional uint64 access_token = 17
     */
    accessToken?: bigint;
    /**
     * @generated from protobuf field: optional uint32 master_package_id = 18
     */
    masterPackageId?: number;
}
/**
 * @generated from protobuf message CMsgClientLoggedOff
 */
export interface CMsgClientLoggedOff {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientLogOff
 */
export interface CMsgClientLogOff {
}
/**
 * @generated from protobuf message CMsgClientLogon
 */
export interface CMsgClientLogon {
    /**
     * @generated from protobuf field: optional uint32 protocol_version = 1
     */
    protocolVersion?: number;
    /**
     * @generated from protobuf field: optional uint32 deprecated_obfustucated_private_ip = 2
     */
    deprecatedObfustucatedPrivateIp?: number;
    /**
     * @generated from protobuf field: optional uint32 cell_id = 3
     */
    cellId?: number;
    /**
     * @generated from protobuf field: optional uint32 last_session_id = 4
     */
    lastSessionId?: number;
    /**
     * @generated from protobuf field: optional uint32 client_package_version = 5
     */
    clientPackageVersion?: number;
    /**
     * @generated from protobuf field: optional string client_language = 6
     */
    clientLanguage?: string;
    /**
     * @generated from protobuf field: optional uint32 client_os_type = 7
     */
    clientOsType?: number;
    /**
     * @generated from protobuf field: optional bool should_remember_password = 8 [default = false]
     */
    shouldRememberPassword?: boolean;
    /**
     * @generated from protobuf field: optional string wine_version = 9
     */
    wineVersion?: string;
    /**
     * @generated from protobuf field: optional uint32 deprecated_10 = 10
     */
    deprecated10?: number;
    /**
     * @generated from protobuf field: optional CMsgIPAddress obfuscated_private_ip = 11
     */
    obfuscatedPrivateIp?: CMsgIPAddress;
    /**
     * @generated from protobuf field: optional uint32 deprecated_public_ip = 20
     */
    deprecatedPublicIp?: number;
    /**
     * @generated from protobuf field: optional uint32 qos_level = 21
     */
    qosLevel?: number;
    /**
     * @generated from protobuf field: optional fixed64 client_supplied_steam_id = 22
     */
    clientSuppliedSteamId?: bigint;
    /**
     * @generated from protobuf field: optional CMsgIPAddress public_ip = 23
     */
    publicIp?: CMsgIPAddress;
    /**
     * @generated from protobuf field: optional bytes machine_id = 30
     */
    machineId?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 launcher_type = 31 [default = 0]
     */
    launcherType?: number;
    /**
     * @generated from protobuf field: optional uint32 ui_mode = 32 [default = 0]
     */
    uiMode?: number;
    /**
     * @generated from protobuf field: optional uint32 chat_mode = 33 [default = 0]
     */
    chatMode?: number;
    /**
     * @generated from protobuf field: optional bytes steam2_auth_ticket = 41
     */
    steam2AuthTicket?: Uint8Array;
    /**
     * @generated from protobuf field: optional string email_address = 42
     */
    emailAddress?: string;
    /**
     * @generated from protobuf field: optional fixed32 rtime32_account_creation = 43
     */
    rtime32AccountCreation?: number;
    /**
     * @generated from protobuf field: optional string account_name = 50
     */
    accountName?: string;
    /**
     * @generated from protobuf field: optional string password = 51
     */
    password?: string;
    /**
     * @generated from protobuf field: optional string game_server_token = 52
     */
    gameServerToken?: string;
    /**
     * @generated from protobuf field: optional string login_key = 60
     */
    loginKey?: string;
    /**
     * @generated from protobuf field: optional bool was_converted_deprecated_msg = 70 [default = false]
     */
    wasConvertedDeprecatedMsg?: boolean;
    /**
     * @generated from protobuf field: optional string anon_user_target_account_name = 80
     */
    anonUserTargetAccountName?: string;
    /**
     * @generated from protobuf field: optional fixed64 resolved_user_steam_id = 81
     */
    resolvedUserSteamId?: bigint;
    /**
     * @generated from protobuf field: optional int32 eresult_sentryfile = 82
     */
    eresultSentryfile?: number;
    /**
     * @generated from protobuf field: optional bytes sha_sentryfile = 83
     */
    shaSentryfile?: Uint8Array;
    /**
     * @generated from protobuf field: optional string auth_code = 84
     */
    authCode?: string;
    /**
     * @generated from protobuf field: optional int32 otp_type = 85
     */
    otpType?: number;
    /**
     * @generated from protobuf field: optional uint32 otp_value = 86
     */
    otpValue?: number;
    /**
     * @generated from protobuf field: optional string otp_identifier = 87
     */
    otpIdentifier?: string;
    /**
     * @generated from protobuf field: optional bool steam2_ticket_request = 88
     */
    steam2TicketRequest?: boolean;
    /**
     * @generated from protobuf field: optional bytes sony_psn_ticket = 90
     */
    sonyPsnTicket?: Uint8Array;
    /**
     * @generated from protobuf field: optional string sony_psn_service_id = 91
     */
    sonyPsnServiceId?: string;
    /**
     * @generated from protobuf field: optional bool create_new_psn_linked_account_if_needed = 92 [default = false]
     */
    createNewPsnLinkedAccountIfNeeded?: boolean;
    /**
     * @generated from protobuf field: optional string sony_psn_name = 93
     */
    sonyPsnName?: string;
    /**
     * @generated from protobuf field: optional int32 game_server_app_id = 94
     */
    gameServerAppId?: number;
    /**
     * @generated from protobuf field: optional bool steamguard_dont_remember_computer = 95
     */
    steamguardDontRememberComputer?: boolean;
    /**
     * @generated from protobuf field: optional string machine_name = 96
     */
    machineName?: string;
    /**
     * @generated from protobuf field: optional string machine_name_userchosen = 97
     */
    machineNameUserchosen?: string;
    /**
     * @generated from protobuf field: optional string country_override = 98
     */
    countryOverride?: string;
    /**
     * @generated from protobuf field: optional bool is_steam_box = 99
     */
    isSteamBox?: boolean;
    /**
     * @generated from protobuf field: optional uint64 client_instance_id = 100
     */
    clientInstanceId?: bigint;
    /**
     * @generated from protobuf field: optional string two_factor_code = 101
     */
    twoFactorCode?: string;
    /**
     * @generated from protobuf field: optional bool supports_rate_limit_response = 102
     */
    supportsRateLimitResponse?: boolean;
    /**
     * @generated from protobuf field: optional string web_logon_nonce = 103
     */
    webLogonNonce?: string;
    /**
     * @generated from protobuf field: optional int32 priority_reason = 104
     */
    priorityReason?: number;
    /**
     * @generated from protobuf field: optional CMsgClientSecret embedded_client_secret = 105
     */
    embeddedClientSecret?: CMsgClientSecret;
    /**
     * @generated from protobuf field: optional bool disable_partner_autogrants = 106
     */
    disablePartnerAutogrants?: boolean;
    /**
     * @generated from protobuf field: optional bool is_steam_deck = 107
     */
    isSteamDeck?: boolean;
    /**
     * @generated from protobuf field: optional string access_token = 108
     */
    accessToken?: string;
    /**
     * @generated from protobuf field: optional bool is_chrome_os = 109
     */
    isChromeOs?: boolean;
    /**
     * @generated from protobuf field: optional bool is_tesla = 110
     */
    isTesla?: boolean;
}
/**
 * @generated from protobuf message CMsgClientLogonResponse
 */
export interface CMsgClientLogonResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 legacy_out_of_game_heartbeat_seconds = 2
     */
    legacyOutOfGameHeartbeatSeconds?: number;
    /**
     * optional int32 out_of_game_heartbeat_seconds = 2;
     *
     * @generated from protobuf field: optional int32 heartbeat_seconds = 3
     */
    heartbeatSeconds?: number;
    /**
     * optional int32 in_game_heartbeat_seconds = 3;
     *
     * @generated from protobuf field: optional uint32 deprecated_public_ip = 4
     */
    deprecatedPublicIp?: number;
    /**
     * @generated from protobuf field: optional fixed32 rtime32_server_time = 5
     */
    rtime32ServerTime?: number;
    /**
     * @generated from protobuf field: optional uint32 account_flags = 6
     */
    accountFlags?: number;
    /**
     * @generated from protobuf field: optional uint32 cell_id = 7
     */
    cellId?: number;
    /**
     * @generated from protobuf field: optional string email_domain = 8
     */
    emailDomain?: string;
    /**
     * @generated from protobuf field: optional bytes steam2_ticket = 9
     */
    steam2Ticket?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 eresult_extended = 10
     */
    eresultExtended?: number;
    /**
     * @generated from protobuf field: optional string webapi_authenticate_user_nonce = 11
     */
    webapiAuthenticateUserNonce?: string;
    /**
     * @generated from protobuf field: optional uint32 cell_id_ping_threshold = 12
     */
    cellIdPingThreshold?: number;
    /**
     * @generated from protobuf field: optional bool deprecated_use_pics = 13
     */
    deprecatedUsePics?: boolean;
    /**
     * @generated from protobuf field: optional string vanity_url = 14
     */
    vanityUrl?: string;
    /**
     * @generated from protobuf field: optional CMsgIPAddress public_ip = 15
     */
    publicIp?: CMsgIPAddress;
    /**
     * @generated from protobuf field: optional string user_country = 16
     */
    userCountry?: string;
    /**
     * @generated from protobuf field: optional fixed64 client_supplied_steamid = 20
     */
    clientSuppliedSteamid?: bigint;
    /**
     * @generated from protobuf field: optional string ip_country_code = 21
     */
    ipCountryCode?: string;
    /**
     * @generated from protobuf field: optional bytes parental_settings = 22
     */
    parentalSettings?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes parental_setting_signature = 23
     */
    parentalSettingSignature?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 count_loginfailures_to_migrate = 24
     */
    countLoginfailuresToMigrate?: number;
    /**
     * @generated from protobuf field: optional int32 count_disconnects_to_migrate = 25
     */
    countDisconnectsToMigrate?: number;
    /**
     * @generated from protobuf field: optional int32 ogs_data_report_time_window = 26
     */
    ogsDataReportTimeWindow?: number;
    /**
     * @generated from protobuf field: optional uint64 client_instance_id = 27
     */
    clientInstanceId?: bigint;
    /**
     * @generated from protobuf field: optional bool force_client_update_check = 28
     */
    forceClientUpdateCheck?: boolean;
    /**
     * @generated from protobuf field: optional string agreement_session_url = 29
     */
    agreementSessionUrl?: string;
    /**
     * @generated from protobuf field: optional uint64 token_id = 30
     */
    tokenId?: bigint;
    /**
     * @generated from protobuf field: optional uint64 family_group_id = 31
     */
    familyGroupId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientManageFriendsGroup
 */
export interface CMsgClientManageFriendsGroup {
    /**
     * @generated from protobuf field: optional int32 groupid = 1
     */
    groupid?: number;
    /**
     * @generated from protobuf field: optional string groupname = 2
     */
    groupname?: string;
    /**
     * @generated from protobuf field: repeated fixed64 steamid_friends_added = 3
     */
    steamidFriendsAdded: bigint[];
    /**
     * @generated from protobuf field: repeated fixed64 steamid_friends_removed = 4
     */
    steamidFriendsRemoved: bigint[];
}
/**
 * @generated from protobuf message CMsgClientManageFriendsGroupResponse
 */
export interface CMsgClientManageFriendsGroupResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientMMSCreateLobby
 */
export interface CMsgClientMMSCreateLobby {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional int32 max_members = 2
     */
    maxMembers?: number;
    /**
     * @generated from protobuf field: optional int32 lobby_type = 3
     */
    lobbyType?: number;
    /**
     * @generated from protobuf field: optional int32 lobby_flags = 4
     */
    lobbyFlags?: number;
    /**
     * @generated from protobuf field: optional uint32 cell_id = 5
     */
    cellId?: number;
    /**
     * @generated from protobuf field: optional uint32 deprecated_public_ip = 6
     */
    deprecatedPublicIp?: number;
    /**
     * @generated from protobuf field: optional bytes metadata = 7
     */
    metadata?: Uint8Array;
    /**
     * @generated from protobuf field: optional string persona_name_owner = 8
     */
    personaNameOwner?: string;
    /**
     * @generated from protobuf field: optional CMsgIPAddress public_ip = 9
     */
    publicIp?: CMsgIPAddress;
}
/**
 * @generated from protobuf message CMsgClientMMSCreateLobbyResponse
 */
export interface CMsgClientMMSCreateLobbyResponse {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional int32 eresult = 3 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientMMSGetLobbyData
 */
export interface CMsgClientMMSGetLobbyData {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
}
/**
 * @generated from protobuf message CMsgClientMMSGetLobbyList
 */
export interface CMsgClientMMSGetLobbyList {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional int32 num_lobbies_requested = 3
     */
    numLobbiesRequested?: number;
    /**
     * @generated from protobuf field: optional uint32 cell_id = 4
     */
    cellId?: number;
    /**
     * @generated from protobuf field: optional uint32 deprecated_public_ip = 5
     */
    deprecatedPublicIp?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientMMSGetLobbyList_Filter filters = 6
     */
    filters: CMsgClientMMSGetLobbyList_Filter[];
    /**
     * @generated from protobuf field: optional CMsgIPAddress public_ip = 7
     */
    publicIp?: CMsgIPAddress;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientMMSGetLobbyList_Filter
 */
export interface CMsgClientMMSGetLobbyList_Filter {
    /**
     * @generated from protobuf field: optional string key = 1
     */
    key?: string;
    /**
     * @generated from protobuf field: optional string value = 2
     */
    value?: string;
    /**
     * @generated from protobuf field: optional int32 comparision = 3
     */
    comparision?: number;
    /**
     * @generated from protobuf field: optional int32 filter_type = 4
     */
    filterType?: number;
}
/**
 * @generated from protobuf message CMsgClientMMSGetLobbyListResponse
 */
export interface CMsgClientMMSGetLobbyListResponse {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional int32 eresult = 3 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientMMSGetLobbyListResponse_Lobby lobbies = 4
     */
    lobbies: CMsgClientMMSGetLobbyListResponse_Lobby[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientMMSGetLobbyListResponse_Lobby
 */
export interface CMsgClientMMSGetLobbyListResponse_Lobby {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional int32 max_members = 2
     */
    maxMembers?: number;
    /**
     * @generated from protobuf field: optional int32 lobby_type = 3
     */
    lobbyType?: number;
    /**
     * @generated from protobuf field: optional int32 lobby_flags = 4
     */
    lobbyFlags?: number;
    /**
     * @generated from protobuf field: optional bytes metadata = 5
     */
    metadata?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 num_members = 6
     */
    numMembers?: number;
    /**
     * @generated from protobuf field: optional float distance = 7
     */
    distance?: number;
    /**
     * @generated from protobuf field: optional int64 weight = 8
     */
    weight?: bigint;
}
/**
 * @generated from protobuf message CMsgClientMMSGetLobbyStatus
 */
export interface CMsgClientMMSGetLobbyStatus {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional bool claim_membership = 3
     */
    claimMembership?: boolean;
    /**
     * @generated from protobuf field: optional bool claim_ownership = 4
     */
    claimOwnership?: boolean;
}
/**
 * @generated from protobuf message CMsgClientMMSGetLobbyStatusResponse
 */
export interface CMsgClientMMSGetLobbyStatusResponse {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional int32 lobby_status = 3
     */
    lobbyStatus?: number;
}
/**
 * @generated from protobuf message CMsgClientMMSInviteToLobby
 */
export interface CMsgClientMMSInviteToLobby {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_user_invited = 3
     */
    steamIdUserInvited?: bigint;
}
/**
 * @generated from protobuf message CMsgClientMMSJoinLobby
 */
export interface CMsgClientMMSJoinLobby {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional string persona_name = 3
     */
    personaName?: string;
}
/**
 * @generated from protobuf message CMsgClientMMSJoinLobbyResponse
 */
export interface CMsgClientMMSJoinLobbyResponse {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional int32 chat_room_enter_response = 3
     */
    chatRoomEnterResponse?: number;
    /**
     * @generated from protobuf field: optional int32 max_members = 4
     */
    maxMembers?: number;
    /**
     * @generated from protobuf field: optional int32 lobby_type = 5
     */
    lobbyType?: number;
    /**
     * @generated from protobuf field: optional int32 lobby_flags = 6
     */
    lobbyFlags?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_owner = 7
     */
    steamIdOwner?: bigint;
    /**
     * @generated from protobuf field: optional bytes metadata = 8
     */
    metadata?: Uint8Array;
    /**
     * @generated from protobuf field: repeated CMsgClientMMSJoinLobbyResponse_Member members = 9
     */
    members: CMsgClientMMSJoinLobbyResponse_Member[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientMMSJoinLobbyResponse_Member
 */
export interface CMsgClientMMSJoinLobbyResponse_Member {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional string persona_name = 2
     */
    personaName?: string;
    /**
     * @generated from protobuf field: optional bytes metadata = 3
     */
    metadata?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientMMSLeaveLobby
 */
export interface CMsgClientMMSLeaveLobby {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
}
/**
 * @generated from protobuf message CMsgClientMMSLeaveLobbyResponse
 */
export interface CMsgClientMMSLeaveLobbyResponse {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional int32 eresult = 3 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientMMSLobbyChatMsg
 */
export interface CMsgClientMMSLobbyChatMsg {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_sender = 3
     */
    steamIdSender?: bigint;
    /**
     * @generated from protobuf field: optional bytes lobby_message = 4
     */
    lobbyMessage?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientMMSLobbyData
 */
export interface CMsgClientMMSLobbyData {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional int32 num_members = 3
     */
    numMembers?: number;
    /**
     * @generated from protobuf field: optional int32 max_members = 4
     */
    maxMembers?: number;
    /**
     * @generated from protobuf field: optional int32 lobby_type = 5
     */
    lobbyType?: number;
    /**
     * @generated from protobuf field: optional int32 lobby_flags = 6
     */
    lobbyFlags?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_owner = 7
     */
    steamIdOwner?: bigint;
    /**
     * @generated from protobuf field: optional bytes metadata = 8
     */
    metadata?: Uint8Array;
    /**
     * @generated from protobuf field: repeated CMsgClientMMSLobbyData_Member members = 9
     */
    members: CMsgClientMMSLobbyData_Member[];
    /**
     * @generated from protobuf field: optional uint32 lobby_cellid = 10
     */
    lobbyCellid?: number;
    /**
     * @generated from protobuf field: optional bool owner_should_accept_changes = 11
     */
    ownerShouldAcceptChanges?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientMMSLobbyData_Member
 */
export interface CMsgClientMMSLobbyData_Member {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional string persona_name = 2
     */
    personaName?: string;
    /**
     * @generated from protobuf field: optional bytes metadata = 3
     */
    metadata?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientMMSLobbyGameServerSet
 */
export interface CMsgClientMMSLobbyGameServerSet {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional uint32 deprecated_game_server_ip = 3
     */
    deprecatedGameServerIp?: number;
    /**
     * @generated from protobuf field: optional uint32 game_server_port = 4
     */
    gameServerPort?: number;
    /**
     * @generated from protobuf field: optional fixed64 game_server_steam_id = 5
     */
    gameServerSteamId?: bigint;
    /**
     * @generated from protobuf field: optional CMsgIPAddress game_server_ip = 6
     */
    gameServerIp?: CMsgIPAddress;
}
/**
 * @generated from protobuf message CMsgClientMMSSendLobbyChatMsg
 */
export interface CMsgClientMMSSendLobbyChatMsg {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_target = 3
     */
    steamIdTarget?: bigint;
    /**
     * @generated from protobuf field: optional bytes lobby_message = 4
     */
    lobbyMessage?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientMMSSetLobbyData
 */
export interface CMsgClientMMSSetLobbyData {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_member = 3
     */
    steamIdMember?: bigint;
    /**
     * @generated from protobuf field: optional int32 max_members = 4
     */
    maxMembers?: number;
    /**
     * @generated from protobuf field: optional int32 lobby_type = 5
     */
    lobbyType?: number;
    /**
     * @generated from protobuf field: optional int32 lobby_flags = 6
     */
    lobbyFlags?: number;
    /**
     * @generated from protobuf field: optional bytes metadata = 7
     */
    metadata?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientMMSSetLobbyDataResponse
 */
export interface CMsgClientMMSSetLobbyDataResponse {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional int32 eresult = 3 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientMMSSetLobbyGameServer
 */
export interface CMsgClientMMSSetLobbyGameServer {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional uint32 deprecated_game_server_ip = 3
     */
    deprecatedGameServerIp?: number;
    /**
     * @generated from protobuf field: optional uint32 game_server_port = 4
     */
    gameServerPort?: number;
    /**
     * @generated from protobuf field: optional fixed64 game_server_steam_id = 5
     */
    gameServerSteamId?: bigint;
    /**
     * @generated from protobuf field: optional CMsgIPAddress game_server_ip = 6
     */
    gameServerIp?: CMsgIPAddress;
}
/**
 * @generated from protobuf message CMsgClientMMSSetLobbyLinked
 */
export interface CMsgClientMMSSetLobbyLinked {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby2 = 3
     */
    steamIdLobby2?: bigint;
}
/**
 * @generated from protobuf message CMsgClientMMSSetLobbyOwner
 */
export interface CMsgClientMMSSetLobbyOwner {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_new_owner = 3
     */
    steamIdNewOwner?: bigint;
}
/**
 * @generated from protobuf message CMsgClientMMSSetLobbyOwnerResponse
 */
export interface CMsgClientMMSSetLobbyOwnerResponse {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional int32 eresult = 3 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientMMSSetRatelimitPolicyOnClient
 */
export interface CMsgClientMMSSetRatelimitPolicyOnClient {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional bool enable_rate_limits = 2
     */
    enableRateLimits?: boolean;
    /**
     * @generated from protobuf field: optional int32 seconds_per_message = 3
     */
    secondsPerMessage?: number;
    /**
     * @generated from protobuf field: optional int32 milliseconds_per_data_update = 4
     */
    millisecondsPerDataUpdate?: number;
}
/**
 * @generated from protobuf message CMsgClientMMSUserJoinedLobby
 */
export interface CMsgClientMMSUserJoinedLobby {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_user = 3
     */
    steamIdUser?: bigint;
    /**
     * @generated from protobuf field: optional string persona_name = 4
     */
    personaName?: string;
}
/**
 * @generated from protobuf message CMsgClientMMSUserLeftLobby
 */
export interface CMsgClientMMSUserLeftLobby {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_lobby = 2
     */
    steamIdLobby?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_user = 3
     */
    steamIdUser?: bigint;
    /**
     * @generated from protobuf field: optional string persona_name = 4
     */
    personaName?: string;
}
/**
 * @generated from protobuf message CMsgClientNetworkingCertReply
 */
export interface CMsgClientNetworkingCertReply {
    /**
     * @generated from protobuf field: optional bytes cert = 4
     */
    cert?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 ca_key_id = 5
     */
    caKeyId?: bigint;
    /**
     * @generated from protobuf field: optional bytes ca_signature = 6
     */
    caSignature?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientNetworkingCertRequest
 */
export interface CMsgClientNetworkingCertRequest {
    /**
     * @generated from protobuf field: optional bytes key_data = 2
     */
    keyData?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 app_id = 3
     */
    appId?: number;
}
/**
 * @generated from protobuf message CMsgClientNetworkingMobileCertReply
 */
export interface CMsgClientNetworkingMobileCertReply {
    /**
     * @generated from protobuf field: optional string encoded_cert = 1
     */
    encodedCert?: string;
}
/**
 * @generated from protobuf message CMsgClientNetworkingMobileCertRequest
 */
export interface CMsgClientNetworkingMobileCertRequest {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
}
/**
 * @generated from protobuf message CMsgClientNewLoginKey
 */
export interface CMsgClientNewLoginKey {
    /**
     * @generated from protobuf field: optional uint32 unique_id = 1
     */
    uniqueId?: number;
    /**
     * @generated from protobuf field: optional string login_key = 2
     */
    loginKey?: string;
}
/**
 * @generated from protobuf message CMsgClientNewLoginKeyAccepted
 */
export interface CMsgClientNewLoginKeyAccepted {
    /**
     * @generated from protobuf field: optional uint32 unique_id = 1
     */
    uniqueId?: number;
}
/**
 * @generated from protobuf message CMsgClientOfflineMessageNotification
 */
export interface CMsgClientOfflineMessageNotification {
    /**
     * @generated from protobuf field: optional uint32 offline_messages = 1
     */
    offlineMessages?: number;
    /**
     * @generated from protobuf field: repeated uint32 friends_with_offline_messages = 2
     */
    friendsWithOfflineMessages: number[];
}
/**
 * @generated from protobuf message CMsgClientOGSReportBug
 */
export interface CMsgClientOGSReportBug {
    /**
     * @generated from protobuf field: optional uint64 sessionid = 1
     */
    sessionid?: bigint;
    /**
     * @generated from protobuf field: optional string bugtext = 2
     */
    bugtext?: string;
    /**
     * @generated from protobuf field: optional bytes screenshot = 3
     */
    screenshot?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientOGSReportString
 */
export interface CMsgClientOGSReportString {
    /**
     * @generated from protobuf field: optional bool accumulated = 1
     */
    accumulated?: boolean;
    /**
     * @generated from protobuf field: optional uint64 sessionid = 2
     */
    sessionid?: bigint;
    /**
     * @generated from protobuf field: optional int32 severity = 3
     */
    severity?: number;
    /**
     * @generated from protobuf field: optional string formatter = 4
     */
    formatter?: string;
    /**
     * @generated from protobuf field: optional bytes varargs = 5
     */
    varargs?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientP2PConnectionFailInfo
 */
export interface CMsgClientP2PConnectionFailInfo {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_dest = 1
     */
    steamIdDest?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_src = 2
     */
    steamIdSrc?: bigint;
    /**
     * @generated from protobuf field: optional uint32 app_id = 3
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 ep2p_session_error = 4
     */
    ep2PSessionError?: number;
    /**
     * @generated from protobuf field: optional fixed64 connection_id_dest = 5
     */
    connectionIdDest?: bigint;
    /**
     * @generated from protobuf field: optional uint32 close_reason = 7
     */
    closeReason?: number;
    /**
     * @generated from protobuf field: optional string close_message = 8
     */
    closeMessage?: string;
}
/**
 * @generated from protobuf message CMsgClientP2PConnectionInfo
 */
export interface CMsgClientP2PConnectionInfo {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_dest = 1
     */
    steamIdDest?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steam_id_src = 2
     */
    steamIdSrc?: bigint;
    /**
     * @generated from protobuf field: optional uint32 app_id = 3
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional bytes candidate = 4
     */
    candidate?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 connection_id_src = 5
     */
    connectionIdSrc?: bigint;
    /**
     * @generated from protobuf field: optional bytes rendezvous = 6
     */
    rendezvous?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientPackageInfoRequest
 */
export interface CMsgClientPackageInfoRequest {
    /**
     * @generated from protobuf field: repeated uint32 package_ids = 1
     */
    packageIds: number[];
    /**
     * @generated from protobuf field: optional bool meta_data_only = 2
     */
    metaDataOnly?: boolean;
}
/**
 * @generated from protobuf message CMsgClientPackageInfoResponse
 */
export interface CMsgClientPackageInfoResponse {
    /**
     * @generated from protobuf field: repeated CMsgClientPackageInfoResponse_Package packages = 1
     */
    packages: CMsgClientPackageInfoResponse_Package[];
    /**
     * @generated from protobuf field: repeated uint32 packages_unknown = 2
     */
    packagesUnknown: number[];
    /**
     * @generated from protobuf field: optional uint32 packages_pending = 3
     */
    packagesPending?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientPackageInfoResponse_Package
 */
export interface CMsgClientPackageInfoResponse_Package {
    /**
     * @generated from protobuf field: optional uint32 package_id = 1
     */
    packageId?: number;
    /**
     * @generated from protobuf field: optional uint32 change_number = 2
     */
    changeNumber?: number;
    /**
     * @generated from protobuf field: optional bytes sha = 3
     */
    sha?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes buffer = 4
     */
    buffer?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientPersonaState
 */
export interface CMsgClientPersonaState {
    /**
     * @generated from protobuf field: optional uint32 status_flags = 1
     */
    statusFlags?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientPersonaState_Friend friends = 2
     */
    friends: CMsgClientPersonaState_Friend[];
}
/**
 * Used by: ChatRoom, ChatRoomClient, common.proto
 *
 * @generated from protobuf message CMsgClientPersonaState_Friend
 */
export interface CMsgClientPersonaState_Friend {
    /**
     * @generated from protobuf field: optional fixed64 friendid = 1
     */
    friendid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 persona_state = 2
     */
    personaState?: number;
    /**
     * @generated from protobuf field: optional uint32 game_played_app_id = 3
     */
    gamePlayedAppId?: number;
    /**
     * @generated from protobuf field: optional uint32 game_server_ip = 4
     */
    gameServerIp?: number;
    /**
     * @generated from protobuf field: optional uint32 game_server_port = 5
     */
    gameServerPort?: number;
    /**
     * @generated from protobuf field: optional uint32 persona_state_flags = 6
     */
    personaStateFlags?: number;
    /**
     * @generated from protobuf field: optional uint32 online_session_instances = 7
     */
    onlineSessionInstances?: number;
    /**
     * @generated from protobuf field: optional bool persona_set_by_user = 10
     */
    personaSetByUser?: boolean;
    /**
     * @generated from protobuf field: optional string player_name = 15
     */
    playerName?: string;
    /**
     * @generated from protobuf field: optional uint32 query_port = 20
     */
    queryPort?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid_source = 25
     */
    steamidSource?: bigint;
    /**
     * @generated from protobuf field: optional bytes avatar_hash = 31
     */
    avatarHash?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 last_logoff = 45
     */
    lastLogoff?: number;
    /**
     * @generated from protobuf field: optional uint32 last_logon = 46
     */
    lastLogon?: number;
    /**
     * @generated from protobuf field: optional uint32 last_seen_online = 47
     */
    lastSeenOnline?: number;
    /**
     * @generated from protobuf field: optional uint32 clan_rank = 50
     */
    clanRank?: number;
    /**
     * @generated from protobuf field: optional string game_name = 55
     */
    gameName?: string;
    /**
     * @generated from protobuf field: optional fixed64 gameid = 56
     */
    gameid?: bigint;
    /**
     * @generated from protobuf field: optional bytes game_data_blob = 60
     */
    gameDataBlob?: Uint8Array;
    /**
     * @generated from protobuf field: optional CMsgClientPersonaState_Friend_ClanData clan_data = 64
     */
    clanData?: CMsgClientPersonaState_Friend_ClanData;
    /**
     * @generated from protobuf field: optional string clan_tag = 65
     */
    clanTag?: string;
    /**
     * @generated from protobuf field: repeated CMsgClientPersonaState_Friend_KV rich_presence = 71
     */
    richPresence: CMsgClientPersonaState_Friend_KV[];
    /**
     * @generated from protobuf field: optional fixed64 broadcast_id = 72
     */
    broadcastId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 game_lobby_id = 73
     */
    gameLobbyId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 watching_broadcast_accountid = 74
     */
    watchingBroadcastAccountid?: number;
    /**
     * @generated from protobuf field: optional uint32 watching_broadcast_appid = 75
     */
    watchingBroadcastAppid?: number;
    /**
     * @generated from protobuf field: optional uint32 watching_broadcast_viewers = 76
     */
    watchingBroadcastViewers?: number;
    /**
     * @generated from protobuf field: optional string watching_broadcast_title = 77
     */
    watchingBroadcastTitle?: string;
    /**
     * @generated from protobuf field: optional bool is_community_banned = 78
     */
    isCommunityBanned?: boolean;
    /**
     * @generated from protobuf field: optional bool player_name_pending_review = 79
     */
    playerNamePendingReview?: boolean;
    /**
     * @generated from protobuf field: optional bool avatar_pending_review = 80
     */
    avatarPendingReview?: boolean;
    /**
     * @generated from protobuf field: optional bool on_steam_deck = 81
     */
    onSteamDeck?: boolean;
    /**
     * @generated from protobuf field: repeated CMsgClientPersonaState_Friend_OtherGameData other_game_data = 82
     */
    otherGameData: CMsgClientPersonaState_Friend_OtherGameData[];
}
/**
 * Used by: ChatRoom, ChatRoomClient, common.proto
 *
 * @generated from protobuf message CMsgClientPersonaState_Friend_ClanData
 */
export interface CMsgClientPersonaState_Friend_ClanData {
    /**
     * @generated from protobuf field: optional uint32 ogg_app_id = 1
     */
    oggAppId?: number;
    /**
     * @generated from protobuf field: optional uint64 chat_group_id = 2
     */
    chatGroupId?: bigint;
}
/**
 * Used by: ChatRoom, ChatRoomClient, common.proto
 *
 * @generated from protobuf message CMsgClientPersonaState_Friend_KV
 */
export interface CMsgClientPersonaState_Friend_KV {
    /**
     * @generated from protobuf field: optional string key = 1
     */
    key?: string;
    /**
     * @generated from protobuf field: optional string value = 2
     */
    value?: string;
}
/**
 * Used by: ChatRoom, ChatRoomClient, common.proto
 *
 * @generated from protobuf message CMsgClientPersonaState_Friend_OtherGameData
 */
export interface CMsgClientPersonaState_Friend_OtherGameData {
    /**
     * @generated from protobuf field: optional uint64 gameid = 1
     */
    gameid?: bigint;
    /**
     * @generated from protobuf field: repeated CMsgClientPersonaState_Friend_KV rich_presence = 2
     */
    richPresence: CMsgClientPersonaState_Friend_KV[];
}
/**
 * @generated from protobuf message CMsgClientPICSAccessTokenRequest
 */
export interface CMsgClientPICSAccessTokenRequest {
    /**
     * @generated from protobuf field: repeated uint32 packageids = 1
     */
    packageids: number[];
    /**
     * @generated from protobuf field: repeated uint32 appids = 2
     */
    appids: number[];
}
/**
 * @generated from protobuf message CMsgClientPICSAccessTokenResponse
 */
export interface CMsgClientPICSAccessTokenResponse {
    /**
     * @generated from protobuf field: repeated CMsgClientPICSAccessTokenResponse_PackageToken package_access_tokens = 1
     */
    packageAccessTokens: CMsgClientPICSAccessTokenResponse_PackageToken[];
    /**
     * @generated from protobuf field: repeated uint32 package_denied_tokens = 2
     */
    packageDeniedTokens: number[];
    /**
     * @generated from protobuf field: repeated CMsgClientPICSAccessTokenResponse_AppToken app_access_tokens = 3
     */
    appAccessTokens: CMsgClientPICSAccessTokenResponse_AppToken[];
    /**
     * @generated from protobuf field: repeated uint32 app_denied_tokens = 4
     */
    appDeniedTokens: number[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientPICSAccessTokenResponse_AppToken
 */
export interface CMsgClientPICSAccessTokenResponse_AppToken {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint64 access_token = 2
     */
    accessToken?: bigint;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientPICSAccessTokenResponse_PackageToken
 */
export interface CMsgClientPICSAccessTokenResponse_PackageToken {
    /**
     * @generated from protobuf field: optional uint32 packageid = 1
     */
    packageid?: number;
    /**
     * @generated from protobuf field: optional uint64 access_token = 2
     */
    accessToken?: bigint;
}
/**
 * @generated from protobuf message CMsgClientPICSChangesSinceRequest
 */
export interface CMsgClientPICSChangesSinceRequest {
    /**
     * @generated from protobuf field: optional uint32 since_change_number = 1
     */
    sinceChangeNumber?: number;
    /**
     * @generated from protobuf field: optional bool send_app_info_changes = 2
     */
    sendAppInfoChanges?: boolean;
    /**
     * @generated from protobuf field: optional bool send_package_info_changes = 3
     */
    sendPackageInfoChanges?: boolean;
    /**
     * @generated from protobuf field: optional uint32 num_app_info_cached = 4
     */
    numAppInfoCached?: number;
    /**
     * @generated from protobuf field: optional uint32 num_package_info_cached = 5
     */
    numPackageInfoCached?: number;
}
/**
 * @generated from protobuf message CMsgClientPICSChangesSinceResponse
 */
export interface CMsgClientPICSChangesSinceResponse {
    /**
     * @generated from protobuf field: optional uint32 current_change_number = 1
     */
    currentChangeNumber?: number;
    /**
     * @generated from protobuf field: optional uint32 since_change_number = 2
     */
    sinceChangeNumber?: number;
    /**
     * @generated from protobuf field: optional bool force_full_update = 3
     */
    forceFullUpdate?: boolean;
    /**
     * @generated from protobuf field: repeated CMsgClientPICSChangesSinceResponse_PackageChange package_changes = 4
     */
    packageChanges: CMsgClientPICSChangesSinceResponse_PackageChange[];
    /**
     * @generated from protobuf field: repeated CMsgClientPICSChangesSinceResponse_AppChange app_changes = 5
     */
    appChanges: CMsgClientPICSChangesSinceResponse_AppChange[];
    /**
     * @generated from protobuf field: optional bool force_full_app_update = 6
     */
    forceFullAppUpdate?: boolean;
    /**
     * @generated from protobuf field: optional bool force_full_package_update = 7
     */
    forceFullPackageUpdate?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientPICSChangesSinceResponse_AppChange
 */
export interface CMsgClientPICSChangesSinceResponse_AppChange {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 change_number = 2
     */
    changeNumber?: number;
    /**
     * @generated from protobuf field: optional bool needs_token = 3
     */
    needsToken?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientPICSChangesSinceResponse_PackageChange
 */
export interface CMsgClientPICSChangesSinceResponse_PackageChange {
    /**
     * @generated from protobuf field: optional uint32 packageid = 1
     */
    packageid?: number;
    /**
     * @generated from protobuf field: optional uint32 change_number = 2
     */
    changeNumber?: number;
    /**
     * @generated from protobuf field: optional bool needs_token = 3
     */
    needsToken?: boolean;
}
/**
 * @generated from protobuf message CMsgClientPICSProductInfoRequest
 */
export interface CMsgClientPICSProductInfoRequest {
    /**
     * @generated from protobuf field: repeated CMsgClientPICSProductInfoRequest_PackageInfo packages = 1
     */
    packages: CMsgClientPICSProductInfoRequest_PackageInfo[];
    /**
     * @generated from protobuf field: repeated CMsgClientPICSProductInfoRequest_AppInfo apps = 2
     */
    apps: CMsgClientPICSProductInfoRequest_AppInfo[];
    /**
     * @generated from protobuf field: optional bool meta_data_only = 3
     */
    metaDataOnly?: boolean;
    /**
     * @generated from protobuf field: optional uint32 num_prev_failed = 4
     */
    numPrevFailed?: number;
    /**
     * @generated from protobuf field: optional uint32 supports_package_tokens = 5
     */
    supportsPackageTokens?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientPICSProductInfoRequest_AppInfo
 */
export interface CMsgClientPICSProductInfoRequest_AppInfo {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint64 access_token = 2
     */
    accessToken?: bigint;
    /**
     * @generated from protobuf field: optional bool only_public_obsolete = 3
     */
    onlyPublicObsolete?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientPICSProductInfoRequest_PackageInfo
 */
export interface CMsgClientPICSProductInfoRequest_PackageInfo {
    /**
     * @generated from protobuf field: optional uint32 packageid = 1
     */
    packageid?: number;
    /**
     * @generated from protobuf field: optional uint64 access_token = 2
     */
    accessToken?: bigint;
}
/**
 * @generated from protobuf message CMsgClientPICSProductInfoResponse
 */
export interface CMsgClientPICSProductInfoResponse {
    /**
     * @generated from protobuf field: repeated CMsgClientPICSProductInfoResponse_AppInfo apps = 1
     */
    apps: CMsgClientPICSProductInfoResponse_AppInfo[];
    /**
     * @generated from protobuf field: repeated uint32 unknown_appids = 2
     */
    unknownAppids: number[];
    /**
     * @generated from protobuf field: repeated CMsgClientPICSProductInfoResponse_PackageInfo packages = 3
     */
    packages: CMsgClientPICSProductInfoResponse_PackageInfo[];
    /**
     * @generated from protobuf field: repeated uint32 unknown_packageids = 4
     */
    unknownPackageids: number[];
    /**
     * @generated from protobuf field: optional bool meta_data_only = 5
     */
    metaDataOnly?: boolean;
    /**
     * @generated from protobuf field: optional bool response_pending = 6
     */
    responsePending?: boolean;
    /**
     * @generated from protobuf field: optional uint32 http_min_size = 7
     */
    httpMinSize?: number;
    /**
     * @generated from protobuf field: optional string http_host = 8
     */
    httpHost?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientPICSProductInfoResponse_AppInfo
 */
export interface CMsgClientPICSProductInfoResponse_AppInfo {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 change_number = 2
     */
    changeNumber?: number;
    /**
     * @generated from protobuf field: optional bool missing_token = 3
     */
    missingToken?: boolean;
    /**
     * @generated from protobuf field: optional bytes sha = 4
     */
    sha?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes buffer = 5
     */
    buffer?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool only_public = 6
     */
    onlyPublic?: boolean;
    /**
     * @generated from protobuf field: optional uint32 size = 7
     */
    size?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientPICSProductInfoResponse_PackageInfo
 */
export interface CMsgClientPICSProductInfoResponse_PackageInfo {
    /**
     * @generated from protobuf field: optional uint32 packageid = 1
     */
    packageid?: number;
    /**
     * @generated from protobuf field: optional uint32 change_number = 2
     */
    changeNumber?: number;
    /**
     * @generated from protobuf field: optional bool missing_token = 3
     */
    missingToken?: boolean;
    /**
     * @generated from protobuf field: optional bytes sha = 4
     */
    sha?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes buffer = 5
     */
    buffer?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 size = 6
     */
    size?: number;
}
/**
 * @generated from protobuf message CMsgClientPlayerNicknameList
 */
export interface CMsgClientPlayerNicknameList {
    /**
     * @generated from protobuf field: optional bool removal = 1
     */
    removal?: boolean;
    /**
     * @generated from protobuf field: optional bool incremental = 2
     */
    incremental?: boolean;
    /**
     * @generated from protobuf field: repeated CMsgClientPlayerNicknameList_PlayerNickname nicknames = 3
     */
    nicknames: CMsgClientPlayerNicknameList_PlayerNickname[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientPlayerNicknameList_PlayerNickname
 */
export interface CMsgClientPlayerNicknameList_PlayerNickname {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string nickname = 3
     */
    nickname?: string;
}
/**
 * @generated from protobuf message CMsgClientPlayingSessionState
 */
export interface CMsgClientPlayingSessionState {
    /**
     * @generated from protobuf field: optional bool playing_blocked = 2
     */
    playingBlocked?: boolean;
    /**
     * @generated from protobuf field: optional uint32 playing_app = 3
     */
    playingApp?: number;
}
/**
 * @generated from protobuf message CMsgClientPurchaseResponse
 */
export interface CMsgClientPurchaseResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 purchase_result_details = 2
     */
    purchaseResultDetails?: number;
    /**
     * @generated from protobuf field: optional bytes purchase_receipt_info = 3
     */
    purchaseReceiptInfo?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientPurchaseWithMachineID
 */
export interface CMsgClientPurchaseWithMachineID {
    /**
     * @generated from protobuf field: optional uint32 package_id = 1
     */
    packageId?: number;
    /**
     * @generated from protobuf field: optional bytes machine_info = 2
     */
    machineInfo?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientReadMachineAuth
 */
export interface CMsgClientReadMachineAuth {
    /**
     * @generated from protobuf field: optional string filename = 1
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional uint32 offset = 2
     */
    offset?: number;
    /**
     * @generated from protobuf field: optional uint32 cubtoread = 3
     */
    cubtoread?: number;
}
/**
 * @generated from protobuf message CMsgClientReadMachineAuthResponse
 */
export interface CMsgClientReadMachineAuthResponse {
    /**
     * @generated from protobuf field: optional string filename = 1
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional uint32 eresult = 2
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 filesize = 3
     */
    filesize?: number;
    /**
     * @generated from protobuf field: optional bytes sha_file = 4
     */
    shaFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 getlasterror = 5
     */
    getlasterror?: number;
    /**
     * @generated from protobuf field: optional uint32 offset = 6
     */
    offset?: number;
    /**
     * @generated from protobuf field: optional uint32 cubread = 7
     */
    cubread?: number;
    /**
     * @generated from protobuf field: optional bytes bytes_read = 8
     */
    bytesRead?: Uint8Array;
    /**
     * @generated from protobuf field: optional string filename_sentry = 9
     */
    filenameSentry?: string;
}
/**
 * @generated from protobuf message CMsgClientRedeemGuestPass
 */
export interface CMsgClientRedeemGuestPass {
    /**
     * @generated from protobuf field: optional fixed64 guest_pass_id = 1
     */
    guestPassId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientRedeemGuestPassResponse
 */
export interface CMsgClientRedeemGuestPassResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 package_id = 2
     */
    packageId?: number;
    /**
     * @generated from protobuf field: optional uint32 must_own_appid = 3
     */
    mustOwnAppid?: number;
}
/**
 * @generated from protobuf message CMsgClientRegisterAuthTicketWithCM
 */
export interface CMsgClientRegisterAuthTicketWithCM {
    /**
     * @generated from protobuf field: optional uint32 protocol_version = 1
     */
    protocolVersion?: number;
    /**
     * @generated from protobuf field: optional bytes ticket = 3
     */
    ticket?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint64 client_instance_id = 4
     */
    clientInstanceId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientRegisterKey
 */
export interface CMsgClientRegisterKey {
    /**
     * @generated from protobuf field: optional string key = 1
     */
    key?: string;
}
/**
 * @generated from protobuf message CMsgClientRegisterOEMMachine
 */
export interface CMsgClientRegisterOEMMachine {
    /**
     * @generated from protobuf field: optional bytes oem_register_file = 1
     */
    oemRegisterFile?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientRegisterOEMMachineResponse
 */
export interface CMsgClientRegisterOEMMachineResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientRemoveFriend
 */
export interface CMsgClientRemoveFriend {
    /**
     * @generated from protobuf field: optional fixed64 friendid = 1
     */
    friendid?: bigint;
}
/**
 * @generated from protobuf message CMsgClientRemoveFriendFromGroup
 */
export interface CMsgClientRemoveFriendFromGroup {
    /**
     * @generated from protobuf field: optional int32 groupid = 1
     */
    groupid?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamiduser = 2
     */
    steamiduser?: bigint;
}
/**
 * @generated from protobuf message CMsgClientRemoveFriendFromGroupResponse
 */
export interface CMsgClientRemoveFriendFromGroupResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientReportOverlayDetourFailure
 */
export interface CMsgClientReportOverlayDetourFailure {
    /**
     * @generated from protobuf field: repeated string failure_strings = 1
     */
    failureStrings: string[];
}
/**
 * @generated from protobuf message CMsgClientRequestAccountData
 */
export interface CMsgClientRequestAccountData {
    /**
     * @generated from protobuf field: optional string account_or_email = 1
     */
    accountOrEmail?: string;
    /**
     * @generated from protobuf field: optional uint32 action = 2
     */
    action?: number;
}
/**
 * @generated from protobuf message CMsgClientRequestAccountDataResponse
 */
export interface CMsgClientRequestAccountDataResponse {
    /**
     * @generated from protobuf field: optional uint32 action = 1
     */
    action?: number;
    /**
     * @generated from protobuf field: optional uint32 eresult = 2
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional string account_name = 3
     */
    accountName?: string;
    /**
     * @generated from protobuf field: optional uint32 ct_matches = 4
     */
    ctMatches?: number;
    /**
     * @generated from protobuf field: optional string account_name_suggestion1 = 5
     */
    accountNameSuggestion1?: string;
    /**
     * @generated from protobuf field: optional string account_name_suggestion2 = 6
     */
    accountNameSuggestion2?: string;
    /**
     * @generated from protobuf field: optional string account_name_suggestion3 = 7
     */
    accountNameSuggestion3?: string;
}
/**
 * @generated from protobuf message CMsgClientRequestCommentNotifications
 */
export interface CMsgClientRequestCommentNotifications {
}
/**
 * @generated from protobuf message CMsgClientRequestedClientStats
 */
export interface CMsgClientRequestedClientStats {
    /**
     * @generated from protobuf field: repeated CMsgClientRequestedClientStats_StatsToSend stats_to_send = 1
     */
    statsToSend: CMsgClientRequestedClientStats_StatsToSend[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientRequestedClientStats_StatsToSend
 */
export interface CMsgClientRequestedClientStats_StatsToSend {
    /**
     * @generated from protobuf field: optional uint32 client_stat = 1
     */
    clientStat?: number;
    /**
     * @generated from protobuf field: optional uint32 stat_aggregate_method = 2
     */
    statAggregateMethod?: number;
}
/**
 * @generated from protobuf message CMsgClientRequestEncryptedAppTicket
 */
export interface CMsgClientRequestEncryptedAppTicket {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional bytes userdata = 2
     */
    userdata?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientRequestEncryptedAppTicketResponse
 */
export interface CMsgClientRequestEncryptedAppTicketResponse {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional int32 eresult = 2 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional EncryptedAppTicket encrypted_app_ticket = 3
     */
    encryptedAppTicket?: EncryptedAppTicket;
}
/**
 * @generated from protobuf message CMsgClientRequestForgottenPasswordEmail
 */
export interface CMsgClientRequestForgottenPasswordEmail {
    /**
     * @generated from protobuf field: optional string account_name = 1
     */
    accountName?: string;
    /**
     * @generated from protobuf field: optional string password_tried = 2
     */
    passwordTried?: string;
}
/**
 * @generated from protobuf message CMsgClientRequestForgottenPasswordEmailResponse
 */
export interface CMsgClientRequestForgottenPasswordEmailResponse {
    /**
     * @generated from protobuf field: optional uint32 eResult = 1
     */
    eResult?: number;
    /**
     * @generated from protobuf field: optional bool use_secret_question = 2
     */
    useSecretQuestion?: boolean;
}
/**
 * @generated from protobuf message CMsgClientRequestFreeLicense
 */
export interface CMsgClientRequestFreeLicense {
    /**
     * @generated from protobuf field: repeated uint32 appids = 2
     */
    appids: number[];
}
/**
 * @generated from protobuf message CMsgClientRequestFreeLicenseResponse
 */
export interface CMsgClientRequestFreeLicenseResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated uint32 granted_packageids = 2
     */
    grantedPackageids: number[];
    /**
     * @generated from protobuf field: repeated uint32 granted_appids = 3
     */
    grantedAppids: number[];
}
/**
 * @generated from protobuf message CMsgClientRequestFriendData
 */
export interface CMsgClientRequestFriendData {
    /**
     * @generated from protobuf field: optional uint32 persona_state_requested = 1
     */
    personaStateRequested?: number;
    /**
     * @generated from protobuf field: repeated fixed64 friends = 2
     */
    friends: bigint[];
}
/**
 * @generated from protobuf message CMsgClientRequestItemAnnouncements
 */
export interface CMsgClientRequestItemAnnouncements {
}
/**
 * @generated from protobuf message CMsgClientRequestMachineAuth
 */
export interface CMsgClientRequestMachineAuth {
    /**
     * @generated from protobuf field: optional string filename = 1
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional uint32 eresult_sentryfile = 2
     */
    eresultSentryfile?: number;
    /**
     * @generated from protobuf field: optional uint32 filesize = 3
     */
    filesize?: number;
    /**
     * @generated from protobuf field: optional bytes sha_sentryfile = 4
     */
    shaSentryfile?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 lock_account_action = 6
     */
    lockAccountAction?: number;
    /**
     * @generated from protobuf field: optional uint32 otp_type = 7
     */
    otpType?: number;
    /**
     * @generated from protobuf field: optional string otp_identifier = 8
     */
    otpIdentifier?: string;
    /**
     * @generated from protobuf field: optional bytes otp_sharedsecret = 9
     */
    otpSharedsecret?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 otp_value = 10
     */
    otpValue?: number;
    /**
     * @generated from protobuf field: optional string machine_name = 11
     */
    machineName?: string;
    /**
     * @generated from protobuf field: optional string machine_name_userchosen = 12
     */
    machineNameUserchosen?: string;
}
/**
 * @generated from protobuf message CMsgClientRequestMachineAuthResponse
 */
export interface CMsgClientRequestMachineAuthResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientRequestOfflineMessageCount
 */
export interface CMsgClientRequestOfflineMessageCount {
}
/**
 * @generated from protobuf message CMsgClientRequestWebAPIAuthenticateUserNonce
 */
export interface CMsgClientRequestWebAPIAuthenticateUserNonce {
    /**
     * @generated from protobuf field: optional int32 token_type = 1 [default = -1]
     */
    tokenType?: number;
}
/**
 * @generated from protobuf message CMsgClientRequestWebAPIAuthenticateUserNonceResponse
 */
export interface CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 token_type = 3 [default = -1]
     */
    tokenType?: number;
    /**
     * @generated from protobuf field: optional string webapi_authenticate_user_nonce = 11
     */
    webapiAuthenticateUserNonce?: string;
}
/**
 * @generated from protobuf message CMsgClientRichPresenceInfo
 */
export interface CMsgClientRichPresenceInfo {
    /**
     * @generated from protobuf field: repeated CMsgClientRichPresenceInfo_RichPresence rich_presence = 1
     */
    richPresence: CMsgClientRichPresenceInfo_RichPresence[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientRichPresenceInfo_RichPresence
 */
export interface CMsgClientRichPresenceInfo_RichPresence {
    /**
     * @generated from protobuf field: optional fixed64 steamid_user = 1
     */
    steamidUser?: bigint;
    /**
     * @generated from protobuf field: optional bytes rich_presence_kv = 2
     */
    richPresenceKv?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientRichPresenceRequest
 */
export interface CMsgClientRichPresenceRequest {
    /**
     * @generated from protobuf field: repeated fixed64 steamid_request = 1
     */
    steamidRequest: bigint[];
}
/**
 * @generated from protobuf message CMsgClientRichPresenceUpload
 */
export interface CMsgClientRichPresenceUpload {
    /**
     * @generated from protobuf field: optional bytes rich_presence_kv = 1
     */
    richPresenceKv?: Uint8Array;
    /**
     * @generated from protobuf field: repeated fixed64 steamid_broadcast = 2
     */
    steamidBroadcast: bigint[];
}
/**
 * @generated from protobuf message CMsgClientScreenshotsChanged
 */
export interface CMsgClientScreenshotsChanged {
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientSecret
 */
export interface CMsgClientSecret {
    /**
     * @generated from protobuf field: optional uint32 version = 1
     */
    version?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 2
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 deviceid = 3
     */
    deviceid?: number;
    /**
     * @generated from protobuf field: optional fixed64 nonce = 4
     */
    nonce?: bigint;
    /**
     * @generated from protobuf field: optional bytes hmac = 5
     */
    hmac?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientSentLogs
 */
export interface CMsgClientSentLogs {
}
/**
 * @generated from protobuf message CMsgClientServersAvailable
 */
export interface CMsgClientServersAvailable {
    /**
     * @generated from protobuf field: repeated CMsgClientServersAvailable_Server_Types_Available server_types_available = 1
     */
    serverTypesAvailable: CMsgClientServersAvailable_Server_Types_Available[];
    /**
     * @generated from protobuf field: optional uint32 server_type_for_auth_services = 2
     */
    serverTypeForAuthServices?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientServersAvailable_Server_Types_Available
 */
export interface CMsgClientServersAvailable_Server_Types_Available {
    /**
     * @generated from protobuf field: optional uint32 server = 1
     */
    server?: number;
    /**
     * @generated from protobuf field: optional bool changed = 2
     */
    changed?: boolean;
}
/**
 * @generated from protobuf message CMsgClientServerTimestampRequest
 */
export interface CMsgClientServerTimestampRequest {
    /**
     * @generated from protobuf field: optional uint64 client_request_timestamp = 1
     */
    clientRequestTimestamp?: bigint;
}
/**
 * @generated from protobuf message CMsgClientServerTimestampResponse
 */
export interface CMsgClientServerTimestampResponse {
    /**
     * @generated from protobuf field: optional uint64 client_request_timestamp = 1
     */
    clientRequestTimestamp?: bigint;
    /**
     * @generated from protobuf field: optional uint64 server_timestamp_ms = 2
     */
    serverTimestampMs?: bigint;
}
/**
 * @generated from protobuf message CMsgClientServiceCall
 */
export interface CMsgClientServiceCall {
    /**
     * @generated from protobuf field: optional bytes sysid_routing = 1
     */
    sysidRouting?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 call_handle = 2
     */
    callHandle?: number;
    /**
     * @generated from protobuf field: optional uint32 module_crc = 3
     */
    moduleCrc?: number;
    /**
     * @generated from protobuf field: optional bytes module_hash = 4
     */
    moduleHash?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 function_id = 5
     */
    functionId?: number;
    /**
     * @generated from protobuf field: optional uint32 cub_output_max = 6
     */
    cubOutputMax?: number;
    /**
     * @generated from protobuf field: optional uint32 flags = 7
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional bytes callparameter = 8
     */
    callparameter?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool ping_only = 9
     */
    pingOnly?: boolean;
    /**
     * @generated from protobuf field: optional uint32 max_outstanding_calls = 10
     */
    maxOutstandingCalls?: number;
}
/**
 * @generated from protobuf message CMsgClientServiceCallResponse
 */
export interface CMsgClientServiceCallResponse {
    /**
     * @generated from protobuf field: optional bytes sysid_routing = 1
     */
    sysidRouting?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 call_handle = 2
     */
    callHandle?: number;
    /**
     * @generated from protobuf field: optional uint32 module_crc = 3
     */
    moduleCrc?: number;
    /**
     * @generated from protobuf field: optional bytes module_hash = 4
     */
    moduleHash?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 ecallresult = 5
     */
    ecallresult?: number;
    /**
     * @generated from protobuf field: optional bytes result_content = 6
     */
    resultContent?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes os_version_info = 7
     */
    osVersionInfo?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes system_info = 8
     */
    systemInfo?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 load_address = 9
     */
    loadAddress?: bigint;
    /**
     * @generated from protobuf field: optional bytes exception_record = 10
     */
    exceptionRecord?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes portable_os_version_info = 11
     */
    portableOsVersionInfo?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes portable_system_info = 12
     */
    portableSystemInfo?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool was_converted = 13
     */
    wasConverted?: boolean;
    /**
     * @generated from protobuf field: optional uint32 internal_result = 14
     */
    internalResult?: number;
    /**
     * @generated from protobuf field: optional uint32 current_count = 15
     */
    currentCount?: number;
    /**
     * @generated from protobuf field: optional uint32 last_call_handle = 16
     */
    lastCallHandle?: number;
    /**
     * @generated from protobuf field: optional uint32 last_call_module_crc = 17
     */
    lastCallModuleCrc?: number;
    /**
     * @generated from protobuf field: optional bytes last_call_sysid_routing = 18
     */
    lastCallSysidRouting?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 last_ecallresult = 19
     */
    lastEcallresult?: number;
    /**
     * @generated from protobuf field: optional uint32 last_callissue_delta = 20
     */
    lastCallissueDelta?: number;
    /**
     * @generated from protobuf field: optional uint32 last_callcomplete_delta = 21
     */
    lastCallcompleteDelta?: number;
}
/**
 * @generated from protobuf message CMsgClientServiceMethodLegacy
 */
export interface CMsgClientServiceMethodLegacy {
    /**
     * @generated from protobuf field: optional string method_name = 1
     */
    methodName?: string;
    /**
     * @generated from protobuf field: optional bytes serialized_method = 2
     */
    serializedMethod?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool is_notification = 3
     */
    isNotification?: boolean;
}
/**
 * @generated from protobuf message CMsgClientServiceMethodLegacyResponse
 */
export interface CMsgClientServiceMethodLegacyResponse {
    /**
     * @generated from protobuf field: optional string method_name = 1
     */
    methodName?: string;
    /**
     * @generated from protobuf field: optional bytes serialized_method_response = 2
     */
    serializedMethodResponse?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientServiceModule
 */
export interface CMsgClientServiceModule {
    /**
     * @generated from protobuf field: optional uint32 module_crc = 1
     */
    moduleCrc?: number;
    /**
     * @generated from protobuf field: optional bytes module_hash = 2
     */
    moduleHash?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes module_content = 3
     */
    moduleContent?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientSessionToken
 */
export interface CMsgClientSessionToken {
    /**
     * @generated from protobuf field: optional uint64 token = 1
     */
    token?: bigint;
}
/**
 * @generated from protobuf message CMsgClientSetClientAppUpdateState
 */
export interface CMsgClientSetClientAppUpdateState {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional bool update = 2
     */
    update?: boolean;
}
/**
 * @generated from protobuf message CMsgClientSetClientAppUpdateStateResponse
 */
export interface CMsgClientSetClientAppUpdateStateResponse {
    /**
     * @generated from protobuf field: optional uint32 result = 1
     */
    result?: number;
}
/**
 * @generated from protobuf message CMsgClientSetPlayerNickname
 */
export interface CMsgClientSetPlayerNickname {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string nickname = 2
     */
    nickname?: string;
}
/**
 * @generated from protobuf message CMsgClientSetPlayerNicknameResponse
 */
export interface CMsgClientSetPlayerNicknameResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientSettings
 */
export interface CMsgClientSettings {
    /**
     * @generated from protobuf field: optional bool no_save_personal_info = 1
     */
    noSavePersonalInfo?: boolean;
    /**
     * @generated from protobuf field: optional bool oobe_test_mode_enabled = 2
     */
    oobeTestModeEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool in_client_beta = 3
     */
    inClientBeta?: boolean;
    /**
     * @generated from protobuf field: optional bool is_steam_sideloaded = 4
     */
    isSteamSideloaded?: boolean;
    /**
     * @generated from protobuf field: optional string preferred_monitor = 5
     */
    preferredMonitor?: string;
    /**
     * @generated from protobuf field: optional bool steam_cef_gpu_blocklist_disabled = 6
     */
    steamCefGpuBlocklistDisabled?: boolean;
    /**
     * @generated from protobuf field: optional bool bigpicture_windowed = 7
     */
    bigpictureWindowed?: boolean;
    /**
     * @generated from protobuf field: optional string display_name = 8
     */
    displayName?: string;
    /**
     * @generated from protobuf field: optional bool is_external_display = 9
     */
    isExternalDisplay?: boolean;
    /**
     * @generated from protobuf field: optional float steam_os_underscan_level = 10
     */
    steamOsUnderscanLevel?: number;
    /**
     * @generated from protobuf field: optional bool steam_os_underscan_enabled = 11
     */
    steamOsUnderscanEnabled?: boolean;
    /**
     * @generated from protobuf field: optional float min_scale_factor = 12
     */
    minScaleFactor?: number;
    /**
     * @generated from protobuf field: optional float max_scale_factor = 13
     */
    maxScaleFactor?: number;
    /**
     * @generated from protobuf field: optional float auto_scale_factor = 14
     */
    autoScaleFactor?: number;
    /**
     * @generated from protobuf field: optional bool small_mode = 16
     */
    smallMode?: boolean;
    /**
     * @generated from protobuf field: optional bool skip_steamvr_install_dialog = 19
     */
    skipSteamvrInstallDialog?: boolean;
    /**
     * @generated from protobuf field: optional bool always_show_user_chooser = 20
     */
    alwaysShowUserChooser?: boolean;
    /**
     * @generated from protobuf field: optional bool os_version_unsupported = 21
     */
    osVersionUnsupported?: boolean;
    /**
     * @generated from protobuf field: optional bool show_family_sharing_notifications = 3000
     */
    showFamilySharingNotifications?: boolean;
    /**
     * @generated from protobuf field: optional bool show_copy_count_in_library = 3001
     */
    showCopyCountInLibrary?: boolean;
    /**
     * @generated from protobuf field: optional int32 overlay_fps_counter_corner = 4000
     */
    overlayFpsCounterCorner?: number;
    /**
     * @generated from protobuf field: optional bool overlay_fps_counter_high_contrast = 4001
     */
    overlayFpsCounterHighContrast?: boolean;
    /**
     * @generated from protobuf field: optional CMsgHotkey overlay_key = 4002
     */
    overlayKey?: CMsgHotkey;
    /**
     * @generated from protobuf field: optional CMsgHotkey screenshot_key = 4003
     */
    screenshotKey?: CMsgHotkey;
    /**
     * @generated from protobuf field: optional bool enable_overlay = 4004
     */
    enableOverlay?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_screenshot_notification = 4006
     */
    enableScreenshotNotification?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_screenshot_sound = 4007
     */
    enableScreenshotSound?: boolean;
    /**
     * @generated from protobuf field: optional bool save_uncompressed_screenshots = 4008
     */
    saveUncompressedScreenshots?: boolean;
    /**
     * @generated from protobuf field: optional string screenshots_path = 4009
     */
    screenshotsPath?: string;
    /**
     * @generated from protobuf field: optional int32 default_ping_rate = 4010
     */
    defaultPingRate?: number;
    /**
     * @generated from protobuf field: optional int32 server_ping_rate = 4011
     */
    serverPingRate?: number;
    /**
     * @generated from protobuf field: optional int32 steam_networking_share_ip = 4012
     */
    steamNetworkingShareIp?: number;
    /**
     * @generated from protobuf field: optional string web_browser_home = 4013
     */
    webBrowserHome?: string;
    /**
     * @generated from protobuf field: optional string voice_mic_device_name = 4014
     */
    voiceMicDeviceName?: string;
    /**
     * @generated from protobuf field: optional float voice_mic_input_gain = 4015
     */
    voiceMicInputGain?: number;
    /**
     * @generated from protobuf field: optional float voice_speaker_output_gain = 4016
     */
    voiceSpeakerOutputGain?: number;
    /**
     * @generated from protobuf field: optional int32 voice_push_to_talk_setting = 4017
     */
    voicePushToTalkSetting?: number;
    /**
     * @generated from protobuf field: optional CMsgHotkey voice_push_to_talk_key = 4018
     */
    voicePushToTalkKey?: CMsgHotkey;
    /**
     * @generated from protobuf field: optional bool overlay_toolbar_list_view = 4019
     */
    overlayToolbarListView?: boolean;
    /**
     * @generated from protobuf field: optional bool always_use_gamepadui_overlay = 4020
     */
    alwaysUseGamepaduiOverlay?: boolean;
    /**
     * @generated from protobuf field: optional string overlay_tabs = 4021
     */
    overlayTabs?: string;
    /**
     * @generated from protobuf field: optional bool overlay_scale_interface = 4022
     */
    overlayScaleInterface?: boolean;
    /**
     * @generated from protobuf field: optional bool overlay_restore_browser_tabs = 4023
     */
    overlayRestoreBrowserTabs?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_avif_screenshots = 4024
     */
    enableAvifScreenshots?: boolean;
    /**
     * @generated from protobuf field: optional int32 overlay_fps_counter_detail_level = 4025
     */
    overlayFpsCounterDetailLevel?: number;
    /**
     * @generated from protobuf field: optional float overlay_fps_counter_saturation_factor = 4026
     */
    overlayFpsCounterSaturationFactor?: number;
    /**
     * @generated from protobuf field: optional float overlay_fps_counter_bgopacity = 4027
     */
    overlayFpsCounterBgopacity?: number;
    /**
     * @generated from protobuf field: optional float overlay_fps_counter_scale_factor = 4028
     */
    overlayFpsCounterScaleFactor?: number;
    /**
     * @generated from protobuf field: optional CMsgHotkey overlay_fps_counter_key = 4029
     */
    overlayFpsCounterKey?: CMsgHotkey;
    /**
     * @generated from protobuf field: optional bool overlay_fps_counter_fps_graph = 4030
     */
    overlayFpsCounterFpsGraph?: boolean;
    /**
     * @generated from protobuf field: optional bool overlay_fps_counter_cpu_graph = 4031
     */
    overlayFpsCounterCpuGraph?: boolean;
    /**
     * @generated from protobuf field: optional bool smooth_scroll_webviews = 5000
     */
    smoothScrollWebviews?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_gpu_accelerated_webviews = 5001
     */
    enableGpuAcceleratedWebviews?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_hardware_video_decoding = 5003
     */
    enableHardwareVideoDecoding?: boolean;
    /**
     * @generated from protobuf field: optional bool run_at_startup = 5004
     */
    runAtStartup?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_dpi_scaling = 5005
     */
    enableDpiScaling?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_marketing_messages = 5006
     */
    enableMarketingMessages?: boolean;
    /**
     * @generated from protobuf field: optional bool start_in_big_picture_mode = 5007
     */
    startInBigPictureMode?: boolean;
    /**
     * @generated from protobuf field: optional uint32 jumplist_flags = 5008
     */
    jumplistFlags?: number;
    /**
     * @generated from protobuf field: optional bool enable_ui_sounds = 5009
     */
    enableUiSounds?: boolean;
    /**
     * @generated from protobuf field: optional bool disable_all_toasts = 6000
     */
    disableAllToasts?: boolean;
    /**
     * @generated from protobuf field: optional bool disable_toasts_in_game = 6001
     */
    disableToastsInGame?: boolean;
    /**
     * @generated from protobuf field: optional bool play_sound_on_toast = 6002
     */
    playSoundOnToast?: boolean;
    /**
     * @generated from protobuf field: optional int32 library_display_size = 7000
     */
    libraryDisplaySize?: number;
    /**
     * @generated from protobuf field: optional bool library_whats_new_show_only_product_updates = 7001
     */
    libraryWhatsNewShowOnlyProductUpdates?: boolean;
    /**
     * @generated from protobuf field: optional bool show_store_content_on_home = 7002
     */
    showStoreContentOnHome?: boolean;
    /**
     * @generated from protobuf field: optional string start_page = 7003
     */
    startPage?: string;
    /**
     * @generated from protobuf field: optional bool library_low_bandwidth_mode = 7004
     */
    libraryLowBandwidthMode?: boolean;
    /**
     * @generated from protobuf field: optional bool library_low_perf_mode = 7005
     */
    libraryLowPerfMode?: boolean;
    /**
     * @generated from protobuf field: optional bool library_disable_community_content = 7006
     */
    libraryDisableCommunityContent?: boolean;
    /**
     * @generated from protobuf field: optional bool library_display_icon_in_game_list = 7007
     */
    libraryDisplayIconInGameList?: boolean;
    /**
     * @generated from protobuf field: optional bool ready_to_play_includes_streaming = 7008
     */
    readyToPlayIncludesStreaming?: boolean;
    /**
     * @generated from protobuf field: optional bool show_steam_deck_info = 7009
     */
    showSteamDeckInfo?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_shader_precache = 8000
     */
    enableShaderPrecache?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_shader_background_processing = 8001
     */
    enableShaderBackgroundProcessing?: boolean;
    /**
     * @generated from protobuf field: optional uint64 shader_precached_size = 8002
     */
    shaderPrecachedSize?: bigint;
    /**
     * @generated from protobuf field: optional bool needs_steam_service_repair = 8003
     */
    needsSteamServiceRepair?: boolean;
    /**
     * @generated from protobuf field: optional int32 download_peer_content = 8004
     */
    downloadPeerContent?: number;
    /**
     * @generated from protobuf field: optional bool download_rate_bits_per_s = 8005
     */
    downloadRateBitsPerS?: boolean;
    /**
     * @generated from protobuf field: optional bool restrict_auto_updates = 8006
     */
    restrictAutoUpdates?: boolean;
    /**
     * @generated from protobuf field: optional int32 restrict_auto_updates_start = 8007
     */
    restrictAutoUpdatesStart?: number;
    /**
     * @generated from protobuf field: optional int32 restrict_auto_updates_end = 8008
     */
    restrictAutoUpdatesEnd?: number;
    /**
     * @generated from protobuf field: optional int32 download_region = 8009
     */
    downloadRegion?: number;
    /**
     * @generated from protobuf field: optional bool download_while_app_running = 8010
     */
    downloadWhileAppRunning?: boolean;
    /**
     * @generated from protobuf field: optional bool download_throttle_while_streaming = 8011
     */
    downloadThrottleWhileStreaming?: boolean;
    /**
     * @generated from protobuf field: optional int32 download_throttle_rate = 8012
     */
    downloadThrottleRate?: number;
    /**
     * @generated from protobuf field: optional int32 default_app_update_behavior = 8013
     */
    defaultAppUpdateBehavior?: number;
    /**
     * @generated from protobuf field: optional bool cloud_enabled = 10000
     */
    cloudEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool show_screenshot_manager = 10001
     */
    showScreenshotManager?: boolean;
    /**
     * @generated from protobuf field: optional int32 music_volume = 11000
     */
    musicVolume?: number;
    /**
     * @generated from protobuf field: optional bool music_pause_on_app_start = 11001
     */
    musicPauseOnAppStart?: boolean;
    /**
     * @generated from protobuf field: optional bool music_pause_on_voice_chat = 11002
     */
    musicPauseOnVoiceChat?: boolean;
    /**
     * @generated from protobuf field: optional bool music_download_high_quality = 11003
     */
    musicDownloadHighQuality?: boolean;
    /**
     * @generated from protobuf field: optional bool music_playlist_notification = 11004
     */
    musicPlaylistNotification?: boolean;
    /**
     * @generated from protobuf field: optional int32 broadcast_permissions = 12000
     */
    broadcastPermissions?: number;
    /**
     * @generated from protobuf field: optional int32 broadcast_output_width = 12001
     */
    broadcastOutputWidth?: number;
    /**
     * @generated from protobuf field: optional int32 broadcast_output_height = 12002
     */
    broadcastOutputHeight?: number;
    /**
     * @generated from protobuf field: optional int32 broadcast_bitrate = 12003
     */
    broadcastBitrate?: number;
    /**
     * @generated from protobuf field: optional int32 broadcast_encoding_option = 12004
     */
    broadcastEncodingOption?: number;
    /**
     * @generated from protobuf field: optional bool broadcast_record_all_video = 12005
     */
    broadcastRecordAllVideo?: boolean;
    /**
     * @generated from protobuf field: optional bool broadcast_record_all_audio = 12006
     */
    broadcastRecordAllAudio?: boolean;
    /**
     * @generated from protobuf field: optional bool broadcast_record_microphone = 12007
     */
    broadcastRecordMicrophone?: boolean;
    /**
     * @generated from protobuf field: optional bool broadcast_show_upload_stats = 12008
     */
    broadcastShowUploadStats?: boolean;
    /**
     * @generated from protobuf field: optional bool broadcast_show_live_reminder = 12009
     */
    broadcastShowLiveReminder?: boolean;
    /**
     * @generated from protobuf field: optional int32 broadcast_chat_corner = 12010
     */
    broadcastChatCorner?: number;
    /**
     * @generated from protobuf field: optional bool gamestream_hardware_video_encode = 13000
     */
    gamestreamHardwareVideoEncode?: boolean;
    /**
     * @generated from protobuf field: optional bool gamestream_enable_video_h265 = 13001
     */
    gamestreamEnableVideoH265?: boolean;
    /**
     * @generated from protobuf field: optional bool steam_input_configurator_error_msg_enable = 14001
     */
    steamInputConfiguratorErrorMsgEnable?: boolean;
    /**
     * @generated from protobuf field: optional bool controller_guide_button_focus_steam = 14002
     */
    controllerGuideButtonFocusSteam?: boolean;
    /**
     * @generated from protobuf field: optional int32 controller_ps_support = 14003
     */
    controllerPsSupport?: number;
    /**
     * @generated from protobuf field: optional bool controller_xbox_support = 14004
     */
    controllerXboxSupport?: boolean;
    /**
     * @generated from protobuf field: optional bool controller_xbox_driver = 14005
     */
    controllerXboxDriver?: boolean;
    /**
     * @generated from protobuf field: optional bool controller_switch_support = 14006
     */
    controllerSwitchSupport?: boolean;
    /**
     * @generated from protobuf field: optional bool controller_generic_support = 14007
     */
    controllerGenericSupport?: boolean;
    /**
     * @generated from protobuf field: optional int32 controller_power_off_timeout = 14008
     */
    controllerPowerOffTimeout?: number;
    /**
     * @generated from protobuf field: optional bool turn_off_controller_on_exit = 14009
     */
    turnOffControllerOnExit?: boolean;
    /**
     * @generated from protobuf field: optional bool controller_combine_nintendo_joycons = 14010
     */
    controllerCombineNintendoJoycons?: boolean;
    /**
     * @generated from protobuf field: optional uint64 startup_movie_id = 16000
     */
    startupMovieId?: bigint;
    /**
     * @generated from protobuf field: optional string startup_movie_local_path = 16001
     */
    startupMovieLocalPath?: string;
    /**
     * @generated from protobuf field: optional bool startup_movie_shuffle = 16002
     */
    startupMovieShuffle?: boolean;
    /**
     * @generated from protobuf field: optional bool startup_movie_used_for_resume = 16003
     */
    startupMovieUsedForResume?: boolean;
    /**
     * @generated from protobuf field: optional bool game_notes_enable_spellcheck = 17001
     */
    gameNotesEnableSpellcheck?: boolean;
    /**
     * @generated from protobuf field: optional int32 screenshot_items_per_row = 18000
     */
    screenshotItemsPerRow?: number;
    /**
     * @generated from protobuf field: optional string gamerecording_background_path = 18201
     */
    gamerecordingBackgroundPath?: string;
    /**
     * @generated from protobuf field: optional string gamerecording_background_max_keep = 18202
     */
    gamerecordingBackgroundMaxKeep?: string;
    /**
     * @generated from protobuf field: optional int32 gamerecording_background_time_resolution = 18203
     */
    gamerecordingBackgroundTimeResolution?: number;
    /**
     * @generated from protobuf field: optional CMsgHotkey gamerecording_background_mk = 18207
     */
    gamerecordingBackgroundMk?: CMsgHotkey;
    /**
     * @generated from protobuf field: optional CMsgHotkey gamerecording_background_tg = 18208
     */
    gamerecordingBackgroundTg?: CMsgHotkey;
    /**
     * @generated from protobuf field: optional bool gamerecording_background_a_m = 18209
     */
    gamerecordingBackgroundAM?: boolean;
    /**
     * @generated from protobuf field: optional string gamerecording_video_bitrate = 18210
     */
    gamerecordingVideoBitrate?: string;
    /**
     * @generated from protobuf field: optional int32 gamerecording_background_mode = 18212
     */
    gamerecordingBackgroundMode?: number;
    /**
     * @generated from protobuf field: optional int32 gamerecording_background_audio = 18213
     */
    gamerecordingBackgroundAudio?: number;
    /**
     * @generated from protobuf field: optional int32 gamerecording_max_fps = 18214
     */
    gamerecordingMaxFps?: number;
    /**
     * @generated from protobuf field: optional CMsgHotkey gamerecording_hotkey_ic = 18215
     */
    gamerecordingHotkeyIc?: CMsgHotkey;
    /**
     * @generated from protobuf field: optional float gamerecording_ic_seconds = 18216
     */
    gamerecordingIcSeconds?: number;
    /**
     * @generated from protobuf field: optional int32 gamerecording_export_limit_type = 18217
     */
    gamerecordingExportLimitType?: number;
    /**
     * @generated from protobuf field: optional int32 gamerecording_export_limit_size_mb = 18218
     */
    gamerecordingExportLimitSizeMb?: number;
    /**
     * @generated from protobuf field: optional int32 gamerecording_export_limit_bitrate = 18219
     */
    gamerecordingExportLimitBitrate?: number;
    /**
     * @generated from protobuf field: optional int32 gamerecording_export_limit_width = 18220
     */
    gamerecordingExportLimitWidth?: number;
    /**
     * @generated from protobuf field: optional int32 gamerecording_export_limit_height = 18221
     */
    gamerecordingExportLimitHeight?: number;
    /**
     * @generated from protobuf field: optional int32 gamerecording_export_limit_frame_rate = 18222
     */
    gamerecordingExportLimitFrameRate?: number;
    /**
     * @generated from protobuf field: optional string gamerecording_export_directory = 18223
     */
    gamerecordingExportDirectory?: string;
    /**
     * @generated from protobuf field: optional int32 gamerecording_export_codec = 18224
     */
    gamerecordingExportCodec?: number;
    /**
     * @generated from protobuf field: optional int32 gamerecording_video_maxheight = 18225
     */
    gamerecordingVideoMaxheight?: number;
    /**
     * @generated from protobuf field: optional bool gamerecording_force_mic_mono = 18226
     */
    gamerecordingForceMicMono?: boolean;
    /**
     * @generated from protobuf field: optional bool gamerecording_automatic_gain_control = 18227
     */
    gamerecordingAutomaticGainControl?: boolean;
    /**
     * @generated from protobuf field: optional bool show_timestamps_in_console = 20000
     */
    showTimestampsInConsole?: boolean;
    /**
     * @generated from protobuf field: optional bool force_oobe = 20001
     */
    forceOobe?: boolean;
    /**
     * @generated from protobuf field: optional int32 override_browser_composer_mode = 20002
     */
    overrideBrowserComposerMode?: number;
    /**
     * @generated from protobuf field: optional bool cef_remote_debugging_enabled = 20003
     */
    cefRemoteDebuggingEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool force_deck_perf_tab = 20004
     */
    forceDeckPerfTab?: boolean;
    /**
     * @generated from protobuf field: optional bool force_fake_mandatory_update = 20005
     */
    forceFakeMandatoryUpdate?: boolean;
    /**
     * @generated from protobuf field: optional bool hdr_compat_testing = 20006
     */
    hdrCompatTesting?: boolean;
    /**
     * @generated from protobuf field: optional bool developer_mode_enabled = 20007
     */
    developerModeEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool show_advanced_update_channels = 20008
     */
    showAdvancedUpdateChannels?: boolean;
    /**
     * @generated from protobuf field: optional int32 gamescope_hdr_visualization = 21001
     */
    gamescopeHdrVisualization?: number;
    /**
     * @generated from protobuf field: optional int32 gamescope_app_target_framerate = 21002
     */
    gamescopeAppTargetFramerate?: number;
    /**
     * @generated from protobuf field: optional bool gamescope_enable_app_target_framerate = 21003
     */
    gamescopeEnableAppTargetFramerate?: boolean;
    /**
     * @generated from protobuf field: optional bool gamescope_disable_framelimit = 21004
     */
    gamescopeDisableFramelimit?: boolean;
    /**
     * @generated from protobuf field: optional int32 gamescope_display_refresh_rate = 21005
     */
    gamescopeDisplayRefreshRate?: number;
    /**
     * @generated from protobuf field: optional bool gamescope_use_game_refresh_rate_in_steam = 21006
     */
    gamescopeUseGameRefreshRateInSteam?: boolean;
    /**
     * @generated from protobuf field: optional bool gamescope_disable_mura_correction = 21007
     */
    gamescopeDisableMuraCorrection?: boolean;
    /**
     * @generated from protobuf field: optional bool gamescope_include_steamui_in_screenshots = 21008
     */
    gamescopeIncludeSteamuiInScreenshots?: boolean;
    /**
     * @generated from protobuf field: optional bool gamescope_allow_tearing = 21009
     */
    gamescopeAllowTearing?: boolean;
    /**
     * @generated from protobuf field: optional bool gamescope_composite_debug = 21010
     */
    gamescopeCompositeDebug?: boolean;
    /**
     * @generated from protobuf field: optional bool gamescope_force_composite = 21011
     */
    gamescopeForceComposite?: boolean;
    /**
     * @generated from protobuf field: optional string gamescope_game_resolution_global = 21012
     */
    gamescopeGameResolutionGlobal?: string;
    /**
     * @generated from protobuf field: optional CMsgHotkey gamescope_guide_hotkey = 21013
     */
    gamescopeGuideHotkey?: CMsgHotkey;
    /**
     * @generated from protobuf field: optional CMsgHotkey gamescope_qam_hotkey = 21014
     */
    gamescopeQamHotkey?: CMsgHotkey;
    /**
     * @generated from protobuf field: optional bool gamescope_hdr_enabled = 21015
     */
    gamescopeHdrEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool gamescope_native_external_res_in_steam = 21016
     */
    gamescopeNativeExternalResInSteam?: boolean;
    /**
     * @generated from protobuf field: optional int32 steamos_status_led_brightness = 22000
     */
    steamosStatusLedBrightness?: number;
    /**
     * @generated from protobuf field: optional bool steamos_tdp_limit_enabled = 22001
     */
    steamosTdpLimitEnabled?: boolean;
    /**
     * @generated from protobuf field: optional int32 steamos_tdp_limit = 22002
     */
    steamosTdpLimit?: number;
    /**
     * @generated from protobuf field: optional bool steamos_cec_enabled = 22003
     */
    steamosCecEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool steamos_cec_wake_on_resume = 22004
     */
    steamosCecWakeOnResume?: boolean;
    /**
     * @generated from protobuf field: optional bool steamos_wifi_debug = 22005
     */
    steamosWifiDebug?: boolean;
    /**
     * @generated from protobuf field: optional bool steamos_wifi_force_wpa_supplicant = 22006
     */
    steamosWifiForceWpaSupplicant?: boolean;
    /**
     * @generated from protobuf field: optional int32 steamos_magnifier_scale = 22007
     */
    steamosMagnifierScale?: number;
    /**
     * @generated from protobuf field: optional bool steamos_manual_gpu_clock_enabled = 22008
     */
    steamosManualGpuClockEnabled?: boolean;
    /**
     * @generated from protobuf field: optional int32 steamos_manual_gpu_clock_hz = 22009
     */
    steamosManualGpuClockHz?: number;
    /**
     * @generated from protobuf field: optional string steamos_platform_performance_profile = 22010
     */
    steamosPlatformPerformanceProfile?: string;
    /**
     * @generated from protobuf field: optional bool steamos_charge_limit_enabled = 22011
     */
    steamosChargeLimitEnabled?: boolean;
    /**
     * @generated from protobuf field: optional int32 steamos_charge_limit = 22012
     */
    steamosChargeLimit?: number;
    /**
     * @generated from protobuf field: optional bool steamos_charge_limit_devmode = 22013
     */
    steamosChargeLimitDevmode?: boolean;
    /**
     * @generated from protobuf field: optional bool setting_validation_bool = 23001
     */
    settingValidationBool?: boolean;
    /**
     * @generated from protobuf field: optional int32 setting_validation_enum = 23002
     */
    settingValidationEnum?: number;
    /**
     * @generated from protobuf field: optional int32 setting_validation_int32 = 23003
     */
    settingValidationInt32?: number;
    /**
     * @generated from protobuf field: optional uint32 setting_validation_uint32 = 23004
     */
    settingValidationUint32?: number;
    /**
     * @generated from protobuf field: optional uint64 setting_validation_uint64 = 23005
     */
    settingValidationUint64?: bigint;
    /**
     * @generated from protobuf field: optional float setting_validation_float = 23006
     */
    settingValidationFloat?: number;
    /**
     * @generated from protobuf field: optional string setting_validation_string = 23007
     */
    settingValidationString?: string;
    /**
     * @generated from protobuf field: optional CMsgHotkey setting_validation_hotkey = 23008
     */
    settingValidationHotkey?: CMsgHotkey;
    /**
     * @generated from protobuf field: optional bool system_bluetooth_enabled = 24000
     */
    systemBluetoothEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool hardware_updater_enabled = 24001
     */
    hardwareUpdaterEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool vr_show_perf_graph_in_hmd = 25000
     */
    vrShowPerfGraphInHmd?: boolean;
    /**
     * @generated from protobuf field: optional bool accessibility_debug_visualizer = 26000
     */
    accessibilityDebugVisualizer?: boolean;
    /**
     * @generated from protobuf field: optional bool accessibility_screen_reader_enabled = 26001
     */
    accessibilityScreenReaderEnabled?: boolean;
    /**
     * @generated from protobuf field: optional float accessibility_screen_reader_rate = 26002
     */
    accessibilityScreenReaderRate?: number;
    /**
     * @generated from protobuf field: optional float accessibility_screen_reader_pitch = 26003
     */
    accessibilityScreenReaderPitch?: number;
    /**
     * @generated from protobuf field: optional float accessibility_screen_reader_volume = 26004
     */
    accessibilityScreenReaderVolume?: number;
    /**
     * @generated from protobuf field: optional bool accessibility_high_contrast_mode = 26005
     */
    accessibilityHighContrastMode?: boolean;
    /**
     * @generated from protobuf field: optional bool accessibility_reduce_motion = 26006
     */
    accessibilityReduceMotion?: boolean;
    /**
     * @generated from protobuf field: optional uint32 accessibility_minimum_font_size = 26008
     */
    accessibilityMinimumFontSize?: number;
    /**
     * @generated from protobuf field: optional string accessibility_color_filter_name = 26009
     */
    accessibilityColorFilterName?: string;
    /**
     * @generated from protobuf field: optional float accessibility_desktop_ui_scale = 26010
     */
    accessibilityDesktopUiScale?: number;
    /**
     * @generated from protobuf field: optional bool controller_enable_chord = 140011
     */
    controllerEnableChord?: boolean;
    /**
     * @generated from protobuf field: optional bool controller_poll_rate = 140012
     */
    controllerPollRate?: boolean;
}
/**
 * @generated from protobuf message CMsgClientSharedLibraryLockStatus
 */
export interface CMsgClientSharedLibraryLockStatus {
    /**
     * @generated from protobuf field: repeated CMsgClientSharedLibraryLockStatus_LockedLibrary locked_library = 1
     */
    lockedLibrary: CMsgClientSharedLibraryLockStatus_LockedLibrary[];
    /**
     * @generated from protobuf field: optional uint32 own_library_locked_by = 2
     */
    ownLibraryLockedBy?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientSharedLibraryLockStatus_LockedLibrary
 */
export interface CMsgClientSharedLibraryLockStatus_LockedLibrary {
    /**
     * @generated from protobuf field: optional uint32 owner_id = 1
     */
    ownerId?: number;
    /**
     * @generated from protobuf field: optional uint32 locked_by = 2
     */
    lockedBy?: number;
}
/**
 * @generated from protobuf message CMsgClientSharedLibraryStopPlaying
 */
export interface CMsgClientSharedLibraryStopPlaying {
    /**
     * @generated from protobuf field: optional int32 seconds_left = 1
     */
    secondsLeft?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientSharedLibraryStopPlaying_StopApp stop_apps = 2
     */
    stopApps: CMsgClientSharedLibraryStopPlaying_StopApp[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientSharedLibraryStopPlaying_StopApp
 */
export interface CMsgClientSharedLibraryStopPlaying_StopApp {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 owner_id = 2
     */
    ownerId?: number;
}
/**
 * @generated from protobuf message CMsgClientStat2
 */
export interface CMsgClientStat2 {
    /**
     * @generated from protobuf field: repeated CMsgClientStat2_StatDetail stat_detail = 1
     */
    statDetail: CMsgClientStat2_StatDetail[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientStat2_StatDetail
 */
export interface CMsgClientStat2_StatDetail {
    /**
     * @generated from protobuf field: optional uint32 client_stat = 1
     */
    clientStat?: number;
    /**
     * @generated from protobuf field: optional int64 ll_value = 2
     */
    llValue?: bigint;
    /**
     * @generated from protobuf field: optional uint32 time_of_day = 3
     */
    timeOfDay?: number;
    /**
     * @generated from protobuf field: optional uint32 cell_id = 4
     */
    cellId?: number;
    /**
     * @generated from protobuf field: optional uint32 depot_id = 5
     */
    depotId?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 6
     */
    appId?: number;
}
/**
 * @generated from protobuf message CMsgClientStatsUpdated
 */
export interface CMsgClientStatsUpdated {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 game_id = 2
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 crc_stats = 3
     */
    crcStats?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientStatsUpdated_Updated_Stats updated_stats = 4
     */
    updatedStats: CMsgClientStatsUpdated_Updated_Stats[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientStatsUpdated_Updated_Stats
 */
export interface CMsgClientStatsUpdated_Updated_Stats {
    /**
     * @generated from protobuf field: optional uint32 stat_id = 1
     */
    statId?: number;
    /**
     * @generated from protobuf field: optional uint32 stat_value = 2
     */
    statValue?: number;
}
/**
 * @generated from protobuf message CMsgClientStoreUserStats
 */
export interface CMsgClientStoreUserStats {
    /**
     * @generated from protobuf field: optional fixed64 game_id = 1
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional bool explicit_reset = 2
     */
    explicitReset?: boolean;
    /**
     * @generated from protobuf field: repeated CMsgClientStoreUserStats_Stats_To_Store stats_to_store = 3
     */
    statsToStore: CMsgClientStoreUserStats_Stats_To_Store[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientStoreUserStats_Stats_To_Store
 */
export interface CMsgClientStoreUserStats_Stats_To_Store {
    /**
     * @generated from protobuf field: optional uint32 stat_id = 1
     */
    statId?: number;
    /**
     * @generated from protobuf field: optional uint32 stat_value = 2
     */
    statValue?: number;
}
/**
 * @generated from protobuf message CMsgClientStoreUserStats2
 */
export interface CMsgClientStoreUserStats2 {
    /**
     * @generated from protobuf field: optional fixed64 game_id = 1
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 settor_steam_id = 2
     */
    settorSteamId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 settee_steam_id = 3
     */
    setteeSteamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 crc_stats = 4
     */
    crcStats?: number;
    /**
     * @generated from protobuf field: optional bool explicit_reset = 5
     */
    explicitReset?: boolean;
    /**
     * @generated from protobuf field: repeated CMsgClientStoreUserStats2_Stats stats = 6
     */
    stats: CMsgClientStoreUserStats2_Stats[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientStoreUserStats2_Stats
 */
export interface CMsgClientStoreUserStats2_Stats {
    /**
     * @generated from protobuf field: optional uint32 stat_id = 1
     */
    statId?: number;
    /**
     * @generated from protobuf field: optional uint32 stat_value = 2
     */
    statValue?: number;
}
/**
 * @generated from protobuf message CMsgClientStoreUserStatsResponse
 */
export interface CMsgClientStoreUserStatsResponse {
    /**
     * @generated from protobuf field: optional fixed64 game_id = 1
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional int32 eresult = 2 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 crc_stats = 3
     */
    crcStats?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientStoreUserStatsResponse_Stats_Failed_Validation stats_failed_validation = 4
     */
    statsFailedValidation: CMsgClientStoreUserStatsResponse_Stats_Failed_Validation[];
    /**
     * @generated from protobuf field: optional bool stats_out_of_date = 5
     */
    statsOutOfDate?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientStoreUserStatsResponse_Stats_Failed_Validation
 */
export interface CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    /**
     * @generated from protobuf field: optional uint32 stat_id = 1
     */
    statId?: number;
    /**
     * @generated from protobuf field: optional uint32 reverted_stat_value = 2
     */
    revertedStatValue?: number;
}
/**
 * @generated from protobuf message CMsgClientTicketAuthComplete
 */
export interface CMsgClientTicketAuthComplete {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 game_id = 2
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 estate = 3
     */
    estate?: number;
    /**
     * @generated from protobuf field: optional uint32 eauth_session_response = 4
     */
    eauthSessionResponse?: number;
    /**
     * @generated from protobuf field: optional bytes DEPRECATED_ticket = 5
     */
    dEPRECATEDTicket?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 ticket_crc = 6
     */
    ticketCrc?: number;
    /**
     * @generated from protobuf field: optional uint32 ticket_sequence = 7
     */
    ticketSequence?: number;
    /**
     * @generated from protobuf field: optional fixed64 owner_steam_id = 8
     */
    ownerSteamId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientUCMAddScreenshot
 */
export interface CMsgClientUCMAddScreenshot {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string filename = 2
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional string thumbname = 3
     */
    thumbname?: string;
    /**
     * @generated from protobuf field: optional fixed32 rtime32_created = 4
     */
    rtime32Created?: number;
    /**
     * @generated from protobuf field: optional uint32 width = 5
     */
    width?: number;
    /**
     * @generated from protobuf field: optional uint32 height = 6
     */
    height?: number;
    /**
     * @generated from protobuf field: optional uint32 permissions = 7
     */
    permissions?: number;
    /**
     * @generated from protobuf field: optional string caption = 8
     */
    caption?: string;
    /**
     * @generated from protobuf field: optional string shortcut_name = 9
     */
    shortcutName?: string;
    /**
     * @generated from protobuf field: repeated CMsgClientUCMAddScreenshot_Tag tag = 10
     */
    tag: CMsgClientUCMAddScreenshot_Tag[];
    /**
     * @generated from protobuf field: repeated fixed64 tagged_steamid = 11
     */
    taggedSteamid: bigint[];
    /**
     * @generated from protobuf field: optional bool spoiler_tag = 12
     */
    spoilerTag?: boolean;
    /**
     * @generated from protobuf field: repeated uint64 tagged_publishedfileid = 13
     */
    taggedPublishedfileid: bigint[];
    /**
     * @generated from protobuf field: optional string vr_filename = 14
     */
    vrFilename?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUCMAddScreenshot_Tag
 */
export interface CMsgClientUCMAddScreenshot_Tag {
    /**
     * @generated from protobuf field: optional string tag_name = 1
     */
    tagName?: string;
    /**
     * @generated from protobuf field: optional string tag_value = 2
     */
    tagValue?: string;
}
/**
 * @generated from protobuf message CMsgClientUCMAddScreenshotResponse
 */
export interface CMsgClientUCMAddScreenshotResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed64 screenshotid = 2 [default = 18446744073709551615]
     */
    screenshotid?: bigint;
}
/**
 * @generated from protobuf message CMsgClientUCMDeletePublishedFile
 */
export interface CMsgClientUCMDeletePublishedFile {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMDeletePublishedFileResponse
 */
export interface CMsgClientUCMDeletePublishedFileResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMDeleteScreenshot
 */
export interface CMsgClientUCMDeleteScreenshot {
    /**
     * @generated from protobuf field: optional fixed64 screenshotid = 1 [default = 18446744073709551615]
     */
    screenshotid?: bigint;
}
/**
 * @generated from protobuf message CMsgClientUCMDeleteScreenshotResponse
 */
export interface CMsgClientUCMDeleteScreenshotResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMEnumeratePublishedFilesByUserAction
 */
export interface CMsgClientUCMEnumeratePublishedFilesByUserAction {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 start_index = 2
     */
    startIndex?: number;
    /**
     * @generated from protobuf field: optional int32 action = 3
     */
    action?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMEnumeratePublishedFilesByUserActionResponse
 */
export interface CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId published_files = 2
     */
    publishedFiles: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId[];
    /**
     * @generated from protobuf field: optional uint32 total_results = 3
     */
    totalResults?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId
 */
export interface CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 rtime_time_stamp = 2 [default = 0]
     */
    rtimeTimeStamp?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMEnumerateUserPublishedFiles
 */
export interface CMsgClientUCMEnumerateUserPublishedFiles {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 start_index = 2
     */
    startIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 sort_order = 3
     */
    sortOrder?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMEnumerateUserPublishedFilesResponse
 */
export interface CMsgClientUCMEnumerateUserPublishedFilesResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId published_files = 2
     */
    publishedFiles: CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId[];
    /**
     * @generated from protobuf field: optional uint32 total_results = 3
     */
    totalResults?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId
 */
export interface CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientUCMEnumerateUserSubscribedFiles
 */
export interface CMsgClientUCMEnumerateUserSubscribedFiles {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 start_index = 2
     */
    startIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 list_type = 3 [default = 1]
     */
    listType?: number;
    /**
     * @generated from protobuf field: optional uint32 matching_file_type = 4 [default = 0]
     */
    matchingFileType?: number;
    /**
     * @generated from protobuf field: optional uint32 count = 5 [default = 50]
     */
    count?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMEnumerateUserSubscribedFilesResponse
 */
export interface CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId subscribed_files = 2
     */
    subscribedFiles: CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId[];
    /**
     * @generated from protobuf field: optional uint32 total_results = 3
     */
    totalResults?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId
 */
export interface CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 rtime32_subscribed = 2 [default = 0]
     */
    rtime32Subscribed?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates
 */
export interface CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 start_index = 2
     */
    startIndex?: number;
    /**
     * @generated from protobuf field: optional fixed32 start_time = 3
     */
    startTime?: number;
    /**
     * @generated from protobuf field: optional uint32 desired_revision = 4 [default = 0]
     */
    desiredRevision?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse
 */
export interface CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId subscribed_files = 2
     */
    subscribedFiles: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId[];
    /**
     * @generated from protobuf field: optional uint32 total_results = 3
     */
    totalResults?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId
 */
export interface CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 rtime32_subscribed = 2 [default = 0]
     */
    rtime32Subscribed?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 3
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional fixed64 file_hcontent = 4
     */
    fileHcontent?: bigint;
    /**
     * @generated from protobuf field: optional uint32 file_size = 5
     */
    fileSize?: number;
    /**
     * @generated from protobuf field: optional fixed32 rtime32_last_updated = 6
     */
    rtime32LastUpdated?: number;
    /**
     * @generated from protobuf field: optional bool is_depot_content = 7
     */
    isDepotContent?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUCMGetPublishedFilesForUser
 */
export interface CMsgClientUCMGetPublishedFilesForUser {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 creator_steam_id = 2
     */
    creatorSteamId?: bigint;
    /**
     * @generated from protobuf field: repeated string required_tags = 3
     */
    requiredTags: string[];
    /**
     * @generated from protobuf field: repeated string excluded_tags = 4
     */
    excludedTags: string[];
    /**
     * @generated from protobuf field: optional uint32 start_index = 5
     */
    startIndex?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMGetPublishedFilesForUserResponse
 */
export interface CMsgClientUCMGetPublishedFilesForUserResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId published_files = 2
     */
    publishedFiles: CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId[];
    /**
     * @generated from protobuf field: optional uint32 total_results = 3
     */
    totalResults?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId
 */
export interface CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientUCMPublishedFileUpdated
 */
export interface CMsgClientUCMPublishedFileUpdated {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 time_updated = 3
     */
    timeUpdated?: number;
    /**
     * @generated from protobuf field: optional fixed64 hcontent = 4
     */
    hcontent?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 file_size = 5
     */
    fileSize?: number;
    /**
     * @generated from protobuf field: optional bool is_depot_content = 6
     */
    isDepotContent?: boolean;
    /**
     * @generated from protobuf field: optional uint32 revision = 7
     */
    revision?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMPublishFile
 */
export interface CMsgClientUCMPublishFile {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string file_name = 2
     */
    fileName?: string;
    /**
     * @generated from protobuf field: optional string preview_file_name = 3
     */
    previewFileName?: string;
    /**
     * @generated from protobuf field: optional uint32 consumer_app_id = 4
     */
    consumerAppId?: number;
    /**
     * @generated from protobuf field: optional string title = 5
     */
    title?: string;
    /**
     * @generated from protobuf field: optional string description = 6
     */
    description?: string;
    /**
     * @generated from protobuf field: repeated string tags = 8
     */
    tags: string[];
    /**
     * @generated from protobuf field: optional bool workshop_file = 9
     */
    workshopFile?: boolean;
    /**
     * @generated from protobuf field: optional int32 visibility = 10
     */
    visibility?: number;
    /**
     * @generated from protobuf field: optional uint32 file_type = 11
     */
    fileType?: number;
    /**
     * @generated from protobuf field: optional string url = 12
     */
    url?: string;
    /**
     * @generated from protobuf field: optional uint32 video_provider = 13
     */
    videoProvider?: number;
    /**
     * @generated from protobuf field: optional string video_account_name = 14
     */
    videoAccountName?: string;
    /**
     * @generated from protobuf field: optional string video_identifier = 15
     */
    videoIdentifier?: string;
    /**
     * @generated from protobuf field: optional bool in_progress = 16
     */
    inProgress?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUCMPublishFileResponse
 */
export interface CMsgClientUCMPublishFileResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 2 [default = 18446744073709551615]
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional bool needs_workshop_legal_agreement_acceptance = 3 [default = false]
     */
    needsWorkshopLegalAgreementAcceptance?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUCMSetUserPublishedFileAction
 */
export interface CMsgClientUCMSetUserPublishedFileAction {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional int32 action = 3
     */
    action?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMSetUserPublishedFileActionResponse
 */
export interface CMsgClientUCMSetUserPublishedFileActionResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientUCMUpdatePublishedFile
 */
export interface CMsgClientUCMUpdatePublishedFile {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 2
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional string file_name = 3
     */
    fileName?: string;
    /**
     * @generated from protobuf field: optional string preview_file_name = 4
     */
    previewFileName?: string;
    /**
     * @generated from protobuf field: optional string title = 5
     */
    title?: string;
    /**
     * @generated from protobuf field: optional string description = 6
     */
    description?: string;
    /**
     * @generated from protobuf field: repeated string tags = 7
     */
    tags: string[];
    /**
     * @generated from protobuf field: optional int32 visibility = 8
     */
    visibility?: number;
    /**
     * @generated from protobuf field: optional bool update_file = 9
     */
    updateFile?: boolean;
    /**
     * @generated from protobuf field: optional bool update_preview_file = 10
     */
    updatePreviewFile?: boolean;
    /**
     * @generated from protobuf field: optional bool update_title = 11
     */
    updateTitle?: boolean;
    /**
     * @generated from protobuf field: optional bool update_description = 12
     */
    updateDescription?: boolean;
    /**
     * @generated from protobuf field: optional bool update_tags = 13
     */
    updateTags?: boolean;
    /**
     * @generated from protobuf field: optional bool update_visibility = 14
     */
    updateVisibility?: boolean;
    /**
     * @generated from protobuf field: optional string change_description = 15
     */
    changeDescription?: string;
    /**
     * @generated from protobuf field: optional bool update_url = 16
     */
    updateUrl?: boolean;
    /**
     * @generated from protobuf field: optional string url = 17
     */
    url?: string;
    /**
     * @generated from protobuf field: optional bool update_content_manifest = 18
     */
    updateContentManifest?: boolean;
    /**
     * @generated from protobuf field: optional fixed64 content_manifest = 19
     */
    contentManifest?: bigint;
    /**
     * @generated from protobuf field: optional string metadata = 20
     */
    metadata?: string;
    /**
     * @generated from protobuf field: optional bool update_metadata = 21
     */
    updateMetadata?: boolean;
    /**
     * @generated from protobuf field: optional int32 language = 22 [default = 0]
     */
    language?: number;
    /**
     * @generated from protobuf field: repeated string removed_kvtags = 23
     */
    removedKvtags: string[];
    /**
     * @generated from protobuf field: repeated CMsgClientUCMUpdatePublishedFile_KeyValueTag kvtags = 24
     */
    kvtags: CMsgClientUCMUpdatePublishedFile_KeyValueTag[];
    /**
     * @generated from protobuf field: repeated CMsgClientUCMUpdatePublishedFile_AdditionalPreview previews = 25
     */
    previews: CMsgClientUCMUpdatePublishedFile_AdditionalPreview[];
    /**
     * @generated from protobuf field: repeated int32 previews_to_remove = 26
     */
    previewsToRemove: number[];
    /**
     * @generated from protobuf field: optional bool clear_in_progress = 27
     */
    clearInProgress?: boolean;
    /**
     * @generated from protobuf field: optional bool remove_all_kvtags = 28
     */
    removeAllKvtags?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUCMUpdatePublishedFile_AdditionalPreview
 */
export interface CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
    /**
     * @generated from protobuf field: optional string original_file_name = 1
     */
    originalFileName?: string;
    /**
     * @generated from protobuf field: optional string internal_file_name = 2
     */
    internalFileName?: string;
    /**
     * @generated from protobuf field: optional string videoid = 3
     */
    videoid?: string;
    /**
     * @generated from protobuf field: optional uint32 preview_type = 4
     */
    previewType?: number;
    /**
     * @generated from protobuf field: optional int32 update_index = 5 [default = -1]
     */
    updateIndex?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUCMUpdatePublishedFile_KeyValueTag
 */
export interface CMsgClientUCMUpdatePublishedFile_KeyValueTag {
    /**
     * @generated from protobuf field: optional string key = 1
     */
    key?: string;
    /**
     * @generated from protobuf field: optional string value = 2
     */
    value?: string;
}
/**
 * @generated from protobuf message CMsgClientUCMUpdatePublishedFileResponse
 */
export interface CMsgClientUCMUpdatePublishedFileResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional bool needs_workshop_legal_agreement_acceptance = 2 [default = false]
     */
    needsWorkshopLegalAgreementAcceptance?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUDSP2PSessionEnded
 */
export interface CMsgClientUDSP2PSessionEnded {
    /**
     * @generated from protobuf field: optional fixed64 steamid_remote = 1
     */
    steamidRemote?: bigint;
    /**
     * @generated from protobuf field: optional int32 appid = 2
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional int32 session_length_sec = 3
     */
    sessionLengthSec?: number;
    /**
     * @generated from protobuf field: optional int32 session_error = 4
     */
    sessionError?: number;
    /**
     * @generated from protobuf field: optional int32 nattype = 5
     */
    nattype?: number;
    /**
     * @generated from protobuf field: optional int32 bytes_recv = 6
     */
    bytesRecv?: number;
    /**
     * @generated from protobuf field: optional int32 bytes_sent = 7
     */
    bytesSent?: number;
    /**
     * @generated from protobuf field: optional int32 bytes_sent_relay = 8
     */
    bytesSentRelay?: number;
    /**
     * @generated from protobuf field: optional int32 bytes_recv_relay = 9
     */
    bytesRecvRelay?: number;
    /**
     * @generated from protobuf field: optional int32 time_to_connect_ms = 10
     */
    timeToConnectMs?: number;
}
/**
 * @generated from protobuf message CMsgClientUDSP2PSessionStarted
 */
export interface CMsgClientUDSP2PSessionStarted {
    /**
     * @generated from protobuf field: optional fixed64 steamid_remote = 1
     */
    steamidRemote?: bigint;
    /**
     * @generated from protobuf field: optional int32 appid = 2
     */
    appid?: number;
}
/**
 * @generated from protobuf message CMsgClientUFSDeleteFileRequest
 */
export interface CMsgClientUFSDeleteFileRequest {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string file_name = 2
     */
    fileName?: string;
    /**
     * @generated from protobuf field: optional bool is_explicit_delete = 3
     */
    isExplicitDelete?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUFSDeleteFileResponse
 */
export interface CMsgClientUFSDeleteFileResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional string file_name = 2
     */
    fileName?: string;
}
/**
 * @generated from protobuf message CMsgClientUFSDownloadRequest
 */
export interface CMsgClientUFSDownloadRequest {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string file_name = 2
     */
    fileName?: string;
    /**
     * @generated from protobuf field: optional bool can_handle_http = 3
     */
    canHandleHttp?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUFSDownloadResponse
 */
export interface CMsgClientUFSDownloadResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 file_size = 3
     */
    fileSize?: number;
    /**
     * @generated from protobuf field: optional uint32 raw_file_size = 4
     */
    rawFileSize?: number;
    /**
     * @generated from protobuf field: optional bytes sha_file = 5
     */
    shaFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint64 time_stamp = 6
     */
    timeStamp?: bigint;
    /**
     * @generated from protobuf field: optional bool is_explicit_delete = 7
     */
    isExplicitDelete?: boolean;
    /**
     * @generated from protobuf field: optional bool use_http = 8
     */
    useHttp?: boolean;
    /**
     * @generated from protobuf field: optional string http_host = 9
     */
    httpHost?: string;
    /**
     * @generated from protobuf field: optional string http_url = 10
     */
    httpUrl?: string;
    /**
     * @generated from protobuf field: optional bytes kv_headers = 11
     */
    kvHeaders?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool use_https = 12
     */
    useHttps?: boolean;
    /**
     * @generated from protobuf field: optional bool encrypted = 13
     */
    encrypted?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUFSFileChunk
 */
export interface CMsgClientUFSFileChunk {
    /**
     * @generated from protobuf field: optional bytes sha_file = 1
     */
    shaFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 file_start = 2
     */
    fileStart?: number;
    /**
     * @generated from protobuf field: optional bytes data = 3
     */
    data?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientUFSGetFileListForApp
 */
export interface CMsgClientUFSGetFileListForApp {
    /**
     * @generated from protobuf field: repeated uint32 apps_to_query = 1
     */
    appsToQuery: number[];
    /**
     * @generated from protobuf field: optional bool send_path_prefixes = 2
     */
    sendPathPrefixes?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUFSGetFileListForAppResponse
 */
export interface CMsgClientUFSGetFileListForAppResponse {
    /**
     * @generated from protobuf field: repeated CMsgClientUFSGetFileListForAppResponse_File files = 1
     */
    files: CMsgClientUFSGetFileListForAppResponse_File[];
    /**
     * @generated from protobuf field: repeated string path_prefixes = 2
     */
    pathPrefixes: string[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUFSGetFileListForAppResponse_File
 */
export interface CMsgClientUFSGetFileListForAppResponse_File {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string file_name = 2
     */
    fileName?: string;
    /**
     * @generated from protobuf field: optional bytes sha_file = 3
     */
    shaFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint64 time_stamp = 4
     */
    timeStamp?: bigint;
    /**
     * @generated from protobuf field: optional uint32 raw_file_size = 5
     */
    rawFileSize?: number;
    /**
     * @generated from protobuf field: optional bool is_explicit_delete = 6
     */
    isExplicitDelete?: boolean;
    /**
     * @generated from protobuf field: optional uint32 platforms_to_sync = 7
     */
    platformsToSync?: number;
    /**
     * @generated from protobuf field: optional uint32 path_prefix_index = 8
     */
    pathPrefixIndex?: number;
}
/**
 * @generated from protobuf message CMsgClientUFSGetSingleFileInfo
 */
export interface CMsgClientUFSGetSingleFileInfo {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string file_name = 2
     */
    fileName?: string;
}
/**
 * @generated from protobuf message CMsgClientUFSGetSingleFileInfoResponse
 */
export interface CMsgClientUFSGetSingleFileInfoResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string file_name = 3
     */
    fileName?: string;
    /**
     * @generated from protobuf field: optional bytes sha_file = 4
     */
    shaFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint64 time_stamp = 5
     */
    timeStamp?: bigint;
    /**
     * @generated from protobuf field: optional uint32 raw_file_size = 6
     */
    rawFileSize?: number;
    /**
     * @generated from protobuf field: optional bool is_explicit_delete = 7
     */
    isExplicitDelete?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUFSGetUGCDetails
 */
export interface CMsgClientUFSGetUGCDetails {
    /**
     * @generated from protobuf field: optional fixed64 hcontent = 1 [default = 18446744073709551615]
     */
    hcontent?: bigint;
}
/**
 * @generated from protobuf message CMsgClientUFSGetUGCDetailsResponse
 */
export interface CMsgClientUFSGetUGCDetailsResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional string url = 2
     */
    url?: string;
    /**
     * @generated from protobuf field: optional uint32 app_id = 3
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string filename = 4
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional fixed64 steamid_creator = 5
     */
    steamidCreator?: bigint;
    /**
     * @generated from protobuf field: optional uint32 file_size = 6
     */
    fileSize?: number;
    /**
     * @generated from protobuf field: optional uint32 compressed_file_size = 7
     */
    compressedFileSize?: number;
    /**
     * @generated from protobuf field: optional string rangecheck_host = 8
     */
    rangecheckHost?: string;
    /**
     * @generated from protobuf field: optional string file_encoded_sha1 = 9
     */
    fileEncodedSha1?: string;
}
/**
 * @generated from protobuf message CMsgClientUFSLoginRequest
 */
export interface CMsgClientUFSLoginRequest {
    /**
     * @generated from protobuf field: optional uint32 protocol_version = 1
     */
    protocolVersion?: number;
    /**
     * @generated from protobuf field: optional uint64 am_session_token = 2
     */
    amSessionToken?: bigint;
    /**
     * @generated from protobuf field: repeated uint32 apps = 3
     */
    apps: number[];
}
/**
 * @generated from protobuf message CMsgClientUFSLoginResponse
 */
export interface CMsgClientUFSLoginResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgClientUFSShareFile
 */
export interface CMsgClientUFSShareFile {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string file_name = 2
     */
    fileName?: string;
}
/**
 * @generated from protobuf message CMsgClientUFSShareFileResponse
 */
export interface CMsgClientUFSShareFileResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed64 hcontent = 2 [default = 18446744073709551615]
     */
    hcontent?: bigint;
}
/**
 * @generated from protobuf message CMsgClientUFSTransferHeartbeat
 */
export interface CMsgClientUFSTransferHeartbeat {
}
/**
 * @generated from protobuf message CMsgClientUFSUploadCommit
 */
export interface CMsgClientUFSUploadCommit {
    /**
     * @generated from protobuf field: repeated CMsgClientUFSUploadCommit_File files = 1
     */
    files: CMsgClientUFSUploadCommit_File[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUFSUploadCommit_File
 */
export interface CMsgClientUFSUploadCommit_File {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional bytes sha_file = 3
     */
    shaFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 cub_file = 4
     */
    cubFile?: number;
    /**
     * @generated from protobuf field: optional string file_name = 5
     */
    fileName?: string;
}
/**
 * @generated from protobuf message CMsgClientUFSUploadCommitResponse
 */
export interface CMsgClientUFSUploadCommitResponse {
    /**
     * @generated from protobuf field: repeated CMsgClientUFSUploadCommitResponse_File files = 1
     */
    files: CMsgClientUFSUploadCommitResponse_File[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUFSUploadCommitResponse_File
 */
export interface CMsgClientUFSUploadCommitResponse_File {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional bytes sha_file = 3
     */
    shaFile?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientUFSUploadFileFinished
 */
export interface CMsgClientUFSUploadFileFinished {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional bytes sha_file = 2
     */
    shaFile?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientUFSUploadFileRequest
 */
export interface CMsgClientUFSUploadFileRequest {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 file_size = 2
     */
    fileSize?: number;
    /**
     * @generated from protobuf field: optional uint32 raw_file_size = 3
     */
    rawFileSize?: number;
    /**
     * @generated from protobuf field: optional bytes sha_file = 4
     */
    shaFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint64 time_stamp = 5
     */
    timeStamp?: bigint;
    /**
     * @generated from protobuf field: optional string file_name = 6
     */
    fileName?: string;
    /**
     * @generated from protobuf field: optional uint32 platforms_to_sync_deprecated = 7
     */
    platformsToSyncDeprecated?: number;
    /**
     * @generated from protobuf field: optional uint32 platforms_to_sync = 8 [default = 4294967295]
     */
    platformsToSync?: number;
    /**
     * @generated from protobuf field: optional uint32 cell_id = 9
     */
    cellId?: number;
    /**
     * @generated from protobuf field: optional bool can_encrypt = 10
     */
    canEncrypt?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUFSUploadFileResponse
 */
export interface CMsgClientUFSUploadFileResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional bytes sha_file = 2
     */
    shaFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool use_http = 3
     */
    useHttp?: boolean;
    /**
     * @generated from protobuf field: optional string http_host = 4
     */
    httpHost?: string;
    /**
     * @generated from protobuf field: optional string http_url = 5
     */
    httpUrl?: string;
    /**
     * @generated from protobuf field: optional bytes kv_headers = 6
     */
    kvHeaders?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool use_https = 7
     */
    useHttps?: boolean;
    /**
     * @generated from protobuf field: optional bool encrypt_file = 8
     */
    encryptFile?: boolean;
}
/**
 * @generated from protobuf message CMsgClientUGSGetGlobalStats
 */
export interface CMsgClientUGSGetGlobalStats {
    /**
     * @generated from protobuf field: optional uint64 gameid = 1
     */
    gameid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 history_days_requested = 2
     */
    historyDaysRequested?: number;
    /**
     * @generated from protobuf field: optional fixed32 time_last_requested = 3
     */
    timeLastRequested?: number;
    /**
     * @generated from protobuf field: optional uint32 first_day_cached = 4
     */
    firstDayCached?: number;
    /**
     * @generated from protobuf field: optional uint32 days_cached = 5
     */
    daysCached?: number;
}
/**
 * @generated from protobuf message CMsgClientUGSGetGlobalStatsResponse
 */
export interface CMsgClientUGSGetGlobalStatsResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed32 timestamp = 2
     */
    timestamp?: number;
    /**
     * @generated from protobuf field: optional int32 day_current = 3
     */
    dayCurrent?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientUGSGetGlobalStatsResponse_Day days = 4
     */
    days: CMsgClientUGSGetGlobalStatsResponse_Day[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUGSGetGlobalStatsResponse_Day
 */
export interface CMsgClientUGSGetGlobalStatsResponse_Day {
    /**
     * @generated from protobuf field: optional uint32 day_id = 1
     */
    dayId?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientUGSGetGlobalStatsResponse_Day_Stat stats = 2
     */
    stats: CMsgClientUGSGetGlobalStatsResponse_Day_Stat[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUGSGetGlobalStatsResponse_Day_Stat
 */
export interface CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
    /**
     * @generated from protobuf field: optional int32 stat_id = 1
     */
    statId?: number;
    /**
     * @generated from protobuf field: optional int64 data = 2
     */
    data?: bigint;
}
/**
 * @generated from protobuf message CMsgClientUIMode
 */
export interface CMsgClientUIMode {
    /**
     * @generated from protobuf field: optional uint32 uimode = 1
     */
    uimode?: number;
    /**
     * @generated from protobuf field: optional uint32 chat_mode = 2
     */
    chatMode?: number;
}
/**
 * @generated from protobuf message CMsgClientUninstallClientApp
 */
export interface CMsgClientUninstallClientApp {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
}
/**
 * @generated from protobuf message CMsgClientUninstallClientAppResponse
 */
export interface CMsgClientUninstallClientAppResponse {
    /**
     * @generated from protobuf field: optional uint32 result = 1
     */
    result?: number;
}
/**
 * @generated from protobuf message CMsgClientUnsignedInstallScript
 */
export interface CMsgClientUnsignedInstallScript {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string file_name = 2
     */
    fileName?: string;
    /**
     * @generated from protobuf field: optional uint32 file_size = 3
     */
    fileSize?: number;
    /**
     * @generated from protobuf field: optional bool signature_broken = 4
     */
    signatureBroken?: boolean;
    /**
     * @generated from protobuf field: optional uint32 depot_id = 5
     */
    depotId?: number;
    /**
     * @generated from protobuf field: optional uint64 manifest_id = 6
     */
    manifestId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 file_flags = 7
     */
    fileFlags?: number;
}
/**
 * @generated from protobuf message CMsgClientUpdateAppJobReport
 */
export interface CMsgClientUpdateAppJobReport {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: repeated uint32 depot_ids = 2
     */
    depotIds: number[];
    /**
     * @generated from protobuf field: optional uint32 app_state = 3
     */
    appState?: number;
    /**
     * @generated from protobuf field: optional uint32 job_app_error = 4
     */
    jobAppError?: number;
    /**
     * @generated from protobuf field: optional string error_details = 5
     */
    errorDetails?: string;
    /**
     * @generated from protobuf field: optional uint32 job_duration = 6
     */
    jobDuration?: number;
    /**
     * @generated from protobuf field: optional uint32 files_validation_failed = 7
     */
    filesValidationFailed?: number;
    /**
     * @generated from protobuf field: optional uint64 job_bytes_downloaded = 8
     */
    jobBytesDownloaded?: bigint;
    /**
     * @generated from protobuf field: optional uint64 job_bytes_staged = 9
     */
    jobBytesStaged?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes_comitted = 10
     */
    bytesComitted?: bigint;
    /**
     * @generated from protobuf field: optional uint32 start_app_state = 11
     */
    startAppState?: number;
    /**
     * @generated from protobuf field: optional fixed64 stats_machine_id = 12
     */
    statsMachineId?: bigint;
    /**
     * @generated from protobuf field: optional string branch_name = 13
     */
    branchName?: string;
    /**
     * @generated from protobuf field: optional uint64 total_bytes_downloaded = 14
     */
    totalBytesDownloaded?: bigint;
    /**
     * @generated from protobuf field: optional uint64 total_bytes_staged = 15
     */
    totalBytesStaged?: bigint;
    /**
     * @generated from protobuf field: optional uint64 total_bytes_restored = 16
     */
    totalBytesRestored?: bigint;
    /**
     * @generated from protobuf field: optional bool is_borrowed = 17
     */
    isBorrowed?: boolean;
    /**
     * @generated from protobuf field: optional bool is_free_weekend = 18
     */
    isFreeWeekend?: boolean;
    /**
     * @generated from protobuf field: optional uint64 total_bytes_legacy = 19
     */
    totalBytesLegacy?: bigint;
    /**
     * @generated from protobuf field: optional uint64 total_bytes_patched = 20
     */
    totalBytesPatched?: bigint;
    /**
     * @generated from protobuf field: optional uint64 total_bytes_saved = 21
     */
    totalBytesSaved?: bigint;
    /**
     * @generated from protobuf field: optional uint32 cell_id = 22
     */
    cellId?: number;
}
/**
 * @generated from protobuf message CMsgClientUpdateMachineAuth
 */
export interface CMsgClientUpdateMachineAuth {
    /**
     * @generated from protobuf field: optional string filename = 1
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional uint32 offset = 2
     */
    offset?: number;
    /**
     * @generated from protobuf field: optional uint32 cubtowrite = 3
     */
    cubtowrite?: number;
    /**
     * @generated from protobuf field: optional bytes bytes = 4
     */
    bytes?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 otp_type = 5
     */
    otpType?: number;
    /**
     * @generated from protobuf field: optional string otp_identifier = 6
     */
    otpIdentifier?: string;
    /**
     * @generated from protobuf field: optional bytes otp_sharedsecret = 7
     */
    otpSharedsecret?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 otp_timedrift = 8
     */
    otpTimedrift?: number;
}
/**
 * @generated from protobuf message CMsgClientUpdateMachineAuthResponse
 */
export interface CMsgClientUpdateMachineAuthResponse {
    /**
     * @generated from protobuf field: optional string filename = 1
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional uint32 eresult = 2
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 filesize = 3
     */
    filesize?: number;
    /**
     * @generated from protobuf field: optional bytes sha_file = 4
     */
    shaFile?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 getlasterror = 5
     */
    getlasterror?: number;
    /**
     * @generated from protobuf field: optional uint32 offset = 6
     */
    offset?: number;
    /**
     * @generated from protobuf field: optional uint32 cubwrote = 7
     */
    cubwrote?: number;
    /**
     * @generated from protobuf field: optional int32 otp_type = 8
     */
    otpType?: number;
    /**
     * @generated from protobuf field: optional uint32 otp_value = 9
     */
    otpValue?: number;
    /**
     * @generated from protobuf field: optional string otp_identifier = 10
     */
    otpIdentifier?: string;
}
/**
 * @generated from protobuf message CMsgClientUpdateUserGameInfo
 */
export interface CMsgClientUpdateUserGameInfo {
    /**
     * @generated from protobuf field: optional fixed64 steamid_idgs = 1
     */
    steamidIdgs?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 gameid = 2
     */
    gameid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 game_ip = 3
     */
    gameIp?: number;
    /**
     * @generated from protobuf field: optional uint32 game_port = 4
     */
    gamePort?: number;
    /**
     * @generated from protobuf field: optional bytes token = 5
     */
    token?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgClientUseLocalDeviceAuthorizations
 */
export interface CMsgClientUseLocalDeviceAuthorizations {
    /**
     * @generated from protobuf field: repeated uint32 authorization_account_id = 1
     */
    authorizationAccountId: number[];
    /**
     * @generated from protobuf field: repeated CMsgClientUseLocalDeviceAuthorizations_DeviceToken device_tokens = 2
     */
    deviceTokens: CMsgClientUseLocalDeviceAuthorizations_DeviceToken[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUseLocalDeviceAuthorizations_DeviceToken
 */
export interface CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
    /**
     * @generated from protobuf field: optional uint32 owner_account_id = 1
     */
    ownerAccountId?: number;
    /**
     * @generated from protobuf field: optional uint64 token_id = 2
     */
    tokenId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientUserNotifications
 */
export interface CMsgClientUserNotifications {
    /**
     * @generated from protobuf field: repeated CMsgClientUserNotifications_Notification notifications = 1
     */
    notifications: CMsgClientUserNotifications_Notification[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientUserNotifications_Notification
 */
export interface CMsgClientUserNotifications_Notification {
    /**
     * @generated from protobuf field: optional uint32 user_notification_type = 1
     */
    userNotificationType?: number;
    /**
     * @generated from protobuf field: optional uint32 count = 2
     */
    count?: number;
}
/**
 * @generated from protobuf message CMsgClientVanityURLChangedNotification
 */
export interface CMsgClientVanityURLChangedNotification {
    /**
     * @generated from protobuf field: optional string vanity_url = 1
     */
    vanityUrl?: string;
}
/**
 * @generated from protobuf message CMsgClientVoiceCallPreAuthorize
 */
export interface CMsgClientVoiceCallPreAuthorize {
    /**
     * @generated from protobuf field: optional fixed64 caller_steamid = 1
     */
    callerSteamid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 receiver_steamid = 2
     */
    receiverSteamid?: bigint;
    /**
     * @generated from protobuf field: optional int32 caller_id = 3
     */
    callerId?: number;
    /**
     * @generated from protobuf field: optional bool hangup = 4
     */
    hangup?: boolean;
}
/**
 * @generated from protobuf message CMsgClientVoiceCallPreAuthorizeResponse
 */
export interface CMsgClientVoiceCallPreAuthorizeResponse {
    /**
     * @generated from protobuf field: optional fixed64 caller_steamid = 1
     */
    callerSteamid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 receiver_steamid = 2
     */
    receiverSteamid?: bigint;
    /**
     * @generated from protobuf field: optional int32 eresult = 3 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 caller_id = 4
     */
    callerId?: number;
}
/**
 * @generated from protobuf message CMsgClientWalletInfoUpdate
 */
export interface CMsgClientWalletInfoUpdate {
    /**
     * @generated from protobuf field: optional bool has_wallet = 1
     */
    hasWallet?: boolean;
    /**
     * @generated from protobuf field: optional int32 balance = 2
     */
    balance?: number;
    /**
     * @generated from protobuf field: optional int32 currency = 3
     */
    currency?: number;
    /**
     * @generated from protobuf field: optional int32 balance_delayed = 4
     */
    balanceDelayed?: number;
    /**
     * @generated from protobuf field: optional int64 balance64 = 5
     */
    balance64?: bigint;
    /**
     * @generated from protobuf field: optional int64 balance64_delayed = 6
     */
    balance64Delayed?: bigint;
}
/**
 * @generated from protobuf message CMsgClientWorkshopItemChangesRequest
 */
export interface CMsgClientWorkshopItemChangesRequest {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 last_time_updated = 2
     */
    lastTimeUpdated?: number;
    /**
     * @generated from protobuf field: optional uint32 num_items_needed = 3
     */
    numItemsNeeded?: number;
}
/**
 * @generated from protobuf message CMsgClientWorkshopItemChangesResponse
 */
export interface CMsgClientWorkshopItemChangesResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 update_time = 2
     */
    updateTime?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo workshop_items = 5
     */
    workshopItems: CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo
 */
export interface CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 time_updated = 2
     */
    timeUpdated?: number;
    /**
     * @generated from protobuf field: optional fixed64 manifest_id = 3
     */
    manifestId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientWorkshopItemInfoRequest
 */
export interface CMsgClientWorkshopItemInfoRequest {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 last_time_updated = 2
     */
    lastTimeUpdated?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientWorkshopItemInfoRequest_WorkshopItem workshop_items = 3
     */
    workshopItems: CMsgClientWorkshopItemInfoRequest_WorkshopItem[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientWorkshopItemInfoRequest_WorkshopItem
 */
export interface CMsgClientWorkshopItemInfoRequest_WorkshopItem {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 time_updated = 2
     */
    timeUpdated?: number;
}
/**
 * @generated from protobuf message CMsgClientWorkshopItemInfoResponse
 */
export interface CMsgClientWorkshopItemInfoResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 update_time = 2
     */
    updateTime?: number;
    /**
     * @generated from protobuf field: repeated CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo workshop_items = 3
     */
    workshopItems: CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo[];
    /**
     * @generated from protobuf field: repeated fixed64 private_items = 4
     */
    privateItems: bigint[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo
 */
export interface CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 time_updated = 2
     */
    timeUpdated?: number;
    /**
     * @generated from protobuf field: optional fixed64 manifest_id = 3
     */
    manifestId?: bigint;
    /**
     * @generated from protobuf field: optional bool is_legacy = 4
     */
    isLegacy?: boolean;
}
/**
 * @generated from protobuf message CMsgCloudPendingRemoteOperations
 */
export interface CMsgCloudPendingRemoteOperations {
    /**
     * @generated from protobuf field: repeated CCloud_PendingRemoteOperation operations = 1
     */
    operations: CCloud_PendingRemoteOperation[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerActionSetMiscSettings
 */
export interface CMsgControllerActionSetMiscSettings {
    /**
     * @generated from protobuf field: optional string cursor_visible_action_set_key = 1
     */
    cursorVisibleActionSetKey?: string;
    /**
     * @generated from protobuf field: optional string cursor_hidden_action_set_key = 2
     */
    cursorHiddenActionSetKey?: string;
}
/**
 * @generated from protobuf message CMsgControllerConfiguration
 */
export interface CMsgControllerConfiguration {
    /**
     * @generated from protobuf field: optional uint32 binding_handle = 1
     */
    bindingHandle?: number;
    /**
     * @generated from protobuf field: optional string display_name = 2
     */
    displayName?: string;
    /**
     * @generated from protobuf field: optional string description = 3
     */
    description?: string;
    /**
     * @generated from protobuf field: optional string creator = 4
     */
    creator?: string;
    /**
     * @generated from protobuf field: optional int32 controller_type = 5
     */
    controllerType?: number;
    /**
     * @generated from protobuf field: optional string capability_bits = 6
     */
    capabilityBits?: string;
    /**
     * @generated from protobuf field: optional int32 controller_style = 7
     */
    controllerStyle?: number;
    /**
     * @generated from protobuf field: repeated CMsgGameActionSet sets = 8
     */
    sets: CMsgGameActionSet[];
    /**
     * @generated from protobuf field: repeated CMsgControllerMode modes = 9
     */
    modes: CMsgControllerMode[];
    /**
     * @generated from protobuf field: optional string error_msg = 10
     */
    errorMsg?: string;
    /**
     * @generated from protobuf field: optional string action_block_path = 11
     */
    actionBlockPath?: string;
    /**
     * @generated from protobuf field: optional CMsgControllerActionSetMiscSettings misc_action_set_settings = 12
     */
    miscActionSetSettings?: CMsgControllerActionSetMiscSettings;
    /**
     * @generated from protobuf field: optional string url = 13
     */
    url?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInput
 */
export interface CMsgControllerInput {
    /**
     * @generated from protobuf field: optional int32 key = 1
     */
    key?: number;
    /**
     * @generated from protobuf field: repeated CMsgControllerInputActivator activators = 2
     */
    activators: CMsgControllerInputActivator[];
    /**
     * @generated from protobuf field: repeated CMsgControllerInputActivator disabled_activators = 3
     */
    disabledActivators: CMsgControllerInputActivator[];
    /**
     * @generated from protobuf field: optional bool inherited_from_parentset = 4
     */
    inheritedFromParentset?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputActivator
 */
export interface CMsgControllerInputActivator {
    /**
     * @generated from protobuf field: optional int32 activation = 1
     */
    activation?: number;
    /**
     * @generated from protobuf field: repeated CMsgControllerInputBinding bindings = 2
     */
    bindings: CMsgControllerInputBinding[];
    /**
     * @generated from protobuf field: repeated CMsgControllerSetting settings = 3
     */
    settings: CMsgControllerSetting[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputBinding
 */
export interface CMsgControllerInputBinding {
    /**
     * @generated from protobuf field: optional int32 type = 1
     */
    type?: number;
    /**
     * @generated from protobuf field: optional CMsgControllerInputBinding_KeyBindingData key_binding_data = 2
     */
    keyBindingData?: CMsgControllerInputBinding_KeyBindingData;
    /**
     * @generated from protobuf field: optional CMsgControllerInputKeyBinding keyboard_key = 3
     */
    keyboardKey?: CMsgControllerInputKeyBinding;
    /**
     * @generated from protobuf field: optional CMsgControllerInputMouseButtonBinding mouse_button = 4
     */
    mouseButton?: CMsgControllerInputMouseButtonBinding;
    /**
     * @generated from protobuf field: optional CMsgControllerInputGamepadButtonBinding gamepad_button = 5
     */
    gamepadButton?: CMsgControllerInputGamepadButtonBinding;
    /**
     * @generated from protobuf field: optional CMsgControllerInputMouseWheelBinding mouse_wheel = 6
     */
    mouseWheel?: CMsgControllerInputMouseWheelBinding;
    /**
     * @generated from protobuf field: optional CMsgControllerInputModeShiftBinding mode_shift = 7
     */
    modeShift?: CMsgControllerInputModeShiftBinding;
    /**
     * @generated from protobuf field: optional CMsgControllerInputGameActionBinding game_action = 8
     */
    gameAction?: CMsgControllerInputGameActionBinding;
    /**
     * @generated from protobuf field: optional CMsgControllerInputControllerActionBinding controller_action = 9
     */
    controllerAction?: CMsgControllerInputControllerActionBinding;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputBinding_IconBindingData
 */
export interface CMsgControllerInputBinding_IconBindingData {
    /**
     * @generated from protobuf field: optional string icon_filename = 1
     */
    iconFilename?: string;
    /**
     * @generated from protobuf field: optional string color_foreground = 2
     */
    colorForeground?: string;
    /**
     * @generated from protobuf field: optional string color_background = 3
     */
    colorBackground?: string;
    /**
     * @generated from protobuf field: optional string icon_url = 4
     */
    iconUrl?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputBinding_KeyBindingData
 */
export interface CMsgControllerInputBinding_KeyBindingData {
    /**
     * @generated from protobuf field: optional string keys_bound_utf8 = 1
     */
    keysBoundUtf8?: string;
    /**
     * @generated from protobuf field: optional string friendly_name_utf8 = 2
     */
    friendlyNameUtf8?: string;
    /**
     * @generated from protobuf field: optional CMsgControllerInputBinding_IconBindingData icon_data = 3
     */
    iconData?: CMsgControllerInputBinding_IconBindingData;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputControllerActionBinding
 */
export interface CMsgControllerInputControllerActionBinding {
    /**
     * @generated from protobuf field: optional int32 action = 1
     */
    action?: number;
    /**
     * @generated from protobuf field: optional CMsgControllerInputControllerActionMouseBinding mouse = 2
     */
    mouse?: CMsgControllerInputControllerActionMouseBinding;
    /**
     * @generated from protobuf field: optional CMsgControllerInputControllerActionCameraHorizonReset camera_horizon_reset = 3
     */
    cameraHorizonReset?: CMsgControllerInputControllerActionCameraHorizonReset;
    /**
     * @generated from protobuf field: optional CMsgControllerInputControllerActionDotsPer360CalibrationSpin dots_per_360_calibration_spin = 4
     */
    dotsPer360CalibrationSpin?: CMsgControllerInputControllerActionDotsPer360CalibrationSpin;
    /**
     * @generated from protobuf field: optional CMsgControllerInputControllerActionTurnToFaceDirection turn_to_face_direction = 5
     */
    turnToFaceDirection?: CMsgControllerInputControllerActionTurnToFaceDirection;
    /**
     * @generated from protobuf field: optional CMsgControllerInputControllerActionGameActionSetBinding action_set = 6
     */
    actionSet?: CMsgControllerInputControllerActionGameActionSetBinding;
    /**
     * @generated from protobuf field: optional CMsgControllerInputControllerActionLEDColorBinding led_color = 7
     */
    ledColor?: CMsgControllerInputControllerActionLEDColorBinding;
    /**
     * @generated from protobuf field: optional CMsgControllerInputControllerActionChangePlayerNumberBinding change_player_number = 8
     */
    changePlayerNumber?: CMsgControllerInputControllerActionChangePlayerNumberBinding;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputControllerActionCameraHorizonReset
 */
export interface CMsgControllerInputControllerActionCameraHorizonReset {
    /**
     * @generated from protobuf field: optional int32 camera_dip_angle = 1
     */
    cameraDipAngle?: number;
    /**
     * @generated from protobuf field: optional int32 delay_duration = 2
     */
    delayDuration?: number;
    /**
     * @generated from protobuf field: optional int32 camera_horizon_reset_angle = 3
     */
    cameraHorizonResetAngle?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputControllerActionChangePlayerNumberBinding
 */
export interface CMsgControllerInputControllerActionChangePlayerNumberBinding {
    /**
     * @generated from protobuf field: optional int32 player_number = 1
     */
    playerNumber?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputControllerActionDotsPer360CalibrationSpin
 */
export interface CMsgControllerInputControllerActionDotsPer360CalibrationSpin {
    /**
     * @generated from protobuf field: optional int32 spin_by_amount = 1
     */
    spinByAmount?: number;
    /**
     * @generated from protobuf field: optional int32 spin_duration = 2
     */
    spinDuration?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputControllerActionGameActionSetBinding
 */
export interface CMsgControllerInputControllerActionGameActionSetBinding {
    /**
     * @generated from protobuf field: optional int32 preset_type = 1
     */
    presetType?: number;
    /**
     * @generated from protobuf field: optional string action_set_key = 2
     */
    actionSetKey?: string;
    /**
     * @generated from protobuf field: optional bool display = 3
     */
    display?: boolean;
    /**
     * @generated from protobuf field: optional bool beep = 4
     */
    beep?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputControllerActionLEDColorBinding
 */
export interface CMsgControllerInputControllerActionLEDColorBinding {
    /**
     * @generated from protobuf field: optional int32 setting = 1
     */
    setting?: number;
    /**
     * @generated from protobuf field: optional int32 brightness = 2
     */
    brightness?: number;
    /**
     * @generated from protobuf field: optional int32 saturation = 3
     */
    saturation?: number;
    /**
     * @generated from protobuf field: optional int32 color_r = 4
     */
    colorR?: number;
    /**
     * @generated from protobuf field: optional int32 color_g = 5
     */
    colorG?: number;
    /**
     * @generated from protobuf field: optional int32 color_b = 6
     */
    colorB?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputControllerActionMouseBinding
 */
export interface CMsgControllerInputControllerActionMouseBinding {
    /**
     * @generated from protobuf field: optional sint32 x = 1
     */
    x?: number;
    /**
     * @generated from protobuf field: optional sint32 y = 2
     */
    y?: number;
    /**
     * @generated from protobuf field: optional bool restore = 3
     */
    restore?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputControllerActionTurnToFaceDirection
 */
export interface CMsgControllerInputControllerActionTurnToFaceDirection {
    /**
     * @generated from protobuf field: optional int32 source_of_direction = 1
     */
    sourceOfDirection?: number;
    /**
     * @generated from protobuf field: optional int32 turn_duration = 2
     */
    turnDuration?: number;
    /**
     * @generated from protobuf field: optional bool use_last_direction_if_deadzoned = 3
     */
    useLastDirectionIfDeadzoned?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputGameActionBinding
 */
export interface CMsgControllerInputGameActionBinding {
    /**
     * @generated from protobuf field: optional string action_set_key = 1
     */
    actionSetKey?: string;
    /**
     * @generated from protobuf field: optional string action_key = 2
     */
    actionKey?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputGamepadButtonBinding
 */
export interface CMsgControllerInputGamepadButtonBinding {
    /**
     * @generated from protobuf field: optional int32 button = 1
     */
    button?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputKeyBinding
 */
export interface CMsgControllerInputKeyBinding {
    /**
     * @generated from protobuf field: optional int32 key = 1
     */
    key?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputModeShiftBinding
 */
export interface CMsgControllerInputModeShiftBinding {
    /**
     * @generated from protobuf field: optional int32 source = 1
     */
    source?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputMouseButtonBinding
 */
export interface CMsgControllerInputMouseButtonBinding {
    /**
     * @generated from protobuf field: optional int32 button = 1
     */
    button?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerInputMouseWheelBinding
 */
export interface CMsgControllerInputMouseWheelBinding {
    /**
     * @generated from protobuf field: optional int32 button = 1
     */
    button?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerMode
 */
export interface CMsgControllerMode {
    /**
     * @generated from protobuf field: optional int32 mode = 1
     */
    mode?: number;
    /**
     * @generated from protobuf field: optional uint32 modeid = 2
     */
    modeid?: number;
    /**
     * @generated from protobuf field: optional string description = 3
     */
    description?: string;
    /**
     * @generated from protobuf field: repeated CMsgControllerInput inputs = 4
     */
    inputs: CMsgControllerInput[];
    /**
     * @generated from protobuf field: repeated CMsgControllerSetting settings = 5
     */
    settings: CMsgControllerSetting[];
    /**
     * @generated from protobuf field: optional string friendlyname = 6
     */
    friendlyname?: string;
    /**
     * @generated from protobuf field: optional int32 source = 7
     */
    source?: number;
    /**
     * @generated from protobuf field: optional CMsgControllerVirtualMenuPreviewInfo virtual_menu_info = 8
     */
    virtualMenuInfo?: CMsgControllerVirtualMenuPreviewInfo;
    /**
     * @generated from protobuf field: optional bool mode_shift = 9
     */
    modeShift?: boolean;
    /**
     * @generated from protobuf field: optional uint32 reference_modeid = 10
     */
    referenceModeid?: number;
    /**
     * @generated from protobuf field: repeated int32 mode_shift_buttons = 11
     */
    modeShiftButtons: number[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerSetting
 */
export interface CMsgControllerSetting {
    /**
     * @generated from protobuf field: optional int32 key = 1
     */
    key?: number;
    /**
     * @generated from protobuf field: optional sint32 int_value = 2
     */
    intValue?: number;
    /**
     * @generated from protobuf field: optional sint32 int_min = 3
     */
    intMin?: number;
    /**
     * @generated from protobuf field: optional sint32 int_max = 4
     */
    intMax?: number;
    /**
     * @generated from protobuf field: optional sint32 int_default = 5
     */
    intDefault?: number;
    /**
     * @generated from protobuf field: optional CMsgControllerSetting parentset_setting = 6
     */
    parentsetSetting?: CMsgControllerSetting;
    /**
     * @generated from protobuf field: optional sint64 long_value = 7
     */
    longValue?: bigint;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerSourceGroup
 */
export interface CMsgControllerSourceGroup {
    /**
     * @generated from protobuf field: optional int32 mode = 1
     */
    mode?: number;
    /**
     * @generated from protobuf field: optional CMsgControllerInputGameActionBinding game_action = 2
     */
    gameAction?: CMsgControllerInputGameActionBinding;
    /**
     * @generated from protobuf field: repeated CMsgControllerInput inputs = 3
     */
    inputs: CMsgControllerInput[];
    /**
     * @generated from protobuf field: repeated CMsgControllerSetting settings = 4
     */
    settings: CMsgControllerSetting[];
    /**
     * @generated from protobuf field: optional uint32 modeid = 5
     */
    modeid?: number;
    /**
     * @generated from protobuf field: optional bool mode_shift = 6
     */
    modeShift?: boolean;
    /**
     * @generated from protobuf field: optional CMsgControllerSourceGroup mode_shift_source_group = 7
     */
    modeShiftSourceGroup?: CMsgControllerSourceGroup;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerSources
 */
export interface CMsgControllerSources {
    /**
     * @generated from protobuf field: optional int32 key = 1
     */
    key?: number;
    /**
     * @generated from protobuf field: optional CMsgControllerSourceGroup active_group = 2
     */
    activeGroup?: CMsgControllerSourceGroup;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgControllerVirtualMenuPreviewInfo
 */
export interface CMsgControllerVirtualMenuPreviewInfo {
    /**
     * @generated from protobuf field: optional int32 source = 1
     */
    source?: number;
    /**
     * @generated from protobuf field: optional float x_pos = 2
     */
    xPos?: number;
    /**
     * @generated from protobuf field: optional float y_pos = 3
     */
    yPos?: number;
    /**
     * @generated from protobuf field: optional float opacity = 4
     */
    opacity?: number;
    /**
     * @generated from protobuf field: optional float scale = 5
     */
    scale?: number;
    /**
     * @generated from protobuf field: optional bool show_labels = 6
     */
    showLabels?: boolean;
    /**
     * @generated from protobuf field: optional uint32 menu_style = 7
     */
    menuStyle?: number;
    /**
     * @generated from protobuf field: optional bool force_on = 8
     */
    forceOn?: boolean;
    /**
     * @generated from protobuf field: repeated CVirtualMenuKey keys = 9
     */
    keys: CVirtualMenuKey[];
}
/**
 * @generated from protobuf message CMsgCREGetUserPublishedItemVoteDetails
 */
export interface CMsgCREGetUserPublishedItemVoteDetails {
    /**
     * @generated from protobuf field: repeated CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId published_file_ids = 1
     */
    publishedFileIds: CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId
 */
export interface CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
}
/**
 * @generated from protobuf message CMsgCREGetUserPublishedItemVoteDetailsResponse
 */
export interface CMsgCREGetUserPublishedItemVoteDetailsResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail user_item_vote_details = 2
     */
    userItemVoteDetails: CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail
 */
export interface CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional int32 vote = 2 [default = 0]
     */
    vote?: number;
}
/**
 * @generated from protobuf message CMsgCREItemVoteSummary
 */
export interface CMsgCREItemVoteSummary {
    /**
     * @generated from protobuf field: repeated CMsgCREItemVoteSummary_PublishedFileId published_file_ids = 1
     */
    publishedFileIds: CMsgCREItemVoteSummary_PublishedFileId[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgCREItemVoteSummary_PublishedFileId
 */
export interface CMsgCREItemVoteSummary_PublishedFileId {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
}
/**
 * @generated from protobuf message CMsgCREItemVoteSummaryResponse
 */
export interface CMsgCREItemVoteSummaryResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgCREItemVoteSummaryResponse_ItemVoteSummary item_vote_summaries = 2
     */
    itemVoteSummaries: CMsgCREItemVoteSummaryResponse_ItemVoteSummary[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgCREItemVoteSummaryResponse_ItemVoteSummary
 */
export interface CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional int32 votes_for = 2
     */
    votesFor?: number;
    /**
     * @generated from protobuf field: optional int32 votes_against = 3
     */
    votesAgainst?: number;
    /**
     * @generated from protobuf field: optional int32 reports = 4
     */
    reports?: number;
    /**
     * @generated from protobuf field: optional float score = 5
     */
    score?: number;
}
/**
 * @generated from protobuf message CMsgCREUpdateUserPublishedItemVote
 */
export interface CMsgCREUpdateUserPublishedItemVote {
    /**
     * @generated from protobuf field: optional fixed64 published_file_id = 1
     */
    publishedFileId?: bigint;
    /**
     * @generated from protobuf field: optional bool vote_up = 2
     */
    voteUp?: boolean;
}
/**
 * @generated from protobuf message CMsgCREUpdateUserPublishedItemVoteResponse
 */
export interface CMsgCREUpdateUserPublishedItemVoteResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgDownloadRateStatistics
 */
export interface CMsgDownloadRateStatistics {
    /**
     * @generated from protobuf field: optional uint32 cell_id = 1
     */
    cellId?: number;
    /**
     * @generated from protobuf field: repeated CMsgDownloadRateStatistics_StatsInfo stats = 2
     */
    stats: CMsgDownloadRateStatistics_StatsInfo[];
    /**
     * @generated from protobuf field: optional uint32 throttling_kbps = 3
     */
    throttlingKbps?: number;
    /**
     * @generated from protobuf field: optional uint32 steam_realm = 4
     */
    steamRealm?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgDownloadRateStatistics_StatsInfo
 */
export interface CMsgDownloadRateStatistics_StatsInfo {
    /**
     * @generated from protobuf field: optional uint32 source_type = 1
     */
    sourceType?: number;
    /**
     * @generated from protobuf field: optional uint32 source_id = 2
     */
    sourceId?: number;
    /**
     * @generated from protobuf field: optional uint32 seconds = 3
     */
    seconds?: number;
    /**
     * @generated from protobuf field: optional uint64 bytes = 4
     */
    bytes?: bigint;
    /**
     * @generated from protobuf field: optional string host_name = 5
     */
    hostName?: string;
    /**
     * @generated from protobuf field: optional uint64 microseconds = 6
     */
    microseconds?: bigint;
    /**
     * @generated from protobuf field: optional bool used_ipv6 = 7
     */
    usedIpv6?: boolean;
    /**
     * @generated from protobuf field: optional bool proxied = 8
     */
    proxied?: boolean;
}
/**
 * @generated from protobuf message CMsgDPGetNumberOfCurrentPlayers
 */
export interface CMsgDPGetNumberOfCurrentPlayers {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
}
/**
 * @generated from protobuf message CMsgDPGetNumberOfCurrentPlayersResponse
 */
export interface CMsgDPGetNumberOfCurrentPlayersResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 player_count = 2
     */
    playerCount?: number;
}
/**
 * @generated from protobuf message CMsgDRMDownloadRequestWithCrashData
 */
export interface CMsgDRMDownloadRequestWithCrashData {
    /**
     * @generated from protobuf field: optional uint32 download_flags = 1
     */
    downloadFlags?: number;
    /**
     * @generated from protobuf field: optional uint32 download_types_known = 2
     */
    downloadTypesKnown?: number;
    /**
     * @generated from protobuf field: optional bytes guid_drm = 3
     */
    guidDrm?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes guid_split = 4
     */
    guidSplit?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes guid_merge = 5
     */
    guidMerge?: Uint8Array;
    /**
     * @generated from protobuf field: optional string module_name = 6
     */
    moduleName?: string;
    /**
     * @generated from protobuf field: optional string module_path = 7
     */
    modulePath?: string;
    /**
     * @generated from protobuf field: optional bytes crash_data = 8
     */
    crashData?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgDRMDownloadResponse
 */
export interface CMsgDRMDownloadResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 blob_download_type = 3
     */
    blobDownloadType?: number;
    /**
     * @generated from protobuf field: optional bytes merge_guid = 4
     */
    mergeGuid?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 download_file_dfs_ip = 5
     */
    downloadFileDfsIp?: number;
    /**
     * @generated from protobuf field: optional uint32 download_file_dfs_port = 6
     */
    downloadFileDfsPort?: number;
    /**
     * @generated from protobuf field: optional string download_file_url = 7
     */
    downloadFileUrl?: string;
    /**
     * @generated from protobuf field: optional string module_path = 8
     */
    modulePath?: string;
}
/**
 * @generated from protobuf message CMsgDRMFinalResult
 */
export interface CMsgDRMFinalResult {
    /**
     * @generated from protobuf field: optional uint32 eResult = 1 [default = 2]
     */
    eResult?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 blob_download_type = 3
     */
    blobDownloadType?: number;
    /**
     * @generated from protobuf field: optional uint32 error_detail = 4
     */
    errorDetail?: number;
    /**
     * @generated from protobuf field: optional bytes merge_guid = 5
     */
    mergeGuid?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 download_file_dfs_ip = 6
     */
    downloadFileDfsIp?: number;
    /**
     * @generated from protobuf field: optional uint32 download_file_dfs_port = 7
     */
    downloadFileDfsPort?: number;
    /**
     * @generated from protobuf field: optional string download_file_url = 8
     */
    downloadFileUrl?: string;
}
/**
 * @generated from protobuf message CMsgFSEnumerateFollowingList
 */
export interface CMsgFSEnumerateFollowingList {
    /**
     * @generated from protobuf field: optional uint32 start_index = 1
     */
    startIndex?: number;
}
/**
 * @generated from protobuf message CMsgFSEnumerateFollowingListResponse
 */
export interface CMsgFSEnumerateFollowingListResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 total_results = 2
     */
    totalResults?: number;
    /**
     * @generated from protobuf field: repeated fixed64 steam_ids = 3
     */
    steamIds: bigint[];
}
/**
 * @generated from protobuf message CMsgFSGetFollowerCount
 */
export interface CMsgFSGetFollowerCount {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
}
/**
 * @generated from protobuf message CMsgFSGetFollowerCountResponse
 */
export interface CMsgFSGetFollowerCountResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 count = 2 [default = 0]
     */
    count?: number;
}
/**
 * @generated from protobuf message CMsgFSGetIsFollowing
 */
export interface CMsgFSGetIsFollowing {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
}
/**
 * @generated from protobuf message CMsgFSGetIsFollowingResponse
 */
export interface CMsgFSGetIsFollowingResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional bool is_following = 2 [default = false]
     */
    isFollowing?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgGameAction
 */
export interface CMsgGameAction {
    /**
     * @generated from protobuf field: optional string key = 1
     */
    key?: string;
    /**
     * @generated from protobuf field: optional string display_name = 2
     */
    displayName?: string;
    /**
     * @generated from protobuf field: repeated int32 modes = 3
     */
    modes: number[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgGameActionBindingType
 */
export interface CMsgGameActionBindingType {
    /**
     * @generated from protobuf field: optional int32 key = 1
     */
    key?: number;
    /**
     * @generated from protobuf field: repeated CMsgGameAction actions = 2
     */
    actions: CMsgGameAction[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgGameActionSet
 */
export interface CMsgGameActionSet {
    /**
     * @generated from protobuf field: optional string key = 1
     */
    key?: string;
    /**
     * @generated from protobuf field: optional string display_name = 2
     */
    displayName?: string;
    /**
     * @generated from protobuf field: optional bool legacy_set = 3
     */
    legacySet?: boolean;
    /**
     * @generated from protobuf field: repeated CMsgGameActionSet layers = 4
     */
    layers: CMsgGameActionSet[];
    /**
     * @generated from protobuf field: repeated CMsgGameActionBindingType action_binding_types = 5
     */
    actionBindingTypes: CMsgGameActionBindingType[];
    /**
     * @generated from protobuf field: repeated CMsgControllerSources source_bindings = 6
     */
    sourceBindings: CMsgControllerSources[];
}
/**
 * @generated from protobuf message CMsgGameServerData
 */
export interface CMsgGameServerData {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_gs = 1
     */
    steamIdGs?: bigint;
    /**
     * @generated from protobuf field: optional uint32 deprecated_ip = 2
     */
    deprecatedIp?: number;
    /**
     * @generated from protobuf field: optional uint32 query_port = 3
     */
    queryPort?: number;
    /**
     * @generated from protobuf field: optional uint32 game_port = 4
     */
    gamePort?: number;
    /**
     * @generated from protobuf field: optional uint32 sourcetv_port = 5
     */
    sourcetvPort?: number;
    /**
     * @generated from protobuf field: optional uint32 app_id = 6
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string gamedir = 7
     */
    gamedir?: string;
    /**
     * @generated from protobuf field: optional string version = 8
     */
    version?: string;
    /**
     * @generated from protobuf field: optional string product = 9
     */
    product?: string;
    /**
     * @generated from protobuf field: optional string region = 10
     */
    region?: string;
    /**
     * @generated from protobuf field: repeated CMsgGameServerData_Player players = 11
     */
    players: CMsgGameServerData_Player[];
    /**
     * @generated from protobuf field: optional uint32 max_players = 12
     */
    maxPlayers?: number;
    /**
     * @generated from protobuf field: optional uint32 bot_count = 13
     */
    botCount?: number;
    /**
     * @generated from protobuf field: optional bool password = 14
     */
    password?: boolean;
    /**
     * @generated from protobuf field: optional bool secure = 15
     */
    secure?: boolean;
    /**
     * @generated from protobuf field: optional bool dedicated = 16
     */
    dedicated?: boolean;
    /**
     * @generated from protobuf field: optional string os = 17
     */
    os?: string;
    /**
     * @generated from protobuf field: optional string game_data = 18
     */
    gameData?: string;
    /**
     * @generated from protobuf field: optional uint32 game_data_version = 19
     */
    gameDataVersion?: number;
    /**
     * @generated from protobuf field: optional string game_type = 20
     */
    gameType?: string;
    /**
     * @generated from protobuf field: optional string map = 21
     */
    map?: string;
    /**
     * @generated from protobuf field: optional string name = 22
     */
    name?: string;
    /**
     * @generated from protobuf field: optional CMsgIPAddress game_ip_address = 23
     */
    gameIpAddress?: CMsgIPAddress;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgGameServerData_Player
 */
export interface CMsgGameServerData_Player {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
}
/**
 * @generated from protobuf message CMsgGameServerOutOfDate
 */
export interface CMsgGameServerOutOfDate {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_gs = 1
     */
    steamIdGs?: bigint;
    /**
     * @generated from protobuf field: optional bool reject = 2
     */
    reject?: boolean;
    /**
     * @generated from protobuf field: optional string message = 3
     */
    message?: string;
}
/**
 * @generated from protobuf message CMsgGameServerPingSample
 */
export interface CMsgGameServerPingSample {
    /**
     * @generated from protobuf field: optional fixed32 my_ip = 1
     */
    myIp?: number;
    /**
     * @generated from protobuf field: optional int32 gs_app_id = 2
     */
    gsAppId?: number;
    /**
     * @generated from protobuf field: repeated CMsgGameServerPingSample_Sample gs_samples = 3
     */
    gsSamples: CMsgGameServerPingSample_Sample[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgGameServerPingSample_Sample
 */
export interface CMsgGameServerPingSample_Sample {
    /**
     * @generated from protobuf field: optional fixed32 ip = 1
     */
    ip?: number;
    /**
     * @generated from protobuf field: optional uint32 avg_ping_ms = 2
     */
    avgPingMs?: number;
    /**
     * @generated from protobuf field: optional uint32 stddev_ping_ms_x10 = 3
     */
    stddevPingMsX10?: number;
}
/**
 * @generated from protobuf message CMsgGameServerRemove
 */
export interface CMsgGameServerRemove {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 deprecated_ip = 2
     */
    deprecatedIp?: number;
    /**
     * @generated from protobuf field: optional uint32 query_port = 3
     */
    queryPort?: number;
    /**
     * @generated from protobuf field: optional CMsgIPAddress ip = 4
     */
    ip?: CMsgIPAddress;
}
/**
 * @generated from protobuf message CMsgGCClient
 */
export interface CMsgGCClient {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 msgtype = 2
     */
    msgtype?: number;
    /**
     * @generated from protobuf field: optional bytes payload = 3
     */
    payload?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 steamid = 4
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string gcname = 5
     */
    gcname?: string;
    /**
     * @generated from protobuf field: optional uint32 ip = 6
     */
    ip?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgGCRoutingProtoBufHeader
 */
export interface CMsgGCRoutingProtoBufHeader {
    /**
     * @generated from protobuf field: optional uint64 dst_gcid_queue = 1
     */
    dstGcidQueue?: bigint;
    /**
     * @generated from protobuf field: optional uint32 dst_gc_dir_index = 2
     */
    dstGcDirIndex?: number;
}
/**
 * @generated from protobuf message CMsgGenerateSystemReportReply
 */
export interface CMsgGenerateSystemReportReply {
    /**
     * @generated from protobuf field: optional string report_id = 1
     */
    reportId?: string;
}
/**
 * @generated from protobuf message CMsgGMSClientServerQueryResponse
 */
export interface CMsgGMSClientServerQueryResponse {
    /**
     * @generated from protobuf field: repeated CMsgGMSClientServerQueryResponse_Server servers = 1
     */
    servers: CMsgGMSClientServerQueryResponse_Server[];
    /**
     * @generated from protobuf field: optional string error = 2
     */
    error?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgGMSClientServerQueryResponse_Server
 */
export interface CMsgGMSClientServerQueryResponse_Server {
    /**
     * @generated from protobuf field: optional uint32 deprecated_server_ip = 1
     */
    deprecatedServerIp?: number;
    /**
     * @generated from protobuf field: optional uint32 server_port = 2
     */
    serverPort?: number;
    /**
     * @generated from protobuf field: optional uint32 auth_players = 3
     */
    authPlayers?: number;
    /**
     * @generated from protobuf field: optional CMsgIPAddress server_ip = 4
     */
    serverIp?: CMsgIPAddress;
}
/**
 * @generated from protobuf message CMsgGSApprove
 */
export interface CMsgGSApprove {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 owner_steam_id = 2
     */
    ownerSteamId?: bigint;
}
/**
 * @generated from protobuf message CMsgGSAssociateWithClan
 */
export interface CMsgGSAssociateWithClan {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_clan = 1
     */
    steamIdClan?: bigint;
}
/**
 * @generated from protobuf message CMsgGSAssociateWithClanResponse
 */
export interface CMsgGSAssociateWithClanResponse {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_clan = 1
     */
    steamIdClan?: bigint;
    /**
     * @generated from protobuf field: optional uint32 eresult = 2 [default = 2]
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgGSComputeNewPlayerCompatibility
 */
export interface CMsgGSComputeNewPlayerCompatibility {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_candidate = 1
     */
    steamIdCandidate?: bigint;
}
/**
 * @generated from protobuf message CMsgGSComputeNewPlayerCompatibilityResponse
 */
export interface CMsgGSComputeNewPlayerCompatibilityResponse {
    /**
     * @generated from protobuf field: optional fixed64 steam_id_candidate = 1
     */
    steamIdCandidate?: bigint;
    /**
     * @generated from protobuf field: optional uint32 eresult = 2 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional bool is_clan_member = 3
     */
    isClanMember?: boolean;
    /**
     * @generated from protobuf field: optional int32 ct_dont_like_you = 4
     */
    ctDontLikeYou?: number;
    /**
     * @generated from protobuf field: optional int32 ct_you_dont_like = 5
     */
    ctYouDontLike?: number;
    /**
     * @generated from protobuf field: optional int32 ct_clanmembers_dont_like_you = 6
     */
    ctClanmembersDontLikeYou?: number;
}
/**
 * @generated from protobuf message CMsgGSDeny
 */
export interface CMsgGSDeny {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional int32 edeny_reason = 2
     */
    edenyReason?: number;
    /**
     * @generated from protobuf field: optional string deny_string = 3
     */
    denyString?: string;
}
/**
 * @generated from protobuf message CMsgGSDisconnectNotice
 */
export interface CMsgGSDisconnectNotice {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
}
/**
 * @generated from protobuf message CMsgGSKick
 */
export interface CMsgGSKick {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional int32 edeny_reason = 2
     */
    edenyReason?: number;
}
/**
 * @generated from protobuf message CMsgGSPlayerList
 */
export interface CMsgGSPlayerList {
    /**
     * @generated from protobuf field: repeated CMsgGSPlayerList_Player players = 1
     */
    players: CMsgGSPlayerList_Player[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgGSPlayerList_Player
 */
export interface CMsgGSPlayerList_Player {
    /**
     * @generated from protobuf field: optional uint64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 deprecated_public_ip = 2
     */
    deprecatedPublicIp?: number;
    /**
     * @generated from protobuf field: optional bytes token = 3
     */
    token?: Uint8Array;
    /**
     * @generated from protobuf field: optional CMsgIPAddress public_ip = 4
     */
    publicIp?: CMsgIPAddress;
}
/**
 * @generated from protobuf message CMsgGSServerType
 */
export interface CMsgGSServerType {
    /**
     * @generated from protobuf field: optional uint32 app_id_served = 1
     */
    appIdServed?: number;
    /**
     * @generated from protobuf field: optional uint32 flags = 2
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional uint32 deprecated_game_ip_address = 3
     */
    deprecatedGameIpAddress?: number;
    /**
     * @generated from protobuf field: optional uint32 game_port = 4
     */
    gamePort?: number;
    /**
     * @generated from protobuf field: optional string game_dir = 5
     */
    gameDir?: string;
    /**
     * @generated from protobuf field: optional string game_version = 6
     */
    gameVersion?: string;
    /**
     * @generated from protobuf field: optional uint32 game_query_port = 7
     */
    gameQueryPort?: number;
}
/**
 * @generated from protobuf message CMsgGSStatusReply
 */
export interface CMsgGSStatusReply {
    /**
     * @generated from protobuf field: optional bool is_secure = 1
     */
    isSecure?: boolean;
}
/**
 * @generated from protobuf message CMsgGSUserPlaying
 */
export interface CMsgGSUserPlaying {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 deprecated_public_ip = 2
     */
    deprecatedPublicIp?: number;
    /**
     * @generated from protobuf field: optional bytes token = 3
     */
    token?: Uint8Array;
    /**
     * @generated from protobuf field: optional CMsgIPAddress public_ip = 4
     */
    publicIp?: CMsgIPAddress;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgHotkey
 */
export interface CMsgHotkey {
    /**
     * @generated from protobuf field: optional uint32 key_code = 1
     */
    keyCode?: number;
    /**
     * @generated from protobuf field: optional bool alt_key = 2
     */
    altKey?: boolean;
    /**
     * @generated from protobuf field: optional bool shift_key = 3
     */
    shiftKey?: boolean;
    /**
     * @generated from protobuf field: optional bool ctrl_key = 4
     */
    ctrlKey?: boolean;
    /**
     * @generated from protobuf field: optional bool meta_key = 5
     */
    metaKey?: boolean;
    /**
     * @generated from protobuf field: optional string display_name = 6
     */
    displayName?: string;
}
/**
 * Used by: Authentication, AuthenticationSupport, Community, common.proto
 *
 * @generated from protobuf message CMsgIPAddress
 */
export interface CMsgIPAddress {
    /**
     * @generated from protobuf field: optional fixed32 v4 = 1
     */
    v4?: number;
    /**
     * @generated from protobuf field: optional bytes v6 = 2
     */
    v6?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgIPAddressBucket
 */
export interface CMsgIPAddressBucket {
    /**
     * @generated from protobuf field: optional CMsgIPAddress original_ip_address = 1
     */
    originalIpAddress?: CMsgIPAddress;
    /**
     * @generated from protobuf field: optional fixed64 bucket = 2
     */
    bucket?: bigint;
}
/**
 * @generated from protobuf message CMsgMobileChatFriendMessage
 */
export interface CMsgMobileChatFriendMessage {
    /**
     * @generated from protobuf field: optional fixed64 steamid_friend = 1
     */
    steamidFriend?: bigint;
    /**
     * @generated from protobuf field: optional bool local_echo = 2
     */
    localEcho?: boolean;
    /**
     * @generated from protobuf field: optional int32 chat_entry_type = 3
     */
    chatEntryType?: number;
    /**
     * @generated from protobuf field: optional string message = 4
     */
    message?: string;
    /**
     * @generated from protobuf field: optional fixed32 current_message_timestamp = 5
     */
    currentMessageTimestamp?: number;
    /**
     * @generated from protobuf field: optional fixed32 current_message_ordinal = 6
     */
    currentMessageOrdinal?: number;
    /**
     * @generated from protobuf field: optional fixed32 previous_message_timestamp = 7
     */
    previousMessageTimestamp?: number;
    /**
     * @generated from protobuf field: optional fixed32 previous_message_ordinal = 8
     */
    previousMessageOrdinal?: number;
    /**
     * @generated from protobuf field: optional string client_message_id = 9
     */
    clientMessageId?: string;
}
/**
 * @generated from protobuf message CMsgMonitorInfo
 */
export interface CMsgMonitorInfo {
    /**
     * @generated from protobuf field: optional string selected_display_name = 1
     */
    selectedDisplayName?: string;
    /**
     * @generated from protobuf field: repeated CMsgMonitorInfo_MonitorInfo monitors = 2
     */
    monitors: CMsgMonitorInfo_MonitorInfo[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgMonitorInfo_MonitorInfo
 */
export interface CMsgMonitorInfo_MonitorInfo {
    /**
     * @generated from protobuf field: optional string monitor_device_name = 1
     */
    monitorDeviceName?: string;
    /**
     * @generated from protobuf field: optional string monitor_display_name = 2
     */
    monitorDisplayName?: string;
}
/**
 * @generated from protobuf message CMsgMulti
 */
export interface CMsgMulti {
    /**
     * @generated from protobuf field: optional uint32 size_unzipped = 1
     */
    sizeUnzipped?: number;
    /**
     * @generated from protobuf field: optional bytes message_body = 2
     */
    messageBody?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgNetworkDeviceConnect
 */
export interface CMsgNetworkDeviceConnect {
    /**
     * @generated from protobuf field: optional uint32 device_id = 1 [default = 0]
     */
    deviceId?: number;
    /**
     * @generated from protobuf field: optional CMsgNetworkDeviceConnect_KnownAP ap_known = 2
     */
    apKnown?: CMsgNetworkDeviceConnect_KnownAP;
    /**
     * @generated from protobuf field: optional CMsgNetworkDeviceConnect_CustomAP ap_custom = 3
     */
    apCustom?: CMsgNetworkDeviceConnect_CustomAP;
    /**
     * @generated from protobuf field: optional CMsgNetworkDeviceConnect_Credentials credentials = 4
     */
    credentials?: CMsgNetworkDeviceConnect_Credentials;
    /**
     * @generated from protobuf field: optional CMsgNetworkDeviceIP4Config ip4 = 5
     */
    ip4?: CMsgNetworkDeviceIP4Config;
    /**
     * @generated from protobuf field: optional CMsgNetworkDeviceIP6Config ip6 = 6
     */
    ip6?: CMsgNetworkDeviceIP6Config;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDeviceConnect_Credentials
 */
export interface CMsgNetworkDeviceConnect_Credentials {
    /**
     * @generated from protobuf field: optional string username = 1
     */
    username?: string;
    /**
     * @generated from protobuf field: optional string password = 2
     */
    password?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDeviceConnect_CustomAP
 */
export interface CMsgNetworkDeviceConnect_CustomAP {
    /**
     * @generated from protobuf field: optional string ssid = 1
     */
    ssid?: string;
    /**
     * @generated from protobuf field: optional int32 esecurity = 2
     */
    esecurity?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDeviceConnect_KnownAP
 */
export interface CMsgNetworkDeviceConnect_KnownAP {
    /**
     * @generated from protobuf field: optional uint32 ap_id = 1
     */
    apId?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDeviceIP4Address
 */
export interface CMsgNetworkDeviceIP4Address {
    /**
     * @generated from protobuf field: optional int32 ip = 1 [default = 0]
     */
    ip?: number;
    /**
     * @generated from protobuf field: optional int32 netmask = 2
     */
    netmask?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDeviceIP4Config
 */
export interface CMsgNetworkDeviceIP4Config {
    /**
     * @generated from protobuf field: repeated CMsgNetworkDeviceIP4Address addresses = 1
     */
    addresses: CMsgNetworkDeviceIP4Address[];
    /**
     * @generated from protobuf field: repeated int32 dns_ip = 2
     */
    dnsIp: number[];
    /**
     * @generated from protobuf field: optional int32 gateway_ip = 3
     */
    gatewayIp?: number;
    /**
     * @generated from protobuf field: optional bool is_dhcp_enabled = 4
     */
    isDhcpEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_default_route = 5
     */
    isDefaultRoute?: boolean;
    /**
     * @generated from protobuf field: optional bool is_enabled = 6 [default = false]
     */
    isEnabled?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDeviceIP6Address
 */
export interface CMsgNetworkDeviceIP6Address {
    /**
     * @generated from protobuf field: optional string ip = 1 [default = ""]
     */
    ip?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDeviceIP6Config
 */
export interface CMsgNetworkDeviceIP6Config {
    /**
     * @generated from protobuf field: repeated CMsgNetworkDeviceIP6Address addresses = 1
     */
    addresses: CMsgNetworkDeviceIP6Address[];
    /**
     * @generated from protobuf field: repeated string dns_ip = 2
     */
    dnsIp: string[];
    /**
     * @generated from protobuf field: optional string gateway_ip = 3
     */
    gatewayIp?: string;
    /**
     * @generated from protobuf field: optional bool is_dhcp_enabled = 4
     */
    isDhcpEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_default_route = 5
     */
    isDefaultRoute?: boolean;
    /**
     * @generated from protobuf field: optional bool is_enabled = 6 [default = false]
     */
    isEnabled?: boolean;
}
/**
 * @generated from protobuf message CMsgNetworkDevicesData
 */
export interface CMsgNetworkDevicesData {
    /**
     * @generated from protobuf field: repeated CMsgNetworkDevicesData_Device devices = 1
     */
    devices: CMsgNetworkDevicesData_Device[];
    /**
     * @generated from protobuf field: optional bool is_wifi_enabled = 2
     */
    isWifiEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_wifi_scanning_enabled = 3
     */
    isWifiScanningEnabled?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDevicesData_Device
 */
export interface CMsgNetworkDevicesData_Device {
    /**
     * @generated from protobuf field: optional uint32 id = 1 [default = 0]
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 etype = 2
     */
    etype?: number;
    /**
     * @generated from protobuf field: optional int32 estate = 3
     */
    estate?: number;
    /**
     * @generated from protobuf field: optional string mac = 4
     */
    mac?: string;
    /**
     * @generated from protobuf field: optional string vendor = 5
     */
    vendor?: string;
    /**
     * @generated from protobuf field: optional string product = 6
     */
    product?: string;
    /**
     * @generated from protobuf field: optional CMsgNetworkDeviceIP4Config ip4 = 7
     */
    ip4?: CMsgNetworkDeviceIP4Config;
    /**
     * @generated from protobuf field: optional CMsgNetworkDeviceIP6Config ip6 = 8
     */
    ip6?: CMsgNetworkDeviceIP6Config;
    /**
     * @generated from protobuf field: optional CMsgNetworkDevicesData_Device_Wired wired = 9
     */
    wired?: CMsgNetworkDevicesData_Device_Wired;
    /**
     * @generated from protobuf field: optional CMsgNetworkDevicesData_Device_Wireless wireless = 10
     */
    wireless?: CMsgNetworkDevicesData_Device_Wireless;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDevicesData_Device_Wired
 */
export interface CMsgNetworkDevicesData_Device_Wired {
    /**
     * @generated from protobuf field: optional bool is_cable_present = 1 [default = false]
     */
    isCablePresent?: boolean;
    /**
     * @generated from protobuf field: optional uint32 speed_mbit = 2
     */
    speedMbit?: number;
    /**
     * @generated from protobuf field: optional string friendly_name = 3
     */
    friendlyName?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDevicesData_Device_Wireless
 */
export interface CMsgNetworkDevicesData_Device_Wireless {
    /**
     * @generated from protobuf field: repeated CMsgNetworkDevicesData_Device_Wireless_AP aps = 1
     */
    aps: CMsgNetworkDevicesData_Device_Wireless_AP[];
    /**
     * @generated from protobuf field: optional int32 esecurity_supported = 2
     */
    esecuritySupported?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgNetworkDevicesData_Device_Wireless_AP
 */
export interface CMsgNetworkDevicesData_Device_Wireless_AP {
    /**
     * @generated from protobuf field: optional uint32 id = 1 [default = 0]
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 estrength = 2
     */
    estrength?: number;
    /**
     * @generated from protobuf field: optional string ssid = 3
     */
    ssid?: string;
    /**
     * @generated from protobuf field: optional bool is_active = 4
     */
    isActive?: boolean;
    /**
     * @generated from protobuf field: optional bool is_autoconnect = 5
     */
    isAutoconnect?: boolean;
    /**
     * @generated from protobuf field: optional int32 esecurity = 6
     */
    esecurity?: number;
    /**
     * @generated from protobuf field: optional string user_name = 7
     */
    userName?: string;
    /**
     * @generated from protobuf field: optional string password = 8
     */
    password?: string;
    /**
     * @generated from protobuf field: optional int32 strength_raw = 9
     */
    strengthRaw?: number;
}
/**
 * @generated from protobuf message CMsgPersonaChangeResponse
 */
export interface CMsgPersonaChangeResponse {
    /**
     * @generated from protobuf field: optional uint32 result = 1
     */
    result?: number;
    /**
     * @generated from protobuf field: optional string player_name = 2
     */
    playerName?: string;
}
/**
 * @generated from protobuf message CMsgProtoBufHeader
 */
export interface CMsgProtoBufHeader {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional int32 client_sessionid = 2
     */
    clientSessionid?: number;
    /**
     * @generated from protobuf field: optional uint32 routing_appid = 3
     */
    routingAppid?: number;
    /**
     * @generated from protobuf field: optional fixed64 jobid_source = 10 [default = 18446744073709551615]
     */
    jobidSource?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 jobid_target = 11 [default = 18446744073709551615]
     */
    jobidTarget?: bigint;
    /**
     * @generated from protobuf field: optional string target_job_name = 12
     */
    targetJobName?: string;
    /**
     * @generated from protobuf field: optional int32 eresult = 13 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional string error_message = 14
     */
    errorMessage?: string;
    /**
     * @generated from protobuf field: optional uint32 ip = 15
     */
    ip?: number;
    /**
     * @generated from protobuf field: optional uint32 auth_account_flags = 16
     */
    authAccountFlags?: number;
    /**
     * @generated from protobuf field: optional int32 transport_error = 17 [default = 1]
     */
    transportError?: number;
    /**
     * @generated from protobuf field: optional uint64 messageid = 18 [default = 18446744073709551615]
     */
    messageid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 publisher_group_id = 19
     */
    publisherGroupId?: number;
    /**
     * @generated from protobuf field: optional uint32 sysid = 20
     */
    sysid?: number;
    /**
     * @generated from protobuf field: optional uint64 trace_tag = 21
     */
    traceTag?: bigint;
    /**
     * @generated from protobuf field: optional uint32 token_source = 22
     */
    tokenSource?: number;
    /**
     * @generated from protobuf field: optional bool admin_spoofing_user = 23
     */
    adminSpoofingUser?: boolean;
    /**
     * @generated from protobuf field: optional int32 seq_num = 24
     */
    seqNum?: number;
    /**
     * @generated from protobuf field: optional uint32 webapi_key_id = 25
     */
    webapiKeyId?: number;
    /**
     * @generated from protobuf field: optional bool is_from_external_source = 26
     */
    isFromExternalSource?: boolean;
    /**
     * @generated from protobuf field: repeated uint32 forward_to_sysid = 27
     */
    forwardToSysid: number[];
    /**
     * @generated from protobuf field: optional uint32 cm_sysid = 28
     */
    cmSysid?: number;
    /**
     * @generated from protobuf field: optional bytes ip_v6 = 29
     */
    ipV6?: Uint8Array;
    /**
     * @generated from protobuf field: optional string wg_token = 30
     */
    wgToken?: string;
    /**
     * @generated from protobuf field: optional uint32 launcher_type = 31 [default = 0]
     */
    launcherType?: number;
    /**
     * @generated from protobuf field: optional uint32 realm = 32 [default = 0]
     */
    realm?: number;
    /**
     * @generated from protobuf field: optional int32 timeout_ms = 33 [default = -1]
     */
    timeoutMs?: number;
    /**
     * @generated from protobuf field: optional string debug_source = 34
     */
    debugSource?: string;
    /**
     * @generated from protobuf field: optional uint32 debug_source_string_index = 35
     */
    debugSourceStringIndex?: number;
    /**
     * @generated from protobuf field: optional uint64 token_id = 36
     */
    tokenId?: bigint;
    /**
     * @generated from protobuf field: optional CMsgGCRoutingProtoBufHeader routing_gc = 37
     */
    routingGc?: CMsgGCRoutingProtoBufHeader;
    /**
     * @generated from protobuf field: optional int32 session_disposition = 38 [default = 0]
     */
    sessionDisposition?: number;
    /**
     * @generated from protobuf field: optional string wg_token__field_39 = 39
     */
    wgTokenField39?: string;
    /**
     * @generated from protobuf field: optional string webui_auth_key = 40
     */
    webuiAuthKey?: string;
    /**
     * @generated from protobuf field: repeated int32 exclude_client_sessionids = 41
     */
    excludeClientSessionids: number[];
    /**
     * @generated from protobuf field: optional fixed64 admin_request_spoofing_steamid = 43
     */
    adminRequestSpoofingSteamid?: bigint;
    /**
     * @generated from protobuf field: optional bool is_valveds = 44
     */
    isValveds?: boolean;
    /**
     * @generated from protobuf field: optional fixed64 trace_tag__field_45 = 45
     */
    traceTagField45?: bigint;
}
/**
 * @generated from protobuf message CMsgProtobufWrapped
 */
export interface CMsgProtobufWrapped {
    /**
     * @generated from protobuf field: optional bytes message_body = 1
     */
    messageBody?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSelectOSBranchParams
 */
export interface CMsgSelectOSBranchParams {
    /**
     * @generated from protobuf field: optional int32 branch = 1
     */
    branch?: number;
    /**
     * @generated from protobuf field: optional string custom_branch = 2
     */
    customBranch?: string;
}
/**
 * @generated from protobuf message CMsgSetControllerActionSet
 */
export interface CMsgSetControllerActionSet {
    /**
     * @generated from protobuf field: optional string action_set_key = 1
     */
    actionSetKey?: string;
    /**
     * @generated from protobuf field: optional string action_set_layer_key = 2
     */
    actionSetLayerKey?: string;
    /**
     * @generated from protobuf field: optional string new_display_name = 3
     */
    newDisplayName?: string;
    /**
     * @generated from protobuf field: optional string action_set_to_copy_key = 4
     */
    actionSetToCopyKey?: string;
}
/**
 * @generated from protobuf message CMsgSetControllerInputActivator
 */
export interface CMsgSetControllerInputActivator {
    /**
     * @generated from protobuf field: optional string action_set_key = 1
     */
    actionSetKey?: string;
    /**
     * @generated from protobuf field: optional string action_set_layer_key = 2
     */
    actionSetLayerKey?: string;
    /**
     * @generated from protobuf field: optional int32 source_binding_key = 3
     */
    sourceBindingKey?: number;
    /**
     * @generated from protobuf field: optional bool mode_shift = 4
     */
    modeShift?: boolean;
    /**
     * @generated from protobuf field: optional int32 input_key = 5
     */
    inputKey?: number;
    /**
     * @generated from protobuf field: optional int32 activator_index = 6
     */
    activatorIndex?: number;
    /**
     * @generated from protobuf field: optional int32 new_activation = 7
     */
    newActivation?: number;
    /**
     * @generated from protobuf field: optional CMsgControllerSetting new_setting = 8
     */
    newSetting?: CMsgControllerSetting;
    /**
     * @generated from protobuf field: optional int32 modeid = 9
     */
    modeid?: number;
}
/**
 * @generated from protobuf message CMsgSetControllerInputActivatorEnabled
 */
export interface CMsgSetControllerInputActivatorEnabled {
    /**
     * @generated from protobuf field: optional string action_set_key = 1
     */
    actionSetKey?: string;
    /**
     * @generated from protobuf field: optional string action_set_layer_key = 2
     */
    actionSetLayerKey?: string;
    /**
     * @generated from protobuf field: optional int32 source_binding_key = 3
     */
    sourceBindingKey?: number;
    /**
     * @generated from protobuf field: optional bool mode_shift = 4
     */
    modeShift?: boolean;
    /**
     * @generated from protobuf field: optional int32 input_key = 5
     */
    inputKey?: number;
    /**
     * @generated from protobuf field: optional int32 activator_index = 6
     */
    activatorIndex?: number;
    /**
     * @generated from protobuf field: optional bool enabled = 7
     */
    enabled?: boolean;
    /**
     * @generated from protobuf field: optional int32 modeid = 8
     */
    modeid?: number;
}
/**
 * @generated from protobuf message CMsgSetControllerInputBinding
 */
export interface CMsgSetControllerInputBinding {
    /**
     * @generated from protobuf field: optional string action_set_key = 1
     */
    actionSetKey?: string;
    /**
     * @generated from protobuf field: optional string action_set_layer_key = 2
     */
    actionSetLayerKey?: string;
    /**
     * @generated from protobuf field: optional int32 source_binding_key = 3
     */
    sourceBindingKey?: number;
    /**
     * @generated from protobuf field: optional bool mode_shift = 4
     */
    modeShift?: boolean;
    /**
     * @generated from protobuf field: optional int32 input_key = 5
     */
    inputKey?: number;
    /**
     * @generated from protobuf field: optional int32 activator_index = 6
     */
    activatorIndex?: number;
    /**
     * @generated from protobuf field: optional int32 binding_index = 7
     */
    bindingIndex?: number;
    /**
     * @generated from protobuf field: optional CMsgControllerInputBinding new_binding = 8
     */
    newBinding?: CMsgControllerInputBinding;
    /**
     * @generated from protobuf field: optional int32 source_mode = 9
     */
    sourceMode?: number;
    /**
     * @generated from protobuf field: optional int32 modeid = 10
     */
    modeid?: number;
}
/**
 * @generated from protobuf message CMsgSetControllerSourceMode
 */
export interface CMsgSetControllerSourceMode {
    /**
     * @generated from protobuf field: optional string action_set_key = 1
     */
    actionSetKey?: string;
    /**
     * @generated from protobuf field: optional string action_set_layer_key = 2
     */
    actionSetLayerKey?: string;
    /**
     * @generated from protobuf field: optional int32 source_binding_key = 3
     */
    sourceBindingKey?: number;
    /**
     * @generated from protobuf field: optional bool mode_shift = 4
     */
    modeShift?: boolean;
    /**
     * @generated from protobuf field: optional int32 new_mode = 5
     */
    newMode?: number;
    /**
     * @generated from protobuf field: optional CMsgControllerInputGameActionBinding new_game_action = 6
     */
    newGameAction?: CMsgControllerInputGameActionBinding;
    /**
     * @generated from protobuf field: optional CMsgControllerSetting new_setting = 7
     */
    newSetting?: CMsgControllerSetting;
    /**
     * @generated from protobuf field: optional string new_name = 8
     */
    newName?: string;
    /**
     * @generated from protobuf field: optional uint32 modeid = 9
     */
    modeid?: number;
    /**
     * @generated from protobuf field: optional bool change_mode = 10
     */
    changeMode?: boolean;
    /**
     * @generated from protobuf field: optional bool new_virtual_menu = 11
     */
    newVirtualMenu?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_virtual_menu_support = 12
     */
    enableVirtualMenuSupport?: boolean;
}
/**
 * @generated from protobuf message CMsgSetModeShiftButton
 */
export interface CMsgSetModeShiftButton {
    /**
     * @generated from protobuf field: optional string action_set_key = 1
     */
    actionSetKey?: string;
    /**
     * @generated from protobuf field: optional string action_set_layer_key = 2
     */
    actionSetLayerKey?: string;
    /**
     * @generated from protobuf field: optional int32 modeid = 3
     */
    modeid?: number;
    /**
     * @generated from protobuf field: optional int32 source = 4
     */
    source?: number;
    /**
     * @generated from protobuf field: repeated int32 mode_shift_buttons_digital_io = 5
     */
    modeShiftButtonsDigitalIo: number[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSteamDatagramConnectionQuality
 */
export interface CMsgSteamDatagramConnectionQuality {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramLinkInstantaneousStats instantaneous = 1
     */
    instantaneous?: CMsgSteamDatagramLinkInstantaneousStats;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramLinkLifetimeStats lifetime = 2
     */
    lifetime?: CMsgSteamDatagramLinkLifetimeStats;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSteamDatagramLinkInstantaneousStats
 */
export interface CMsgSteamDatagramLinkInstantaneousStats {
    /**
     * @generated from protobuf field: optional uint32 out_packets_per_sec_x10 = 1
     */
    outPacketsPerSecX10?: number;
    /**
     * @generated from protobuf field: optional uint32 out_bytes_per_sec = 2
     */
    outBytesPerSec?: number;
    /**
     * @generated from protobuf field: optional uint32 in_packets_per_sec_x10 = 3
     */
    inPacketsPerSecX10?: number;
    /**
     * @generated from protobuf field: optional uint32 in_bytes_per_sec = 4
     */
    inBytesPerSec?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ms = 5
     */
    pingMs?: number;
    /**
     * @generated from protobuf field: optional uint32 packets_dropped_pct = 6
     */
    packetsDroppedPct?: number;
    /**
     * @generated from protobuf field: optional uint32 packets_weird_sequence_pct = 7
     */
    packetsWeirdSequencePct?: number;
    /**
     * @generated from protobuf field: optional uint32 peak_jitter_usec = 8
     */
    peakJitterUsec?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSteamDatagramLinkLifetimeStats
 */
export interface CMsgSteamDatagramLinkLifetimeStats {
    /**
     * @generated from protobuf field: optional uint32 connected_seconds = 2
     */
    connectedSeconds?: number;
    /**
     * @generated from protobuf field: optional uint64 packets_sent = 3
     */
    packetsSent?: bigint;
    /**
     * @generated from protobuf field: optional uint64 kb_sent = 4
     */
    kbSent?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv = 5
     */
    packetsRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 kb_recv = 6
     */
    kbRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_sequenced = 7
     */
    packetsRecvSequenced?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_dropped = 8
     */
    packetsRecvDropped?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_out_of_order = 9
     */
    packetsRecvOutOfOrder?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_duplicate = 10
     */
    packetsRecvDuplicate?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_lurch = 11
     */
    packetsRecvLurch?: bigint;
    /**
     * @generated from protobuf field: repeated uint64 multipath_packets_recv_sequenced = 12
     */
    multipathPacketsRecvSequenced: bigint[];
    /**
     * @generated from protobuf field: repeated uint64 multipath_packets_recv_later = 13
     */
    multipathPacketsRecvLater: bigint[];
    /**
     * @generated from protobuf field: optional uint32 multipath_send_enabled = 14
     */
    multipathSendEnabled?: number;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_out_of_order_corrected = 15
     */
    packetsRecvOutOfOrderCorrected?: bigint;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_100 = 21
     */
    qualityHistogram100?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_99 = 22
     */
    qualityHistogram99?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_97 = 23
     */
    qualityHistogram97?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_95 = 24
     */
    qualityHistogram95?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_90 = 25
     */
    qualityHistogram90?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_75 = 26
     */
    qualityHistogram75?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_50 = 27
     */
    qualityHistogram50?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_1 = 28
     */
    qualityHistogram1?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_dead = 29
     */
    qualityHistogramDead?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_ntile_2nd = 30
     */
    qualityNtile2Nd?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_ntile_5th = 31
     */
    qualityNtile5Th?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_ntile_25th = 32
     */
    qualityNtile25Th?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_ntile_50th = 33
     */
    qualityNtile50Th?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_25 = 41
     */
    pingHistogram25?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_50 = 42
     */
    pingHistogram50?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_75 = 43
     */
    pingHistogram75?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_100 = 44
     */
    pingHistogram100?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_125 = 45
     */
    pingHistogram125?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_150 = 46
     */
    pingHistogram150?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_200 = 47
     */
    pingHistogram200?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_300 = 48
     */
    pingHistogram300?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_max = 49
     */
    pingHistogramMax?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ntile_5th = 50
     */
    pingNtile5Th?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ntile_50th = 51
     */
    pingNtile50Th?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ntile_75th = 52
     */
    pingNtile75Th?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ntile_95th = 53
     */
    pingNtile95Th?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ntile_98th = 54
     */
    pingNtile98Th?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_negligible = 61
     */
    jitterHistogramNegligible?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_1 = 62
     */
    jitterHistogram1?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_2 = 63
     */
    jitterHistogram2?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_5 = 64
     */
    jitterHistogram5?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_10 = 65
     */
    jitterHistogram10?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_20 = 66
     */
    jitterHistogram20?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSteamDatagramP2PRoutingSummary
 */
export interface CMsgSteamDatagramP2PRoutingSummary {
    /**
     * @generated from protobuf field: optional CMsgSteamNetworkingICESessionSummary ice = 2
     */
    ice?: CMsgSteamNetworkingICESessionSummary;
    /**
     * @generated from protobuf field: optional CMsgSteamNetworkingP2PSDRRoutingSummary sdr = 3
     */
    sdr?: CMsgSteamNetworkingP2PSDRRoutingSummary;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSteamNetworkingICESessionSummary
 */
export interface CMsgSteamNetworkingICESessionSummary {
    /**
     * @generated from protobuf field: optional uint32 local_candidate_types = 1
     */
    localCandidateTypes?: number;
    /**
     * @generated from protobuf field: optional uint32 remote_candidate_types = 2
     */
    remoteCandidateTypes?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_route_kind = 3
     */
    initialRouteKind?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_ping = 4
     */
    initialPing?: number;
    /**
     * @generated from protobuf field: optional uint32 negotiation_ms = 5
     */
    negotiationMs?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_score = 6
     */
    initialScore?: number;
    /**
     * @generated from protobuf field: optional uint32 failure_reason_code = 7
     */
    failureReasonCode?: number;
    /**
     * @generated from protobuf field: optional uint32 selected_seconds = 12
     */
    selectedSeconds?: number;
    /**
     * @generated from protobuf field: optional uint32 user_settings = 13
     */
    userSettings?: number;
    /**
     * @generated from protobuf field: optional uint32 ice_enable_var = 14
     */
    iceEnableVar?: number;
    /**
     * @generated from protobuf field: optional uint32 local_candidate_types_allowed = 15
     */
    localCandidateTypesAllowed?: number;
    /**
     * @generated from protobuf field: optional uint32 best_route_kind = 16
     */
    bestRouteKind?: number;
    /**
     * @generated from protobuf field: optional uint32 best_ping = 17
     */
    bestPing?: number;
    /**
     * @generated from protobuf field: optional uint32 best_score = 18
     */
    bestScore?: number;
    /**
     * @generated from protobuf field: optional uint32 best_time = 19
     */
    bestTime?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSteamNetworkingP2PSDRRoutingSummary
 */
export interface CMsgSteamNetworkingP2PSDRRoutingSummary {
    /**
     * @generated from protobuf field: optional uint32 initial_ping = 1
     */
    initialPing?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_ping_front_local = 2
     */
    initialPingFrontLocal?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_ping_front_remote = 3
     */
    initialPingFrontRemote?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_score = 4
     */
    initialScore?: number;
    /**
     * @generated from protobuf field: optional fixed32 initial_pop_local = 5
     */
    initialPopLocal?: number;
    /**
     * @generated from protobuf field: optional fixed32 initial_pop_remote = 6
     */
    initialPopRemote?: number;
    /**
     * @generated from protobuf field: optional uint32 negotiation_ms = 7
     */
    negotiationMs?: number;
    /**
     * @generated from protobuf field: optional uint32 selected_seconds = 8
     */
    selectedSeconds?: number;
    /**
     * @generated from protobuf field: optional uint32 best_ping = 11
     */
    bestPing?: number;
    /**
     * @generated from protobuf field: optional uint32 best_ping_front_local = 12
     */
    bestPingFrontLocal?: number;
    /**
     * @generated from protobuf field: optional uint32 best_ping_front_remote = 13
     */
    bestPingFrontRemote?: number;
    /**
     * @generated from protobuf field: optional uint32 best_score = 14
     */
    bestScore?: number;
    /**
     * @generated from protobuf field: optional fixed32 best_pop_local = 15
     */
    bestPopLocal?: number;
    /**
     * @generated from protobuf field: optional fixed32 best_pop_remote = 16
     */
    bestPopRemote?: number;
    /**
     * @generated from protobuf field: optional uint32 best_time = 17
     */
    bestTime?: number;
}
/**
 * @generated from protobuf message CMsgSwapControllerSourceModes
 */
export interface CMsgSwapControllerSourceModes {
    /**
     * @generated from protobuf field: optional string action_set_key_a = 1
     */
    actionSetKeyA?: string;
    /**
     * @generated from protobuf field: optional string action_set_layer_key_a = 2
     */
    actionSetLayerKeyA?: string;
    /**
     * @generated from protobuf field: optional int32 source_a = 3
     */
    sourceA?: number;
    /**
     * @generated from protobuf field: optional string action_set_key_b = 4
     */
    actionSetKeyB?: string;
    /**
     * @generated from protobuf field: optional string action_set_layer_key_b = 5
     */
    actionSetLayerKeyB?: string;
    /**
     * @generated from protobuf field: optional int32 source_b = 6
     */
    sourceB?: number;
}
/**
 * @generated from protobuf message CMsgSwapModeInputBindings
 */
export interface CMsgSwapModeInputBindings {
    /**
     * @generated from protobuf field: optional string action_set_key = 1
     */
    actionSetKey?: string;
    /**
     * @generated from protobuf field: optional string action_set_layer_key = 2
     */
    actionSetLayerKey?: string;
    /**
     * @generated from protobuf field: optional int32 source_binding_key = 3
     */
    sourceBindingKey?: number;
    /**
     * @generated from protobuf field: optional bool mode_shift = 4
     */
    modeShift?: boolean;
    /**
     * @generated from protobuf field: optional int32 modeid = 5
     */
    modeid?: number;
    /**
     * @generated from protobuf field: repeated CMsgSwapModeInputBindings_CModeInputSwap swaps = 6
     */
    swaps: CMsgSwapModeInputBindings_CModeInputSwap[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSwapModeInputBindings_CModeInputSwap
 */
export interface CMsgSwapModeInputBindings_CModeInputSwap {
    /**
     * @generated from protobuf field: optional int32 old_key = 1
     */
    oldKey?: number;
    /**
     * @generated from protobuf field: optional int32 new_key = 2
     */
    newKey?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemAudioManagerDevice
 */
export interface CMsgSystemAudioManagerDevice {
    /**
     * @generated from protobuf field: optional CMsgSystemAudioManagerObject base = 1
     */
    base?: CMsgSystemAudioManagerObject;
    /**
     * @generated from protobuf field: optional string name = 2
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string nick = 3
     */
    nick?: string;
    /**
     * @generated from protobuf field: optional string description = 4
     */
    description?: string;
    /**
     * @generated from protobuf field: optional string api = 5
     */
    api?: string;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemAudioManagerLink
 */
export interface CMsgSystemAudioManagerLink {
    /**
     * @generated from protobuf field: optional CMsgSystemAudioManagerObject base = 1
     */
    base?: CMsgSystemAudioManagerObject;
    /**
     * @generated from protobuf field: optional uint32 output_node_id = 2
     */
    outputNodeId?: number;
    /**
     * @generated from protobuf field: optional uint32 output_port_id = 3
     */
    outputPortId?: number;
    /**
     * @generated from protobuf field: optional uint32 input_node_id = 4
     */
    inputNodeId?: number;
    /**
     * @generated from protobuf field: optional uint32 input_port_id = 5
     */
    inputPortId?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemAudioManagerNode
 */
export interface CMsgSystemAudioManagerNode {
    /**
     * @generated from protobuf field: optional CMsgSystemAudioManagerObject base = 1
     */
    base?: CMsgSystemAudioManagerObject;
    /**
     * @generated from protobuf field: optional uint32 device_id = 2
     */
    deviceId?: number;
    /**
     * @generated from protobuf field: optional string name = 3
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string nick = 4
     */
    nick?: string;
    /**
     * @generated from protobuf field: optional string description = 5
     */
    description?: string;
    /**
     * @generated from protobuf field: optional int32 edirection = 6
     */
    edirection?: number;
    /**
     * @generated from protobuf field: optional CMsgSystemAudioVolume volume = 7
     */
    volume?: CMsgSystemAudioVolume;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemAudioManagerObject
 */
export interface CMsgSystemAudioManagerObject {
    /**
     * @generated from protobuf field: optional uint32 id = 1
     */
    id?: number;
    /**
     * @generated from protobuf field: optional fixed32 rtime_last_update = 2
     */
    rtimeLastUpdate?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemAudioManagerPort
 */
export interface CMsgSystemAudioManagerPort {
    /**
     * @generated from protobuf field: optional CMsgSystemAudioManagerObject base = 1
     */
    base?: CMsgSystemAudioManagerObject;
    /**
     * @generated from protobuf field: optional uint32 node_id = 3
     */
    nodeId?: number;
    /**
     * @generated from protobuf field: optional string name = 4
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string alias = 5
     */
    alias?: string;
    /**
     * @generated from protobuf field: optional int32 etype = 6
     */
    etype?: number;
    /**
     * @generated from protobuf field: optional int32 edirection = 7
     */
    edirection?: number;
    /**
     * @generated from protobuf field: optional bool is_physical = 8
     */
    isPhysical?: boolean;
    /**
     * @generated from protobuf field: optional bool is_terminal = 9
     */
    isTerminal?: boolean;
    /**
     * @generated from protobuf field: optional bool is_control = 10
     */
    isControl?: boolean;
    /**
     * @generated from protobuf field: optional bool is_monitor = 11
     */
    isMonitor?: boolean;
}
/**
 * @generated from protobuf message CMsgSystemAudioManagerState
 */
export interface CMsgSystemAudioManagerState {
    /**
     * @generated from protobuf field: optional fixed32 rtime_filter = 1
     */
    rtimeFilter?: number;
    /**
     * @generated from protobuf field: optional int32 counter = 2
     */
    counter?: number;
    /**
     * @generated from protobuf field: optional CMsgSystemAudioManagerStateHW hw = 3
     */
    hw?: CMsgSystemAudioManagerStateHW;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemAudioManagerStateHW
 */
export interface CMsgSystemAudioManagerStateHW {
    /**
     * @generated from protobuf field: repeated CMsgSystemAudioManagerDevice devices = 1
     */
    devices: CMsgSystemAudioManagerDevice[];
    /**
     * @generated from protobuf field: repeated CMsgSystemAudioManagerNode nodes = 2
     */
    nodes: CMsgSystemAudioManagerNode[];
    /**
     * @generated from protobuf field: repeated CMsgSystemAudioManagerPort ports = 3
     */
    ports: CMsgSystemAudioManagerPort[];
    /**
     * @generated from protobuf field: repeated CMsgSystemAudioManagerLink links = 4
     */
    links: CMsgSystemAudioManagerLink[];
}
/**
 * @generated from protobuf message CMsgSystemAudioManagerUpdateSomething
 */
export interface CMsgSystemAudioManagerUpdateSomething {
    /**
     * @generated from protobuf field: optional int32 counter = 1
     */
    counter?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemAudioVolume
 */
export interface CMsgSystemAudioVolume {
    /**
     * @generated from protobuf field: repeated CMsgSystemAudioVolume_ChannelEntry entries = 1
     */
    entries: CMsgSystemAudioVolume_ChannelEntry[];
    /**
     * @generated from protobuf field: optional bool is_muted = 2
     */
    isMuted?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemAudioVolume_ChannelEntry
 */
export interface CMsgSystemAudioVolume_ChannelEntry {
    /**
     * @generated from protobuf field: optional int32 echannel = 1
     */
    echannel?: number;
    /**
     * @generated from protobuf field: optional float volume = 2
     */
    volume?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemDisplay
 */
export interface CMsgSystemDisplay {
    /**
     * @generated from protobuf field: optional int32 id = 1
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string name = 2
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string description = 3
     */
    description?: string;
    /**
     * @generated from protobuf field: optional bool is_primary = 4
     */
    isPrimary?: boolean;
    /**
     * @generated from protobuf field: optional bool is_enabled = 5
     */
    isEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_internal = 6
     */
    isInternal?: boolean;
    /**
     * @generated from protobuf field: optional bool has_mode_override = 7
     */
    hasModeOverride?: boolean;
    /**
     * @generated from protobuf field: optional int32 width_mm = 8
     */
    widthMm?: number;
    /**
     * @generated from protobuf field: optional int32 height_mm = 9
     */
    heightMm?: number;
    /**
     * @generated from protobuf field: optional int32 current_mode_id = 10
     */
    currentModeId?: number;
    /**
     * @generated from protobuf field: repeated CMsgSystemDisplayMode modes = 11
     */
    modes: CMsgSystemDisplayMode[];
    /**
     * @generated from protobuf field: optional int32 refresh_rate_min = 12
     */
    refreshRateMin?: number;
    /**
     * @generated from protobuf field: optional int32 refresh_rate_max = 13
     */
    refreshRateMax?: number;
    /**
     * @generated from protobuf field: optional bool is_vrr_capable = 14
     */
    isVrrCapable?: boolean;
    /**
     * @generated from protobuf field: optional bool is_vrr_output_active = 15
     */
    isVrrOutputActive?: boolean;
    /**
     * @generated from protobuf field: optional bool is_hdr_capable = 16
     */
    isHdrCapable?: boolean;
    /**
     * @generated from protobuf field: optional bool is_hdr_output_active = 17
     */
    isHdrOutputActive?: boolean;
    /**
     * @generated from protobuf field: repeated int32 supported_refresh_rates = 18
     */
    supportedRefreshRates: number[];
}
/**
 * @generated from protobuf message CMsgSystemDisplayManagerSetMode
 */
export interface CMsgSystemDisplayManagerSetMode {
    /**
     * @generated from protobuf field: optional int32 display_id = 1
     */
    displayId?: number;
    /**
     * @generated from protobuf field: optional int32 mode_id = 2
     */
    modeId?: number;
}
/**
 * @generated from protobuf message CMsgSystemDisplayManagerState
 */
export interface CMsgSystemDisplayManagerState {
    /**
     * @generated from protobuf field: repeated CMsgSystemDisplay displays = 1
     */
    displays: CMsgSystemDisplay[];
    /**
     * @generated from protobuf field: optional bool is_mode_switching_supported = 2
     */
    isModeSwitchingSupported?: boolean;
    /**
     * @generated from protobuf field: optional int32 compatibility_mode = 3
     */
    compatibilityMode?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemDisplayMode
 */
export interface CMsgSystemDisplayMode {
    /**
     * @generated from protobuf field: optional int32 id = 1
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 width = 2
     */
    width?: number;
    /**
     * @generated from protobuf field: optional int32 height = 3
     */
    height?: number;
    /**
     * @generated from protobuf field: optional int32 refresh_hz = 4
     */
    refreshHz?: number;
}
/**
 * @generated from protobuf message CMsgSystemDockState
 */
export interface CMsgSystemDockState {
    /**
     * @generated from protobuf field: optional CMsgSystemDockUpdateState update_state = 1
     */
    updateState?: CMsgSystemDockUpdateState;
}
/**
 * @generated from protobuf message CMsgSystemDockUpdateFirmware
 */
export interface CMsgSystemDockUpdateFirmware {
    /**
     * @generated from protobuf field: optional bool check_only = 1
     */
    checkOnly?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemDockUpdateState
 */
export interface CMsgSystemDockUpdateState {
    /**
     * @generated from protobuf field: optional int32 state = 1
     */
    state?: number;
    /**
     * @generated from protobuf field: optional fixed32 rtime_last_checked = 2
     */
    rtimeLastChecked?: number;
    /**
     * @generated from protobuf field: optional string version_current = 3
     */
    versionCurrent?: string;
    /**
     * @generated from protobuf field: optional string version_available = 4
     */
    versionAvailable?: string;
    /**
     * @generated from protobuf field: optional float stage_progress = 5
     */
    stageProgress?: number;
    /**
     * @generated from protobuf field: optional fixed32 rtime_estimated_completion = 6
     */
    rtimeEstimatedCompletion?: number;
    /**
     * @generated from protobuf field: optional int32 old_fw_workaround = 7
     */
    oldFwWorkaround?: number;
}
/**
 * @generated from protobuf message CMsgSystemManagerSettings
 */
export interface CMsgSystemManagerSettings {
    /**
     * @generated from protobuf field: optional float idle_backlight_dim_battery_seconds = 1
     */
    idleBacklightDimBatterySeconds?: number;
    /**
     * @generated from protobuf field: optional float idle_backlight_dim_ac_seconds = 2
     */
    idleBacklightDimAcSeconds?: number;
    /**
     * @generated from protobuf field: optional float idle_suspend_battery_seconds = 3
     */
    idleSuspendBatterySeconds?: number;
    /**
     * @generated from protobuf field: optional float idle_suspend_ac_seconds = 4
     */
    idleSuspendAcSeconds?: number;
    /**
     * @generated from protobuf field: optional bool idle_suspend_supressed = 5
     */
    idleSuspendSupressed?: boolean;
    /**
     * @generated from protobuf field: optional bool is_adaptive_brightness_available = 6
     */
    isAdaptiveBrightnessAvailable?: boolean;
    /**
     * @generated from protobuf field: optional bool display_adaptive_brightness_enabled = 7
     */
    displayAdaptiveBrightnessEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool display_nightmode_enabled = 10
     */
    displayNightmodeEnabled?: boolean;
    /**
     * @generated from protobuf field: optional float display_nightmode_tintstrength = 11
     */
    displayNightmodeTintstrength?: number;
    /**
     * @generated from protobuf field: optional float display_nightmode_maxhue = 12
     */
    displayNightmodeMaxhue?: number;
    /**
     * @generated from protobuf field: optional float display_nightmode_maxsat = 13
     */
    displayNightmodeMaxsat?: number;
    /**
     * @generated from protobuf field: optional float display_nightmode_uiexp = 14
     */
    displayNightmodeUiexp?: number;
    /**
     * @generated from protobuf field: optional float display_nightmode_blend = 15
     */
    displayNightmodeBlend?: number;
    /**
     * @generated from protobuf field: optional bool display_nightmode_reset = 16
     */
    displayNightmodeReset?: boolean;
    /**
     * @generated from protobuf field: optional bool display_nightmode_schedule_enabled = 17
     */
    displayNightmodeScheduleEnabled?: boolean;
    /**
     * @generated from protobuf field: optional float display_nightmode_schedule_starttime = 18
     */
    displayNightmodeScheduleStarttime?: number;
    /**
     * @generated from protobuf field: optional float display_nightmode_schedule_endtime = 19
     */
    displayNightmodeScheduleEndtime?: number;
    /**
     * @generated from protobuf field: optional bool display_diagnostics_enabled = 20
     */
    displayDiagnosticsEnabled?: boolean;
    /**
     * @generated from protobuf field: optional float als_lux_primary = 21
     */
    alsLuxPrimary?: number;
    /**
     * @generated from protobuf field: optional float als_lux_median = 22
     */
    alsLuxMedian?: number;
    /**
     * @generated from protobuf field: optional float display_backlight_raw = 23
     */
    displayBacklightRaw?: number;
    /**
     * @generated from protobuf field: optional float display_brightness_adaptivemin = 24
     */
    displayBrightnessAdaptivemin?: number;
    /**
     * @generated from protobuf field: optional float display_brightness_adaptivemax = 25
     */
    displayBrightnessAdaptivemax?: number;
    /**
     * @generated from protobuf field: optional bool is_wifi_powersave_enabled = 26
     */
    isWifiPowersaveEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_fan_control_available = 27
     */
    isFanControlAvailable?: boolean;
    /**
     * @generated from protobuf field: optional int32 fan_control_mode = 28
     */
    fanControlMode?: number;
    /**
     * @generated from protobuf field: optional bool is_display_brightness_available = 29
     */
    isDisplayBrightnessAvailable?: boolean;
    /**
     * @generated from protobuf field: optional bool is_display_colormanagement_available = 31
     */
    isDisplayColormanagementAvailable?: boolean;
    /**
     * @generated from protobuf field: optional float display_colorgamut = 32
     */
    displayColorgamut?: number;
    /**
     * @generated from protobuf field: optional float als_lux_alternate = 33
     */
    alsLuxAlternate?: number;
    /**
     * @generated from protobuf field: optional bool is_display_colortemp_available = 34
     */
    isDisplayColortempAvailable?: boolean;
    /**
     * @generated from protobuf field: optional float display_colortemp = 35
     */
    displayColortemp?: number;
    /**
     * @generated from protobuf field: optional float display_colortemp_default = 36
     */
    displayColortempDefault?: number;
    /**
     * @generated from protobuf field: optional bool display_colortemp_enabled = 37
     */
    displayColortempEnabled?: boolean;
    /**
     * @generated from protobuf field: optional int32 display_colorgamut_labelset = 38
     */
    displayColorgamutLabelset?: number;
    /**
     * @generated from protobuf field: optional float display_brightness_overdrive_hdr_split = 39
     */
    displayBrightnessOverdriveHdrSplit?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemPerfDiagnosticEntry
 */
export interface CMsgSystemPerfDiagnosticEntry {
    /**
     * @generated from protobuf field: optional string name = 1
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 2
     */
    value?: string;
}
/**
 * @generated from protobuf message CMsgSystemPerfDiagnosticInfo
 */
export interface CMsgSystemPerfDiagnosticInfo {
    /**
     * @generated from protobuf field: repeated CMsgSystemPerfDiagnosticEntry entries = 1
     */
    entries: CMsgSystemPerfDiagnosticEntry[];
    /**
     * @generated from protobuf field: repeated CMsgSystemPerfNetworkInterface interfaces = 2
     */
    interfaces: CMsgSystemPerfNetworkInterface[];
    /**
     * @generated from protobuf field: optional float battery_temp_c = 3
     */
    batteryTempC?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemPerfLimits
 */
export interface CMsgSystemPerfLimits {
    /**
     * @generated from protobuf field: optional int32 cpu_governor_manual_min_mhz = 1
     */
    cpuGovernorManualMinMhz?: number;
    /**
     * @generated from protobuf field: optional int32 cpu_governor_manual_max_mhz = 2
     */
    cpuGovernorManualMaxMhz?: number;
    /**
     * @generated from protobuf field: optional int32 fsr_sharpness_min = 3
     */
    fsrSharpnessMin?: number;
    /**
     * @generated from protobuf field: optional int32 fsr_sharpness_max = 4
     */
    fsrSharpnessMax?: number;
    /**
     * @generated from protobuf field: optional int32 gpu_performance_manual_min_mhz = 5
     */
    gpuPerformanceManualMinMhz?: number;
    /**
     * @generated from protobuf field: optional int32 gpu_performance_manual_max_mhz = 6
     */
    gpuPerformanceManualMaxMhz?: number;
    /**
     * @generated from protobuf field: optional bool perf_overlay_is_standalone = 7
     */
    perfOverlayIsStandalone?: boolean;
    /**
     * @generated from protobuf field: optional bool is_dynamic_vrs_available = 8
     */
    isDynamicVrsAvailable?: boolean;
    /**
     * @generated from protobuf field: optional bool is_manual_display_refresh_rate_available = 9
     */
    isManualDisplayRefreshRateAvailable?: boolean;
    /**
     * @generated from protobuf field: repeated int32 gpu_performance_levels_available = 10
     */
    gpuPerformanceLevelsAvailable: number[];
    /**
     * @generated from protobuf field: optional int32 display_refresh_manual_hz_min = 11
     */
    displayRefreshManualHzMin?: number;
    /**
     * @generated from protobuf field: optional int32 display_refresh_manual_hz_max = 12
     */
    displayRefreshManualHzMax?: number;
    /**
     * @generated from protobuf field: repeated int32 fps_limit_options = 13
     */
    fpsLimitOptions: number[];
    /**
     * @generated from protobuf field: optional int32 tdp_limit_min = 14
     */
    tdpLimitMin?: number;
    /**
     * @generated from protobuf field: optional int32 tdp_limit_max = 15
     */
    tdpLimitMax?: number;
    /**
     * @generated from protobuf field: optional int32 display_external_refresh_manual_hz_min = 19
     */
    displayExternalRefreshManualHzMin?: number;
    /**
     * @generated from protobuf field: optional int32 display_external_refresh_manual_hz_max = 20
     */
    displayExternalRefreshManualHzMax?: number;
    /**
     * @generated from protobuf field: repeated int32 fps_limit_options_external = 21
     */
    fpsLimitOptionsExternal: number[];
    /**
     * @generated from protobuf field: optional bool is_vrr_supported = 23
     */
    isVrrSupported?: boolean;
    /**
     * @generated from protobuf field: optional bool is_dynamic_refresh_rate_in_steam_supported = 24
     */
    isDynamicRefreshRateInSteamSupported?: boolean;
    /**
     * @generated from protobuf field: repeated int32 split_scaling_filters_available = 26
     */
    splitScalingFiltersAvailable: number[];
    /**
     * @generated from protobuf field: repeated int32 split_scaling_scalers_available = 27
     */
    splitScalingScalersAvailable: number[];
    /**
     * @generated from protobuf field: optional bool disable_refresh_rate_management = 30
     */
    disableRefreshRateManagement?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemPerfNetworkInterface
 */
export interface CMsgSystemPerfNetworkInterface {
    /**
     * @generated from protobuf field: optional string name = 1
     */
    name?: string;
    /**
     * @generated from protobuf field: optional double timestamp = 2
     */
    timestamp?: number;
    /**
     * @generated from protobuf field: optional int64 tx_bytes_total = 3
     */
    txBytesTotal?: bigint;
    /**
     * @generated from protobuf field: optional int64 rx_bytes_total = 4
     */
    rxBytesTotal?: bigint;
    /**
     * @generated from protobuf field: optional int32 tx_bytes_per_sec = 5
     */
    txBytesPerSec?: number;
    /**
     * @generated from protobuf field: optional int32 rx_bytes_per_sec = 6
     */
    rxBytesPerSec?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemPerfSettings
 */
export interface CMsgSystemPerfSettings {
    /**
     * @generated from protobuf field: optional CMsgSystemPerfSettingsGlobal global = 1
     */
    global?: CMsgSystemPerfSettingsGlobal;
    /**
     * @generated from protobuf field: optional CMsgSystemPerfSettingsPerApp per_app = 2
     */
    perApp?: CMsgSystemPerfSettingsPerApp;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemPerfSettingsGlobal
 */
export interface CMsgSystemPerfSettingsGlobal {
    /**
     * @generated from protobuf field: optional float diagnostic_update_rate = 1
     */
    diagnosticUpdateRate?: number;
    /**
     * @generated from protobuf field: optional int32 system_trace_service_state = 2
     */
    systemTraceServiceState?: number;
    /**
     * @generated from protobuf field: optional int32 graphics_profiling_service_state = 3
     */
    graphicsProfilingServiceState?: number;
    /**
     * @generated from protobuf field: optional int32 perf_overlay_service_state = 4
     */
    perfOverlayServiceState?: number;
    /**
     * @generated from protobuf field: optional int32 perf_overlay_level = 5
     */
    perfOverlayLevel?: number;
    /**
     * @generated from protobuf field: optional bool is_show_perf_overlay_over_steam_enabled = 6
     */
    isShowPerfOverlayOverSteamEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_advanced_settings_enabled = 7
     */
    isAdvancedSettingsEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool allow_external_display_refresh_control = 8
     */
    allowExternalDisplayRefreshControl?: boolean;
    /**
     * @generated from protobuf field: optional int32 hdr_on_sdr_tonemap_operator = 12
     */
    hdrOnSdrTonemapOperator?: number;
    /**
     * @generated from protobuf field: optional bool is_hdr_debug_heatmap_enabled = 13
     */
    isHdrDebugHeatmapEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool force_hdr_wide_gammut_for_sdr = 15 [default = true]
     */
    forceHdrWideGammutForSdr?: boolean;
    /**
     * @generated from protobuf field: optional bool is_color_management_enabled = 21
     */
    isColorManagementEnabled?: boolean;
    /**
     * @generated from protobuf field: optional float sdr_to_hdr_brightness = 22
     */
    sdrToHdrBrightness?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemPerfSettingsPerApp
 */
export interface CMsgSystemPerfSettingsPerApp {
    /**
     * @generated from protobuf field: optional int32 gpu_performance_manual_mhz = 1
     */
    gpuPerformanceManualMhz?: number;
    /**
     * @generated from protobuf field: optional int32 fps_limit = 2
     */
    fpsLimit?: number;
    /**
     * @generated from protobuf field: optional bool is_variable_resolution_enabled = 3
     */
    isVariableResolutionEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_dynamic_refresh_rate_enabled = 4
     */
    isDynamicRefreshRateEnabled?: boolean;
    /**
     * @generated from protobuf field: optional int32 tdp_limit = 5
     */
    tdpLimit?: number;
    /**
     * @generated from protobuf field: optional int32 cpu_governor = 6
     */
    cpuGovernor?: number;
    /**
     * @generated from protobuf field: optional int32 cpu_governor_manual_mhz = 7
     */
    cpuGovernorManualMhz?: number;
    /**
     * @generated from protobuf field: optional int32 scaling_filter = 8
     */
    scalingFilter?: number;
    /**
     * @generated from protobuf field: optional int32 fsr_sharpness = 9
     */
    fsrSharpness?: number;
    /**
     * @generated from protobuf field: optional bool is_fps_limit_enabled = 10
     */
    isFpsLimitEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_tdp_limit_enabled = 11
     */
    isTdpLimitEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_low_latency_mode_enabled = 12
     */
    isLowLatencyModeEnabled?: boolean;
    /**
     * @generated from protobuf field: optional int32 display_refresh_manual_hz = 13
     */
    displayRefreshManualHz?: number;
    /**
     * @generated from protobuf field: optional bool is_game_perf_profile_enabled = 14
     */
    isGamePerfProfileEnabled?: boolean;
    /**
     * @generated from protobuf field: optional int32 gpu_performance_level = 15
     */
    gpuPerformanceLevel?: number;
    /**
     * @generated from protobuf field: optional int32 display_external_refresh_manual_hz = 17
     */
    displayExternalRefreshManualHz?: number;
    /**
     * @generated from protobuf field: optional int32 fps_limit_external = 18
     */
    fpsLimitExternal?: number;
    /**
     * @generated from protobuf field: optional bool is_tearing_enabled = 19
     */
    isTearingEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_vrr_enabled = 20
     */
    isVrrEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool use_dynamic_refresh_rate_in_steam = 23
     */
    useDynamicRefreshRateInSteam?: boolean;
    /**
     * @generated from protobuf field: optional int32 split_scaling_filter = 24
     */
    splitScalingFilter?: number;
    /**
     * @generated from protobuf field: optional int32 split_scaling_scaler = 25
     */
    splitScalingScaler?: number;
}
/**
 * @generated from protobuf message CMsgSystemPerfState
 */
export interface CMsgSystemPerfState {
    /**
     * @generated from protobuf field: optional CMsgSystemPerfLimits limits = 1
     */
    limits?: CMsgSystemPerfLimits;
    /**
     * @generated from protobuf field: optional CMsgSystemPerfSettings settings = 2
     */
    settings?: CMsgSystemPerfSettings;
    /**
     * @generated from protobuf field: optional uint64 current_game_id = 3
     */
    currentGameId?: bigint;
    /**
     * @generated from protobuf field: optional uint64 active_profile_game_id = 4
     */
    activeProfileGameId?: bigint;
}
/**
 * @generated from protobuf message CMsgSystemPerfUpdateSettings
 */
export interface CMsgSystemPerfUpdateSettings {
    /**
     * @generated from protobuf field: optional uint64 gameid = 1
     */
    gameid?: bigint;
    /**
     * @generated from protobuf field: optional bool reset_to_default = 2
     */
    resetToDefault?: boolean;
    /**
     * @generated from protobuf field: optional CMsgSystemPerfSettings settings_delta = 3
     */
    settingsDelta?: CMsgSystemPerfSettings;
    /**
     * @generated from protobuf field: optional bool skip_storage_update = 4
     */
    skipStorageUpdate?: boolean;
}
/**
 * @generated from protobuf message CMsgSystemUpdateApplyParams
 */
export interface CMsgSystemUpdateApplyParams {
    /**
     * @generated from protobuf field: repeated int32 apply_types = 1
     */
    applyTypes: number[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemUpdateApplyResult
 */
export interface CMsgSystemUpdateApplyResult {
    /**
     * @generated from protobuf field: optional int32 type = 1
     */
    type?: number;
    /**
     * @generated from protobuf field: optional uint32 eresult = 2 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional bool requires_client_restart = 3 [default = false]
     */
    requiresClientRestart?: boolean;
    /**
     * @generated from protobuf field: optional bool requires_system_restart = 4 [default = false]
     */
    requiresSystemRestart?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemUpdateCheckResult
 */
export interface CMsgSystemUpdateCheckResult {
    /**
     * @generated from protobuf field: optional int32 type = 1
     */
    type?: number;
    /**
     * @generated from protobuf field: optional uint32 eresult = 2 [default = 2]
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed32 rtime_checked = 3
     */
    rtimeChecked?: number;
    /**
     * @generated from protobuf field: optional bool available = 4
     */
    available?: boolean;
    /**
     * @generated from protobuf field: optional string version = 5
     */
    version?: string;
    /**
     * @generated from protobuf field: optional string auto_message = 6
     */
    autoMessage?: string;
    /**
     * @generated from protobuf field: optional bool system_restart_pending = 7
     */
    systemRestartPending?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CMsgSystemUpdateProgress
 */
export interface CMsgSystemUpdateProgress {
    /**
     * @generated from protobuf field: optional float stage_progress = 1
     */
    stageProgress?: number;
    /**
     * @generated from protobuf field: optional int64 stage_size_bytes = 2
     */
    stageSizeBytes?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 rtime_estimated_completion = 3
     */
    rtimeEstimatedCompletion?: number;
}
/**
 * @generated from protobuf message CMsgSystemUpdateState
 */
export interface CMsgSystemUpdateState {
    /**
     * @generated from protobuf field: optional int32 state = 1
     */
    state?: number;
    /**
     * @generated from protobuf field: optional CMsgSystemUpdateProgress progress = 2
     */
    progress?: CMsgSystemUpdateProgress;
    /**
     * @generated from protobuf field: repeated CMsgSystemUpdateCheckResult update_check_results = 3
     */
    updateCheckResults: CMsgSystemUpdateCheckResult[];
    /**
     * @generated from protobuf field: repeated CMsgSystemUpdateApplyResult update_apply_results = 4
     */
    updateApplyResults: CMsgSystemUpdateApplyResult[];
    /**
     * @generated from protobuf field: optional bool supports_os_updates = 5
     */
    supportsOsUpdates?: boolean;
}
/**
 * @generated from protobuf message CMsgTrading_CancelTradeRequest
 */
export interface CMsgTrading_CancelTradeRequest {
    /**
     * @generated from protobuf field: optional uint64 other_steamid = 1
     */
    otherSteamid?: bigint;
}
/**
 * @generated from protobuf message CMsgTrading_InitiateTradeRequest
 */
export interface CMsgTrading_InitiateTradeRequest {
    /**
     * @generated from protobuf field: optional uint32 trade_request_id = 1
     */
    tradeRequestId?: number;
    /**
     * @generated from protobuf field: optional uint64 other_steamid = 2
     */
    otherSteamid?: bigint;
    /**
     * @generated from protobuf field: optional string other_name = 3
     */
    otherName?: string;
}
/**
 * @generated from protobuf message CMsgTrading_InitiateTradeResponse
 */
export interface CMsgTrading_InitiateTradeResponse {
    /**
     * @generated from protobuf field: optional uint32 response = 1
     */
    response?: number;
    /**
     * @generated from protobuf field: optional uint32 trade_request_id = 2
     */
    tradeRequestId?: number;
    /**
     * @generated from protobuf field: optional uint64 other_steamid = 3
     */
    otherSteamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 steamguard_required_days = 4
     */
    steamguardRequiredDays?: number;
    /**
     * @generated from protobuf field: optional uint32 new_device_cooldown_days = 5
     */
    newDeviceCooldownDays?: number;
    /**
     * @generated from protobuf field: optional uint32 default_password_reset_probation_days = 6
     */
    defaultPasswordResetProbationDays?: number;
    /**
     * @generated from protobuf field: optional uint32 password_reset_probation_days = 7
     */
    passwordResetProbationDays?: number;
    /**
     * @generated from protobuf field: optional uint32 default_email_change_probation_days = 8
     */
    defaultEmailChangeProbationDays?: number;
    /**
     * @generated from protobuf field: optional uint32 email_change_probation_days = 9
     */
    emailChangeProbationDays?: number;
}
/**
 * @generated from protobuf message CMsgTrading_StartSession
 */
export interface CMsgTrading_StartSession {
    /**
     * @generated from protobuf field: optional uint64 other_steamid = 1
     */
    otherSteamid?: bigint;
}
/**
 * @generated from protobuf message CMsgWebUITransportFailure
 */
export interface CMsgWebUITransportFailure {
    /**
     * @generated from protobuf field: optional uint32 connect_count = 1
     */
    connectCount?: number;
}
/**
 * @generated from protobuf message CProductImpressionsFromClient_Notification
 */
export interface CProductImpressionsFromClient_Notification {
    /**
     * @generated from protobuf field: repeated CProductImpressionsFromClient_Notification_Impression impressions = 1
     */
    impressions: CProductImpressionsFromClient_Notification_Impression[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CProductImpressionsFromClient_Notification_Impression
 */
export interface CProductImpressionsFromClient_Notification_Impression {
    /**
     * @generated from protobuf field: optional int32 type = 1
     */
    type?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 2
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 num_impressions = 3
     */
    numImpressions?: number;
}
/**
 * @generated from protobuf message CRemotePlay_SessionStopped_Notification
 */
export interface CRemotePlay_SessionStopped_Notification {
    /**
     * @generated from protobuf field: optional fixed64 record_id = 1
     */
    recordId?: bigint;
    /**
     * @generated from protobuf field: optional bool used_x264 = 2
     */
    usedX264?: boolean;
    /**
     * @generated from protobuf field: optional bool used_h264 = 3
     */
    usedH264?: boolean;
    /**
     * @generated from protobuf field: optional bool used_hevc = 4
     */
    usedHevc?: boolean;
}
/**
 * @generated from protobuf message CSteamVR_AudioSettings_ChangeSettings_Request
 */
export interface CSteamVR_AudioSettings_ChangeSettings_Request {
    /**
     * @generated from protobuf field: optional CSteamVR_AudioSettings_Settings settings = 1
     */
    settings?: CSteamVR_AudioSettings_Settings;
}
/**
 * @generated from protobuf message CSteamVR_AudioSettings_RegisterForSettings_Request
 */
export interface CSteamVR_AudioSettings_RegisterForSettings_Request {
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CSteamVR_AudioSettings_Settings
 */
export interface CSteamVR_AudioSettings_Settings {
    /**
     * @generated from protobuf field: optional CSteamVR_AudioSettings_Settings_Channel main = 1
     */
    main?: CSteamVR_AudioSettings_Settings_Channel;
    /**
     * @generated from protobuf field: optional CSteamVR_AudioSettings_Settings_Channel audio_mirror = 2
     */
    audioMirror?: CSteamVR_AudioSettings_Settings_Channel;
    /**
     * @generated from protobuf field: optional CSteamVR_AudioSettings_Settings_Channel microphone = 3
     */
    microphone?: CSteamVR_AudioSettings_Settings_Channel;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CSteamVR_AudioSettings_Settings_Channel
 */
export interface CSteamVR_AudioSettings_Settings_Channel {
    /**
     * @generated from protobuf field: optional bool available = 1
     */
    available?: boolean;
    /**
     * @generated from protobuf field: optional bool muted = 2
     */
    muted?: boolean;
    /**
     * @generated from protobuf field: optional float volume = 3
     */
    volume?: number;
}
/**
 * @generated from protobuf message CSteamVR_AudioSettings_SettingsChanged_Notification
 */
export interface CSteamVR_AudioSettings_SettingsChanged_Notification {
    /**
     * @generated from protobuf field: optional CSteamVR_AudioSettings_Settings settings = 1
     */
    settings?: CSteamVR_AudioSettings_Settings;
}
/**
 * @generated from protobuf message CSteamVR_Header
 */
export interface CSteamVR_Header {
    /**
     * @generated from protobuf field: optional int32 type = 1
     */
    type?: number;
    /**
     * @generated from protobuf field: optional uint32 id = 2
     */
    id?: number;
}
/**
 * @generated from protobuf message CSteamVR_Settings_SetValue_Request
 */
export interface CSteamVR_Settings_SetValue_Request {
    /**
     * @generated from protobuf field: optional string section = 1
     */
    section?: string;
    /**
     * @generated from protobuf field: optional string settings_key = 2
     */
    settingsKey?: string;
    /**
     * @generated from protobuf field: optional bool bool = 3
     */
    bool?: boolean;
    /**
     * @generated from protobuf field: optional int32 int = 4
     */
    int?: number;
    /**
     * @generated from protobuf field: optional float float = 5
     */
    float?: number;
    /**
     * @generated from protobuf field: optional string string = 6
     */
    string?: string;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_Active_Notification
 */
export interface CSteamVR_VoiceChat_Active_Notification {
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_ConfigureVideo_Request
 */
export interface CSteamVR_VoiceChat_ConfigureVideo_Request {
    /**
     * @generated from protobuf field: optional bool send = 1
     */
    send?: boolean;
    /**
     * @generated from protobuf field: optional bool receive = 2
     */
    receive?: boolean;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_ConfigureVideo_Response
 */
export interface CSteamVR_VoiceChat_ConfigureVideo_Response {
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_ExitRoomChat_Request
 */
export interface CSteamVR_VoiceChat_ExitRoomChat_Request {
    /**
     * @generated from protobuf field: optional uint64 chat_group_id = 1
     */
    chatGroupId?: bigint;
    /**
     * @generated from protobuf field: optional uint64 chat_room_id = 2
     */
    chatRoomId?: bigint;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_ExitRoomChat_Response
 */
export interface CSteamVR_VoiceChat_ExitRoomChat_Response {
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_GetAvatarUrl_Request
 */
export interface CSteamVR_VoiceChat_GetAvatarUrl_Request {
    /**
     * @generated from protobuf field: optional fixed64 profile_steamid = 1
     */
    profileSteamid?: bigint;
    /**
     * @generated from protobuf field: optional int32 avatar_type = 2
     */
    avatarType?: number;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_GetAvatarUrl_Response
 */
export interface CSteamVR_VoiceChat_GetAvatarUrl_Response {
    /**
     * @generated from protobuf field: optional string profile_avatar_url = 1
     */
    profileAvatarUrl?: string;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_GroupName_Notification
 */
export interface CSteamVR_VoiceChat_GroupName_Notification {
    /**
     * @generated from protobuf field: optional string name = 1
     */
    name?: string;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_Inactive_Notification
 */
export interface CSteamVR_VoiceChat_Inactive_Notification {
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_InitiateRoomChat_Request
 */
export interface CSteamVR_VoiceChat_InitiateRoomChat_Request {
    /**
     * @generated from protobuf field: optional uint64 chat_group_id = 1
     */
    chatGroupId?: bigint;
    /**
     * @generated from protobuf field: optional uint64 chat_room_id = 2
     */
    chatRoomId?: bigint;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_InitiateRoomChat_Response
 */
export interface CSteamVR_VoiceChat_InitiateRoomChat_Response {
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification
 */
export interface CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification {
    /**
     * @generated from protobuf field: optional uint64 chat_group_id = 1
     */
    chatGroupId?: bigint;
    /**
     * @generated from protobuf field: optional uint64 chat_room_id = 2
     */
    chatRoomId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 sender_accountid = 3
     */
    senderAccountid?: number;
    /**
     * @generated from protobuf field: optional uint32 timestamp = 4
     */
    timestamp?: number;
    /**
     * @generated from protobuf field: optional uint32 ordinal = 5
     */
    ordinal?: number;
    /**
     * @generated from protobuf field: optional string message = 6
     */
    message?: string;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_PerUserGainValue_Notification
 */
export interface CSteamVR_VoiceChat_PerUserGainValue_Notification {
    /**
     * @generated from protobuf field: optional uint32 accountid = 1
     */
    accountid?: number;
    /**
     * @generated from protobuf field: optional bool muted = 2
     */
    muted?: boolean;
    /**
     * @generated from protobuf field: optional float gain = 3
     */
    gain?: number;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_PerUserVoiceStatus_Notification
 */
export interface CSteamVR_VoiceChat_PerUserVoiceStatus_Notification {
    /**
     * @generated from protobuf field: optional uint32 accountid = 1
     */
    accountid?: number;
    /**
     * @generated from protobuf field: optional bool mic_muted_locally = 2
     */
    micMutedLocally?: boolean;
    /**
     * @generated from protobuf field: optional bool output_muted_locally = 3
     */
    outputMutedLocally?: boolean;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_Ready_Notification
 */
export interface CSteamVR_VoiceChat_Ready_Notification {
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_SendGroupChatMessage_Request
 */
export interface CSteamVR_VoiceChat_SendGroupChatMessage_Request {
    /**
     * @generated from protobuf field: optional string message_with_bbcode = 1
     */
    messageWithBbcode?: string;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_SendGroupChatMessage_Response
 */
export interface CSteamVR_VoiceChat_SendGroupChatMessage_Response {
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_SetDefaultSession_Notification
 */
export interface CSteamVR_VoiceChat_SetDefaultSession_Notification {
    /**
     * @generated from protobuf field: optional uint64 chat_group_id = 1
     */
    chatGroupId?: bigint;
    /**
     * @generated from protobuf field: optional uint64 chat_room_id = 2
     */
    chatRoomId?: bigint;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_SetPerUserMuting_Request
 */
export interface CSteamVR_VoiceChat_SetPerUserMuting_Request {
    /**
     * @generated from protobuf field: optional uint32 accountid = 1
     */
    accountid?: number;
    /**
     * @generated from protobuf field: optional bool muted = 2
     */
    muted?: boolean;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_SetPerUserMuting_Response
 */
export interface CSteamVR_VoiceChat_SetPerUserMuting_Response {
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_SetPerUserVideo_Request
 */
export interface CSteamVR_VoiceChat_SetPerUserVideo_Request {
    /**
     * @generated from protobuf field: optional uint32 accountid = 1
     */
    accountid?: number;
    /**
     * @generated from protobuf field: optional bool receive = 2
     */
    receive?: boolean;
}
/**
 * @generated from protobuf message CSteamVR_VoiceChat_SetPerUserVideo_Response
 */
export interface CSteamVR_VoiceChat_SetPerUserVideo_Response {
}
/**
 * @generated from protobuf message CSteamVR_VRGamepadUI_Message
 */
export interface CSteamVR_VRGamepadUI_Message {
    /**
     * @generated from protobuf field: optional bytes header = 1
     */
    header?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes payload = 2
     */
    payload?: Uint8Array;
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_Active_Notification
 */
export interface CSteamVR_WebRTC_Active_Notification {
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_CloseDataChannel_Request
 */
export interface CSteamVR_WebRTC_CloseDataChannel_Request {
    /**
     * @generated from protobuf field: optional uint32 channel_id = 1
     */
    channelId?: number;
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_CloseDataChannel_Response
 */
export interface CSteamVR_WebRTC_CloseDataChannel_Response {
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_CreateDataChannel_Request
 */
export interface CSteamVR_WebRTC_CreateDataChannel_Request {
    /**
     * @generated from protobuf field: optional string label = 1
     */
    label?: string;
    /**
     * @generated from protobuf field: optional bool ordered = 2
     */
    ordered?: boolean;
    /**
     * @generated from protobuf field: optional uint32 max_retransmits = 3
     */
    maxRetransmits?: number;
    /**
     * @generated from protobuf field: optional uint32 max_packet_life_time = 4
     */
    maxPacketLifeTime?: number;
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_CreateDataChannel_Response
 */
export interface CSteamVR_WebRTC_CreateDataChannel_Response {
    /**
     * @generated from protobuf field: optional uint32 channel_id = 1
     */
    channelId?: number;
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_DataChannel_Close_Notification
 */
export interface CSteamVR_WebRTC_DataChannel_Close_Notification {
    /**
     * @generated from protobuf field: optional uint32 channel_id = 1
     */
    channelId?: number;
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_DataChannel_Error_Notification
 */
export interface CSteamVR_WebRTC_DataChannel_Error_Notification {
    /**
     * @generated from protobuf field: optional uint32 channel_id = 1
     */
    channelId?: number;
    /**
     * @generated from protobuf field: optional string reason = 2
     */
    reason?: string;
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_DataChannel_Message_Notification
 */
export interface CSteamVR_WebRTC_DataChannel_Message_Notification {
    /**
     * @generated from protobuf field: optional uint32 channel_id = 1
     */
    channelId?: number;
    /**
     * @generated from protobuf field: optional bytes data = 2
     */
    data?: Uint8Array;
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_DataChannel_Open_Notification
 */
export interface CSteamVR_WebRTC_DataChannel_Open_Notification {
    /**
     * @generated from protobuf field: optional uint32 channel_id = 1
     */
    channelId?: number;
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_Inactive_Notification
 */
export interface CSteamVR_WebRTC_Inactive_Notification {
}
/**
 * @generated from protobuf message CSteamVR_WebRTC_OnDataChannel_Notification
 */
export interface CSteamVR_WebRTC_OnDataChannel_Notification {
    /**
     * @generated from protobuf field: optional fixed64 source_steamid = 1
     */
    sourceSteamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 channel_id = 2
     */
    channelId?: number;
    /**
     * @generated from protobuf field: optional string label = 3
     */
    label?: string;
}
/**
 * Used by: PartnerStoreBrowse, StoreBrowse
 *
 * @generated from protobuf message CStoreBrowse_GetItems_Request
 */
export interface CStoreBrowse_GetItems_Request {
    /**
     * @generated from protobuf field: repeated StoreItemID ids = 1
     */
    ids: StoreItemID[];
    /**
     * @generated from protobuf field: optional StoreBrowseContext context = 2
     */
    context?: StoreBrowseContext;
    /**
     * @generated from protobuf field: optional StoreBrowseItemDataRequest data_request = 3
     */
    dataRequest?: StoreBrowseItemDataRequest;
}
/**
 * Used by: PartnerStoreBrowse, StoreBrowse
 *
 * @generated from protobuf message CStoreBrowse_GetItems_Response
 */
export interface CStoreBrowse_GetItems_Response {
    /**
     * @generated from protobuf field: repeated StoreItem store_items = 1
     */
    storeItems: StoreItem[];
}
/**
 * Used by: Store, StoreBrowse, StoreQuery
 *
 * @generated from protobuf message CStorePageFilter
 */
export interface CStorePageFilter {
    /**
     * @generated from protobuf field: optional CStorePageFilter_SalePageFilter sale_filter = 1
     */
    saleFilter?: CStorePageFilter_SalePageFilter;
    /**
     * @generated from protobuf field: optional CStorePageFilter_ContentHubFilter content_hub_filter = 2
     */
    contentHubFilter?: CStorePageFilter_ContentHubFilter;
    /**
     * @generated from protobuf field: repeated CStorePageFilter_StoreFilter store_filters = 3
     */
    storeFilters: CStorePageFilter_StoreFilter[];
}
/**
 * Used by: Store, StoreBrowse, StoreQuery
 *
 * @generated from protobuf message CStorePageFilter_ContentHubFilter
 */
export interface CStorePageFilter_ContentHubFilter {
    /**
     * @generated from protobuf field: optional string hub_type = 1
     */
    hubType?: string;
    /**
     * @generated from protobuf field: optional string hub_category = 2
     */
    hubCategory?: string;
    /**
     * @generated from protobuf field: optional uint32 hub_tagid = 3
     */
    hubTagid?: number;
    /**
     * @generated from protobuf field: optional int32 discount_filter = 4
     */
    discountFilter?: number;
    /**
     * @generated from protobuf field: optional CStorePageFilter_ContentHubFilter_OptInInfo optin = 5
     */
    optin?: CStorePageFilter_ContentHubFilter_OptInInfo;
}
/**
 * Used by: Store, StoreBrowse, StoreQuery
 *
 * @generated from protobuf message CStorePageFilter_ContentHubFilter_OptInInfo
 */
export interface CStorePageFilter_ContentHubFilter_OptInInfo {
    /**
     * @generated from protobuf field: optional string name = 1
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint32 optin_tagid = 2
     */
    optinTagid?: number;
    /**
     * @generated from protobuf field: optional uint32 prune_tagid = 3
     */
    pruneTagid?: number;
    /**
     * @generated from protobuf field: optional bool optin_only = 4
     */
    optinOnly?: boolean;
}
/**
 * Used by: Store, StoreBrowse, StoreQuery
 *
 * @generated from protobuf message CStorePageFilter_SalePageFilter
 */
export interface CStorePageFilter_SalePageFilter {
    /**
     * @generated from protobuf field: optional uint32 sale_tagid = 1
     */
    saleTagid?: number;
}
/**
 * Used by: Store, StoreBrowse, StoreQuery
 *
 * @generated from protobuf message CStorePageFilter_StoreFilter
 */
export interface CStorePageFilter_StoreFilter {
    /**
     * @generated from protobuf field: optional string filter_json = 1
     */
    filterJson?: string;
    /**
     * @generated from protobuf field: optional string cache_key = 2
     */
    cacheKey?: string;
}
/**
 * @generated from protobuf message CStreamingClientConfig
 */
export interface CStreamingClientConfig {
    /**
     * @generated from protobuf field: optional int32 quality = 1 [default = 2]
     */
    quality?: number;
    /**
     * @generated from protobuf field: optional uint32 desired_resolution_x = 2
     */
    desiredResolutionX?: number;
    /**
     * @generated from protobuf field: optional uint32 desired_resolution_y = 3
     */
    desiredResolutionY?: number;
    /**
     * @generated from protobuf field: optional uint32 desired_framerate_numerator = 4
     */
    desiredFramerateNumerator?: number;
    /**
     * @generated from protobuf field: optional uint32 desired_framerate_denominator = 5
     */
    desiredFramerateDenominator?: number;
    /**
     * @generated from protobuf field: optional int32 desired_bitrate_kbps = 6 [default = -1]
     */
    desiredBitrateKbps?: number;
    /**
     * @generated from protobuf field: optional bool enable_hardware_decoding = 7 [default = true]
     */
    enableHardwareDecoding?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_performance_overlay = 8 [default = false]
     */
    enablePerformanceOverlay?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_video_streaming = 9 [default = true]
     */
    enableVideoStreaming?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_audio_streaming = 10 [default = true]
     */
    enableAudioStreaming?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_input_streaming = 11 [default = true]
     */
    enableInputStreaming?: boolean;
    /**
     * @generated from protobuf field: optional int32 audio_channels = 12 [default = 2]
     */
    audioChannels?: number;
    /**
     * @generated from protobuf field: optional bool enable_video_hevc = 13 [default = false]
     */
    enableVideoHevc?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_performance_icons = 14 [default = true]
     */
    enablePerformanceIcons?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_microphone_streaming = 15 [default = false]
     */
    enableMicrophoneStreaming?: boolean;
    /**
     * @generated from protobuf field: optional string controller_overlay_hotkey = 16
     */
    controllerOverlayHotkey?: string;
    /**
     * @generated from protobuf field: optional bool enable_touch_controller_OBSOLETE = 17 [default = false]
     */
    enableTouchControllerOBSOLETE?: boolean;
    /**
     * @generated from protobuf field: optional int32 p2p_scope = 19 [default = 0]
     */
    p2PScope?: number;
    /**
     * @generated from protobuf field: optional bool enable_audio_uncompressed = 20 [default = false]
     */
    enableAudioUncompressed?: boolean;
    /**
     * @generated from protobuf field: optional CStreamVideoLimit display_limit = 21
     */
    displayLimit?: CStreamVideoLimit;
    /**
     * @generated from protobuf field: optional CStreamVideoLimit quality_limit = 22
     */
    qualityLimit?: CStreamVideoLimit;
    /**
     * @generated from protobuf field: optional CStreamVideoLimit runtime_limit = 23
     */
    runtimeLimit?: CStreamVideoLimit;
    /**
     * @generated from protobuf field: repeated CStreamVideoLimit decoder_limit = 24
     */
    decoderLimit: CStreamVideoLimit[];
    /**
     * @generated from protobuf field: optional bool enable_unreliable_fec = 25 [default = false]
     */
    enableUnreliableFec?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_video_av1 = 26 [default = false]
     */
    enableVideoAv1?: boolean;
}
/**
 * @generated from protobuf message CStreamingServerConfig
 */
export interface CStreamingServerConfig {
    /**
     * @generated from protobuf field: optional bool change_desktop_resolution = 1
     */
    changeDesktopResolution?: boolean;
    /**
     * @generated from protobuf field: optional bool dynamically_adjust_resolution_OBSOLETE = 2
     */
    dynamicallyAdjustResolutionOBSOLETE?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_capture_nvfbc = 3
     */
    enableCaptureNvfbc?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_hardware_encoding_nvidia_OBSOLETE = 4
     */
    enableHardwareEncodingNvidiaOBSOLETE?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_hardware_encoding_amd_OBSOLETE = 5
     */
    enableHardwareEncodingAmdOBSOLETE?: boolean;
    /**
     * @generated from protobuf field: optional bool enable_hardware_encoding_intel_OBSOLETE = 6
     */
    enableHardwareEncodingIntelOBSOLETE?: boolean;
    /**
     * @generated from protobuf field: optional int32 software_encoding_threads = 7
     */
    softwareEncodingThreads?: number;
    /**
     * @generated from protobuf field: optional bool enable_traffic_priority = 8
     */
    enableTrafficPriority?: boolean;
    /**
     * @generated from protobuf field: optional int32 host_play_audio = 9 [default = 0]
     */
    hostPlayAudio?: number;
    /**
     * @generated from protobuf field: optional bool enable_hardware_encoding = 10
     */
    enableHardwareEncoding?: boolean;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CStreamVideoLimit
 */
export interface CStreamVideoLimit {
    /**
     * @generated from protobuf field: optional int32 codec = 1
     */
    codec?: number;
    /**
     * @generated from protobuf field: optional CStreamVideoMode mode = 2
     */
    mode?: CStreamVideoMode;
    /**
     * @generated from protobuf field: optional int32 bitrate_kbps = 3
     */
    bitrateKbps?: number;
    /**
     * @generated from protobuf field: optional int32 burst_bitrate_kbps = 4
     */
    burstBitrateKbps?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CStreamVideoMode
 */
export interface CStreamVideoMode {
    /**
     * @generated from protobuf field: optional uint32 width = 1
     */
    width?: number;
    /**
     * @generated from protobuf field: optional uint32 height = 2
     */
    height?: number;
    /**
     * @generated from protobuf field: optional uint32 refresh_rate = 3
     */
    refreshRate?: number;
    /**
     * @generated from protobuf field: optional uint32 refresh_rate_numerator = 4
     */
    refreshRateNumerator?: number;
    /**
     * @generated from protobuf field: optional uint32 refresh_rate_denominator = 5
     */
    refreshRateDenominator?: number;
}
/**
 * Used by: Test_TransportError, TransportValidation
 *
 * @generated from protobuf message CTransportValidation_AppendToString_Request
 */
export interface CTransportValidation_AppendToString_Request {
    /**
     * @generated from protobuf field: repeated string append_strings = 1
     */
    appendStrings: string[];
}
/**
 * Used by: Test_TransportError, TransportValidation
 *
 * @generated from protobuf message CTransportValidation_AppendToString_Response
 */
export interface CTransportValidation_AppendToString_Response {
    /**
     * @generated from protobuf field: optional string combined_text = 1
     */
    combinedText?: string;
}
/**
 * Used by: AccountCart, Wishlist
 *
 * @generated from protobuf message CUserInterface_CuratorData
 */
export interface CUserInterface_CuratorData {
    /**
     * @generated from protobuf field: optional uint32 clanid = 1
     */
    clanid?: number;
    /**
     * @generated from protobuf field: optional uint64 listid = 2
     */
    listid?: bigint;
}
/**
 * Used by: AccountCart, Wishlist
 *
 * @generated from protobuf message CUserInterface_NavData
 */
export interface CUserInterface_NavData {
    /**
     * @generated from protobuf field: optional string domain = 1
     */
    domain?: string;
    /**
     * @generated from protobuf field: optional string controller = 2
     */
    controller?: string;
    /**
     * @generated from protobuf field: optional string method = 3
     */
    method?: string;
    /**
     * @generated from protobuf field: optional string submethod = 4
     */
    submethod?: string;
    /**
     * @generated from protobuf field: optional string feature = 5
     */
    feature?: string;
    /**
     * @generated from protobuf field: optional uint32 depth = 6
     */
    depth?: number;
    /**
     * @generated from protobuf field: optional string countrycode = 7
     */
    countrycode?: string;
    /**
     * @generated from protobuf field: optional uint64 webkey = 8
     */
    webkey?: bigint;
    /**
     * @generated from protobuf field: optional bool is_client = 9
     */
    isClient?: boolean;
    /**
     * @generated from protobuf field: optional CUserInterface_CuratorData curator_data = 10
     */
    curatorData?: CUserInterface_CuratorData;
    /**
     * @generated from protobuf field: optional bool is_likely_bot = 11
     */
    isLikelyBot?: boolean;
    /**
     * @generated from protobuf field: optional bool is_utm = 12
     */
    isUtm?: boolean;
}
/**
 * Used by: GameRecordingClip, VideoClip
 *
 * @generated from protobuf message CVideo_GameRecordingSegmentInfo
 */
export interface CVideo_GameRecordingSegmentInfo {
    /**
     * @generated from protobuf field: optional uint32 segment_number = 1
     */
    segmentNumber?: number;
    /**
     * @generated from protobuf field: optional uint64 segment_size_bytes = 2
     */
    segmentSizeBytes?: bigint;
    /**
     * @generated from protobuf field: optional string component_name = 3
     */
    componentName?: string;
    /**
     * @generated from protobuf field: optional string representation_name = 4
     */
    representationName?: string;
}
/**
 * @generated from protobuf message CVirtualMenuCreateDestroy
 */
export interface CVirtualMenuCreateDestroy {
    /**
     * @generated from protobuf field: optional bool created = 1
     */
    created?: boolean;
    /**
     * @generated from protobuf field: optional uint32 controller_idx = 2
     */
    controllerIdx?: number;
    /**
     * @generated from protobuf field: optional uint32 menu_idx = 3
     */
    menuIdx?: number;
    /**
     * @generated from protobuf field: optional uint32 source = 4
     */
    source?: number;
    /**
     * @generated from protobuf field: optional float x_position = 5
     */
    xPosition?: number;
    /**
     * @generated from protobuf field: optional float y_position = 6
     */
    yPosition?: number;
    /**
     * @generated from protobuf field: optional float opacity = 7
     */
    opacity?: number;
    /**
     * @generated from protobuf field: optional float scale = 8
     */
    scale?: number;
    /**
     * @generated from protobuf field: optional bool show_labels = 9
     */
    showLabels?: boolean;
    /**
     * @generated from protobuf field: optional bool force_on = 10
     */
    forceOn?: boolean;
    /**
     * @generated from protobuf field: optional uint32 appID = 11
     */
    appID?: number;
    /**
     * @generated from protobuf field: optional uint32 menu_style = 12
     */
    menuStyle?: number;
    /**
     * @generated from protobuf field: repeated CVirtualMenuCreateDestroy_TouchMenuKey popup_keys = 13
     */
    popupKeys: CVirtualMenuCreateDestroy_TouchMenuKey[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVirtualMenuCreateDestroy_TouchMenuKey
 */
export interface CVirtualMenuCreateDestroy_TouchMenuKey {
    /**
     * @generated from protobuf field: optional uint32 key_idx = 1
     */
    keyIdx?: number;
    /**
     * @generated from protobuf field: optional bool bound = 2
     */
    bound?: boolean;
    /**
     * @generated from protobuf field: optional bool placeholder = 3
     */
    placeholder?: boolean;
    /**
     * @generated from protobuf field: optional uint32 binding_type = 4
     */
    bindingType?: number;
    /**
     * @generated from protobuf field: optional float x = 5
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 6
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float width = 7
     */
    width?: number;
    /**
     * @generated from protobuf field: optional float height = 8
     */
    height?: number;
    /**
     * @generated from protobuf field: optional string description = 9
     */
    description?: string;
    /**
     * @generated from protobuf field: optional string label = 10
     */
    label?: string;
    /**
     * @generated from protobuf field: optional string glyph_path = 11
     */
    glyphPath?: string;
    /**
     * @generated from protobuf field: optional string icon_filename = 12
     */
    iconFilename?: string;
    /**
     * @generated from protobuf field: optional string color_foreground = 13
     */
    colorForeground?: string;
    /**
     * @generated from protobuf field: optional string color_background = 14
     */
    colorBackground?: string;
    /**
     * @generated from protobuf field: optional uint32 quandrants = 15
     */
    quandrants?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVirtualMenuKey
 */
export interface CVirtualMenuKey {
    /**
     * @generated from protobuf field: optional uint32 key_index = 1
     */
    keyIndex?: number;
    /**
     * @generated from protobuf field: optional bool bound = 2
     */
    bound?: boolean;
    /**
     * @generated from protobuf field: optional float x = 3
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 4
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float width = 5
     */
    width?: number;
    /**
     * @generated from protobuf field: optional float height = 6
     */
    height?: number;
    /**
     * @generated from protobuf field: optional string description = 7
     */
    description?: string;
    /**
     * @generated from protobuf field: optional string label = 8
     */
    label?: string;
    /**
     * @generated from protobuf field: optional string glyph_path = 9
     */
    glyphPath?: string;
    /**
     * @generated from protobuf field: optional string icon_filename = 10
     */
    iconFilename?: string;
    /**
     * @generated from protobuf field: optional string color_foreground = 11
     */
    colorForeground?: string;
    /**
     * @generated from protobuf field: optional string color_background = 12
     */
    colorBackground?: string;
    /**
     * @generated from protobuf field: optional uint32 quadrants = 13
     */
    quadrants?: number;
    /**
     * @generated from protobuf field: optional uint32 binding_type = 14
     */
    bindingType?: number;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_DashboardActionInvoked_Request
 */
export interface CVRGamepadUI_Message_DashboardActionInvoked_Request {
    /**
     * @generated from protobuf field: optional uint32 action_id = 1
     */
    actionId?: number;
    /**
     * @generated from protobuf field: optional bool toggle_value = 2
     */
    toggleValue?: boolean;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_DashboardActionInvoked_Response
 */
export interface CVRGamepadUI_Message_DashboardActionInvoked_Response {
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request
 */
export interface CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request {
    /**
     * @generated from protobuf field: optional uint32 window_id = 1
     */
    windowId?: number;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response
 */
export interface CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response {
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_DashboardTabClicked_Request
 */
export interface CVRGamepadUI_Message_DashboardTabClicked_Request {
    /**
     * @generated from protobuf field: optional uint32 tab_id = 1
     */
    tabId?: number;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_DashboardTabClicked_Response
 */
export interface CVRGamepadUI_Message_DashboardTabClicked_Response {
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_Error_Response
 */
export interface CVRGamepadUI_Message_Error_Response {
    /**
     * @generated from protobuf field: optional int32 error = 1
     */
    error?: number;
    /**
     * @generated from protobuf field: optional string description = 2
     */
    description?: string;
    /**
     * @generated from protobuf field: optional int32 origin = 3
     */
    origin?: number;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_ExecuteSteamURL_Request
 */
export interface CVRGamepadUI_Message_ExecuteSteamURL_Request {
    /**
     * @generated from protobuf field: optional string url = 1
     */
    url?: string;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_ExecuteSteamURL_Response
 */
export interface CVRGamepadUI_Message_ExecuteSteamURL_Response {
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_Header
 */
export interface CVRGamepadUI_Message_Header {
    /**
     * @generated from protobuf field: optional string name = 1
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint32 message_id = 2
     */
    messageId?: number;
    /**
     * @generated from protobuf field: optional uint32 response_to_message_id = 3
     */
    responseToMessageId?: number;
    /**
     * @generated from protobuf field: optional bool is_error_response = 4
     */
    isErrorResponse?: boolean;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_HideDashboardPopup_Request
 */
export interface CVRGamepadUI_Message_HideDashboardPopup_Request {
    /**
     * @generated from protobuf field: optional uint32 dashboard_popup_request_id = 1
     */
    dashboardPopupRequestId?: number;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_HideDashboardPopup_Response
 */
export interface CVRGamepadUI_Message_HideDashboardPopup_Response {
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_RemoteVideoStream_Request
 */
export interface CVRGamepadUI_Message_RemoteVideoStream_Request {
    /**
     * @generated from protobuf field: optional uint32 source_accountid = 1
     */
    sourceAccountid?: number;
    /**
     * @generated from protobuf field: optional string video_uniqueid = 2
     */
    videoUniqueid?: string;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_RemoteVideoStream_Response
 */
export interface CVRGamepadUI_Message_RemoteVideoStream_Response {
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Request
 */
export interface CVRGamepadUI_Message_ShowDashboardPopup_Request {
    /**
     * @generated from protobuf field: optional uint32 dashboard_popup_request_id = 1
     */
    dashboardPopupRequestId?: number;
    /**
     * @generated from protobuf field: optional string popup_overlay_key = 2
     */
    popupOverlayKey?: string;
    /**
     * @generated from protobuf field: optional string parent_overlay_key = 3
     */
    parentOverlayKey?: string;
    /**
     * @generated from protobuf field: optional CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition origin_on_parent = 4
     */
    originOnParent?: CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition;
    /**
     * @generated from protobuf field: optional CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition origin_on_popup = 5
     */
    originOnPopup?: CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition;
    /**
     * @generated from protobuf field: optional CVRGamepadUI_Message_ShowDashboardPopup_Request_Position offset = 6
     */
    offset?: CVRGamepadUI_Message_ShowDashboardPopup_Request_Position;
    /**
     * @generated from protobuf field: optional CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation rotation = 7
     */
    rotation?: CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation;
    /**
     * @generated from protobuf field: optional bool inherit_parent_pitch = 8
     */
    inheritParentPitch?: boolean;
    /**
     * @generated from protobuf field: optional bool inherit_parent_curvature = 9
     */
    inheritParentCurvature?: boolean;
    /**
     * @generated from protobuf field: optional CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect clip_rect = 10
     */
    clipRect?: CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect;
    /**
     * @generated from protobuf field: optional bool interactive = 11
     */
    interactive?: boolean;
    /**
     * @generated from protobuf field: optional bool requires_laser = 12
     */
    requiresLaser?: boolean;
    /**
     * @generated from protobuf field: optional string parent_device_path = 13
     */
    parentDevicePath?: string;
    /**
     * @generated from protobuf field: optional int32 sort_order = 14
     */
    sortOrder?: number;
    /**
     * @generated from protobuf field: optional int32 parent_enum = 15
     */
    parentEnum?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition
 */
export interface CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition {
    /**
     * @generated from protobuf field: optional float x = 1
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2
     */
    y?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Request_Position
 */
export interface CVRGamepadUI_Message_ShowDashboardPopup_Request_Position {
    /**
     * @generated from protobuf field: optional float x_pixels = 1
     */
    xPixels?: number;
    /**
     * @generated from protobuf field: optional float y_pixels = 2
     */
    yPixels?: number;
    /**
     * @generated from protobuf field: optional float z_pixels = 3
     */
    zPixels?: number;
    /**
     * @generated from protobuf field: optional float x_meters = 4
     */
    xMeters?: number;
    /**
     * @generated from protobuf field: optional float y_meters = 5
     */
    yMeters?: number;
    /**
     * @generated from protobuf field: optional float z_meters = 6
     */
    zMeters?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect
 */
export interface CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect {
    /**
     * @generated from protobuf field: optional float u_min = 1
     */
    uMin?: number;
    /**
     * @generated from protobuf field: optional float v_min = 2
     */
    vMin?: number;
    /**
     * @generated from protobuf field: optional float u_max = 3
     */
    uMax?: number;
    /**
     * @generated from protobuf field: optional float v_max = 4
     */
    vMax?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation
 */
export interface CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation {
    /**
     * @generated from protobuf field: optional float pitch_degrees = 1
     */
    pitchDegrees?: number;
    /**
     * @generated from protobuf field: optional float yaw_degrees = 2
     */
    yawDegrees?: number;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Response
 */
export interface CVRGamepadUI_Message_ShowDashboardPopup_Response {
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_ShowGame_Request
 */
export interface CVRGamepadUI_Message_ShowGame_Request {
    /**
     * @generated from protobuf field: optional string overlay_key = 1
     */
    overlayKey?: string;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_ShowGame_Response
 */
export interface CVRGamepadUI_Message_ShowGame_Response {
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_ShowOverlay_Request
 */
export interface CVRGamepadUI_Message_ShowOverlay_Request {
    /**
     * @generated from protobuf field: optional string overlay_key = 1
     */
    overlayKey?: string;
}
/**
 * @generated from protobuf message CVRGamepadUI_Message_ShowOverlay_Response
 */
export interface CVRGamepadUI_Message_ShowOverlay_Response {
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVRGamepadUIShared_DashboardAction
 */
export interface CVRGamepadUIShared_DashboardAction {
    /**
     * @generated from protobuf field: optional uint32 action_id = 1
     */
    actionId?: number;
    /**
     * @generated from protobuf field: optional bool visible_in_dashboard_bar = 2
     */
    visibleInDashboardBar?: boolean;
    /**
     * @generated from protobuf field: optional bool enabled = 3
     */
    enabled?: boolean;
    /**
     * @generated from protobuf field: optional string display_name = 4
     */
    displayName?: string;
    /**
     * @generated from protobuf field: optional CVRGamepadUIShared_DashboardActionIcon icon = 5
     */
    icon?: CVRGamepadUIShared_DashboardActionIcon;
    /**
     * @generated from protobuf field: optional CVRGamepadUIShared_DashboardActionIcon icon_active = 6
     */
    iconActive?: CVRGamepadUIShared_DashboardActionIcon;
    /**
     * @generated from protobuf field: optional int32 invocation = 7 [default = 1]
     */
    invocation?: number;
    /**
     * @generated from protobuf field: optional bool active = 8
     */
    active?: boolean;
    /**
     * @generated from protobuf field: optional int32 special_invocation = 9
     */
    specialInvocation?: number;
    /**
     * @generated from protobuf field: optional bool visible_in_menu = 10
     */
    visibleInMenu?: boolean;
    /**
     * @generated from protobuf field: optional bool is_menu = 11
     */
    isMenu?: boolean;
    /**
     * @generated from protobuf field: optional uint32 parent_menu_action_id = 12
     */
    parentMenuActionId?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVRGamepadUIShared_DashboardActionIcon
 */
export interface CVRGamepadUIShared_DashboardActionIcon {
    /**
     * @generated from protobuf field: optional int32 enum = 1
     */
    enum?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVRGamepadUIShared_DashboardTabIcon
 */
export interface CVRGamepadUIShared_DashboardTabIcon {
    /**
     * @generated from protobuf field: optional int32 enum = 1
     */
    enum?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 2
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string overlay = 3
     */
    overlay?: string;
    /**
     * @generated from protobuf field: optional uint32 hwnd = 4
     */
    hwnd?: number;
}
/**
 * @generated from protobuf message CVRGamepadUIShared_PathProperty_DashboardActions
 */
export interface CVRGamepadUIShared_PathProperty_DashboardActions {
    /**
     * @generated from protobuf field: repeated CVRGamepadUIShared_DashboardAction actions = 1
     */
    actions: CVRGamepadUIShared_DashboardAction[];
}
/**
 * @generated from protobuf message CVRGamepadUIShared_PathProperty_DashboardTabs
 */
export interface CVRGamepadUIShared_PathProperty_DashboardTabs {
    /**
     * @generated from protobuf field: repeated CVRGamepadUIShared_PathProperty_DashboardTabs_Tab tabs = 1
     */
    tabs: CVRGamepadUIShared_PathProperty_DashboardTabs_Tab[];
    /**
     * @generated from protobuf field: optional uint32 selected_tab_id = 2
     */
    selectedTabId?: number;
    /**
     * @generated from protobuf field: optional uint32 vr_settings_tab_id = 3
     */
    vrSettingsTabId?: number;
    /**
     * @generated from protobuf field: optional uint32 vr_steam_tab_id = 4
     */
    vrSteamTabId?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVRGamepadUIShared_PathProperty_DashboardTabs_Tab
 */
export interface CVRGamepadUIShared_PathProperty_DashboardTabs_Tab {
    /**
     * @generated from protobuf field: optional uint32 tab_id = 1
     */
    tabId?: number;
    /**
     * @generated from protobuf field: optional bool visible_in_dashboard_bar = 2
     */
    visibleInDashboardBar?: boolean;
    /**
     * @generated from protobuf field: optional string display_name = 3
     */
    displayName?: string;
    /**
     * @generated from protobuf field: optional CVRGamepadUIShared_DashboardTabIcon icon = 4
     */
    icon?: CVRGamepadUIShared_DashboardTabIcon;
    /**
     * @generated from protobuf field: optional bool visible_in_dashboard_menu = 5
     */
    visibleInDashboardMenu?: boolean;
}
/**
 * @generated from protobuf message CVRGamepadUIShared_PathProperty_DesktopWindows
 */
export interface CVRGamepadUIShared_PathProperty_DesktopWindows {
    /**
     * @generated from protobuf field: repeated CVRGamepadUIShared_PathProperty_DesktopWindows_Window windows = 1
     */
    windows: CVRGamepadUIShared_PathProperty_DesktopWindows_Window[];
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message CVRGamepadUIShared_PathProperty_DesktopWindows_Window
 */
export interface CVRGamepadUIShared_PathProperty_DesktopWindows_Window {
    /**
     * @generated from protobuf field: optional uint32 window_id = 1
     */
    windowId?: number;
    /**
     * @generated from protobuf field: optional uint32 hwnd = 2
     */
    hwnd?: number;
    /**
     * @generated from protobuf field: optional string title = 3
     */
    title?: string;
    /**
     * @generated from protobuf field: optional uint32 tab_id = 4
     */
    tabId?: number;
}
/**
 * @generated from protobuf message CVRGamepadUIShared_PathProperty_PowerOptions
 */
export interface CVRGamepadUIShared_PathProperty_PowerOptions {
    /**
     * @generated from protobuf field: optional bool can_sleep = 1
     */
    canSleep?: boolean;
    /**
     * @generated from protobuf field: optional bool can_shutdown = 2
     */
    canShutdown?: boolean;
    /**
     * @generated from protobuf field: optional bool can_restart_system = 3
     */
    canRestartSystem?: boolean;
    /**
     * @generated from protobuf field: optional bool can_exitvr = 4
     */
    canExitvr?: boolean;
}
/**
 * @generated from protobuf message CVRGamepadUIShared_PathProperty_VRVersionInfo
 */
export interface CVRGamepadUIShared_PathProperty_VRVersionInfo {
    /**
     * @generated from protobuf field: optional string version = 1
     */
    version?: string;
    /**
     * @generated from protobuf field: optional uint32 webpack_build_timestamp = 2
     */
    webpackBuildTimestamp?: number;
}
/**
 * Used by: common.proto
 *
 * @generated from protobuf message EncryptedAppTicket
 */
export interface EncryptedAppTicket {
    /**
     * @generated from protobuf field: optional uint32 ticket_version_no = 1
     */
    ticketVersionNo?: number;
    /**
     * @generated from protobuf field: optional uint32 crc_encryptedticket = 2
     */
    crcEncryptedticket?: number;
    /**
     * @generated from protobuf field: optional uint32 cb_encrypteduserdata = 3
     */
    cbEncrypteduserdata?: number;
    /**
     * @generated from protobuf field: optional uint32 cb_encrypted_appownershipticket = 4
     */
    cbEncryptedAppownershipticket?: number;
    /**
     * @generated from protobuf field: optional bytes encrypted_ticket = 5
     */
    encryptedTicket?: Uint8Array;
}
/**
 * Used by: LoyaltyRewards, SaleItemRewards
 *
 * @generated from protobuf message LoyaltyRewardDefinition
 */
export interface LoyaltyRewardDefinition {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 defid = 2
     */
    defid?: number;
    /**
     * @generated from protobuf field: optional int32 type = 3
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 community_item_class = 4
     */
    communityItemClass?: number;
    /**
     * @generated from protobuf field: optional uint32 community_item_type = 5
     */
    communityItemType?: number;
    /**
     * @generated from protobuf field: optional int64 point_cost = 6
     */
    pointCost?: bigint;
    /**
     * @generated from protobuf field: optional uint32 timestamp_created = 7
     */
    timestampCreated?: number;
    /**
     * @generated from protobuf field: optional uint32 timestamp_updated = 8
     */
    timestampUpdated?: number;
    /**
     * @generated from protobuf field: optional uint32 timestamp_available = 9
     */
    timestampAvailable?: number;
    /**
     * @generated from protobuf field: optional int64 quantity = 10
     */
    quantity?: bigint;
    /**
     * @generated from protobuf field: optional string internal_description = 11
     */
    internalDescription?: string;
    /**
     * @generated from protobuf field: optional bool active = 12
     */
    active?: boolean;
    /**
     * @generated from protobuf field: optional LoyaltyRewardDefinition_CommunityItemData community_item_data = 13
     */
    communityItemData?: LoyaltyRewardDefinition_CommunityItemData;
    /**
     * @generated from protobuf field: optional uint32 timestamp_available_end = 14
     */
    timestampAvailableEnd?: number;
    /**
     * @generated from protobuf field: repeated uint32 bundle_defids = 15
     */
    bundleDefids: number[];
    /**
     * @generated from protobuf field: optional uint32 usable_duration = 16
     */
    usableDuration?: number;
    /**
     * @generated from protobuf field: optional uint32 bundle_discount = 17
     */
    bundleDiscount?: number;
    /**
     * @generated from protobuf field: optional uint32 timestamp_free_until = 18
     */
    timestampFreeUntil?: number;
}
/**
 * Used by: LoyaltyRewards, SaleItemRewards
 *
 * @generated from protobuf message LoyaltyRewardDefinition_BadgeData
 */
export interface LoyaltyRewardDefinition_BadgeData {
    /**
     * @generated from protobuf field: optional int32 level = 1
     */
    level?: number;
    /**
     * @generated from protobuf field: optional string image = 2
     */
    image?: string;
}
/**
 * Used by: LoyaltyRewards, SaleItemRewards
 *
 * @generated from protobuf message LoyaltyRewardDefinition_CommunityItemData
 */
export interface LoyaltyRewardDefinition_CommunityItemData {
    /**
     * @generated from protobuf field: optional string item_name = 1
     */
    itemName?: string;
    /**
     * @generated from protobuf field: optional string item_title = 2
     */
    itemTitle?: string;
    /**
     * @generated from protobuf field: optional string item_description = 3
     */
    itemDescription?: string;
    /**
     * @generated from protobuf field: optional string item_image_small = 4
     */
    itemImageSmall?: string;
    /**
     * @generated from protobuf field: optional string item_image_large = 5
     */
    itemImageLarge?: string;
    /**
     * @generated from protobuf field: optional string item_movie_webm = 6
     */
    itemMovieWebm?: string;
    /**
     * @generated from protobuf field: optional string item_movie_mp4 = 7
     */
    itemMovieMp4?: string;
    /**
     * @generated from protobuf field: optional bool animated = 8
     */
    animated?: boolean;
    /**
     * @generated from protobuf field: repeated LoyaltyRewardDefinition_BadgeData badge_data = 9
     */
    badgeData: LoyaltyRewardDefinition_BadgeData[];
    /**
     * @generated from protobuf field: optional string item_movie_webm_small = 10
     */
    itemMovieWebmSmall?: string;
    /**
     * @generated from protobuf field: optional string item_movie_mp4_small = 11
     */
    itemMovieMp4Small?: string;
    /**
     * @generated from protobuf field: optional string profile_theme_id = 12
     */
    profileThemeId?: string;
    /**
     * @generated from protobuf field: optional bool tiled = 13
     */
    tiled?: boolean;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreBrowseContext
 */
export interface StoreBrowseContext {
    /**
     * @generated from protobuf field: optional string language = 1
     */
    language?: string;
    /**
     * @generated from protobuf field: optional int32 elanguage = 2
     */
    elanguage?: number;
    /**
     * @generated from protobuf field: optional string country_code = 3
     */
    countryCode?: string;
    /**
     * @generated from protobuf field: optional int32 steam_realm = 4
     */
    steamRealm?: number;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreBrowseFilterFailure
 */
export interface StoreBrowseFilterFailure {
    /**
     * @generated from protobuf field: optional int32 filter_failure = 1 [default = 0]
     */
    filterFailure?: number;
    /**
     * @generated from protobuf field: optional bool already_owned = 5
     */
    alreadyOwned?: boolean;
    /**
     * @generated from protobuf field: optional bool on_wishlist = 6
     */
    onWishlist?: boolean;
    /**
     * @generated from protobuf field: optional bool ignored = 7
     */
    ignored?: boolean;
    /**
     * @generated from protobuf field: optional bool not_in_users_language = 10
     */
    notInUsersLanguage?: boolean;
    /**
     * @generated from protobuf field: optional bool not_on_users_platform = 11
     */
    notOnUsersPlatform?: boolean;
    /**
     * @generated from protobuf field: optional bool demo_for_owned_game = 12
     */
    demoForOwnedGame?: boolean;
    /**
     * @generated from protobuf field: optional bool dlc_for_unowned_game = 13
     */
    dlcForUnownedGame?: boolean;
    /**
     * @generated from protobuf field: optional bool nonpreferred_product_type = 20
     */
    nonpreferredProductType?: boolean;
    /**
     * @generated from protobuf field: repeated uint32 excluded_tagids = 21
     */
    excludedTagids: number[];
    /**
     * @generated from protobuf field: repeated int32 excluded_content_descriptorids = 30
     */
    excludedContentDescriptorids: number[];
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreBrowseItemDataRequest
 */
export interface StoreBrowseItemDataRequest {
    /**
     * @generated from protobuf field: optional bool include_assets = 1
     */
    includeAssets?: boolean;
    /**
     * @generated from protobuf field: optional bool include_release = 2
     */
    includeRelease?: boolean;
    /**
     * @generated from protobuf field: optional bool include_platforms = 3
     */
    includePlatforms?: boolean;
    /**
     * @generated from protobuf field: optional bool include_all_purchase_options = 4
     */
    includeAllPurchaseOptions?: boolean;
    /**
     * @generated from protobuf field: optional bool include_screenshots = 5
     */
    includeScreenshots?: boolean;
    /**
     * @generated from protobuf field: optional bool include_trailers = 6
     */
    includeTrailers?: boolean;
    /**
     * @generated from protobuf field: optional bool include_ratings = 7
     */
    includeRatings?: boolean;
    /**
     * @generated from protobuf field: optional int32 include_tag_count = 8
     */
    includeTagCount?: number;
    /**
     * @generated from protobuf field: optional bool include_reviews = 9
     */
    includeReviews?: boolean;
    /**
     * @generated from protobuf field: optional bool include_basic_info = 10
     */
    includeBasicInfo?: boolean;
    /**
     * @generated from protobuf field: optional bool include_supported_languages = 11
     */
    includeSupportedLanguages?: boolean;
    /**
     * @generated from protobuf field: optional bool include_full_description = 12
     */
    includeFullDescription?: boolean;
    /**
     * @generated from protobuf field: optional bool include_included_items = 13
     */
    includeIncludedItems?: boolean;
    /**
     * @generated from protobuf field: optional StoreBrowseItemDataRequest included_item_data_request = 14
     */
    includedItemDataRequest?: StoreBrowseItemDataRequest;
    /**
     * @generated from protobuf field: optional bool include_assets_without_overrides = 15
     */
    includeAssetsWithoutOverrides?: boolean;
    /**
     * @generated from protobuf field: optional bool apply_user_filters = 16
     */
    applyUserFilters?: boolean;
    /**
     * @generated from protobuf field: optional bool include_links = 17
     */
    includeLinks?: boolean;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreGameRating
 */
export interface StoreGameRating {
    /**
     * @generated from protobuf field: optional string type = 1
     */
    type?: string;
    /**
     * @generated from protobuf field: optional string rating = 2
     */
    rating?: string;
    /**
     * @generated from protobuf field: repeated string descriptors = 3
     */
    descriptors: string[];
    /**
     * @generated from protobuf field: optional string interactive_elements = 4
     */
    interactiveElements?: string;
    /**
     * @generated from protobuf field: optional int32 required_age = 10
     */
    requiredAge?: number;
    /**
     * @generated from protobuf field: optional bool use_age_gate = 11
     */
    useAgeGate?: boolean;
    /**
     * @generated from protobuf field: optional string image_url = 20
     */
    imageUrl?: string;
    /**
     * @generated from protobuf field: optional string image_target = 21
     */
    imageTarget?: string;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem
 */
export interface StoreItem {
    /**
     * @generated from protobuf field: optional int32 item_type = 1
     */
    itemType?: number;
    /**
     * @generated from protobuf field: optional uint32 id = 2
     */
    id?: number;
    /**
     * @generated from protobuf field: optional uint32 success = 3
     */
    success?: number;
    /**
     * @generated from protobuf field: optional bool visible = 4
     */
    visible?: boolean;
    /**
     * @generated from protobuf field: optional bool unvailable_for_country_restriction = 5
     */
    unvailableForCountryRestriction?: boolean;
    /**
     * @generated from protobuf field: optional string name = 6
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string store_url_path = 7
     */
    storeUrlPath?: string;
    /**
     * @generated from protobuf field: optional uint32 appid = 9
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional int32 type = 10
     */
    type?: number;
    /**
     * @generated from protobuf field: repeated int32 included_types = 11
     */
    includedTypes: number[];
    /**
     * @generated from protobuf field: repeated uint32 included_appids = 12
     */
    includedAppids: number[];
    /**
     * @generated from protobuf field: optional bool is_free = 13
     */
    isFree?: boolean;
    /**
     * @generated from protobuf field: optional bool is_early_access = 14
     */
    isEarlyAccess?: boolean;
    /**
     * @generated from protobuf field: optional StoreItem_RelatedItems related_items = 15
     */
    relatedItems?: StoreItem_RelatedItems;
    /**
     * @generated from protobuf field: optional StoreItem_IncludedItems included_items = 16
     */
    includedItems?: StoreItem_IncludedItems;
    /**
     * @generated from protobuf field: repeated int32 content_descriptorids = 20
     */
    contentDescriptorids: number[];
    /**
     * @generated from protobuf field: repeated uint32 tagids = 21
     */
    tagids: number[];
    /**
     * @generated from protobuf field: optional StoreItem_Categories categories = 22
     */
    categories?: StoreItem_Categories;
    /**
     * @generated from protobuf field: optional StoreItem_Reviews reviews = 23
     */
    reviews?: StoreItem_Reviews;
    /**
     * @generated from protobuf field: optional StoreItem_BasicInfo basic_info = 24
     */
    basicInfo?: StoreItem_BasicInfo;
    /**
     * @generated from protobuf field: repeated StoreItem_Tag tags = 25
     */
    tags: StoreItem_Tag[];
    /**
     * @generated from protobuf field: optional StoreItem_Assets assets = 30
     */
    assets?: StoreItem_Assets;
    /**
     * @generated from protobuf field: optional StoreItem_ReleaseInfo release = 31
     */
    release?: StoreItem_ReleaseInfo;
    /**
     * @generated from protobuf field: optional StoreItem_Platforms platforms = 32
     */
    platforms?: StoreItem_Platforms;
    /**
     * @generated from protobuf field: optional StoreGameRating game_rating = 33
     */
    gameRating?: StoreGameRating;
    /**
     * @generated from protobuf field: optional bool is_coming_soon = 34
     */
    isComingSoon?: boolean;
    /**
     * @generated from protobuf field: optional StoreItem_PurchaseOption best_purchase_option = 40
     */
    bestPurchaseOption?: StoreItem_PurchaseOption;
    /**
     * @generated from protobuf field: repeated StoreItem_PurchaseOption purchase_options = 41
     */
    purchaseOptions: StoreItem_PurchaseOption[];
    /**
     * @generated from protobuf field: repeated StoreItem_PurchaseOption accessories = 42
     */
    accessories: StoreItem_PurchaseOption[];
    /**
     * @generated from protobuf field: optional StoreItem_PurchaseOption self_purchase_option = 43
     */
    selfPurchaseOption?: StoreItem_PurchaseOption;
    /**
     * @generated from protobuf field: optional StoreItem_Screenshots screenshots = 50
     */
    screenshots?: StoreItem_Screenshots;
    /**
     * @generated from protobuf field: optional StoreItem_Trailers trailers = 51
     */
    trailers?: StoreItem_Trailers;
    /**
     * @generated from protobuf field: repeated StoreItem_SupportedLanguage supported_languages = 52
     */
    supportedLanguages: StoreItem_SupportedLanguage[];
    /**
     * @generated from protobuf field: optional string store_url_path_override = 53
     */
    storeUrlPathOverride?: string;
    /**
     * @generated from protobuf field: optional StoreItem_FreeWeekend free_weekend = 54
     */
    freeWeekend?: StoreItem_FreeWeekend;
    /**
     * @generated from protobuf field: optional bool unlisted = 55
     */
    unlisted?: boolean;
    /**
     * @generated from protobuf field: optional uint32 game_count = 56
     */
    gameCount?: number;
    /**
     * @generated from protobuf field: optional string internal_name = 57
     */
    internalName?: string;
    /**
     * @generated from protobuf field: optional string full_description = 58
     */
    fullDescription?: string;
    /**
     * @generated from protobuf field: optional bool is_free_temporarily = 59
     */
    isFreeTemporarily?: boolean;
    /**
     * @generated from protobuf field: optional StoreItem_Assets assets_without_overrides = 60
     */
    assetsWithoutOverrides?: StoreItem_Assets;
    /**
     * @generated from protobuf field: optional StoreBrowseFilterFailure user_filter_failure = 70
     */
    userFilterFailure?: StoreBrowseFilterFailure;
    /**
     * @generated from protobuf field: repeated StoreItem_Link links = 71
     */
    links: StoreItem_Link[];
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Assets
 */
export interface StoreItem_Assets {
    /**
     * @generated from protobuf field: optional string asset_url_format = 1
     */
    assetUrlFormat?: string;
    /**
     * @generated from protobuf field: optional string main_capsule = 2
     */
    mainCapsule?: string;
    /**
     * @generated from protobuf field: optional string small_capsule = 3
     */
    smallCapsule?: string;
    /**
     * @generated from protobuf field: optional string header = 4
     */
    header?: string;
    /**
     * @generated from protobuf field: optional string package_header = 5
     */
    packageHeader?: string;
    /**
     * @generated from protobuf field: optional string page_background = 6
     */
    pageBackground?: string;
    /**
     * @generated from protobuf field: optional string hero_capsule = 7
     */
    heroCapsule?: string;
    /**
     * @generated from protobuf field: optional string hero_capsule_2x = 8
     */
    heroCapsule2X?: string;
    /**
     * @generated from protobuf field: optional string library_capsule = 9
     */
    libraryCapsule?: string;
    /**
     * @generated from protobuf field: optional string library_capsule_2x = 10
     */
    libraryCapsule2X?: string;
    /**
     * @generated from protobuf field: optional string library_hero = 11
     */
    libraryHero?: string;
    /**
     * @generated from protobuf field: optional string library_hero_2x = 12
     */
    libraryHero2X?: string;
    /**
     * @generated from protobuf field: optional string community_icon = 13
     */
    communityIcon?: string;
    /**
     * @generated from protobuf field: optional string clan_avatar = 14
     */
    clanAvatar?: string;
    /**
     * @generated from protobuf field: optional string page_background_path = 15
     */
    pageBackgroundPath?: string;
    /**
     * @generated from protobuf field: optional string raw_page_background = 16
     */
    rawPageBackground?: string;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_BasicInfo
 */
export interface StoreItem_BasicInfo {
    /**
     * @generated from protobuf field: optional string short_description = 1
     */
    shortDescription?: string;
    /**
     * @generated from protobuf field: repeated StoreItem_BasicInfo_CreatorHomeLink publishers = 2
     */
    publishers: StoreItem_BasicInfo_CreatorHomeLink[];
    /**
     * repeated string publishers = 2;
     *
     * @generated from protobuf field: repeated StoreItem_BasicInfo_CreatorHomeLink developers = 3
     */
    developers: StoreItem_BasicInfo_CreatorHomeLink[];
    /**
     * repeated string developers = 3;
     *
     * @generated from protobuf field: repeated StoreItem_BasicInfo_CreatorHomeLink franchises = 4
     */
    franchises: StoreItem_BasicInfo_CreatorHomeLink[];
    /**
     * repeated string franchises = 4;
     *
     * @generated from protobuf field: optional string capsule_headline = 5
     */
    capsuleHeadline?: string;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_BasicInfo_CreatorHomeLink
 */
export interface StoreItem_BasicInfo_CreatorHomeLink {
    /**
     * @generated from protobuf field: optional string name = 1
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint32 creator_clan_account_id = 2
     */
    creatorClanAccountId?: number;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Categories
 */
export interface StoreItem_Categories {
    /**
     * @generated from protobuf field: repeated uint32 supported_player_categoryids = 2
     */
    supportedPlayerCategoryids: number[];
    /**
     * @generated from protobuf field: repeated uint32 feature_categoryids = 3
     */
    featureCategoryids: number[];
    /**
     * @generated from protobuf field: repeated uint32 controller_categoryids = 4
     */
    controllerCategoryids: number[];
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_FreeWeekend
 */
export interface StoreItem_FreeWeekend {
    /**
     * @generated from protobuf field: optional uint32 start_time = 1
     */
    startTime?: number;
    /**
     * @generated from protobuf field: optional uint32 end_time = 2
     */
    endTime?: number;
    /**
     * @generated from protobuf field: optional string text = 3
     */
    text?: string;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_IncludedItems
 */
export interface StoreItem_IncludedItems {
    /**
     * @generated from protobuf field: repeated StoreItem included_apps = 1
     */
    includedApps: StoreItem[];
    /**
     * @generated from protobuf field: repeated StoreItem included_packages = 2
     */
    includedPackages: StoreItem[];
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Link
 */
export interface StoreItem_Link {
    /**
     * @generated from protobuf field: optional int32 link_type = 1
     */
    linkType?: number;
    /**
     * @generated from protobuf field: optional string url = 2
     */
    url?: string;
    /**
     * @generated from protobuf field: optional string text = 3
     */
    text?: string;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Platforms
 */
export interface StoreItem_Platforms {
    /**
     * @generated from protobuf field: optional bool windows = 1
     */
    windows?: boolean;
    /**
     * @generated from protobuf field: optional bool mac = 2
     */
    mac?: boolean;
    /**
     * @generated from protobuf field: optional bool linux = 3
     */
    linux?: boolean;
    /**
     * optional bool steamos_linux = 3;
     *
     * @generated from protobuf field: optional StoreItem_Platforms_VRSupport vr_support = 10
     */
    vrSupport?: StoreItem_Platforms_VRSupport;
    /**
     * @generated from protobuf field: optional int32 steam_deck_compat_category = 11
     */
    steamDeckCompatCategory?: number;
    /**
     * @generated from protobuf field: optional int32 steam_os_compat_category = 12
     */
    steamOsCompatCategory?: number;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Platforms_VRSupport
 */
export interface StoreItem_Platforms_VRSupport {
    /**
     * @generated from protobuf field: optional bool vrhmd = 1
     */
    vrhmd?: boolean;
    /**
     * @generated from protobuf field: optional bool vrhmd_only = 2
     */
    vrhmdOnly?: boolean;
    /**
     * @generated from protobuf field: optional bool htc_vive = 40
     */
    htcVive?: boolean;
    /**
     * @generated from protobuf field: optional bool oculus_rift = 41
     */
    oculusRift?: boolean;
    /**
     * @generated from protobuf field: optional bool windows_mr = 42
     */
    windowsMr?: boolean;
    /**
     * @generated from protobuf field: optional bool valve_index = 43
     */
    valveIndex?: boolean;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_PurchaseOption
 */
export interface StoreItem_PurchaseOption {
    /**
     * @generated from protobuf field: optional int32 packageid = 1
     */
    packageid?: number;
    /**
     * @generated from protobuf field: optional int32 bundleid = 2
     */
    bundleid?: number;
    /**
     * @generated from protobuf field: optional string purchase_option_name = 3
     */
    purchaseOptionName?: string;
    /**
     * @generated from protobuf field: optional int64 final_price_in_cents = 5
     */
    finalPriceInCents?: bigint;
    /**
     * @generated from protobuf field: optional int64 original_price_in_cents = 6
     */
    originalPriceInCents?: bigint;
    /**
     * @generated from protobuf field: optional int64 user_final_price_in_cents = 7
     */
    userFinalPriceInCents?: bigint;
    /**
     * @generated from protobuf field: optional string formatted_final_price = 8
     */
    formattedFinalPrice?: string;
    /**
     * @generated from protobuf field: optional string formatted_original_price = 9
     */
    formattedOriginalPrice?: string;
    /**
     * @generated from protobuf field: optional int32 discount_pct = 10
     */
    discountPct?: number;
    /**
     * @generated from protobuf field: optional int32 user_discount_pct = 11
     */
    userDiscountPct?: number;
    /**
     * @generated from protobuf field: optional int32 bundle_discount_pct = 12
     */
    bundleDiscountPct?: number;
    /**
     * @generated from protobuf field: optional bool is_free_to_keep = 13
     */
    isFreeToKeep?: boolean;
    /**
     * @generated from protobuf field: optional int64 price_before_bundle_discount = 14
     */
    priceBeforeBundleDiscount?: bigint;
    /**
     * @generated from protobuf field: optional string formatted_price_before_bundle_discount = 15
     */
    formattedPriceBeforeBundleDiscount?: string;
    /**
     * @generated from protobuf field: repeated StoreItem_PurchaseOption_Discount active_discounts = 20
     */
    activeDiscounts: StoreItem_PurchaseOption_Discount[];
    /**
     * @generated from protobuf field: repeated StoreItem_PurchaseOption_Discount user_active_discounts = 21
     */
    userActiveDiscounts: StoreItem_PurchaseOption_Discount[];
    /**
     * @generated from protobuf field: repeated StoreItem_PurchaseOption_Discount inactive_discounts = 22
     */
    inactiveDiscounts: StoreItem_PurchaseOption_Discount[];
    /**
     * @generated from protobuf field: optional bool user_can_purchase = 30
     */
    userCanPurchase?: boolean;
    /**
     * @generated from protobuf field: optional bool user_can_purchase_as_gift = 31
     */
    userCanPurchaseAsGift?: boolean;
    /**
     * @generated from protobuf field: optional bool is_commercial_license = 40
     */
    isCommercialLicense?: boolean;
    /**
     * @generated from protobuf field: optional bool should_suppress_discount_pct = 41
     */
    shouldSuppressDiscountPct?: boolean;
    /**
     * @generated from protobuf field: optional bool hide_discount_pct_for_compliance = 42 [default = false]
     */
    hideDiscountPctForCompliance?: boolean;
    /**
     * @generated from protobuf field: optional int32 included_game_count = 43 [default = 1]
     */
    includedGameCount?: number;
    /**
     * @generated from protobuf field: optional int64 lowest_recent_price_in_cents = 44
     */
    lowestRecentPriceInCents?: bigint;
    /**
     * @generated from protobuf field: optional bool requires_shipping = 45
     */
    requiresShipping?: boolean;
    /**
     * @generated from protobuf field: optional StoreItem_PurchaseOption_RecurrenceInfo recurrence_info = 46
     */
    recurrenceInfo?: StoreItem_PurchaseOption_RecurrenceInfo;
    /**
     * @generated from protobuf field: optional uint32 free_to_keep_ends = 47
     */
    freeToKeepEnds?: number;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_PurchaseOption_Discount
 */
export interface StoreItem_PurchaseOption_Discount {
    /**
     * @generated from protobuf field: optional int64 discount_amount = 1
     */
    discountAmount?: bigint;
    /**
     * @generated from protobuf field: optional string discount_description = 2
     */
    discountDescription?: string;
    /**
     * @generated from protobuf field: optional uint32 discount_end_date = 3
     */
    discountEndDate?: number;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_PurchaseOption_RecurrenceInfo
 */
export interface StoreItem_PurchaseOption_RecurrenceInfo {
    /**
     * @generated from protobuf field: optional int32 packageid = 1
     */
    packageid?: number;
    /**
     * @generated from protobuf field: optional int32 billing_agreement_type = 2
     */
    billingAgreementType?: number;
    /**
     * @generated from protobuf field: optional int32 renewal_time_unit = 3
     */
    renewalTimeUnit?: number;
    /**
     * @generated from protobuf field: optional int32 renewal_time_period = 4
     */
    renewalTimePeriod?: number;
    /**
     * @generated from protobuf field: optional int64 renewal_price_in_cents = 5
     */
    renewalPriceInCents?: bigint;
    /**
     * @generated from protobuf field: optional string formatted_renewal_price = 6
     */
    formattedRenewalPrice?: string;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_RelatedItems
 */
export interface StoreItem_RelatedItems {
    /**
     * @generated from protobuf field: optional uint32 parent_appid = 1
     */
    parentAppid?: number;
    /**
     * @generated from protobuf field: repeated uint32 demo_appid = 2
     */
    demoAppid: number[];
    /**
     * @generated from protobuf field: repeated uint32 standalone_demo_appid = 3
     */
    standaloneDemoAppid: number[];
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_ReleaseInfo
 */
export interface StoreItem_ReleaseInfo {
    /**
     * @generated from protobuf field: optional uint32 steam_release_date = 1
     */
    steamReleaseDate?: number;
    /**
     * @generated from protobuf field: optional uint32 original_release_date = 2
     */
    originalReleaseDate?: number;
    /**
     * @generated from protobuf field: optional uint32 original_steam_release_date = 3
     */
    originalSteamReleaseDate?: number;
    /**
     * @generated from protobuf field: optional bool is_coming_soon = 4
     */
    isComingSoon?: boolean;
    /**
     * @generated from protobuf field: optional bool is_preload = 5
     */
    isPreload?: boolean;
    /**
     * @generated from protobuf field: optional string custom_release_date_message = 6
     */
    customReleaseDateMessage?: string;
    /**
     * @generated from protobuf field: optional bool is_abridged_release_date = 7
     */
    isAbridgedReleaseDate?: boolean;
    /**
     * @generated from protobuf field: optional string coming_soon_display = 8
     */
    comingSoonDisplay?: string;
    /**
     * @generated from protobuf field: optional bool is_early_access = 10
     */
    isEarlyAccess?: boolean;
    /**
     * @generated from protobuf field: optional uint32 mac_release_date = 20
     */
    macReleaseDate?: number;
    /**
     * @generated from protobuf field: optional uint32 linux_release_date = 21
     */
    linuxReleaseDate?: number;
    /**
     * @generated from protobuf field: optional bool limited_launch_active = 22
     */
    limitedLaunchActive?: boolean;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Reviews
 */
export interface StoreItem_Reviews {
    /**
     * @generated from protobuf field: optional StoreItem_Reviews_StoreReviewSummary summary_filtered = 1
     */
    summaryFiltered?: StoreItem_Reviews_StoreReviewSummary;
    /**
     * @generated from protobuf field: optional StoreItem_Reviews_StoreReviewSummary summary_unfiltered = 2
     */
    summaryUnfiltered?: StoreItem_Reviews_StoreReviewSummary;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Reviews_StoreReviewSummary
 */
export interface StoreItem_Reviews_StoreReviewSummary {
    /**
     * @generated from protobuf field: optional uint32 review_count = 1
     */
    reviewCount?: number;
    /**
     * @generated from protobuf field: optional int32 percent_positive = 2
     */
    percentPositive?: number;
    /**
     * @generated from protobuf field: optional int32 review_score = 3
     */
    reviewScore?: number;
    /**
     * @generated from protobuf field: optional string review_score_label = 4
     */
    reviewScoreLabel?: string;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Screenshots
 */
export interface StoreItem_Screenshots {
    /**
     * @generated from protobuf field: repeated StoreItem_Screenshots_Screenshot all_ages_screenshots = 2
     */
    allAgesScreenshots: StoreItem_Screenshots_Screenshot[];
    /**
     * @generated from protobuf field: repeated StoreItem_Screenshots_Screenshot mature_content_screenshots = 3
     */
    matureContentScreenshots: StoreItem_Screenshots_Screenshot[];
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Screenshots_Screenshot
 */
export interface StoreItem_Screenshots_Screenshot {
    /**
     * @generated from protobuf field: optional string filename = 1
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional int32 ordinal = 2
     */
    ordinal?: number;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_SupportedLanguage
 */
export interface StoreItem_SupportedLanguage {
    /**
     * @generated from protobuf field: optional int32 elanguage = 1 [default = -1]
     */
    elanguage?: number;
    /**
     * @generated from protobuf field: optional bool supported = 2
     */
    supported?: boolean;
    /**
     * @generated from protobuf field: optional bool full_audio = 3
     */
    fullAudio?: boolean;
    /**
     * @generated from protobuf field: optional bool subtitles = 4
     */
    subtitles?: boolean;
    /**
     * @generated from protobuf field: optional int32 eadditionallanguage = 5 [default = -1]
     */
    eadditionallanguage?: number;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Tag
 */
export interface StoreItem_Tag {
    /**
     * @generated from protobuf field: optional uint32 tagid = 1
     */
    tagid?: number;
    /**
     * @generated from protobuf field: optional uint32 weight = 2
     */
    weight?: number;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Trailers
 */
export interface StoreItem_Trailers {
    /**
     * @generated from protobuf field: repeated StoreItem_Trailers_Trailer highlights = 1
     */
    highlights: StoreItem_Trailers_Trailer[];
    /**
     * @generated from protobuf field: repeated StoreItem_Trailers_Trailer other_trailers = 2
     */
    otherTrailers: StoreItem_Trailers_Trailer[];
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Trailers_Trailer
 */
export interface StoreItem_Trailers_Trailer {
    /**
     * @generated from protobuf field: optional string trailer_name = 1
     */
    trailerName?: string;
    /**
     * @generated from protobuf field: optional string trailer_url_format = 2
     */
    trailerUrlFormat?: string;
    /**
     * @generated from protobuf field: repeated StoreItem_Trailers_VideoSource trailer_480p = 3
     */
    trailer480P: StoreItem_Trailers_VideoSource[];
    /**
     * @generated from protobuf field: repeated StoreItem_Trailers_VideoSource trailer_max = 4
     */
    trailerMax: StoreItem_Trailers_VideoSource[];
    /**
     * @generated from protobuf field: repeated StoreItem_Trailers_VideoSource microtrailer = 5
     */
    microtrailer: StoreItem_Trailers_VideoSource[];
    /**
     * @generated from protobuf field: optional string screenshot_medium = 10
     */
    screenshotMedium?: string;
    /**
     * @generated from protobuf field: optional string screenshot_full = 11
     */
    screenshotFull?: string;
    /**
     * @generated from protobuf field: optional int32 trailer_base_id = 12
     */
    trailerBaseId?: number;
    /**
     * @generated from protobuf field: optional int32 trailer_category = 13
     */
    trailerCategory?: number;
    /**
     * @generated from protobuf field: optional bool all_ages = 14
     */
    allAges?: boolean;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, Store, StoreAppSimilarity, StoreBrowse, StoreQuery, StoreTopSellers, UserStoreVisit, Wishlist
 *
 * @generated from protobuf message StoreItem_Trailers_VideoSource
 */
export interface StoreItem_Trailers_VideoSource {
    /**
     * @generated from protobuf field: optional string filename = 1
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional string type = 2
     */
    type?: string;
}
/**
 * Used by: Checkout, MarketingMessages, PartnerStoreBrowse, SteamCharts, StoreAppSimilarity, StoreBrowse, StoreQuery, UserStoreVisit
 *
 * @generated from protobuf message StoreItemID
 */
export interface StoreItemID {
    /**
     * @generated from protobuf field: optional uint32 appid = 1
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 packageid = 2
     */
    packageid?: number;
    /**
     * @generated from protobuf field: optional uint32 bundleid = 3
     */
    bundleid?: number;
    /**
     * @generated from protobuf field: optional uint32 tagid = 4
     */
    tagid?: number;
    /**
     * @generated from protobuf field: optional uint32 creatorid = 5
     */
    creatorid?: number;
    /**
     * @generated from protobuf field: optional uint32 hubcategoryid = 6
     */
    hubcategoryid?: number;
}
/**
 * Used by: Player, PlayerClient, Store, StoreClient
 *
 * @generated from protobuf message UserContentDescriptorPreferences
 */
export interface UserContentDescriptorPreferences {
    /**
     * @generated from protobuf field: repeated UserContentDescriptorPreferences_ContentDescriptor content_descriptors_to_exclude = 1
     */
    contentDescriptorsToExclude: UserContentDescriptorPreferences_ContentDescriptor[];
}
/**
 * Used by: Player, PlayerClient, Store, StoreClient
 *
 * @generated from protobuf message UserContentDescriptorPreferences_ContentDescriptor
 */
export interface UserContentDescriptorPreferences_ContentDescriptor {
    /**
     * @generated from protobuf field: optional uint32 content_descriptorid = 1
     */
    contentDescriptorid?: number;
    /**
     * @generated from protobuf field: optional uint32 timestamp_added = 2
     */
    timestampAdded?: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class CAppBootstrapData$Type extends MessageType<CAppBootstrapData> {
    constructor() {
        super("CAppBootstrapData", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "user_tag", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CAppBootstrapData>): CAppBootstrapData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userTag = [];
        if (value !== undefined)
            reflectionMergePartial<CAppBootstrapData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CAppBootstrapData): CAppBootstrapData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional bool hidden */ 2:
                    message.hidden = reader.bool();
                    break;
                case /* repeated string user_tag */ 3:
                    message.userTag.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CAppBootstrapData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional bool hidden = 2; */
        if (message.hidden !== undefined)
            writer.tag(2, WireType.Varint).bool(message.hidden);
        /* repeated string user_tag = 3; */
        for (let i = 0; i < message.userTag.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.userTag[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CAppBootstrapData
 */
export const CAppBootstrapData = new CAppBootstrapData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CAppOverview$Type extends MessageType<CAppOverview> {
    constructor() {
        super("CAppOverview", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "visible_in_game_list", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "subscribed_to", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "sort_as", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "app_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 13, name: "mru_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "rt_recent_activity_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "minutes_playtime_forever", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "minutes_playtime_last_two_weeks", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "rt_last_time_played", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "store_tag", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "association", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CAppOverview_AppAssociation },
            { no: 23, name: "store_category", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "rt_original_release_date", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "rt_steam_release_date", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 27, name: "icon_hash", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "logo_hash", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 31, name: "controller_support", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 32, name: "vr_supported", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 36, name: "metacritic_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 37, name: "size_on_disk", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 38, name: "third_party_mod", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 39, name: "icon_data", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 40, name: "icon_data_format", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "gameid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 42, name: "library_capsule_filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 43, name: "per_client_data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CAppOverview_PerClientData },
            { no: 44, name: "most_available_clientid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 45, name: "selected_clientid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 46, name: "rt_store_asset_mtime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 47, name: "rt_custom_image_mtime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 48, name: "optional_parent_app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 49, name: "owner_account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 50, name: "compat_mapping_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 51, name: "compat_mapping_priority", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 52, name: "compat_mapping_tool_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 53, name: "review_score_with_bombs", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 54, name: "review_percentage_with_bombs", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 55, name: "review_score_without_bombs", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 56, name: "review_percentage_without_bombs", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 57, name: "library_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 58, name: "vr_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 59, name: "mastersub_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 60, name: "mastersub_includedwith_logo", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 61, name: "compat_allowlist_setting", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 62, name: "site_license_site_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 63, name: "shortcut_override_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 65, name: "rt_last_time_locally_played", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 66, name: "rt_purchased_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 67, name: "header_filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 68, name: "local_cache_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 72, name: "number_of_copies", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 73, name: "steam_hw_compat_category_packed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 74, name: "album_cover_hash", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CAppOverview>): CAppOverview {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.storeTag = [];
        message.association = [];
        message.storeCategory = [];
        message.perClientData = [];
        if (value !== undefined)
            reflectionMergePartial<CAppOverview>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CAppOverview): CAppOverview {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional string display_name */ 2:
                    message.displayName = reader.string();
                    break;
                case /* optional bool visible_in_game_list */ 4:
                    message.visibleInGameList = reader.bool();
                    break;
                case /* optional bool subscribed_to */ 5:
                    message.subscribedTo = reader.bool();
                    break;
                case /* optional string sort_as */ 6:
                    message.sortAs = reader.string();
                    break;
                case /* optional int32 app_type */ 7:
                    message.appType = reader.int32();
                    break;
                case /* optional uint32 mru_index */ 13:
                    message.mruIndex = reader.uint32();
                    break;
                case /* optional uint32 rt_recent_activity_time = 14 [default = 0] */ 14:
                    message.rtRecentActivityTime = reader.uint32();
                    break;
                case /* optional uint32 minutes_playtime_forever = 16 [default = 0] */ 16:
                    message.minutesPlaytimeForever = reader.uint32();
                    break;
                case /* optional uint32 minutes_playtime_last_two_weeks = 17 [default = 0] */ 17:
                    message.minutesPlaytimeLastTwoWeeks = reader.uint32();
                    break;
                case /* optional uint32 rt_last_time_played = 18 [default = 0] */ 18:
                    message.rtLastTimePlayed = reader.uint32();
                    break;
                case /* repeated uint32 store_tag */ 19:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.storeTag.push(reader.uint32());
                    else
                        message.storeTag.push(reader.uint32());
                    break;
                case /* repeated CAppOverview_AppAssociation association */ 20:
                    message.association.push(CAppOverview_AppAssociation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 store_category */ 23:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.storeCategory.push(reader.uint32());
                    else
                        message.storeCategory.push(reader.uint32());
                    break;
                case /* optional uint32 rt_original_release_date = 25 [default = 0] */ 25:
                    message.rtOriginalReleaseDate = reader.uint32();
                    break;
                case /* optional uint32 rt_steam_release_date = 26 [default = 0] */ 26:
                    message.rtSteamReleaseDate = reader.uint32();
                    break;
                case /* optional string icon_hash */ 27:
                    message.iconHash = reader.string();
                    break;
                case /* optional string logo_hash */ 30:
                    message.logoHash = reader.string();
                    break;
                case /* optional int32 controller_support */ 31:
                    message.controllerSupport = reader.int32();
                    break;
                case /* optional bool vr_supported */ 32:
                    message.vrSupported = reader.bool();
                    break;
                case /* optional uint32 metacritic_score */ 36:
                    message.metacriticScore = reader.uint32();
                    break;
                case /* optional uint64 size_on_disk */ 37:
                    message.sizeOnDisk = reader.uint64().toBigInt();
                    break;
                case /* optional bool third_party_mod */ 38:
                    message.thirdPartyMod = reader.bool();
                    break;
                case /* optional string icon_data */ 39:
                    message.iconData = reader.string();
                    break;
                case /* optional string icon_data_format */ 40:
                    message.iconDataFormat = reader.string();
                    break;
                case /* optional string gameid */ 41:
                    message.gameid = reader.string();
                    break;
                case /* optional string library_capsule_filename */ 42:
                    message.libraryCapsuleFilename = reader.string();
                    break;
                case /* repeated CAppOverview_PerClientData per_client_data */ 43:
                    message.perClientData.push(CAppOverview_PerClientData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 most_available_clientid = 44 [default = 0] */ 44:
                    message.mostAvailableClientid = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 selected_clientid = 45 [default = 0] */ 45:
                    message.selectedClientid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 rt_store_asset_mtime */ 46:
                    message.rtStoreAssetMtime = reader.uint32();
                    break;
                case /* optional uint32 rt_custom_image_mtime */ 47:
                    message.rtCustomImageMtime = reader.uint32();
                    break;
                case /* optional uint32 optional_parent_app_id */ 48:
                    message.optionalParentAppId = reader.uint32();
                    break;
                case /* optional uint32 owner_account_id */ 49:
                    message.ownerAccountId = reader.uint32();
                    break;
                case /* optional bool compat_mapping_enabled */ 50:
                    message.compatMappingEnabled = reader.bool();
                    break;
                case /* optional uint32 compat_mapping_priority */ 51:
                    message.compatMappingPriority = reader.uint32();
                    break;
                case /* optional string compat_mapping_tool_name */ 52:
                    message.compatMappingToolName = reader.string();
                    break;
                case /* optional uint32 review_score_with_bombs = 53 [default = 0] */ 53:
                    message.reviewScoreWithBombs = reader.uint32();
                    break;
                case /* optional uint32 review_percentage_with_bombs = 54 [default = 0] */ 54:
                    message.reviewPercentageWithBombs = reader.uint32();
                    break;
                case /* optional uint32 review_score_without_bombs = 55 [default = 0] */ 55:
                    message.reviewScoreWithoutBombs = reader.uint32();
                    break;
                case /* optional uint32 review_percentage_without_bombs = 56 [default = 0] */ 56:
                    message.reviewPercentageWithoutBombs = reader.uint32();
                    break;
                case /* optional string library_id */ 57:
                    message.libraryId = reader.string();
                    break;
                case /* optional bool vr_only */ 58:
                    message.vrOnly = reader.bool();
                    break;
                case /* optional uint32 mastersub_appid */ 59:
                    message.mastersubAppid = reader.uint32();
                    break;
                case /* optional string mastersub_includedwith_logo */ 60:
                    message.mastersubIncludedwithLogo = reader.string();
                    break;
                case /* optional uint32 compat_allowlist_setting = 61 [default = 0] */ 61:
                    message.compatAllowlistSetting = reader.uint32();
                    break;
                case /* optional string site_license_site_name */ 62:
                    message.siteLicenseSiteName = reader.string();
                    break;
                case /* optional uint32 shortcut_override_appid */ 63:
                    message.shortcutOverrideAppid = reader.uint32();
                    break;
                case /* optional uint32 rt_last_time_locally_played */ 65:
                    message.rtLastTimeLocallyPlayed = reader.uint32();
                    break;
                case /* optional uint32 rt_purchased_time */ 66:
                    message.rtPurchasedTime = reader.uint32();
                    break;
                case /* optional string header_filename */ 67:
                    message.headerFilename = reader.string();
                    break;
                case /* optional uint32 local_cache_version */ 68:
                    message.localCacheVersion = reader.uint32();
                    break;
                case /* optional uint32 number_of_copies = 72 [default = 1] */ 72:
                    message.numberOfCopies = reader.uint32();
                    break;
                case /* optional uint32 steam_hw_compat_category_packed = 73 [default = 0] */ 73:
                    message.steamHwCompatCategoryPacked = reader.uint32();
                    break;
                case /* optional string album_cover_hash */ 74:
                    message.albumCoverHash = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CAppOverview, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional string display_name = 2; */
        if (message.displayName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.displayName);
        /* optional bool visible_in_game_list = 4; */
        if (message.visibleInGameList !== undefined)
            writer.tag(4, WireType.Varint).bool(message.visibleInGameList);
        /* optional bool subscribed_to = 5; */
        if (message.subscribedTo !== undefined)
            writer.tag(5, WireType.Varint).bool(message.subscribedTo);
        /* optional string sort_as = 6; */
        if (message.sortAs !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.sortAs);
        /* optional int32 app_type = 7; */
        if (message.appType !== undefined)
            writer.tag(7, WireType.Varint).int32(message.appType);
        /* optional uint32 mru_index = 13; */
        if (message.mruIndex !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.mruIndex);
        /* optional uint32 rt_recent_activity_time = 14 [default = 0]; */
        if (message.rtRecentActivityTime !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.rtRecentActivityTime);
        /* optional uint32 minutes_playtime_forever = 16 [default = 0]; */
        if (message.minutesPlaytimeForever !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.minutesPlaytimeForever);
        /* optional uint32 minutes_playtime_last_two_weeks = 17 [default = 0]; */
        if (message.minutesPlaytimeLastTwoWeeks !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.minutesPlaytimeLastTwoWeeks);
        /* optional uint32 rt_last_time_played = 18 [default = 0]; */
        if (message.rtLastTimePlayed !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.rtLastTimePlayed);
        /* repeated uint32 store_tag = 19; */
        for (let i = 0; i < message.storeTag.length; i++)
            writer.tag(19, WireType.Varint).uint32(message.storeTag[i]);
        /* repeated CAppOverview_AppAssociation association = 20; */
        for (let i = 0; i < message.association.length; i++)
            CAppOverview_AppAssociation.internalBinaryWrite(message.association[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 store_category = 23; */
        for (let i = 0; i < message.storeCategory.length; i++)
            writer.tag(23, WireType.Varint).uint32(message.storeCategory[i]);
        /* optional uint32 rt_original_release_date = 25 [default = 0]; */
        if (message.rtOriginalReleaseDate !== undefined)
            writer.tag(25, WireType.Varint).uint32(message.rtOriginalReleaseDate);
        /* optional uint32 rt_steam_release_date = 26 [default = 0]; */
        if (message.rtSteamReleaseDate !== undefined)
            writer.tag(26, WireType.Varint).uint32(message.rtSteamReleaseDate);
        /* optional string icon_hash = 27; */
        if (message.iconHash !== undefined)
            writer.tag(27, WireType.LengthDelimited).string(message.iconHash);
        /* optional string logo_hash = 30; */
        if (message.logoHash !== undefined)
            writer.tag(30, WireType.LengthDelimited).string(message.logoHash);
        /* optional int32 controller_support = 31; */
        if (message.controllerSupport !== undefined)
            writer.tag(31, WireType.Varint).int32(message.controllerSupport);
        /* optional bool vr_supported = 32; */
        if (message.vrSupported !== undefined)
            writer.tag(32, WireType.Varint).bool(message.vrSupported);
        /* optional uint32 metacritic_score = 36; */
        if (message.metacriticScore !== undefined)
            writer.tag(36, WireType.Varint).uint32(message.metacriticScore);
        /* optional uint64 size_on_disk = 37; */
        if (message.sizeOnDisk !== undefined)
            writer.tag(37, WireType.Varint).uint64(message.sizeOnDisk);
        /* optional bool third_party_mod = 38; */
        if (message.thirdPartyMod !== undefined)
            writer.tag(38, WireType.Varint).bool(message.thirdPartyMod);
        /* optional string icon_data = 39; */
        if (message.iconData !== undefined)
            writer.tag(39, WireType.LengthDelimited).string(message.iconData);
        /* optional string icon_data_format = 40; */
        if (message.iconDataFormat !== undefined)
            writer.tag(40, WireType.LengthDelimited).string(message.iconDataFormat);
        /* optional string gameid = 41; */
        if (message.gameid !== undefined)
            writer.tag(41, WireType.LengthDelimited).string(message.gameid);
        /* optional string library_capsule_filename = 42; */
        if (message.libraryCapsuleFilename !== undefined)
            writer.tag(42, WireType.LengthDelimited).string(message.libraryCapsuleFilename);
        /* repeated CAppOverview_PerClientData per_client_data = 43; */
        for (let i = 0; i < message.perClientData.length; i++)
            CAppOverview_PerClientData.internalBinaryWrite(message.perClientData[i], writer.tag(43, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 most_available_clientid = 44 [default = 0]; */
        if (message.mostAvailableClientid !== undefined)
            writer.tag(44, WireType.Varint).uint64(message.mostAvailableClientid);
        /* optional uint64 selected_clientid = 45 [default = 0]; */
        if (message.selectedClientid !== undefined)
            writer.tag(45, WireType.Varint).uint64(message.selectedClientid);
        /* optional uint32 rt_store_asset_mtime = 46; */
        if (message.rtStoreAssetMtime !== undefined)
            writer.tag(46, WireType.Varint).uint32(message.rtStoreAssetMtime);
        /* optional uint32 rt_custom_image_mtime = 47; */
        if (message.rtCustomImageMtime !== undefined)
            writer.tag(47, WireType.Varint).uint32(message.rtCustomImageMtime);
        /* optional uint32 optional_parent_app_id = 48; */
        if (message.optionalParentAppId !== undefined)
            writer.tag(48, WireType.Varint).uint32(message.optionalParentAppId);
        /* optional uint32 owner_account_id = 49; */
        if (message.ownerAccountId !== undefined)
            writer.tag(49, WireType.Varint).uint32(message.ownerAccountId);
        /* optional bool compat_mapping_enabled = 50; */
        if (message.compatMappingEnabled !== undefined)
            writer.tag(50, WireType.Varint).bool(message.compatMappingEnabled);
        /* optional uint32 compat_mapping_priority = 51; */
        if (message.compatMappingPriority !== undefined)
            writer.tag(51, WireType.Varint).uint32(message.compatMappingPriority);
        /* optional string compat_mapping_tool_name = 52; */
        if (message.compatMappingToolName !== undefined)
            writer.tag(52, WireType.LengthDelimited).string(message.compatMappingToolName);
        /* optional uint32 review_score_with_bombs = 53 [default = 0]; */
        if (message.reviewScoreWithBombs !== undefined)
            writer.tag(53, WireType.Varint).uint32(message.reviewScoreWithBombs);
        /* optional uint32 review_percentage_with_bombs = 54 [default = 0]; */
        if (message.reviewPercentageWithBombs !== undefined)
            writer.tag(54, WireType.Varint).uint32(message.reviewPercentageWithBombs);
        /* optional uint32 review_score_without_bombs = 55 [default = 0]; */
        if (message.reviewScoreWithoutBombs !== undefined)
            writer.tag(55, WireType.Varint).uint32(message.reviewScoreWithoutBombs);
        /* optional uint32 review_percentage_without_bombs = 56 [default = 0]; */
        if (message.reviewPercentageWithoutBombs !== undefined)
            writer.tag(56, WireType.Varint).uint32(message.reviewPercentageWithoutBombs);
        /* optional string library_id = 57; */
        if (message.libraryId !== undefined)
            writer.tag(57, WireType.LengthDelimited).string(message.libraryId);
        /* optional bool vr_only = 58; */
        if (message.vrOnly !== undefined)
            writer.tag(58, WireType.Varint).bool(message.vrOnly);
        /* optional uint32 mastersub_appid = 59; */
        if (message.mastersubAppid !== undefined)
            writer.tag(59, WireType.Varint).uint32(message.mastersubAppid);
        /* optional string mastersub_includedwith_logo = 60; */
        if (message.mastersubIncludedwithLogo !== undefined)
            writer.tag(60, WireType.LengthDelimited).string(message.mastersubIncludedwithLogo);
        /* optional uint32 compat_allowlist_setting = 61 [default = 0]; */
        if (message.compatAllowlistSetting !== undefined)
            writer.tag(61, WireType.Varint).uint32(message.compatAllowlistSetting);
        /* optional string site_license_site_name = 62; */
        if (message.siteLicenseSiteName !== undefined)
            writer.tag(62, WireType.LengthDelimited).string(message.siteLicenseSiteName);
        /* optional uint32 shortcut_override_appid = 63; */
        if (message.shortcutOverrideAppid !== undefined)
            writer.tag(63, WireType.Varint).uint32(message.shortcutOverrideAppid);
        /* optional uint32 rt_last_time_locally_played = 65; */
        if (message.rtLastTimeLocallyPlayed !== undefined)
            writer.tag(65, WireType.Varint).uint32(message.rtLastTimeLocallyPlayed);
        /* optional uint32 rt_purchased_time = 66; */
        if (message.rtPurchasedTime !== undefined)
            writer.tag(66, WireType.Varint).uint32(message.rtPurchasedTime);
        /* optional string header_filename = 67; */
        if (message.headerFilename !== undefined)
            writer.tag(67, WireType.LengthDelimited).string(message.headerFilename);
        /* optional uint32 local_cache_version = 68; */
        if (message.localCacheVersion !== undefined)
            writer.tag(68, WireType.Varint).uint32(message.localCacheVersion);
        /* optional uint32 number_of_copies = 72 [default = 1]; */
        if (message.numberOfCopies !== undefined)
            writer.tag(72, WireType.Varint).uint32(message.numberOfCopies);
        /* optional uint32 steam_hw_compat_category_packed = 73 [default = 0]; */
        if (message.steamHwCompatCategoryPacked !== undefined)
            writer.tag(73, WireType.Varint).uint32(message.steamHwCompatCategoryPacked);
        /* optional string album_cover_hash = 74; */
        if (message.albumCoverHash !== undefined)
            writer.tag(74, WireType.LengthDelimited).string(message.albumCoverHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CAppOverview
 */
export const CAppOverview = new CAppOverview$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CAppOverview_AppAssociation$Type extends MessageType<CAppOverview_AppAssociation> {
    constructor() {
        super("CAppOverview_AppAssociation", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CAppOverview_AppAssociation>): CAppOverview_AppAssociation {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CAppOverview_AppAssociation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CAppOverview_AppAssociation): CAppOverview_AppAssociation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CAppOverview_AppAssociation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CAppOverview_AppAssociation
 */
export const CAppOverview_AppAssociation = new CAppOverview_AppAssociation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CAppOverview_Change$Type extends MessageType<CAppOverview_Change> {
    constructor() {
        super("CAppOverview_Change", [
            { no: 1, name: "app_overview", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CAppOverview },
            { no: 2, name: "removed_appid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "full_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "update_complete", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CAppOverview_Change>): CAppOverview_Change {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appOverview = [];
        message.removedAppid = [];
        if (value !== undefined)
            reflectionMergePartial<CAppOverview_Change>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CAppOverview_Change): CAppOverview_Change {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CAppOverview app_overview */ 1:
                    message.appOverview.push(CAppOverview.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 removed_appid */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.removedAppid.push(reader.uint32());
                    else
                        message.removedAppid.push(reader.uint32());
                    break;
                case /* optional bool full_update */ 3:
                    message.fullUpdate = reader.bool();
                    break;
                case /* optional bool update_complete */ 4:
                    message.updateComplete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CAppOverview_Change, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CAppOverview app_overview = 1; */
        for (let i = 0; i < message.appOverview.length; i++)
            CAppOverview.internalBinaryWrite(message.appOverview[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 removed_appid = 2; */
        for (let i = 0; i < message.removedAppid.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.removedAppid[i]);
        /* optional bool full_update = 3; */
        if (message.fullUpdate !== undefined)
            writer.tag(3, WireType.Varint).bool(message.fullUpdate);
        /* optional bool update_complete = 4; */
        if (message.updateComplete !== undefined)
            writer.tag(4, WireType.Varint).bool(message.updateComplete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CAppOverview_Change
 */
export const CAppOverview_Change = new CAppOverview_Change$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CAppOverview_PerClientData$Type extends MessageType<CAppOverview_PerClientData> {
    constructor() {
        super("CAppOverview_PerClientData", [
            { no: 1, name: "clientid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "client_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "display_status", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "status_percentage", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "active_beta", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "installed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "bytes_downloaded", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "bytes_total", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "streaming_to_local_client", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "is_available_on_current_platform", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "is_invalid_os_type", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "playtime_left", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "update_available_but_disabled_by_app", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CAppOverview_PerClientData>): CAppOverview_PerClientData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CAppOverview_PerClientData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CAppOverview_PerClientData): CAppOverview_PerClientData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 clientid = 1 [default = 0] */ 1:
                    message.clientid = reader.uint64().toBigInt();
                    break;
                case /* optional string client_name */ 2:
                    message.clientName = reader.string();
                    break;
                case /* optional int32 display_status */ 3:
                    message.displayStatus = reader.int32();
                    break;
                case /* optional uint32 status_percentage */ 4:
                    message.statusPercentage = reader.uint32();
                    break;
                case /* optional string active_beta */ 5:
                    message.activeBeta = reader.string();
                    break;
                case /* optional bool installed */ 6:
                    message.installed = reader.bool();
                    break;
                case /* optional uint64 bytes_downloaded = 7 [default = 0] */ 7:
                    message.bytesDownloaded = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes_total = 8 [default = 0] */ 8:
                    message.bytesTotal = reader.uint64().toBigInt();
                    break;
                case /* optional bool streaming_to_local_client */ 9:
                    message.streamingToLocalClient = reader.bool();
                    break;
                case /* optional bool is_available_on_current_platform */ 10:
                    message.isAvailableOnCurrentPlatform = reader.bool();
                    break;
                case /* optional bool is_invalid_os_type */ 11:
                    message.isInvalidOsType = reader.bool();
                    break;
                case /* optional uint32 playtime_left */ 12:
                    message.playtimeLeft = reader.uint32();
                    break;
                case /* optional bool update_available_but_disabled_by_app */ 14:
                    message.updateAvailableButDisabledByApp = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CAppOverview_PerClientData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 clientid = 1 [default = 0]; */
        if (message.clientid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.clientid);
        /* optional string client_name = 2; */
        if (message.clientName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.clientName);
        /* optional int32 display_status = 3; */
        if (message.displayStatus !== undefined)
            writer.tag(3, WireType.Varint).int32(message.displayStatus);
        /* optional uint32 status_percentage = 4; */
        if (message.statusPercentage !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.statusPercentage);
        /* optional string active_beta = 5; */
        if (message.activeBeta !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.activeBeta);
        /* optional bool installed = 6; */
        if (message.installed !== undefined)
            writer.tag(6, WireType.Varint).bool(message.installed);
        /* optional uint64 bytes_downloaded = 7 [default = 0]; */
        if (message.bytesDownloaded !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.bytesDownloaded);
        /* optional uint64 bytes_total = 8 [default = 0]; */
        if (message.bytesTotal !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.bytesTotal);
        /* optional bool streaming_to_local_client = 9; */
        if (message.streamingToLocalClient !== undefined)
            writer.tag(9, WireType.Varint).bool(message.streamingToLocalClient);
        /* optional bool is_available_on_current_platform = 10; */
        if (message.isAvailableOnCurrentPlatform !== undefined)
            writer.tag(10, WireType.Varint).bool(message.isAvailableOnCurrentPlatform);
        /* optional bool is_invalid_os_type = 11; */
        if (message.isInvalidOsType !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isInvalidOsType);
        /* optional uint32 playtime_left = 12; */
        if (message.playtimeLeft !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.playtimeLeft);
        /* optional bool update_available_but_disabled_by_app = 14; */
        if (message.updateAvailableButDisabledByApp !== undefined)
            writer.tag(14, WireType.Varint).bool(message.updateAvailableButDisabledByApp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CAppOverview_PerClientData
 */
export const CAppOverview_PerClientData = new CAppOverview_PerClientData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CartAmount$Type extends MessageType<CartAmount> {
    constructor() {
        super("CartAmount", [
            { no: 1, name: "amount_in_cents", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "currency_code", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "formatted_amount", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CartAmount>): CartAmount {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CartAmount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CartAmount): CartAmount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 amount_in_cents */ 1:
                    message.amountInCents = reader.int64().toBigInt();
                    break;
                case /* optional int32 currency_code */ 2:
                    message.currencyCode = reader.int32();
                    break;
                case /* optional string formatted_amount */ 3:
                    message.formattedAmount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CartAmount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 amount_in_cents = 1; */
        if (message.amountInCents !== undefined)
            writer.tag(1, WireType.Varint).int64(message.amountInCents);
        /* optional int32 currency_code = 2; */
        if (message.currencyCode !== undefined)
            writer.tag(2, WireType.Varint).int32(message.currencyCode);
        /* optional string formatted_amount = 3; */
        if (message.formattedAmount !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.formattedAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CartAmount
 */
export const CartAmount = new CartAmount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CartCoupon$Type extends MessageType<CartCoupon> {
    constructor() {
        super("CartCoupon", [
            { no: 1, name: "couponid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gidcoupon", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "coupon_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "large_icon_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "discount_pct", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CartCoupon>): CartCoupon {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CartCoupon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CartCoupon): CartCoupon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 couponid */ 1:
                    message.couponid = reader.uint32();
                    break;
                case /* optional uint64 gidcoupon */ 2:
                    message.gidcoupon = reader.uint64().toBigInt();
                    break;
                case /* optional string title */ 5:
                    message.title = reader.string();
                    break;
                case /* optional string coupon_description */ 6:
                    message.couponDescription = reader.string();
                    break;
                case /* optional string large_icon_url */ 7:
                    message.largeIconUrl = reader.string();
                    break;
                case /* optional int32 discount_pct */ 8:
                    message.discountPct = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CartCoupon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 couponid = 1; */
        if (message.couponid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.couponid);
        /* optional uint64 gidcoupon = 2; */
        if (message.gidcoupon !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.gidcoupon);
        /* optional string title = 5; */
        if (message.title !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.title);
        /* optional string coupon_description = 6; */
        if (message.couponDescription !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.couponDescription);
        /* optional string large_icon_url = 7; */
        if (message.largeIconUrl !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.largeIconUrl);
        /* optional int32 discount_pct = 8; */
        if (message.discountPct !== undefined)
            writer.tag(8, WireType.Varint).int32(message.discountPct);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CartCoupon
 */
export const CartCoupon = new CartCoupon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CartGiftInfo$Type extends MessageType<CartGiftInfo> {
    constructor() {
        super("CartGiftInfo", [
            { no: 1, name: "accountid_giftee", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "gift_message", kind: "message", T: () => CartGiftMessage },
            { no: 3, name: "time_scheduled_send", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CartGiftInfo>): CartGiftInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CartGiftInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CartGiftInfo): CartGiftInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 accountid_giftee */ 1:
                    message.accountidGiftee = reader.int32();
                    break;
                case /* optional CartGiftMessage gift_message */ 2:
                    message.giftMessage = CartGiftMessage.internalBinaryRead(reader, reader.uint32(), options, message.giftMessage);
                    break;
                case /* optional int32 time_scheduled_send */ 3:
                    message.timeScheduledSend = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CartGiftInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 accountid_giftee = 1; */
        if (message.accountidGiftee !== undefined)
            writer.tag(1, WireType.Varint).int32(message.accountidGiftee);
        /* optional CartGiftMessage gift_message = 2; */
        if (message.giftMessage)
            CartGiftMessage.internalBinaryWrite(message.giftMessage, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 time_scheduled_send = 3; */
        if (message.timeScheduledSend !== undefined)
            writer.tag(3, WireType.Varint).int32(message.timeScheduledSend);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CartGiftInfo
 */
export const CartGiftInfo = new CartGiftInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CartGiftMessage$Type extends MessageType<CartGiftMessage> {
    constructor() {
        super("CartGiftMessage", [
            { no: 1, name: "gifteename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sentiment", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "signature", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CartGiftMessage>): CartGiftMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CartGiftMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CartGiftMessage): CartGiftMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string gifteename */ 1:
                    message.gifteename = reader.string();
                    break;
                case /* optional string message */ 2:
                    message.message = reader.string();
                    break;
                case /* optional string sentiment */ 3:
                    message.sentiment = reader.string();
                    break;
                case /* optional string signature */ 4:
                    message.signature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CartGiftMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string gifteename = 1; */
        if (message.gifteename !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.gifteename);
        /* optional string message = 2; */
        if (message.message !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* optional string sentiment = 3; */
        if (message.sentiment !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.sentiment);
        /* optional string signature = 4; */
        if (message.signature !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CartGiftMessage
 */
export const CartGiftMessage = new CartGiftMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CBilling_Address$Type extends MessageType<CBilling_Address> {
    constructor() {
        super("CBilling_Address", [
            { no: 1, name: "first_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address1", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "address2", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "city", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "us_state", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "postcode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "zip_plus4", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "phone", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CBilling_Address>): CBilling_Address {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CBilling_Address>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CBilling_Address): CBilling_Address {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string first_name */ 1:
                    message.firstName = reader.string();
                    break;
                case /* optional string last_name */ 2:
                    message.lastName = reader.string();
                    break;
                case /* optional string address1 */ 3:
                    message.address1 = reader.string();
                    break;
                case /* optional string address2 */ 4:
                    message.address2 = reader.string();
                    break;
                case /* optional string city */ 5:
                    message.city = reader.string();
                    break;
                case /* optional string us_state */ 6:
                    message.usState = reader.string();
                    break;
                case /* optional string country_code */ 7:
                    message.countryCode = reader.string();
                    break;
                case /* optional string postcode */ 8:
                    message.postcode = reader.string();
                    break;
                case /* optional int32 zip_plus4 */ 9:
                    message.zipPlus4 = reader.int32();
                    break;
                case /* optional string phone */ 10:
                    message.phone = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CBilling_Address, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string first_name = 1; */
        if (message.firstName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.firstName);
        /* optional string last_name = 2; */
        if (message.lastName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.lastName);
        /* optional string address1 = 3; */
        if (message.address1 !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.address1);
        /* optional string address2 = 4; */
        if (message.address2 !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.address2);
        /* optional string city = 5; */
        if (message.city !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.city);
        /* optional string us_state = 6; */
        if (message.usState !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.usState);
        /* optional string country_code = 7; */
        if (message.countryCode !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.countryCode);
        /* optional string postcode = 8; */
        if (message.postcode !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.postcode);
        /* optional int32 zip_plus4 = 9; */
        if (message.zipPlus4 !== undefined)
            writer.tag(9, WireType.Varint).int32(message.zipPlus4);
        /* optional string phone = 10; */
        if (message.phone !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.phone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CBilling_Address
 */
export const CBilling_Address = new CBilling_Address$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CChatPartyBeacon$Type extends MessageType<CChatPartyBeacon> {
    constructor() {
        super("CChatPartyBeacon", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steamid_owner", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "beacon_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "game_metadata", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CChatPartyBeacon>): CChatPartyBeacon {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CChatPartyBeacon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CChatPartyBeacon): CChatPartyBeacon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steamid_owner */ 2:
                    message.steamidOwner = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 beacon_id */ 3:
                    message.beaconId = reader.fixed64().toBigInt();
                    break;
                case /* optional string game_metadata */ 4:
                    message.gameMetadata = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CChatPartyBeacon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steamid_owner = 2; */
        if (message.steamidOwner !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamidOwner);
        /* optional fixed64 beacon_id = 3; */
        if (message.beaconId !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.beaconId);
        /* optional string game_metadata = 4; */
        if (message.gameMetadata !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.gameMetadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CChatPartyBeacon
 */
export const CChatPartyBeacon = new CChatPartyBeacon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CChatRoleActions$Type extends MessageType<CChatRoleActions> {
    constructor() {
        super("CChatRoleActions", [
            { no: 1, name: "role_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "can_create_rename_delete_channel", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "can_kick", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "can_ban", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "can_invite", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "can_change_tagline_avatar_name", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "can_chat", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "can_view_history", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "can_change_group_roles", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "can_change_user_roles", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "can_mention_all", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "can_set_watching_broadcast", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CChatRoleActions>): CChatRoleActions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CChatRoleActions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CChatRoleActions): CChatRoleActions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 role_id */ 1:
                    message.roleId = reader.uint64().toBigInt();
                    break;
                case /* optional bool can_create_rename_delete_channel */ 2:
                    message.canCreateRenameDeleteChannel = reader.bool();
                    break;
                case /* optional bool can_kick */ 3:
                    message.canKick = reader.bool();
                    break;
                case /* optional bool can_ban */ 4:
                    message.canBan = reader.bool();
                    break;
                case /* optional bool can_invite */ 5:
                    message.canInvite = reader.bool();
                    break;
                case /* optional bool can_change_tagline_avatar_name */ 6:
                    message.canChangeTaglineAvatarName = reader.bool();
                    break;
                case /* optional bool can_chat */ 7:
                    message.canChat = reader.bool();
                    break;
                case /* optional bool can_view_history */ 8:
                    message.canViewHistory = reader.bool();
                    break;
                case /* optional bool can_change_group_roles */ 9:
                    message.canChangeGroupRoles = reader.bool();
                    break;
                case /* optional bool can_change_user_roles */ 10:
                    message.canChangeUserRoles = reader.bool();
                    break;
                case /* optional bool can_mention_all */ 11:
                    message.canMentionAll = reader.bool();
                    break;
                case /* optional bool can_set_watching_broadcast */ 12:
                    message.canSetWatchingBroadcast = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CChatRoleActions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 role_id = 1; */
        if (message.roleId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.roleId);
        /* optional bool can_create_rename_delete_channel = 2; */
        if (message.canCreateRenameDeleteChannel !== undefined)
            writer.tag(2, WireType.Varint).bool(message.canCreateRenameDeleteChannel);
        /* optional bool can_kick = 3; */
        if (message.canKick !== undefined)
            writer.tag(3, WireType.Varint).bool(message.canKick);
        /* optional bool can_ban = 4; */
        if (message.canBan !== undefined)
            writer.tag(4, WireType.Varint).bool(message.canBan);
        /* optional bool can_invite = 5; */
        if (message.canInvite !== undefined)
            writer.tag(5, WireType.Varint).bool(message.canInvite);
        /* optional bool can_change_tagline_avatar_name = 6; */
        if (message.canChangeTaglineAvatarName !== undefined)
            writer.tag(6, WireType.Varint).bool(message.canChangeTaglineAvatarName);
        /* optional bool can_chat = 7; */
        if (message.canChat !== undefined)
            writer.tag(7, WireType.Varint).bool(message.canChat);
        /* optional bool can_view_history = 8; */
        if (message.canViewHistory !== undefined)
            writer.tag(8, WireType.Varint).bool(message.canViewHistory);
        /* optional bool can_change_group_roles = 9; */
        if (message.canChangeGroupRoles !== undefined)
            writer.tag(9, WireType.Varint).bool(message.canChangeGroupRoles);
        /* optional bool can_change_user_roles = 10; */
        if (message.canChangeUserRoles !== undefined)
            writer.tag(10, WireType.Varint).bool(message.canChangeUserRoles);
        /* optional bool can_mention_all = 11; */
        if (message.canMentionAll !== undefined)
            writer.tag(11, WireType.Varint).bool(message.canMentionAll);
        /* optional bool can_set_watching_broadcast = 12; */
        if (message.canSetWatchingBroadcast !== undefined)
            writer.tag(12, WireType.Varint).bool(message.canSetWatchingBroadcast);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CChatRoleActions
 */
export const CChatRoleActions = new CChatRoleActions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CChatRoom_GetChatRoomGroupSummary_Response$Type extends MessageType<CChatRoom_GetChatRoomGroupSummary_Response> {
    constructor() {
        super("CChatRoom_GetChatRoomGroupSummary_Response", [
            { no: 1, name: "chat_group_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "chat_group_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "active_member_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "active_voice_member_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "default_chat_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "chat_rooms", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CChatRoomState },
            { no: 7, name: "clanid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "chat_group_tagline", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "accountid_owner", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "top_members", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "chat_group_avatar_sha", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "rank", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 13, name: "default_role_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "role_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "role_actions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CChatRoleActions },
            { no: 16, name: "watching_broadcast_accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "party_beacons", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CChatPartyBeacon },
            { no: 19, name: "watching_broadcast_channel_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "active_minigame_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "avatar_ugc_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "disabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CChatRoom_GetChatRoomGroupSummary_Response>): CChatRoom_GetChatRoomGroupSummary_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chatRooms = [];
        message.topMembers = [];
        message.roleIds = [];
        message.roleActions = [];
        message.partyBeacons = [];
        if (value !== undefined)
            reflectionMergePartial<CChatRoom_GetChatRoomGroupSummary_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CChatRoom_GetChatRoomGroupSummary_Response): CChatRoom_GetChatRoomGroupSummary_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 chat_group_id */ 1:
                    message.chatGroupId = reader.uint64().toBigInt();
                    break;
                case /* optional string chat_group_name */ 2:
                    message.chatGroupName = reader.string();
                    break;
                case /* optional uint32 active_member_count */ 3:
                    message.activeMemberCount = reader.uint32();
                    break;
                case /* optional uint32 active_voice_member_count */ 4:
                    message.activeVoiceMemberCount = reader.uint32();
                    break;
                case /* optional uint64 default_chat_id */ 5:
                    message.defaultChatId = reader.uint64().toBigInt();
                    break;
                case /* repeated CChatRoomState chat_rooms */ 6:
                    message.chatRooms.push(CChatRoomState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 clanid */ 7:
                    message.clanid = reader.uint32();
                    break;
                case /* optional string chat_group_tagline */ 8:
                    message.chatGroupTagline = reader.string();
                    break;
                case /* optional uint32 accountid_owner */ 9:
                    message.accountidOwner = reader.uint32();
                    break;
                case /* repeated uint32 top_members */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.topMembers.push(reader.uint32());
                    else
                        message.topMembers.push(reader.uint32());
                    break;
                case /* optional bytes chat_group_avatar_sha */ 11:
                    message.chatGroupAvatarSha = reader.bytes();
                    break;
                case /* optional int32 rank */ 12:
                    message.rank = reader.int32();
                    break;
                case /* optional uint64 default_role_id */ 13:
                    message.defaultRoleId = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 role_ids */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.roleIds.push(reader.uint64().toBigInt());
                    else
                        message.roleIds.push(reader.uint64().toBigInt());
                    break;
                case /* repeated CChatRoleActions role_actions */ 15:
                    message.roleActions.push(CChatRoleActions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 watching_broadcast_accountid */ 16:
                    message.watchingBroadcastAccountid = reader.uint32();
                    break;
                case /* optional uint32 appid */ 17:
                    message.appid = reader.uint32();
                    break;
                case /* repeated CChatPartyBeacon party_beacons */ 18:
                    message.partyBeacons.push(CChatPartyBeacon.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 watching_broadcast_channel_id */ 19:
                    message.watchingBroadcastChannelId = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 active_minigame_id */ 20:
                    message.activeMinigameId = reader.uint64().toBigInt();
                    break;
                case /* optional string avatar_ugc_url */ 21:
                    message.avatarUgcUrl = reader.string();
                    break;
                case /* optional bool disabled */ 22:
                    message.disabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CChatRoom_GetChatRoomGroupSummary_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 chat_group_id = 1; */
        if (message.chatGroupId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.chatGroupId);
        /* optional string chat_group_name = 2; */
        if (message.chatGroupName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.chatGroupName);
        /* optional uint32 active_member_count = 3; */
        if (message.activeMemberCount !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.activeMemberCount);
        /* optional uint32 active_voice_member_count = 4; */
        if (message.activeVoiceMemberCount !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.activeVoiceMemberCount);
        /* optional uint64 default_chat_id = 5; */
        if (message.defaultChatId !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.defaultChatId);
        /* repeated CChatRoomState chat_rooms = 6; */
        for (let i = 0; i < message.chatRooms.length; i++)
            CChatRoomState.internalBinaryWrite(message.chatRooms[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 clanid = 7; */
        if (message.clanid !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.clanid);
        /* optional string chat_group_tagline = 8; */
        if (message.chatGroupTagline !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.chatGroupTagline);
        /* optional uint32 accountid_owner = 9; */
        if (message.accountidOwner !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.accountidOwner);
        /* repeated uint32 top_members = 10; */
        for (let i = 0; i < message.topMembers.length; i++)
            writer.tag(10, WireType.Varint).uint32(message.topMembers[i]);
        /* optional bytes chat_group_avatar_sha = 11; */
        if (message.chatGroupAvatarSha !== undefined)
            writer.tag(11, WireType.LengthDelimited).bytes(message.chatGroupAvatarSha);
        /* optional int32 rank = 12; */
        if (message.rank !== undefined)
            writer.tag(12, WireType.Varint).int32(message.rank);
        /* optional uint64 default_role_id = 13; */
        if (message.defaultRoleId !== undefined)
            writer.tag(13, WireType.Varint).uint64(message.defaultRoleId);
        /* repeated uint64 role_ids = 14; */
        for (let i = 0; i < message.roleIds.length; i++)
            writer.tag(14, WireType.Varint).uint64(message.roleIds[i]);
        /* repeated CChatRoleActions role_actions = 15; */
        for (let i = 0; i < message.roleActions.length; i++)
            CChatRoleActions.internalBinaryWrite(message.roleActions[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 watching_broadcast_accountid = 16; */
        if (message.watchingBroadcastAccountid !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.watchingBroadcastAccountid);
        /* optional uint32 appid = 17; */
        if (message.appid !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.appid);
        /* repeated CChatPartyBeacon party_beacons = 18; */
        for (let i = 0; i < message.partyBeacons.length; i++)
            CChatPartyBeacon.internalBinaryWrite(message.partyBeacons[i], writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 watching_broadcast_channel_id = 19; */
        if (message.watchingBroadcastChannelId !== undefined)
            writer.tag(19, WireType.Varint).uint64(message.watchingBroadcastChannelId);
        /* optional uint64 active_minigame_id = 20; */
        if (message.activeMinigameId !== undefined)
            writer.tag(20, WireType.Varint).uint64(message.activeMinigameId);
        /* optional string avatar_ugc_url = 21; */
        if (message.avatarUgcUrl !== undefined)
            writer.tag(21, WireType.LengthDelimited).string(message.avatarUgcUrl);
        /* optional bool disabled = 22; */
        if (message.disabled !== undefined)
            writer.tag(22, WireType.Varint).bool(message.disabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CChatRoom_GetChatRoomGroupSummary_Response
 */
export const CChatRoom_GetChatRoomGroupSummary_Response = new CChatRoom_GetChatRoomGroupSummary_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CChatRoomState$Type extends MessageType<CChatRoomState> {
    constructor() {
        super("CChatRoomState", [
            { no: 1, name: "chat_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "chat_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "voice_allowed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "members_in_voice", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "time_last_message", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "sort_order", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "last_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "accountid_last_message", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CChatRoomState>): CChatRoomState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.membersInVoice = [];
        if (value !== undefined)
            reflectionMergePartial<CChatRoomState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CChatRoomState): CChatRoomState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 chat_id */ 1:
                    message.chatId = reader.uint64().toBigInt();
                    break;
                case /* optional string chat_name */ 2:
                    message.chatName = reader.string();
                    break;
                case /* optional bool voice_allowed */ 3:
                    message.voiceAllowed = reader.bool();
                    break;
                case /* repeated uint32 members_in_voice */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.membersInVoice.push(reader.uint32());
                    else
                        message.membersInVoice.push(reader.uint32());
                    break;
                case /* optional uint32 time_last_message */ 5:
                    message.timeLastMessage = reader.uint32();
                    break;
                case /* optional uint32 sort_order */ 6:
                    message.sortOrder = reader.uint32();
                    break;
                case /* optional string last_message */ 7:
                    message.lastMessage = reader.string();
                    break;
                case /* optional uint32 accountid_last_message */ 8:
                    message.accountidLastMessage = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CChatRoomState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 chat_id = 1; */
        if (message.chatId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.chatId);
        /* optional string chat_name = 2; */
        if (message.chatName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.chatName);
        /* optional bool voice_allowed = 3; */
        if (message.voiceAllowed !== undefined)
            writer.tag(3, WireType.Varint).bool(message.voiceAllowed);
        /* repeated uint32 members_in_voice = 4; */
        for (let i = 0; i < message.membersInVoice.length; i++)
            writer.tag(4, WireType.Varint).uint32(message.membersInVoice[i]);
        /* optional uint32 time_last_message = 5; */
        if (message.timeLastMessage !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.timeLastMessage);
        /* optional uint32 sort_order = 6; */
        if (message.sortOrder !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.sortOrder);
        /* optional string last_message = 7; */
        if (message.lastMessage !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.lastMessage);
        /* optional uint32 accountid_last_message = 8; */
        if (message.accountidLastMessage !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.accountidLastMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CChatRoomState
 */
export const CChatRoomState = new CChatRoomState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClanEventData$Type extends MessageType<CClanEventData> {
    constructor() {
        super("CClanEventData", [
            { no: 1, name: "gid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clan_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "event_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "event_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 5, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "server_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "server_password", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "rtime32_start_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "rtime32_end_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "comment_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "creator_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "last_update_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "event_notes", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "jsondata", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "announcement_body", kind: "message", T: () => CCommunity_ClanAnnouncementInfo },
            { no: 16, name: "published", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "rtime32_visibility_start", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "rtime32_visibility_end", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "broadcaster_accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "follower_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "ignore_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "forum_topic_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 24, name: "rtime32_last_modified", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "news_post_gid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 26, name: "rtime_mod_reviewed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 27, name: "featured_app_tagid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 28, name: "referenced_appids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClanEventData>): CClanEventData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.referencedAppids = [];
        if (value !== undefined)
            reflectionMergePartial<CClanEventData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClanEventData): CClanEventData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 gid */ 1:
                    message.gid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 clan_steamid */ 2:
                    message.clanSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string event_name */ 3:
                    message.eventName = reader.string();
                    break;
                case /* optional int32 event_type */ 4:
                    message.eventType = reader.int32();
                    break;
                case /* optional uint32 appid */ 5:
                    message.appid = reader.uint32();
                    break;
                case /* optional string server_address */ 6:
                    message.serverAddress = reader.string();
                    break;
                case /* optional string server_password */ 7:
                    message.serverPassword = reader.string();
                    break;
                case /* optional uint32 rtime32_start_time */ 8:
                    message.rtime32StartTime = reader.uint32();
                    break;
                case /* optional uint32 rtime32_end_time */ 9:
                    message.rtime32EndTime = reader.uint32();
                    break;
                case /* optional int32 comment_count */ 10:
                    message.commentCount = reader.int32();
                    break;
                case /* optional fixed64 creator_steamid */ 11:
                    message.creatorSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 last_update_steamid */ 12:
                    message.lastUpdateSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string event_notes */ 13:
                    message.eventNotes = reader.string();
                    break;
                case /* optional string jsondata */ 14:
                    message.jsondata = reader.string();
                    break;
                case /* optional CCommunity_ClanAnnouncementInfo announcement_body */ 15:
                    message.announcementBody = CCommunity_ClanAnnouncementInfo.internalBinaryRead(reader, reader.uint32(), options, message.announcementBody);
                    break;
                case /* optional bool published */ 16:
                    message.published = reader.bool();
                    break;
                case /* optional bool hidden */ 17:
                    message.hidden = reader.bool();
                    break;
                case /* optional uint32 rtime32_visibility_start */ 18:
                    message.rtime32VisibilityStart = reader.uint32();
                    break;
                case /* optional uint32 rtime32_visibility_end */ 19:
                    message.rtime32VisibilityEnd = reader.uint32();
                    break;
                case /* optional uint32 broadcaster_accountid */ 20:
                    message.broadcasterAccountid = reader.uint32();
                    break;
                case /* optional uint32 follower_count */ 21:
                    message.followerCount = reader.uint32();
                    break;
                case /* optional uint32 ignore_count */ 22:
                    message.ignoreCount = reader.uint32();
                    break;
                case /* optional fixed64 forum_topic_id */ 23:
                    message.forumTopicId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 rtime32_last_modified */ 24:
                    message.rtime32LastModified = reader.uint32();
                    break;
                case /* optional fixed64 news_post_gid */ 25:
                    message.newsPostGid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 rtime_mod_reviewed */ 26:
                    message.rtimeModReviewed = reader.uint32();
                    break;
                case /* optional uint32 featured_app_tagid */ 27:
                    message.featuredAppTagid = reader.uint32();
                    break;
                case /* repeated uint32 referenced_appids */ 28:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.referencedAppids.push(reader.uint32());
                    else
                        message.referencedAppids.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClanEventData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 gid = 1; */
        if (message.gid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gid);
        /* optional fixed64 clan_steamid = 2; */
        if (message.clanSteamid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.clanSteamid);
        /* optional string event_name = 3; */
        if (message.eventName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.eventName);
        /* optional int32 event_type = 4; */
        if (message.eventType !== undefined)
            writer.tag(4, WireType.Varint).int32(message.eventType);
        /* optional uint32 appid = 5; */
        if (message.appid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.appid);
        /* optional string server_address = 6; */
        if (message.serverAddress !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.serverAddress);
        /* optional string server_password = 7; */
        if (message.serverPassword !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.serverPassword);
        /* optional uint32 rtime32_start_time = 8; */
        if (message.rtime32StartTime !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.rtime32StartTime);
        /* optional uint32 rtime32_end_time = 9; */
        if (message.rtime32EndTime !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.rtime32EndTime);
        /* optional int32 comment_count = 10; */
        if (message.commentCount !== undefined)
            writer.tag(10, WireType.Varint).int32(message.commentCount);
        /* optional fixed64 creator_steamid = 11; */
        if (message.creatorSteamid !== undefined)
            writer.tag(11, WireType.Bit64).fixed64(message.creatorSteamid);
        /* optional fixed64 last_update_steamid = 12; */
        if (message.lastUpdateSteamid !== undefined)
            writer.tag(12, WireType.Bit64).fixed64(message.lastUpdateSteamid);
        /* optional string event_notes = 13; */
        if (message.eventNotes !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.eventNotes);
        /* optional string jsondata = 14; */
        if (message.jsondata !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.jsondata);
        /* optional CCommunity_ClanAnnouncementInfo announcement_body = 15; */
        if (message.announcementBody)
            CCommunity_ClanAnnouncementInfo.internalBinaryWrite(message.announcementBody, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional bool published = 16; */
        if (message.published !== undefined)
            writer.tag(16, WireType.Varint).bool(message.published);
        /* optional bool hidden = 17; */
        if (message.hidden !== undefined)
            writer.tag(17, WireType.Varint).bool(message.hidden);
        /* optional uint32 rtime32_visibility_start = 18; */
        if (message.rtime32VisibilityStart !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.rtime32VisibilityStart);
        /* optional uint32 rtime32_visibility_end = 19; */
        if (message.rtime32VisibilityEnd !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.rtime32VisibilityEnd);
        /* optional uint32 broadcaster_accountid = 20; */
        if (message.broadcasterAccountid !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.broadcasterAccountid);
        /* optional uint32 follower_count = 21; */
        if (message.followerCount !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.followerCount);
        /* optional uint32 ignore_count = 22; */
        if (message.ignoreCount !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.ignoreCount);
        /* optional fixed64 forum_topic_id = 23; */
        if (message.forumTopicId !== undefined)
            writer.tag(23, WireType.Bit64).fixed64(message.forumTopicId);
        /* optional uint32 rtime32_last_modified = 24; */
        if (message.rtime32LastModified !== undefined)
            writer.tag(24, WireType.Varint).uint32(message.rtime32LastModified);
        /* optional fixed64 news_post_gid = 25; */
        if (message.newsPostGid !== undefined)
            writer.tag(25, WireType.Bit64).fixed64(message.newsPostGid);
        /* optional uint32 rtime_mod_reviewed = 26; */
        if (message.rtimeModReviewed !== undefined)
            writer.tag(26, WireType.Varint).uint32(message.rtimeModReviewed);
        /* optional uint32 featured_app_tagid = 27; */
        if (message.featuredAppTagid !== undefined)
            writer.tag(27, WireType.Varint).uint32(message.featuredAppTagid);
        /* repeated uint32 referenced_appids = 28; */
        for (let i = 0; i < message.referencedAppids.length; i++)
            writer.tag(28, WireType.Varint).uint32(message.referencedAppids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClanEventData
 */
export const CClanEventData = new CClanEventData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_AppInterfaceCreation$Type extends MessageType<CClientMetrics_AppInterfaceCreation> {
    constructor() {
        super("CClientMetrics_AppInterfaceCreation", [
            { no: 1, name: "raw_version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "requested_interface_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_AppInterfaceCreation>): CClientMetrics_AppInterfaceCreation {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_AppInterfaceCreation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_AppInterfaceCreation): CClientMetrics_AppInterfaceCreation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string raw_version */ 1:
                    message.rawVersion = reader.string();
                    break;
                case /* optional string requested_interface_type */ 2:
                    message.requestedInterfaceType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_AppInterfaceCreation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string raw_version = 1; */
        if (message.rawVersion !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.rawVersion);
        /* optional string requested_interface_type = 2; */
        if (message.requestedInterfaceType !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.requestedInterfaceType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_AppInterfaceCreation
 */
export const CClientMetrics_AppInterfaceCreation = new CClientMetrics_AppInterfaceCreation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_AppInterfaceMethodCounts$Type extends MessageType<CClientMetrics_AppInterfaceMethodCounts> {
    constructor() {
        super("CClientMetrics_AppInterfaceMethodCounts", [
            { no: 1, name: "interface_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "method_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "call_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_AppInterfaceMethodCounts>): CClientMetrics_AppInterfaceMethodCounts {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_AppInterfaceMethodCounts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_AppInterfaceMethodCounts): CClientMetrics_AppInterfaceMethodCounts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string interface_name */ 1:
                    message.interfaceName = reader.string();
                    break;
                case /* optional string method_name */ 2:
                    message.methodName = reader.string();
                    break;
                case /* optional uint32 call_count */ 3:
                    message.callCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_AppInterfaceMethodCounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string interface_name = 1; */
        if (message.interfaceName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.interfaceName);
        /* optional string method_name = 2; */
        if (message.methodName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.methodName);
        /* optional uint32 call_count = 3; */
        if (message.callCount !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.callCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_AppInterfaceMethodCounts
 */
export const CClientMetrics_AppInterfaceMethodCounts = new CClientMetrics_AppInterfaceMethodCounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_AppInterfaceStats_Notification$Type extends MessageType<CClientMetrics_AppInterfaceStats_Notification> {
    constructor() {
        super("CClientMetrics_AppInterfaceStats_Notification", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "interfaces_created", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CClientMetrics_AppInterfaceCreation },
            { no: 3, name: "methods_called", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CClientMetrics_AppInterfaceMethodCounts },
            { no: 4, name: "session_length_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_AppInterfaceStats_Notification>): CClientMetrics_AppInterfaceStats_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.interfacesCreated = [];
        message.methodsCalled = [];
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_AppInterfaceStats_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_AppInterfaceStats_Notification): CClientMetrics_AppInterfaceStats_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 game_id */ 1:
                    message.gameId = reader.uint64().toBigInt();
                    break;
                case /* repeated CClientMetrics_AppInterfaceCreation interfaces_created */ 2:
                    message.interfacesCreated.push(CClientMetrics_AppInterfaceCreation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CClientMetrics_AppInterfaceMethodCounts methods_called */ 3:
                    message.methodsCalled.push(CClientMetrics_AppInterfaceMethodCounts.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 session_length_seconds */ 4:
                    message.sessionLengthSeconds = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_AppInterfaceStats_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.gameId);
        /* repeated CClientMetrics_AppInterfaceCreation interfaces_created = 2; */
        for (let i = 0; i < message.interfacesCreated.length; i++)
            CClientMetrics_AppInterfaceCreation.internalBinaryWrite(message.interfacesCreated[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CClientMetrics_AppInterfaceMethodCounts methods_called = 3; */
        for (let i = 0; i < message.methodsCalled.length; i++)
            CClientMetrics_AppInterfaceMethodCounts.internalBinaryWrite(message.methodsCalled[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 session_length_seconds = 4; */
        if (message.sessionLengthSeconds !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.sessionLengthSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_AppInterfaceStats_Notification
 */
export const CClientMetrics_AppInterfaceStats_Notification = new CClientMetrics_AppInterfaceStats_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ClientBootstrap_Notification$Type extends MessageType<CClientMetrics_ClientBootstrap_Notification> {
    constructor() {
        super("CClientMetrics_ClientBootstrap_Notification", [
            { no: 1, name: "summary", kind: "message", T: () => CClientMetrics_ClientBootstrap_Summary }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ClientBootstrap_Notification>): CClientMetrics_ClientBootstrap_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ClientBootstrap_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ClientBootstrap_Notification): CClientMetrics_ClientBootstrap_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CClientMetrics_ClientBootstrap_Summary summary */ 1:
                    message.summary = CClientMetrics_ClientBootstrap_Summary.internalBinaryRead(reader, reader.uint32(), options, message.summary);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ClientBootstrap_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CClientMetrics_ClientBootstrap_Summary summary = 1; */
        if (message.summary)
            CClientMetrics_ClientBootstrap_Summary.internalBinaryWrite(message.summary, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ClientBootstrap_Notification
 */
export const CClientMetrics_ClientBootstrap_Notification = new CClientMetrics_ClientBootstrap_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ClientBootstrap_RequestInfo$Type extends MessageType<CClientMetrics_ClientBootstrap_RequestInfo> {
    constructor() {
        super("CClientMetrics_ClientBootstrap_RequestInfo", [
            { no: 1, name: "original_hostname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "actual_hostname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "base_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "status_code", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "address_of_request_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "response_time_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "bytes_received", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "num_retries", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ClientBootstrap_RequestInfo>): CClientMetrics_ClientBootstrap_RequestInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ClientBootstrap_RequestInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ClientBootstrap_RequestInfo): CClientMetrics_ClientBootstrap_RequestInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string original_hostname */ 1:
                    message.originalHostname = reader.string();
                    break;
                case /* optional string actual_hostname */ 2:
                    message.actualHostname = reader.string();
                    break;
                case /* optional string path */ 3:
                    message.path = reader.string();
                    break;
                case /* optional string base_name */ 4:
                    message.baseName = reader.string();
                    break;
                case /* optional bool success */ 5:
                    message.success = reader.bool();
                    break;
                case /* optional uint32 status_code */ 6:
                    message.statusCode = reader.uint32();
                    break;
                case /* optional string address_of_request_url */ 7:
                    message.addressOfRequestUrl = reader.string();
                    break;
                case /* optional uint32 response_time_ms */ 8:
                    message.responseTimeMs = reader.uint32();
                    break;
                case /* optional uint64 bytes_received */ 9:
                    message.bytesReceived = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 num_retries */ 10:
                    message.numRetries = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ClientBootstrap_RequestInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string original_hostname = 1; */
        if (message.originalHostname !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.originalHostname);
        /* optional string actual_hostname = 2; */
        if (message.actualHostname !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actualHostname);
        /* optional string path = 3; */
        if (message.path !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.path);
        /* optional string base_name = 4; */
        if (message.baseName !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.baseName);
        /* optional bool success = 5; */
        if (message.success !== undefined)
            writer.tag(5, WireType.Varint).bool(message.success);
        /* optional uint32 status_code = 6; */
        if (message.statusCode !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.statusCode);
        /* optional string address_of_request_url = 7; */
        if (message.addressOfRequestUrl !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.addressOfRequestUrl);
        /* optional uint32 response_time_ms = 8; */
        if (message.responseTimeMs !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.responseTimeMs);
        /* optional uint64 bytes_received = 9; */
        if (message.bytesReceived !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.bytesReceived);
        /* optional uint32 num_retries = 10; */
        if (message.numRetries !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.numRetries);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ClientBootstrap_RequestInfo
 */
export const CClientMetrics_ClientBootstrap_RequestInfo = new CClientMetrics_ClientBootstrap_RequestInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ClientBootstrap_Summary$Type extends MessageType<CClientMetrics_ClientBootstrap_Summary> {
    constructor() {
        super("CClientMetrics_ClientBootstrap_Summary", [
            { no: 1, name: "launcher_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_realm", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "beta_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "download_completed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "total_time_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "manifest_requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CClientMetrics_ClientBootstrap_RequestInfo },
            { no: 8, name: "package_requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CClientMetrics_ClientBootstrap_RequestInfo }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ClientBootstrap_Summary>): CClientMetrics_ClientBootstrap_Summary {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.manifestRequests = [];
        message.packageRequests = [];
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ClientBootstrap_Summary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ClientBootstrap_Summary): CClientMetrics_ClientBootstrap_Summary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 launcher_type */ 1:
                    message.launcherType = reader.uint32();
                    break;
                case /* optional uint32 steam_realm */ 2:
                    message.steamRealm = reader.uint32();
                    break;
                case /* optional string beta_name */ 3:
                    message.betaName = reader.string();
                    break;
                case /* optional bool download_completed */ 4:
                    message.downloadCompleted = reader.bool();
                    break;
                case /* optional uint32 total_time_ms */ 6:
                    message.totalTimeMs = reader.uint32();
                    break;
                case /* repeated CClientMetrics_ClientBootstrap_RequestInfo manifest_requests */ 7:
                    message.manifestRequests.push(CClientMetrics_ClientBootstrap_RequestInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CClientMetrics_ClientBootstrap_RequestInfo package_requests */ 8:
                    message.packageRequests.push(CClientMetrics_ClientBootstrap_RequestInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ClientBootstrap_Summary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 launcher_type = 1; */
        if (message.launcherType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.launcherType);
        /* optional uint32 steam_realm = 2; */
        if (message.steamRealm !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.steamRealm);
        /* optional string beta_name = 3; */
        if (message.betaName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.betaName);
        /* optional bool download_completed = 4; */
        if (message.downloadCompleted !== undefined)
            writer.tag(4, WireType.Varint).bool(message.downloadCompleted);
        /* optional uint32 total_time_ms = 6; */
        if (message.totalTimeMs !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.totalTimeMs);
        /* repeated CClientMetrics_ClientBootstrap_RequestInfo manifest_requests = 7; */
        for (let i = 0; i < message.manifestRequests.length; i++)
            CClientMetrics_ClientBootstrap_RequestInfo.internalBinaryWrite(message.manifestRequests[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated CClientMetrics_ClientBootstrap_RequestInfo package_requests = 8; */
        for (let i = 0; i < message.packageRequests.length; i++)
            CClientMetrics_ClientBootstrap_RequestInfo.internalBinaryWrite(message.packageRequests[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ClientBootstrap_Summary
 */
export const CClientMetrics_ClientBootstrap_Summary = new CClientMetrics_ClientBootstrap_Summary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ClipRange_Notification$Type extends MessageType<CClientMetrics_ClipRange_Notification> {
    constructor() {
        super("CClientMetrics_ClipRange_Notification", [
            { no: 1, name: "original_range_method", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "start", kind: "message", T: () => CClientMetrics_ClipRange_Notification_RelativeRangeEdge },
            { no: 3, name: "end", kind: "message", T: () => CClientMetrics_ClipRange_Notification_RelativeRangeEdge },
            { no: 4, name: "seconds", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "gameid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ClipRange_Notification>): CClientMetrics_ClipRange_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ClipRange_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ClipRange_Notification): CClientMetrics_ClipRange_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 original_range_method */ 1:
                    message.originalRangeMethod = reader.int32();
                    break;
                case /* optional CClientMetrics_ClipRange_Notification_RelativeRangeEdge start */ 2:
                    message.start = CClientMetrics_ClipRange_Notification_RelativeRangeEdge.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* optional CClientMetrics_ClipRange_Notification_RelativeRangeEdge end */ 3:
                    message.end = CClientMetrics_ClipRange_Notification_RelativeRangeEdge.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                case /* optional float seconds */ 4:
                    message.seconds = reader.float();
                    break;
                case /* optional fixed64 gameid */ 5:
                    message.gameid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ClipRange_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 original_range_method = 1; */
        if (message.originalRangeMethod !== undefined)
            writer.tag(1, WireType.Varint).int32(message.originalRangeMethod);
        /* optional CClientMetrics_ClipRange_Notification_RelativeRangeEdge start = 2; */
        if (message.start)
            CClientMetrics_ClipRange_Notification_RelativeRangeEdge.internalBinaryWrite(message.start, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional CClientMetrics_ClipRange_Notification_RelativeRangeEdge end = 3; */
        if (message.end)
            CClientMetrics_ClipRange_Notification_RelativeRangeEdge.internalBinaryWrite(message.end, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional float seconds = 4; */
        if (message.seconds !== undefined)
            writer.tag(4, WireType.Bit32).float(message.seconds);
        /* optional fixed64 gameid = 5; */
        if (message.gameid !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.gameid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ClipRange_Notification
 */
export const CClientMetrics_ClipRange_Notification = new CClientMetrics_ClipRange_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ClipRange_Notification_RelativeRangeEdge$Type extends MessageType<CClientMetrics_ClipRange_Notification_RelativeRangeEdge> {
    constructor() {
        super("CClientMetrics_ClipRange_Notification_RelativeRangeEdge", [
            { no: 1, name: "original_range_method", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "latest_range_method", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 3, name: "delta_ms", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ClipRange_Notification_RelativeRangeEdge>): CClientMetrics_ClipRange_Notification_RelativeRangeEdge {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ClipRange_Notification_RelativeRangeEdge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ClipRange_Notification_RelativeRangeEdge): CClientMetrics_ClipRange_Notification_RelativeRangeEdge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 original_range_method */ 1:
                    message.originalRangeMethod = reader.int32();
                    break;
                case /* optional int32 latest_range_method */ 2:
                    message.latestRangeMethod = reader.int32();
                    break;
                case /* optional int32 delta_ms */ 3:
                    message.deltaMs = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ClipRange_Notification_RelativeRangeEdge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 original_range_method = 1; */
        if (message.originalRangeMethod !== undefined)
            writer.tag(1, WireType.Varint).int32(message.originalRangeMethod);
        /* optional int32 latest_range_method = 2; */
        if (message.latestRangeMethod !== undefined)
            writer.tag(2, WireType.Varint).int32(message.latestRangeMethod);
        /* optional int32 delta_ms = 3; */
        if (message.deltaMs !== undefined)
            writer.tag(3, WireType.Varint).int32(message.deltaMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ClipRange_Notification_RelativeRangeEdge
 */
export const CClientMetrics_ClipRange_Notification_RelativeRangeEdge = new CClientMetrics_ClipRange_Notification_RelativeRangeEdge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ClipShare_Notification$Type extends MessageType<CClientMetrics_ClipShare_Notification> {
    constructor() {
        super("CClientMetrics_ClipShare_Notification", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "share_method", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 3, name: "seconds", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "gameid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ClipShare_Notification>): CClientMetrics_ClipShare_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ClipShare_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ClipShare_Notification): CClientMetrics_ClipShare_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.uint32();
                    break;
                case /* optional int32 share_method */ 2:
                    message.shareMethod = reader.int32();
                    break;
                case /* optional float seconds */ 3:
                    message.seconds = reader.float();
                    break;
                case /* optional uint64 bytes */ 4:
                    message.bytes = reader.uint64().toBigInt();
                    break;
                case /* optional fixed64 gameid */ 5:
                    message.gameid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ClipShare_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        /* optional int32 share_method = 2; */
        if (message.shareMethod !== undefined)
            writer.tag(2, WireType.Varint).int32(message.shareMethod);
        /* optional float seconds = 3; */
        if (message.seconds !== undefined)
            writer.tag(3, WireType.Bit32).float(message.seconds);
        /* optional uint64 bytes = 4; */
        if (message.bytes !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.bytes);
        /* optional fixed64 gameid = 5; */
        if (message.gameid !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.gameid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ClipShare_Notification
 */
export const CClientMetrics_ClipShare_Notification = new CClientMetrics_ClipShare_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_CloudAppSyncStats_Notification$Type extends MessageType<CClientMetrics_CloudAppSyncStats_Notification> {
    constructor() {
        super("CClientMetrics_CloudAppSyncStats_Notification", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "platform_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "preload", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "blocking_app_launch", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "files_uploaded", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "files_downloaded", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "files_deleted", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "bytes_uploaded", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "bytes_downloaded", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "microsec_total", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "microsec_init_caches", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "microsec_validate_state", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "microsec_ac_launch", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "microsec_ac_prep_user_files", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "microsec_ac_exit", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "microsec_build_sync_list", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "microsec_delete_files", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 18, name: "microsec_download_files", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "microsec_upload_files", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "hardware_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "files_managed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_CloudAppSyncStats_Notification>): CClientMetrics_CloudAppSyncStats_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_CloudAppSyncStats_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_CloudAppSyncStats_Notification): CClientMetrics_CloudAppSyncStats_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 platform_type */ 2:
                    message.platformType = reader.uint32();
                    break;
                case /* optional bool preload */ 3:
                    message.preload = reader.bool();
                    break;
                case /* optional bool blocking_app_launch */ 4:
                    message.blockingAppLaunch = reader.bool();
                    break;
                case /* optional uint32 files_uploaded */ 5:
                    message.filesUploaded = reader.uint32();
                    break;
                case /* optional uint32 files_downloaded */ 6:
                    message.filesDownloaded = reader.uint32();
                    break;
                case /* optional uint32 files_deleted */ 7:
                    message.filesDeleted = reader.uint32();
                    break;
                case /* optional uint64 bytes_uploaded */ 8:
                    message.bytesUploaded = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes_downloaded */ 9:
                    message.bytesDownloaded = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 microsec_total */ 10:
                    message.microsecTotal = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 microsec_init_caches */ 11:
                    message.microsecInitCaches = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 microsec_validate_state */ 12:
                    message.microsecValidateState = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 microsec_ac_launch */ 13:
                    message.microsecAcLaunch = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 microsec_ac_prep_user_files */ 14:
                    message.microsecAcPrepUserFiles = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 microsec_ac_exit */ 15:
                    message.microsecAcExit = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 microsec_build_sync_list */ 16:
                    message.microsecBuildSyncList = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 microsec_delete_files */ 17:
                    message.microsecDeleteFiles = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 microsec_download_files */ 18:
                    message.microsecDownloadFiles = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 microsec_upload_files */ 19:
                    message.microsecUploadFiles = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 hardware_type */ 20:
                    message.hardwareType = reader.uint32();
                    break;
                case /* optional uint32 files_managed */ 21:
                    message.filesManaged = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_CloudAppSyncStats_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 platform_type = 2; */
        if (message.platformType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.platformType);
        /* optional bool preload = 3; */
        if (message.preload !== undefined)
            writer.tag(3, WireType.Varint).bool(message.preload);
        /* optional bool blocking_app_launch = 4; */
        if (message.blockingAppLaunch !== undefined)
            writer.tag(4, WireType.Varint).bool(message.blockingAppLaunch);
        /* optional uint32 files_uploaded = 5; */
        if (message.filesUploaded !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.filesUploaded);
        /* optional uint32 files_downloaded = 6; */
        if (message.filesDownloaded !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.filesDownloaded);
        /* optional uint32 files_deleted = 7; */
        if (message.filesDeleted !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.filesDeleted);
        /* optional uint64 bytes_uploaded = 8; */
        if (message.bytesUploaded !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.bytesUploaded);
        /* optional uint64 bytes_downloaded = 9; */
        if (message.bytesDownloaded !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.bytesDownloaded);
        /* optional uint64 microsec_total = 10; */
        if (message.microsecTotal !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.microsecTotal);
        /* optional uint64 microsec_init_caches = 11; */
        if (message.microsecInitCaches !== undefined)
            writer.tag(11, WireType.Varint).uint64(message.microsecInitCaches);
        /* optional uint64 microsec_validate_state = 12; */
        if (message.microsecValidateState !== undefined)
            writer.tag(12, WireType.Varint).uint64(message.microsecValidateState);
        /* optional uint64 microsec_ac_launch = 13; */
        if (message.microsecAcLaunch !== undefined)
            writer.tag(13, WireType.Varint).uint64(message.microsecAcLaunch);
        /* optional uint64 microsec_ac_prep_user_files = 14; */
        if (message.microsecAcPrepUserFiles !== undefined)
            writer.tag(14, WireType.Varint).uint64(message.microsecAcPrepUserFiles);
        /* optional uint64 microsec_ac_exit = 15; */
        if (message.microsecAcExit !== undefined)
            writer.tag(15, WireType.Varint).uint64(message.microsecAcExit);
        /* optional uint64 microsec_build_sync_list = 16; */
        if (message.microsecBuildSyncList !== undefined)
            writer.tag(16, WireType.Varint).uint64(message.microsecBuildSyncList);
        /* optional uint64 microsec_delete_files = 17; */
        if (message.microsecDeleteFiles !== undefined)
            writer.tag(17, WireType.Varint).uint64(message.microsecDeleteFiles);
        /* optional uint64 microsec_download_files = 18; */
        if (message.microsecDownloadFiles !== undefined)
            writer.tag(18, WireType.Varint).uint64(message.microsecDownloadFiles);
        /* optional uint64 microsec_upload_files = 19; */
        if (message.microsecUploadFiles !== undefined)
            writer.tag(19, WireType.Varint).uint64(message.microsecUploadFiles);
        /* optional uint32 hardware_type = 20; */
        if (message.hardwareType !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.hardwareType);
        /* optional uint32 files_managed = 21; */
        if (message.filesManaged !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.filesManaged);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_CloudAppSyncStats_Notification
 */
export const CClientMetrics_CloudAppSyncStats_Notification = new CClientMetrics_CloudAppSyncStats_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ContentDownloadResponse_Counts$Type extends MessageType<CClientMetrics_ContentDownloadResponse_Counts> {
    constructor() {
        super("CClientMetrics_ContentDownloadResponse_Counts", [
            { no: 1, name: "class_100", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "class_200", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "class_300", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "class_400", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "class_500", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "no_response", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "class_unknown", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ContentDownloadResponse_Counts>): CClientMetrics_ContentDownloadResponse_Counts {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ContentDownloadResponse_Counts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ContentDownloadResponse_Counts): CClientMetrics_ContentDownloadResponse_Counts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 class_100 */ 1:
                    message.class100 = reader.uint32();
                    break;
                case /* optional uint32 class_200 */ 2:
                    message.class200 = reader.uint32();
                    break;
                case /* optional uint32 class_300 */ 3:
                    message.class300 = reader.uint32();
                    break;
                case /* optional uint32 class_400 */ 4:
                    message.class400 = reader.uint32();
                    break;
                case /* optional uint32 class_500 */ 5:
                    message.class500 = reader.uint32();
                    break;
                case /* optional uint32 no_response */ 6:
                    message.noResponse = reader.uint32();
                    break;
                case /* optional uint32 class_unknown */ 7:
                    message.classUnknown = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ContentDownloadResponse_Counts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 class_100 = 1; */
        if (message.class100 !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.class100);
        /* optional uint32 class_200 = 2; */
        if (message.class200 !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.class200);
        /* optional uint32 class_300 = 3; */
        if (message.class300 !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.class300);
        /* optional uint32 class_400 = 4; */
        if (message.class400 !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.class400);
        /* optional uint32 class_500 = 5; */
        if (message.class500 !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.class500);
        /* optional uint32 no_response = 6; */
        if (message.noResponse !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.noResponse);
        /* optional uint32 class_unknown = 7; */
        if (message.classUnknown !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.classUnknown);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ContentDownloadResponse_Counts
 */
export const CClientMetrics_ContentDownloadResponse_Counts = new CClientMetrics_ContentDownloadResponse_Counts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ContentDownloadResponse_Counts_Notification$Type extends MessageType<CClientMetrics_ContentDownloadResponse_Counts_Notification> {
    constructor() {
        super("CClientMetrics_ContentDownloadResponse_Counts_Notification", [
            { no: 1, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "message", T: () => CClientMetrics_ContentDownloadResponse_Hosts }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ContentDownloadResponse_Counts_Notification>): CClientMetrics_ContentDownloadResponse_Counts_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ContentDownloadResponse_Counts_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ContentDownloadResponse_Counts_Notification): CClientMetrics_ContentDownloadResponse_Counts_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 cell_id */ 1:
                    message.cellId = reader.uint32();
                    break;
                case /* optional CClientMetrics_ContentDownloadResponse_Hosts data */ 2:
                    message.data = CClientMetrics_ContentDownloadResponse_Hosts.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ContentDownloadResponse_Counts_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 cell_id = 1; */
        if (message.cellId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cellId);
        /* optional CClientMetrics_ContentDownloadResponse_Hosts data = 2; */
        if (message.data)
            CClientMetrics_ContentDownloadResponse_Hosts.internalBinaryWrite(message.data, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ContentDownloadResponse_Counts_Notification
 */
export const CClientMetrics_ContentDownloadResponse_Counts_Notification = new CClientMetrics_ContentDownloadResponse_Counts_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ContentDownloadResponse_HostCounts$Type extends MessageType<CClientMetrics_ContentDownloadResponse_HostCounts> {
    constructor() {
        super("CClientMetrics_ContentDownloadResponse_HostCounts", [
            { no: 1, name: "hostname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "counts", kind: "message", T: () => CClientMetrics_ContentDownloadResponse_Counts }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ContentDownloadResponse_HostCounts>): CClientMetrics_ContentDownloadResponse_HostCounts {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ContentDownloadResponse_HostCounts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ContentDownloadResponse_HostCounts): CClientMetrics_ContentDownloadResponse_HostCounts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string hostname */ 1:
                    message.hostname = reader.string();
                    break;
                case /* optional uint32 source_type */ 2:
                    message.sourceType = reader.uint32();
                    break;
                case /* optional CClientMetrics_ContentDownloadResponse_Counts counts */ 3:
                    message.counts = CClientMetrics_ContentDownloadResponse_Counts.internalBinaryRead(reader, reader.uint32(), options, message.counts);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ContentDownloadResponse_HostCounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string hostname = 1; */
        if (message.hostname !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.hostname);
        /* optional uint32 source_type = 2; */
        if (message.sourceType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.sourceType);
        /* optional CClientMetrics_ContentDownloadResponse_Counts counts = 3; */
        if (message.counts)
            CClientMetrics_ContentDownloadResponse_Counts.internalBinaryWrite(message.counts, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ContentDownloadResponse_HostCounts
 */
export const CClientMetrics_ContentDownloadResponse_HostCounts = new CClientMetrics_ContentDownloadResponse_HostCounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ContentDownloadResponse_Hosts$Type extends MessageType<CClientMetrics_ContentDownloadResponse_Hosts> {
    constructor() {
        super("CClientMetrics_ContentDownloadResponse_Hosts", [
            { no: 1, name: "hosts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CClientMetrics_ContentDownloadResponse_HostCounts }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ContentDownloadResponse_Hosts>): CClientMetrics_ContentDownloadResponse_Hosts {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hosts = [];
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ContentDownloadResponse_Hosts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ContentDownloadResponse_Hosts): CClientMetrics_ContentDownloadResponse_Hosts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CClientMetrics_ContentDownloadResponse_HostCounts hosts */ 1:
                    message.hosts.push(CClientMetrics_ContentDownloadResponse_HostCounts.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ContentDownloadResponse_Hosts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CClientMetrics_ContentDownloadResponse_HostCounts hosts = 1; */
        for (let i = 0; i < message.hosts.length; i++)
            CClientMetrics_ContentDownloadResponse_HostCounts.internalBinaryWrite(message.hosts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ContentDownloadResponse_Hosts
 */
export const CClientMetrics_ContentDownloadResponse_Hosts = new CClientMetrics_ContentDownloadResponse_Hosts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_ContentValidation_Notification$Type extends MessageType<CClientMetrics_ContentValidation_Notification> {
    constructor() {
        super("CClientMetrics_ContentValidation_Notification", [
            { no: 1, name: "validation_result", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "staged_files", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "user_initiated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "early_out", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "chunks_scanned", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "chunks_corrupt", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "bytes_scanned", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "chunk_bytes_corrupt", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "total_file_size_corrupt", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_ContentValidation_Notification>): CClientMetrics_ContentValidation_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_ContentValidation_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_ContentValidation_Notification): CClientMetrics_ContentValidation_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 validation_result */ 1:
                    message.validationResult = reader.int32();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional bool staged_files */ 3:
                    message.stagedFiles = reader.bool();
                    break;
                case /* optional bool user_initiated */ 4:
                    message.userInitiated = reader.bool();
                    break;
                case /* optional bool early_out */ 5:
                    message.earlyOut = reader.bool();
                    break;
                case /* optional uint32 chunks_scanned */ 6:
                    message.chunksScanned = reader.uint32();
                    break;
                case /* optional uint32 chunks_corrupt */ 7:
                    message.chunksCorrupt = reader.uint32();
                    break;
                case /* optional uint64 bytes_scanned */ 8:
                    message.bytesScanned = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 chunk_bytes_corrupt */ 9:
                    message.chunkBytesCorrupt = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 total_file_size_corrupt */ 10:
                    message.totalFileSizeCorrupt = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_ContentValidation_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 validation_result = 1; */
        if (message.validationResult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.validationResult);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional bool staged_files = 3; */
        if (message.stagedFiles !== undefined)
            writer.tag(3, WireType.Varint).bool(message.stagedFiles);
        /* optional bool user_initiated = 4; */
        if (message.userInitiated !== undefined)
            writer.tag(4, WireType.Varint).bool(message.userInitiated);
        /* optional bool early_out = 5; */
        if (message.earlyOut !== undefined)
            writer.tag(5, WireType.Varint).bool(message.earlyOut);
        /* optional uint32 chunks_scanned = 6; */
        if (message.chunksScanned !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.chunksScanned);
        /* optional uint32 chunks_corrupt = 7; */
        if (message.chunksCorrupt !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.chunksCorrupt);
        /* optional uint64 bytes_scanned = 8; */
        if (message.bytesScanned !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.bytesScanned);
        /* optional uint64 chunk_bytes_corrupt = 9; */
        if (message.chunkBytesCorrupt !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.chunkBytesCorrupt);
        /* optional uint64 total_file_size_corrupt = 10; */
        if (message.totalFileSizeCorrupt !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.totalFileSizeCorrupt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_ContentValidation_Notification
 */
export const CClientMetrics_ContentValidation_Notification = new CClientMetrics_ContentValidation_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_DownloadRates_Notification$Type extends MessageType<CClientMetrics_DownloadRates_Notification> {
    constructor() {
        super("CClientMetrics_DownloadRates_Notification", [
            { no: 1, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CClientMetrics_DownloadRates_Notification_StatsInfo },
            { no: 3, name: "throttling_kbps", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "os_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "device_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_DownloadRates_Notification>): CClientMetrics_DownloadRates_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stats = [];
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_DownloadRates_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_DownloadRates_Notification): CClientMetrics_DownloadRates_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 cell_id */ 1:
                    message.cellId = reader.uint32();
                    break;
                case /* repeated CClientMetrics_DownloadRates_Notification_StatsInfo stats */ 2:
                    message.stats.push(CClientMetrics_DownloadRates_Notification_StatsInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 throttling_kbps */ 3:
                    message.throttlingKbps = reader.uint32();
                    break;
                case /* optional uint32 os_type */ 4:
                    message.osType = reader.uint32();
                    break;
                case /* optional uint32 device_type */ 5:
                    message.deviceType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_DownloadRates_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 cell_id = 1; */
        if (message.cellId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cellId);
        /* repeated CClientMetrics_DownloadRates_Notification_StatsInfo stats = 2; */
        for (let i = 0; i < message.stats.length; i++)
            CClientMetrics_DownloadRates_Notification_StatsInfo.internalBinaryWrite(message.stats[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 throttling_kbps = 3; */
        if (message.throttlingKbps !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.throttlingKbps);
        /* optional uint32 os_type = 4; */
        if (message.osType !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.osType);
        /* optional uint32 device_type = 5; */
        if (message.deviceType !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.deviceType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_DownloadRates_Notification
 */
export const CClientMetrics_DownloadRates_Notification = new CClientMetrics_DownloadRates_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_DownloadRates_Notification_StatsInfo$Type extends MessageType<CClientMetrics_DownloadRates_Notification_StatsInfo> {
    constructor() {
        super("CClientMetrics_DownloadRates_Notification_StatsInfo", [
            { no: 1, name: "source_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "source_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "host_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "microseconds", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "used_ipv6", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "proxied", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "used_http2", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "cache_hits", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "cache_misses", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "hit_bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "miss_bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_DownloadRates_Notification_StatsInfo>): CClientMetrics_DownloadRates_Notification_StatsInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_DownloadRates_Notification_StatsInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_DownloadRates_Notification_StatsInfo): CClientMetrics_DownloadRates_Notification_StatsInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 source_type */ 1:
                    message.sourceType = reader.uint32();
                    break;
                case /* optional uint32 source_id */ 2:
                    message.sourceId = reader.uint32();
                    break;
                case /* optional uint64 bytes */ 3:
                    message.bytes = reader.uint64().toBigInt();
                    break;
                case /* optional string host_name */ 4:
                    message.hostName = reader.string();
                    break;
                case /* optional uint64 microseconds */ 5:
                    message.microseconds = reader.uint64().toBigInt();
                    break;
                case /* optional bool used_ipv6 */ 6:
                    message.usedIpv6 = reader.bool();
                    break;
                case /* optional bool proxied */ 7:
                    message.proxied = reader.bool();
                    break;
                case /* optional bool used_http2 */ 8:
                    message.usedHttp2 = reader.bool();
                    break;
                case /* optional uint32 cache_hits */ 9:
                    message.cacheHits = reader.uint32();
                    break;
                case /* optional uint32 cache_misses */ 10:
                    message.cacheMisses = reader.uint32();
                    break;
                case /* optional uint64 hit_bytes */ 11:
                    message.hitBytes = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 miss_bytes */ 12:
                    message.missBytes = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_DownloadRates_Notification_StatsInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 source_type = 1; */
        if (message.sourceType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.sourceType);
        /* optional uint32 source_id = 2; */
        if (message.sourceId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.sourceId);
        /* optional uint64 bytes = 3; */
        if (message.bytes !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.bytes);
        /* optional string host_name = 4; */
        if (message.hostName !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.hostName);
        /* optional uint64 microseconds = 5; */
        if (message.microseconds !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.microseconds);
        /* optional bool used_ipv6 = 6; */
        if (message.usedIpv6 !== undefined)
            writer.tag(6, WireType.Varint).bool(message.usedIpv6);
        /* optional bool proxied = 7; */
        if (message.proxied !== undefined)
            writer.tag(7, WireType.Varint).bool(message.proxied);
        /* optional bool used_http2 = 8; */
        if (message.usedHttp2 !== undefined)
            writer.tag(8, WireType.Varint).bool(message.usedHttp2);
        /* optional uint32 cache_hits = 9; */
        if (message.cacheHits !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.cacheHits);
        /* optional uint32 cache_misses = 10; */
        if (message.cacheMisses !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.cacheMisses);
        /* optional uint64 hit_bytes = 11; */
        if (message.hitBytes !== undefined)
            writer.tag(11, WireType.Varint).uint64(message.hitBytes);
        /* optional uint64 miss_bytes = 12; */
        if (message.missBytes !== undefined)
            writer.tag(12, WireType.Varint).uint64(message.missBytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_DownloadRates_Notification_StatsInfo
 */
export const CClientMetrics_DownloadRates_Notification_StatsInfo = new CClientMetrics_DownloadRates_Notification_StatsInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_EndGameRecording_Notification$Type extends MessageType<CClientMetrics_EndGameRecording_Notification> {
    constructor() {
        super("CClientMetrics_EndGameRecording_Notification", [
            { no: 1, name: "recording_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "seconds", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "gameid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "instant_clip", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_EndGameRecording_Notification>): CClientMetrics_EndGameRecording_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_EndGameRecording_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_EndGameRecording_Notification): CClientMetrics_EndGameRecording_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 recording_type */ 1:
                    message.recordingType = reader.int32();
                    break;
                case /* optional float seconds */ 2:
                    message.seconds = reader.float();
                    break;
                case /* optional uint64 bytes */ 3:
                    message.bytes = reader.uint64().toBigInt();
                    break;
                case /* optional fixed64 gameid */ 4:
                    message.gameid = reader.fixed64().toBigInt();
                    break;
                case /* optional bool instant_clip */ 5:
                    message.instantClip = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_EndGameRecording_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 recording_type = 1; */
        if (message.recordingType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.recordingType);
        /* optional float seconds = 2; */
        if (message.seconds !== undefined)
            writer.tag(2, WireType.Bit32).float(message.seconds);
        /* optional uint64 bytes = 3; */
        if (message.bytes !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.bytes);
        /* optional fixed64 gameid = 4; */
        if (message.gameid !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.gameid);
        /* optional bool instant_clip = 5; */
        if (message.instantClip !== undefined)
            writer.tag(5, WireType.Varint).bool(message.instantClip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_EndGameRecording_Notification
 */
export const CClientMetrics_EndGameRecording_Notification = new CClientMetrics_EndGameRecording_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_GamePerformance_Notification$Type extends MessageType<CClientMetrics_GamePerformance_Notification> {
    constructor() {
        super("CClientMetrics_GamePerformance_Notification", [
            { no: 1, name: "reports", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CClientMetrics_GamePerformance_Notification_FrameRateReport }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_GamePerformance_Notification>): CClientMetrics_GamePerformance_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reports = [];
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_GamePerformance_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_GamePerformance_Notification): CClientMetrics_GamePerformance_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CClientMetrics_GamePerformance_Notification_FrameRateReport reports */ 1:
                    message.reports.push(CClientMetrics_GamePerformance_Notification_FrameRateReport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_GamePerformance_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CClientMetrics_GamePerformance_Notification_FrameRateReport reports = 1; */
        for (let i = 0; i < message.reports.length; i++)
            CClientMetrics_GamePerformance_Notification_FrameRateReport.internalBinaryWrite(message.reports[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_GamePerformance_Notification
 */
export const CClientMetrics_GamePerformance_Notification = new CClientMetrics_GamePerformance_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_GamePerformance_Notification_FrameRateReport$Type extends MessageType<CClientMetrics_GamePerformance_Notification_FrameRateReport> {
    constructor() {
        super("CClientMetrics_GamePerformance_Notification_FrameRateReport", [
            { no: 1, name: "gameid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "frame_rate", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "manufacturer", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "model", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dx_video_card", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "dx_vendorid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "dx_deviceid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "num_gpu", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "system_ram", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "session_seconds", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_GamePerformance_Notification_FrameRateReport>): CClientMetrics_GamePerformance_Notification_FrameRateReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_GamePerformance_Notification_FrameRateReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_GamePerformance_Notification_FrameRateReport): CClientMetrics_GamePerformance_Notification_FrameRateReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 gameid */ 1:
                    message.gameid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 frame_rate */ 2:
                    message.frameRate = reader.uint32();
                    break;
                case /* optional string manufacturer */ 3:
                    message.manufacturer = reader.string();
                    break;
                case /* optional string model */ 4:
                    message.model = reader.string();
                    break;
                case /* optional string dx_video_card */ 5:
                    message.dxVideoCard = reader.string();
                    break;
                case /* optional int32 dx_vendorid */ 6:
                    message.dxVendorid = reader.int32();
                    break;
                case /* optional int32 dx_deviceid */ 7:
                    message.dxDeviceid = reader.int32();
                    break;
                case /* optional uint32 num_gpu */ 8:
                    message.numGpu = reader.uint32();
                    break;
                case /* optional uint64 system_ram */ 9:
                    message.systemRam = reader.uint64().toBigInt();
                    break;
                case /* optional int32 session_seconds */ 10:
                    message.sessionSeconds = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_GamePerformance_Notification_FrameRateReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 gameid = 1; */
        if (message.gameid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameid);
        /* optional uint32 frame_rate = 2; */
        if (message.frameRate !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.frameRate);
        /* optional string manufacturer = 3; */
        if (message.manufacturer !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.manufacturer);
        /* optional string model = 4; */
        if (message.model !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.model);
        /* optional string dx_video_card = 5; */
        if (message.dxVideoCard !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.dxVideoCard);
        /* optional int32 dx_vendorid = 6; */
        if (message.dxVendorid !== undefined)
            writer.tag(6, WireType.Varint).int32(message.dxVendorid);
        /* optional int32 dx_deviceid = 7; */
        if (message.dxDeviceid !== undefined)
            writer.tag(7, WireType.Varint).int32(message.dxDeviceid);
        /* optional uint32 num_gpu = 8; */
        if (message.numGpu !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.numGpu);
        /* optional uint64 system_ram = 9; */
        if (message.systemRam !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.systemRam);
        /* optional int32 session_seconds = 10; */
        if (message.sessionSeconds !== undefined)
            writer.tag(10, WireType.Varint).int32(message.sessionSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_GamePerformance_Notification_FrameRateReport
 */
export const CClientMetrics_GamePerformance_Notification_FrameRateReport = new CClientMetrics_GamePerformance_Notification_FrameRateReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_IPv6Connectivity_Notification$Type extends MessageType<CClientMetrics_IPv6Connectivity_Notification> {
    constructor() {
        super("CClientMetrics_IPv6Connectivity_Notification", [
            { no: 1, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CClientMetrics_IPv6Connectivity_Result },
            { no: 3, name: "private_ip_is_rfc6598", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_IPv6Connectivity_Notification>): CClientMetrics_IPv6Connectivity_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_IPv6Connectivity_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_IPv6Connectivity_Notification): CClientMetrics_IPv6Connectivity_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 cell_id */ 1:
                    message.cellId = reader.uint32();
                    break;
                case /* repeated CClientMetrics_IPv6Connectivity_Result results */ 2:
                    message.results.push(CClientMetrics_IPv6Connectivity_Result.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool private_ip_is_rfc6598 */ 3:
                    message.privateIpIsRfc6598 = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_IPv6Connectivity_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 cell_id = 1; */
        if (message.cellId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cellId);
        /* repeated CClientMetrics_IPv6Connectivity_Result results = 2; */
        for (let i = 0; i < message.results.length; i++)
            CClientMetrics_IPv6Connectivity_Result.internalBinaryWrite(message.results[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional bool private_ip_is_rfc6598 = 3; */
        if (message.privateIpIsRfc6598 !== undefined)
            writer.tag(3, WireType.Varint).bool(message.privateIpIsRfc6598);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_IPv6Connectivity_Notification
 */
export const CClientMetrics_IPv6Connectivity_Notification = new CClientMetrics_IPv6Connectivity_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_IPv6Connectivity_Result$Type extends MessageType<CClientMetrics_IPv6Connectivity_Result> {
    constructor() {
        super("CClientMetrics_IPv6Connectivity_Result", [
            { no: 1, name: "protocol_tested", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "connectivity_state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_IPv6Connectivity_Result>): CClientMetrics_IPv6Connectivity_Result {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_IPv6Connectivity_Result>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_IPv6Connectivity_Result): CClientMetrics_IPv6Connectivity_Result {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 protocol_tested */ 1:
                    message.protocolTested = reader.uint32();
                    break;
                case /* optional uint32 connectivity_state */ 2:
                    message.connectivityState = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_IPv6Connectivity_Result, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 protocol_tested = 1; */
        if (message.protocolTested !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.protocolTested);
        /* optional uint32 connectivity_state = 2; */
        if (message.connectivityState !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.connectivityState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_IPv6Connectivity_Result
 */
export const CClientMetrics_IPv6Connectivity_Result = new CClientMetrics_IPv6Connectivity_Result$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_SteamPipeWorkStats_Notification$Type extends MessageType<CClientMetrics_SteamPipeWorkStats_Notification> {
    constructor() {
        super("CClientMetrics_SteamPipeWorkStats_Notification", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "depotid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "work_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "operations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CClientMetrics_SteamPipeWorkStats_Operation },
            { no: 5, name: "hardware_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_SteamPipeWorkStats_Notification>): CClientMetrics_SteamPipeWorkStats_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operations = [];
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_SteamPipeWorkStats_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_SteamPipeWorkStats_Notification): CClientMetrics_SteamPipeWorkStats_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 depotid */ 2:
                    message.depotid = reader.uint32();
                    break;
                case /* optional int32 work_type */ 3:
                    message.workType = reader.int32();
                    break;
                case /* repeated CClientMetrics_SteamPipeWorkStats_Operation operations */ 4:
                    message.operations.push(CClientMetrics_SteamPipeWorkStats_Operation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 hardware_type */ 5:
                    message.hardwareType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_SteamPipeWorkStats_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 depotid = 2; */
        if (message.depotid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.depotid);
        /* optional int32 work_type = 3; */
        if (message.workType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.workType);
        /* repeated CClientMetrics_SteamPipeWorkStats_Operation operations = 4; */
        for (let i = 0; i < message.operations.length; i++)
            CClientMetrics_SteamPipeWorkStats_Operation.internalBinaryWrite(message.operations[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 hardware_type = 5; */
        if (message.hardwareType !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.hardwareType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_SteamPipeWorkStats_Notification
 */
export const CClientMetrics_SteamPipeWorkStats_Notification = new CClientMetrics_SteamPipeWorkStats_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientMetrics_SteamPipeWorkStats_Operation$Type extends MessageType<CClientMetrics_SteamPipeWorkStats_Operation> {
    constructor() {
        super("CClientMetrics_SteamPipeWorkStats_Operation", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "num_ops", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "num_bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "busy_time_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "idle_time_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "sum_run_time_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "sum_wait_time_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientMetrics_SteamPipeWorkStats_Operation>): CClientMetrics_SteamPipeWorkStats_Operation {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientMetrics_SteamPipeWorkStats_Operation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientMetrics_SteamPipeWorkStats_Operation): CClientMetrics_SteamPipeWorkStats_Operation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional uint32 num_ops */ 2:
                    message.numOps = reader.uint32();
                    break;
                case /* optional uint64 num_bytes */ 3:
                    message.numBytes = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 busy_time_ms */ 4:
                    message.busyTimeMs = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 idle_time_ms */ 5:
                    message.idleTimeMs = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 sum_run_time_ms */ 6:
                    message.sumRunTimeMs = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 sum_wait_time_ms */ 7:
                    message.sumWaitTimeMs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientMetrics_SteamPipeWorkStats_Operation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional uint32 num_ops = 2; */
        if (message.numOps !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.numOps);
        /* optional uint64 num_bytes = 3; */
        if (message.numBytes !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.numBytes);
        /* optional uint64 busy_time_ms = 4; */
        if (message.busyTimeMs !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.busyTimeMs);
        /* optional uint64 idle_time_ms = 5; */
        if (message.idleTimeMs !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.idleTimeMs);
        /* optional uint64 sum_run_time_ms = 6; */
        if (message.sumRunTimeMs !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.sumRunTimeMs);
        /* optional uint64 sum_wait_time_ms = 7; */
        if (message.sumWaitTimeMs !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.sumWaitTimeMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientMetrics_SteamPipeWorkStats_Operation
 */
export const CClientMetrics_SteamPipeWorkStats_Operation = new CClientMetrics_SteamPipeWorkStats_Operation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationAchievement$Type extends MessageType<CClientNotificationAchievement> {
    constructor() {
        super("CClientNotificationAchievement", [
            { no: 1, name: "achievement_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "image_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "achieved", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "rtime_unlocked", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "min_progress", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "current_progress", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "max_progress", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "global_achieved_pct", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationAchievement>): CClientNotificationAchievement {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationAchievement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationAchievement): CClientNotificationAchievement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string achievement_id */ 1:
                    message.achievementId = reader.string();
                    break;
                case /* optional uint32 appid */ 2:
                    message.appid = reader.uint32();
                    break;
                case /* optional string name */ 3:
                    message.name = reader.string();
                    break;
                case /* optional string description */ 4:
                    message.description = reader.string();
                    break;
                case /* optional string image_url */ 5:
                    message.imageUrl = reader.string();
                    break;
                case /* optional bool achieved */ 6:
                    message.achieved = reader.bool();
                    break;
                case /* optional uint32 rtime_unlocked */ 7:
                    message.rtimeUnlocked = reader.uint32();
                    break;
                case /* optional float min_progress */ 8:
                    message.minProgress = reader.float();
                    break;
                case /* optional float current_progress */ 9:
                    message.currentProgress = reader.float();
                    break;
                case /* optional float max_progress */ 10:
                    message.maxProgress = reader.float();
                    break;
                case /* optional float global_achieved_pct */ 11:
                    message.globalAchievedPct = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationAchievement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string achievement_id = 1; */
        if (message.achievementId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.achievementId);
        /* optional uint32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appid);
        /* optional string name = 3; */
        if (message.name !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* optional string description = 4; */
        if (message.description !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* optional string image_url = 5; */
        if (message.imageUrl !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.imageUrl);
        /* optional bool achieved = 6; */
        if (message.achieved !== undefined)
            writer.tag(6, WireType.Varint).bool(message.achieved);
        /* optional uint32 rtime_unlocked = 7; */
        if (message.rtimeUnlocked !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.rtimeUnlocked);
        /* optional float min_progress = 8; */
        if (message.minProgress !== undefined)
            writer.tag(8, WireType.Bit32).float(message.minProgress);
        /* optional float current_progress = 9; */
        if (message.currentProgress !== undefined)
            writer.tag(9, WireType.Bit32).float(message.currentProgress);
        /* optional float max_progress = 10; */
        if (message.maxProgress !== undefined)
            writer.tag(10, WireType.Bit32).float(message.maxProgress);
        /* optional float global_achieved_pct = 11; */
        if (message.globalAchievedPct !== undefined)
            writer.tag(11, WireType.Bit32).float(message.globalAchievedPct);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationAchievement
 */
export const CClientNotificationAchievement = new CClientNotificationAchievement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationBatteryTemperature$Type extends MessageType<CClientNotificationBatteryTemperature> {
    constructor() {
        super("CClientNotificationBatteryTemperature", [
            { no: 1, name: "temperature", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "notification_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationBatteryTemperature>): CClientNotificationBatteryTemperature {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationBatteryTemperature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationBatteryTemperature): CClientNotificationBatteryTemperature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 temperature */ 1:
                    message.temperature = reader.uint32();
                    break;
                case /* optional string notification_type */ 2:
                    message.notificationType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationBatteryTemperature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 temperature = 1; */
        if (message.temperature !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.temperature);
        /* optional string notification_type = 2; */
        if (message.notificationType !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.notificationType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationBatteryTemperature
 */
export const CClientNotificationBatteryTemperature = new CClientNotificationBatteryTemperature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationBroadcastAvailableToWatch$Type extends MessageType<CClientNotificationBroadcastAvailableToWatch> {
    constructor() {
        super("CClientNotificationBroadcastAvailableToWatch", [
            { no: 1, name: "broadcast_permission", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationBroadcastAvailableToWatch>): CClientNotificationBroadcastAvailableToWatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationBroadcastAvailableToWatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationBroadcastAvailableToWatch): CClientNotificationBroadcastAvailableToWatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 broadcast_permission */ 1:
                    message.broadcastPermission = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationBroadcastAvailableToWatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 broadcast_permission = 1; */
        if (message.broadcastPermission !== undefined)
            writer.tag(1, WireType.Varint).int32(message.broadcastPermission);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationBroadcastAvailableToWatch
 */
export const CClientNotificationBroadcastAvailableToWatch = new CClientNotificationBroadcastAvailableToWatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationCannotReadControllerGuideButton$Type extends MessageType<CClientNotificationCannotReadControllerGuideButton> {
    constructor() {
        super("CClientNotificationCannotReadControllerGuideButton", [
            { no: 1, name: "controller_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationCannotReadControllerGuideButton>): CClientNotificationCannotReadControllerGuideButton {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationCannotReadControllerGuideButton>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationCannotReadControllerGuideButton): CClientNotificationCannotReadControllerGuideButton {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 controller_index */ 1:
                    message.controllerIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationCannotReadControllerGuideButton, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 controller_index = 1; */
        if (message.controllerIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.controllerIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationCannotReadControllerGuideButton
 */
export const CClientNotificationCannotReadControllerGuideButton = new CClientNotificationCannotReadControllerGuideButton$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationClaimSteamDeckRewards$Type extends MessageType<CClientNotificationClaimSteamDeckRewards> {
    constructor() {
        super("CClientNotificationClaimSteamDeckRewards", []);
    }
    create(value?: PartialMessage<CClientNotificationClaimSteamDeckRewards>): CClientNotificationClaimSteamDeckRewards {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationClaimSteamDeckRewards>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationClaimSteamDeckRewards): CClientNotificationClaimSteamDeckRewards {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationClaimSteamDeckRewards, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationClaimSteamDeckRewards
 */
export const CClientNotificationClaimSteamDeckRewards = new CClientNotificationClaimSteamDeckRewards$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationCloudSyncConflict$Type extends MessageType<CClientNotificationCloudSyncConflict> {
    constructor() {
        super("CClientNotificationCloudSyncConflict", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationCloudSyncConflict>): CClientNotificationCloudSyncConflict {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationCloudSyncConflict>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationCloudSyncConflict): CClientNotificationCloudSyncConflict {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationCloudSyncConflict, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationCloudSyncConflict
 */
export const CClientNotificationCloudSyncConflict = new CClientNotificationCloudSyncConflict$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationCloudSyncFailure$Type extends MessageType<CClientNotificationCloudSyncFailure> {
    constructor() {
        super("CClientNotificationCloudSyncFailure", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationCloudSyncFailure>): CClientNotificationCloudSyncFailure {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationCloudSyncFailure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationCloudSyncFailure): CClientNotificationCloudSyncFailure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationCloudSyncFailure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationCloudSyncFailure
 */
export const CClientNotificationCloudSyncFailure = new CClientNotificationCloudSyncFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationDockUnsupportedFirmware$Type extends MessageType<CClientNotificationDockUnsupportedFirmware> {
    constructor() {
        super("CClientNotificationDockUnsupportedFirmware", []);
    }
    create(value?: PartialMessage<CClientNotificationDockUnsupportedFirmware>): CClientNotificationDockUnsupportedFirmware {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationDockUnsupportedFirmware>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationDockUnsupportedFirmware): CClientNotificationDockUnsupportedFirmware {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationDockUnsupportedFirmware, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationDockUnsupportedFirmware
 */
export const CClientNotificationDockUnsupportedFirmware = new CClientNotificationDockUnsupportedFirmware$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationDownloadCompleted$Type extends MessageType<CClientNotificationDownloadCompleted> {
    constructor() {
        super("CClientNotificationDownloadCompleted", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "dlc_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationDownloadCompleted>): CClientNotificationDownloadCompleted {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationDownloadCompleted>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationDownloadCompleted): CClientNotificationDownloadCompleted {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 dlc_appid */ 2:
                    message.dlcAppid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationDownloadCompleted, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 dlc_appid = 2; */
        if (message.dlcAppid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.dlcAppid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationDownloadCompleted
 */
export const CClientNotificationDownloadCompleted = new CClientNotificationDownloadCompleted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationFamilySharingStopPlaying$Type extends MessageType<CClientNotificationFamilySharingStopPlaying> {
    constructor() {
        super("CClientNotificationFamilySharingStopPlaying", [
            { no: 1, name: "accountid_owner", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "seconds_remaining", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationFamilySharingStopPlaying>): CClientNotificationFamilySharingStopPlaying {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationFamilySharingStopPlaying>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationFamilySharingStopPlaying): CClientNotificationFamilySharingStopPlaying {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 accountid_owner */ 1:
                    message.accountidOwner = reader.uint32();
                    break;
                case /* optional uint32 seconds_remaining */ 2:
                    message.secondsRemaining = reader.uint32();
                    break;
                case /* optional uint32 appid */ 3:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationFamilySharingStopPlaying, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 accountid_owner = 1; */
        if (message.accountidOwner !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.accountidOwner);
        /* optional uint32 seconds_remaining = 2; */
        if (message.secondsRemaining !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.secondsRemaining);
        /* optional uint32 appid = 3; */
        if (message.appid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationFamilySharingStopPlaying
 */
export const CClientNotificationFamilySharingStopPlaying = new CClientNotificationFamilySharingStopPlaying$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationFriendInGame$Type extends MessageType<CClientNotificationFriendInGame> {
    constructor() {
        super("CClientNotificationFriendInGame", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "game_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationFriendInGame>): CClientNotificationFriendInGame {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationFriendInGame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationFriendInGame): CClientNotificationFriendInGame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string game_name */ 2:
                    message.gameName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationFriendInGame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional string game_name = 2; */
        if (message.gameName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.gameName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationFriendInGame
 */
export const CClientNotificationFriendInGame = new CClientNotificationFriendInGame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationFriendInviteRollup$Type extends MessageType<CClientNotificationFriendInviteRollup> {
    constructor() {
        super("CClientNotificationFriendInviteRollup", [
            { no: 1, name: "new_invite_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationFriendInviteRollup>): CClientNotificationFriendInviteRollup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationFriendInviteRollup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationFriendInviteRollup): CClientNotificationFriendInviteRollup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 new_invite_count */ 1:
                    message.newInviteCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationFriendInviteRollup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 new_invite_count = 1; */
        if (message.newInviteCount !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.newInviteCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationFriendInviteRollup
 */
export const CClientNotificationFriendInviteRollup = new CClientNotificationFriendInviteRollup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationFriendMessage$Type extends MessageType<CClientNotificationFriendMessage> {
    constructor() {
        super("CClientNotificationFriendMessage", [
            { no: 1, name: "tag", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "steamid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "body", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "notificationid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "response_steamurl", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationFriendMessage>): CClientNotificationFriendMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationFriendMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationFriendMessage): CClientNotificationFriendMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string tag */ 1:
                    message.tag = reader.string();
                    break;
                case /* optional string steamid */ 2:
                    message.steamid = reader.string();
                    break;
                case /* optional string title */ 3:
                    message.title = reader.string();
                    break;
                case /* optional string body */ 4:
                    message.body = reader.string();
                    break;
                case /* optional string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* optional uint32 notificationid */ 6:
                    message.notificationid = reader.uint32();
                    break;
                case /* optional string response_steamurl */ 7:
                    message.responseSteamurl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationFriendMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string tag = 1; */
        if (message.tag !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.tag);
        /* optional string steamid = 2; */
        if (message.steamid !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.steamid);
        /* optional string title = 3; */
        if (message.title !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.title);
        /* optional string body = 4; */
        if (message.body !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.body);
        /* optional string icon = 5; */
        if (message.icon !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* optional uint32 notificationid = 6; */
        if (message.notificationid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.notificationid);
        /* optional string response_steamurl = 7; */
        if (message.responseSteamurl !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.responseSteamurl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationFriendMessage
 */
export const CClientNotificationFriendMessage = new CClientNotificationFriendMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationFriendOnline$Type extends MessageType<CClientNotificationFriendOnline> {
    constructor() {
        super("CClientNotificationFriendOnline", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationFriendOnline>): CClientNotificationFriendOnline {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationFriendOnline>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationFriendOnline): CClientNotificationFriendOnline {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationFriendOnline, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationFriendOnline
 */
export const CClientNotificationFriendOnline = new CClientNotificationFriendOnline$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationGameRecordingError$Type extends MessageType<CClientNotificationGameRecordingError> {
    constructor() {
        super("CClientNotificationGameRecordingError", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "error_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationGameRecordingError>): CClientNotificationGameRecordingError {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationGameRecordingError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationGameRecordingError): CClientNotificationGameRecordingError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 game_id */ 1:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 error_type */ 2:
                    message.errorType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationGameRecordingError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameId);
        /* optional int32 error_type = 2; */
        if (message.errorType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.errorType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationGameRecordingError
 */
export const CClientNotificationGameRecordingError = new CClientNotificationGameRecordingError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationGameRecordingInstantClip$Type extends MessageType<CClientNotificationGameRecordingInstantClip> {
    constructor() {
        super("CClientNotificationGameRecordingInstantClip", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clip_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "duration_secs", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationGameRecordingInstantClip>): CClientNotificationGameRecordingInstantClip {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationGameRecordingInstantClip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationGameRecordingInstantClip): CClientNotificationGameRecordingInstantClip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 game_id */ 1:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional string clip_id */ 2:
                    message.clipId = reader.string();
                    break;
                case /* optional float duration_secs */ 3:
                    message.durationSecs = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationGameRecordingInstantClip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameId);
        /* optional string clip_id = 2; */
        if (message.clipId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.clipId);
        /* optional float duration_secs = 3; */
        if (message.durationSecs !== undefined)
            writer.tag(3, WireType.Bit32).float(message.durationSecs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationGameRecordingInstantClip
 */
export const CClientNotificationGameRecordingInstantClip = new CClientNotificationGameRecordingInstantClip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationGameRecordingStart$Type extends MessageType<CClientNotificationGameRecordingStart> {
    constructor() {
        super("CClientNotificationGameRecordingStart", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationGameRecordingStart>): CClientNotificationGameRecordingStart {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationGameRecordingStart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationGameRecordingStart): CClientNotificationGameRecordingStart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 game_id */ 1:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationGameRecordingStart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationGameRecordingStart
 */
export const CClientNotificationGameRecordingStart = new CClientNotificationGameRecordingStart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationGameRecordingStop$Type extends MessageType<CClientNotificationGameRecordingStop> {
    constructor() {
        super("CClientNotificationGameRecordingStop", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clip_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "duration_secs", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationGameRecordingStop>): CClientNotificationGameRecordingStop {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationGameRecordingStop>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationGameRecordingStop): CClientNotificationGameRecordingStop {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 game_id */ 1:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional string clip_id */ 2:
                    message.clipId = reader.string();
                    break;
                case /* optional float duration_secs */ 3:
                    message.durationSecs = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationGameRecordingStop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameId);
        /* optional string clip_id = 2; */
        if (message.clipId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.clipId);
        /* optional float duration_secs = 3; */
        if (message.durationSecs !== undefined)
            writer.tag(3, WireType.Bit32).float(message.durationSecs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationGameRecordingStop
 */
export const CClientNotificationGameRecordingStop = new CClientNotificationGameRecordingStop$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationGameRecordingUserMarkerAdded$Type extends MessageType<CClientNotificationGameRecordingUserMarkerAdded> {
    constructor() {
        super("CClientNotificationGameRecordingUserMarkerAdded", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationGameRecordingUserMarkerAdded>): CClientNotificationGameRecordingUserMarkerAdded {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationGameRecordingUserMarkerAdded>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationGameRecordingUserMarkerAdded): CClientNotificationGameRecordingUserMarkerAdded {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 game_id */ 1:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationGameRecordingUserMarkerAdded, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationGameRecordingUserMarkerAdded
 */
export const CClientNotificationGameRecordingUserMarkerAdded = new CClientNotificationGameRecordingUserMarkerAdded$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationGroupChatMessage$Type extends MessageType<CClientNotificationGroupChatMessage> {
    constructor() {
        super("CClientNotificationGroupChatMessage", [
            { no: 1, name: "tag", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "steamid_sender", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "chat_group_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "chat_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "body", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "rawbody", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "icon", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "notificationid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationGroupChatMessage>): CClientNotificationGroupChatMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationGroupChatMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationGroupChatMessage): CClientNotificationGroupChatMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string tag */ 1:
                    message.tag = reader.string();
                    break;
                case /* optional string steamid_sender */ 2:
                    message.steamidSender = reader.string();
                    break;
                case /* optional string chat_group_id */ 3:
                    message.chatGroupId = reader.string();
                    break;
                case /* optional string chat_id */ 4:
                    message.chatId = reader.string();
                    break;
                case /* optional string title */ 5:
                    message.title = reader.string();
                    break;
                case /* optional string body */ 6:
                    message.body = reader.string();
                    break;
                case /* optional string rawbody */ 7:
                    message.rawbody = reader.string();
                    break;
                case /* optional string icon */ 8:
                    message.icon = reader.string();
                    break;
                case /* optional uint32 notificationid */ 9:
                    message.notificationid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationGroupChatMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string tag = 1; */
        if (message.tag !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.tag);
        /* optional string steamid_sender = 2; */
        if (message.steamidSender !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.steamidSender);
        /* optional string chat_group_id = 3; */
        if (message.chatGroupId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.chatGroupId);
        /* optional string chat_id = 4; */
        if (message.chatId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.chatId);
        /* optional string title = 5; */
        if (message.title !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.title);
        /* optional string body = 6; */
        if (message.body !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.body);
        /* optional string rawbody = 7; */
        if (message.rawbody !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.rawbody);
        /* optional string icon = 8; */
        if (message.icon !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.icon);
        /* optional uint32 notificationid = 9; */
        if (message.notificationid !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.notificationid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationGroupChatMessage
 */
export const CClientNotificationGroupChatMessage = new CClientNotificationGroupChatMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationHardwareSurveyPending$Type extends MessageType<CClientNotificationHardwareSurveyPending> {
    constructor() {
        super("CClientNotificationHardwareSurveyPending", []);
    }
    create(value?: PartialMessage<CClientNotificationHardwareSurveyPending>): CClientNotificationHardwareSurveyPending {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationHardwareSurveyPending>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationHardwareSurveyPending): CClientNotificationHardwareSurveyPending {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationHardwareSurveyPending, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationHardwareSurveyPending
 */
export const CClientNotificationHardwareSurveyPending = new CClientNotificationHardwareSurveyPending$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationIncomingVoiceChat$Type extends MessageType<CClientNotificationIncomingVoiceChat> {
    constructor() {
        super("CClientNotificationIncomingVoiceChat", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationIncomingVoiceChat>): CClientNotificationIncomingVoiceChat {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationIncomingVoiceChat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationIncomingVoiceChat): CClientNotificationIncomingVoiceChat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationIncomingVoiceChat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationIncomingVoiceChat
 */
export const CClientNotificationIncomingVoiceChat = new CClientNotificationIncomingVoiceChat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationItemAnnouncement$Type extends MessageType<CClientNotificationItemAnnouncement> {
    constructor() {
        super("CClientNotificationItemAnnouncement", [
            { no: 1, name: "new_item_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "new_backpack_items", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationItemAnnouncement>): CClientNotificationItemAnnouncement {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationItemAnnouncement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationItemAnnouncement): CClientNotificationItemAnnouncement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 new_item_count */ 1:
                    message.newItemCount = reader.uint32();
                    break;
                case /* optional bool new_backpack_items */ 2:
                    message.newBackpackItems = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationItemAnnouncement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 new_item_count = 1; */
        if (message.newItemCount !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.newItemCount);
        /* optional bool new_backpack_items = 2; */
        if (message.newBackpackItems !== undefined)
            writer.tag(2, WireType.Varint).bool(message.newBackpackItems);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationItemAnnouncement
 */
export const CClientNotificationItemAnnouncement = new CClientNotificationItemAnnouncement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationLoginRefresh$Type extends MessageType<CClientNotificationLoginRefresh> {
    constructor() {
        super("CClientNotificationLoginRefresh", []);
    }
    create(value?: PartialMessage<CClientNotificationLoginRefresh>): CClientNotificationLoginRefresh {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationLoginRefresh>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationLoginRefresh): CClientNotificationLoginRefresh {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationLoginRefresh, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationLoginRefresh
 */
export const CClientNotificationLoginRefresh = new CClientNotificationLoginRefresh$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationLowBattery$Type extends MessageType<CClientNotificationLowBattery> {
    constructor() {
        super("CClientNotificationLowBattery", [
            { no: 1, name: "pct_remaining", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationLowBattery>): CClientNotificationLowBattery {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationLowBattery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationLowBattery): CClientNotificationLowBattery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float pct_remaining */ 1:
                    message.pctRemaining = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationLowBattery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float pct_remaining = 1; */
        if (message.pctRemaining !== undefined)
            writer.tag(1, WireType.Bit32).float(message.pctRemaining);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationLowBattery
 */
export const CClientNotificationLowBattery = new CClientNotificationLowBattery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationLowDiskSpace$Type extends MessageType<CClientNotificationLowDiskSpace> {
    constructor() {
        super("CClientNotificationLowDiskSpace", [
            { no: 1, name: "folder_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationLowDiskSpace>): CClientNotificationLowDiskSpace {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationLowDiskSpace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationLowDiskSpace): CClientNotificationLowDiskSpace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 folder_index */ 1:
                    message.folderIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationLowDiskSpace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 folder_index = 1; */
        if (message.folderIndex !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.folderIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationLowDiskSpace
 */
export const CClientNotificationLowDiskSpace = new CClientNotificationLowDiskSpace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationOverlaySplashScreen$Type extends MessageType<CClientNotificationOverlaySplashScreen> {
    constructor() {
        super("CClientNotificationOverlaySplashScreen", []);
    }
    create(value?: PartialMessage<CClientNotificationOverlaySplashScreen>): CClientNotificationOverlaySplashScreen {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationOverlaySplashScreen>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationOverlaySplashScreen): CClientNotificationOverlaySplashScreen {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationOverlaySplashScreen, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationOverlaySplashScreen
 */
export const CClientNotificationOverlaySplashScreen = new CClientNotificationOverlaySplashScreen$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationPlaytimeWarning$Type extends MessageType<CClientNotificationPlaytimeWarning> {
    constructor() {
        super("CClientNotificationPlaytimeWarning", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "playtime_remaining", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationPlaytimeWarning>): CClientNotificationPlaytimeWarning {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationPlaytimeWarning>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationPlaytimeWarning): CClientNotificationPlaytimeWarning {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string type */ 1:
                    message.type = reader.string();
                    break;
                case /* optional uint32 playtime_remaining */ 2:
                    message.playtimeRemaining = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationPlaytimeWarning, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* optional uint32 playtime_remaining = 2; */
        if (message.playtimeRemaining !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.playtimeRemaining);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationPlaytimeWarning
 */
export const CClientNotificationPlaytimeWarning = new CClientNotificationPlaytimeWarning$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationRemoteClientConnection$Type extends MessageType<CClientNotificationRemoteClientConnection> {
    constructor() {
        super("CClientNotificationRemoteClientConnection", [
            { no: 1, name: "machine", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "connected", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationRemoteClientConnection>): CClientNotificationRemoteClientConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationRemoteClientConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationRemoteClientConnection): CClientNotificationRemoteClientConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string machine */ 1:
                    message.machine = reader.string();
                    break;
                case /* optional bool connected */ 2:
                    message.connected = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationRemoteClientConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string machine = 1; */
        if (message.machine !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.machine);
        /* optional bool connected = 2; */
        if (message.connected !== undefined)
            writer.tag(2, WireType.Varint).bool(message.connected);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationRemoteClientConnection
 */
export const CClientNotificationRemoteClientConnection = new CClientNotificationRemoteClientConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationRemoteClientStartStream$Type extends MessageType<CClientNotificationRemoteClientStartStream> {
    constructor() {
        super("CClientNotificationRemoteClientStartStream", [
            { no: 1, name: "machine", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "game_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationRemoteClientStartStream>): CClientNotificationRemoteClientStartStream {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationRemoteClientStartStream>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationRemoteClientStartStream): CClientNotificationRemoteClientStartStream {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string machine */ 1:
                    message.machine = reader.string();
                    break;
                case /* optional string game_name */ 2:
                    message.gameName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationRemoteClientStartStream, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string machine = 1; */
        if (message.machine !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.machine);
        /* optional string game_name = 2; */
        if (message.gameName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.gameName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationRemoteClientStartStream
 */
export const CClientNotificationRemoteClientStartStream = new CClientNotificationRemoteClientStartStream$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationScreenshot$Type extends MessageType<CClientNotificationScreenshot> {
    constructor() {
        super("CClientNotificationScreenshot", [
            { no: 1, name: "screenshot_handle", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "local_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationScreenshot>): CClientNotificationScreenshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationScreenshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationScreenshot): CClientNotificationScreenshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string screenshot_handle */ 1:
                    message.screenshotHandle = reader.string();
                    break;
                case /* optional string description */ 2:
                    message.description = reader.string();
                    break;
                case /* optional string local_url */ 3:
                    message.localUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationScreenshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string screenshot_handle = 1; */
        if (message.screenshotHandle !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.screenshotHandle);
        /* optional string description = 2; */
        if (message.description !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* optional string local_url = 3; */
        if (message.localUrl !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.localUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationScreenshot
 */
export const CClientNotificationScreenshot = new CClientNotificationScreenshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationSteamInputActionSetChanged$Type extends MessageType<CClientNotificationSteamInputActionSetChanged> {
    constructor() {
        super("CClientNotificationSteamInputActionSetChanged", [
            { no: 1, name: "controller_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "action_set_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationSteamInputActionSetChanged>): CClientNotificationSteamInputActionSetChanged {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationSteamInputActionSetChanged>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationSteamInputActionSetChanged): CClientNotificationSteamInputActionSetChanged {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 controller_index */ 1:
                    message.controllerIndex = reader.int32();
                    break;
                case /* optional string action_set_name */ 2:
                    message.actionSetName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationSteamInputActionSetChanged, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 controller_index = 1; */
        if (message.controllerIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.controllerIndex);
        /* optional string action_set_name = 2; */
        if (message.actionSetName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionSetName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationSteamInputActionSetChanged
 */
export const CClientNotificationSteamInputActionSetChanged = new CClientNotificationSteamInputActionSetChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationStreamingClientConnection$Type extends MessageType<CClientNotificationStreamingClientConnection> {
    constructor() {
        super("CClientNotificationStreamingClientConnection", [
            { no: 1, name: "hostname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "machine", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "connected", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationStreamingClientConnection>): CClientNotificationStreamingClientConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationStreamingClientConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationStreamingClientConnection): CClientNotificationStreamingClientConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string hostname */ 1:
                    message.hostname = reader.string();
                    break;
                case /* optional string machine */ 2:
                    message.machine = reader.string();
                    break;
                case /* optional bool connected */ 3:
                    message.connected = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationStreamingClientConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string hostname = 1; */
        if (message.hostname !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.hostname);
        /* optional string machine = 2; */
        if (message.machine !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.machine);
        /* optional bool connected = 3; */
        if (message.connected !== undefined)
            writer.tag(3, WireType.Varint).bool(message.connected);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationStreamingClientConnection
 */
export const CClientNotificationStreamingClientConnection = new CClientNotificationStreamingClientConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationSystemUpdate$Type extends MessageType<CClientNotificationSystemUpdate> {
    constructor() {
        super("CClientNotificationSystemUpdate", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationSystemUpdate>): CClientNotificationSystemUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationSystemUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationSystemUpdate): CClientNotificationSystemUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationSystemUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationSystemUpdate
 */
export const CClientNotificationSystemUpdate = new CClientNotificationSystemUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationTimedTrialRemaining$Type extends MessageType<CClientNotificationTimedTrialRemaining> {
    constructor() {
        super("CClientNotificationTimedTrialRemaining", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "icon", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "offline", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "allowed_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "played_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClientNotificationTimedTrialRemaining>): CClientNotificationTimedTrialRemaining {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationTimedTrialRemaining>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationTimedTrialRemaining): CClientNotificationTimedTrialRemaining {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional string icon */ 2:
                    message.icon = reader.string();
                    break;
                case /* optional bool offline */ 3:
                    message.offline = reader.bool();
                    break;
                case /* optional uint32 allowed_seconds */ 4:
                    message.allowedSeconds = reader.uint32();
                    break;
                case /* optional uint32 played_seconds */ 5:
                    message.playedSeconds = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationTimedTrialRemaining, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional string icon = 2; */
        if (message.icon !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.icon);
        /* optional bool offline = 3; */
        if (message.offline !== undefined)
            writer.tag(3, WireType.Varint).bool(message.offline);
        /* optional uint32 allowed_seconds = 4; */
        if (message.allowedSeconds !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.allowedSeconds);
        /* optional uint32 played_seconds = 5; */
        if (message.playedSeconds !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.playedSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationTimedTrialRemaining
 */
export const CClientNotificationTimedTrialRemaining = new CClientNotificationTimedTrialRemaining$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClientNotificationTimerExpired$Type extends MessageType<CClientNotificationTimerExpired> {
    constructor() {
        super("CClientNotificationTimerExpired", []);
    }
    create(value?: PartialMessage<CClientNotificationTimerExpired>): CClientNotificationTimerExpired {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClientNotificationTimerExpired>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClientNotificationTimerExpired): CClientNotificationTimerExpired {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClientNotificationTimerExpired, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClientNotificationTimerExpired
 */
export const CClientNotificationTimerExpired = new CClientNotificationTimerExpired$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCloud_AppExitSyncDone_Notification$Type extends MessageType<CCloud_AppExitSyncDone_Notification> {
    constructor() {
        super("CCloud_AppExitSyncDone_Notification", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "client_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "uploads_completed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "uploads_required", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CCloud_AppExitSyncDone_Notification>): CCloud_AppExitSyncDone_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCloud_AppExitSyncDone_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCloud_AppExitSyncDone_Notification): CCloud_AppExitSyncDone_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint64 client_id */ 2:
                    message.clientId = reader.uint64().toBigInt();
                    break;
                case /* optional bool uploads_completed */ 3:
                    message.uploadsCompleted = reader.bool();
                    break;
                case /* optional bool uploads_required */ 4:
                    message.uploadsRequired = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCloud_AppExitSyncDone_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint64 client_id = 2; */
        if (message.clientId !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.clientId);
        /* optional bool uploads_completed = 3; */
        if (message.uploadsCompleted !== undefined)
            writer.tag(3, WireType.Varint).bool(message.uploadsCompleted);
        /* optional bool uploads_required = 4; */
        if (message.uploadsRequired !== undefined)
            writer.tag(4, WireType.Varint).bool(message.uploadsRequired);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCloud_AppExitSyncDone_Notification
 */
export const CCloud_AppExitSyncDone_Notification = new CCloud_AppExitSyncDone_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCloud_PendingRemoteOperation$Type extends MessageType<CCloud_PendingRemoteOperation> {
    constructor() {
        super("CCloud_PendingRemoteOperation", [
            { no: 1, name: "operation", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "machine_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "time_last_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "os_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "device_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCloud_PendingRemoteOperation>): CCloud_PendingRemoteOperation {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCloud_PendingRemoteOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCloud_PendingRemoteOperation): CCloud_PendingRemoteOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 operation */ 1:
                    message.operation = reader.int32();
                    break;
                case /* optional string machine_name */ 2:
                    message.machineName = reader.string();
                    break;
                case /* optional uint64 client_id */ 3:
                    message.clientId = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 time_last_updated */ 4:
                    message.timeLastUpdated = reader.uint32();
                    break;
                case /* optional int32 os_type */ 5:
                    message.osType = reader.int32();
                    break;
                case /* optional int32 device_type */ 6:
                    message.deviceType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCloud_PendingRemoteOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 operation = 1; */
        if (message.operation !== undefined)
            writer.tag(1, WireType.Varint).int32(message.operation);
        /* optional string machine_name = 2; */
        if (message.machineName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.machineName);
        /* optional uint64 client_id = 3; */
        if (message.clientId !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.clientId);
        /* optional uint32 time_last_updated = 4; */
        if (message.timeLastUpdated !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.timeLastUpdated);
        /* optional int32 os_type = 5; */
        if (message.osType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.osType);
        /* optional int32 device_type = 6; */
        if (message.deviceType !== undefined)
            writer.tag(6, WireType.Varint).int32(message.deviceType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCloud_PendingRemoteOperation
 */
export const CCloud_PendingRemoteOperation = new CCloud_PendingRemoteOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCommunity_ClanAnnouncementInfo$Type extends MessageType<CCommunity_ClanAnnouncementInfo> {
    constructor() {
        super("CCommunity_ClanAnnouncementInfo", [
            { no: 1, name: "gid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clanid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "posterid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "headline", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "posttime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "updatetime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "body", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "commentcount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "language", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "forum_topic_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "event_gid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "voteupcount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "votedowncount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCommunity_ClanAnnouncementInfo>): CCommunity_ClanAnnouncementInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<CCommunity_ClanAnnouncementInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCommunity_ClanAnnouncementInfo): CCommunity_ClanAnnouncementInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 gid */ 1:
                    message.gid = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 clanid */ 2:
                    message.clanid = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 posterid */ 3:
                    message.posterid = reader.uint64().toBigInt();
                    break;
                case /* optional string headline */ 4:
                    message.headline = reader.string();
                    break;
                case /* optional uint32 posttime */ 5:
                    message.posttime = reader.uint32();
                    break;
                case /* optional uint32 updatetime */ 6:
                    message.updatetime = reader.uint32();
                    break;
                case /* optional string body */ 7:
                    message.body = reader.string();
                    break;
                case /* optional int32 commentcount */ 8:
                    message.commentcount = reader.int32();
                    break;
                case /* repeated string tags */ 9:
                    message.tags.push(reader.string());
                    break;
                case /* optional int32 language */ 10:
                    message.language = reader.int32();
                    break;
                case /* optional bool hidden */ 11:
                    message.hidden = reader.bool();
                    break;
                case /* optional fixed64 forum_topic_id */ 12:
                    message.forumTopicId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 event_gid */ 13:
                    message.eventGid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 voteupcount */ 14:
                    message.voteupcount = reader.int32();
                    break;
                case /* optional int32 votedowncount */ 15:
                    message.votedowncount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCommunity_ClanAnnouncementInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 gid = 1; */
        if (message.gid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.gid);
        /* optional uint64 clanid = 2; */
        if (message.clanid !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.clanid);
        /* optional uint64 posterid = 3; */
        if (message.posterid !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.posterid);
        /* optional string headline = 4; */
        if (message.headline !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.headline);
        /* optional uint32 posttime = 5; */
        if (message.posttime !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.posttime);
        /* optional uint32 updatetime = 6; */
        if (message.updatetime !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.updatetime);
        /* optional string body = 7; */
        if (message.body !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.body);
        /* optional int32 commentcount = 8; */
        if (message.commentcount !== undefined)
            writer.tag(8, WireType.Varint).int32(message.commentcount);
        /* repeated string tags = 9; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.tags[i]);
        /* optional int32 language = 10; */
        if (message.language !== undefined)
            writer.tag(10, WireType.Varint).int32(message.language);
        /* optional bool hidden = 11; */
        if (message.hidden !== undefined)
            writer.tag(11, WireType.Varint).bool(message.hidden);
        /* optional fixed64 forum_topic_id = 12; */
        if (message.forumTopicId !== undefined)
            writer.tag(12, WireType.Bit64).fixed64(message.forumTopicId);
        /* optional fixed64 event_gid = 13; */
        if (message.eventGid !== undefined)
            writer.tag(13, WireType.Bit64).fixed64(message.eventGid);
        /* optional int32 voteupcount = 14; */
        if (message.voteupcount !== undefined)
            writer.tag(14, WireType.Varint).int32(message.voteupcount);
        /* optional int32 votedowncount = 15; */
        if (message.votedowncount !== undefined)
            writer.tag(15, WireType.Varint).int32(message.votedowncount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCommunity_ClanAnnouncementInfo
 */
export const CCommunity_ClanAnnouncementInfo = new CCommunity_ClanAnnouncementInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCuratorPreferences$Type extends MessageType<CCuratorPreferences> {
    constructor() {
        super("CCuratorPreferences", [
            { no: 1, name: "supported_languages", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "platform_windows", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "platform_mac", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "platform_linux", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "vr_content", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "adult_content_violence", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "adult_content_sex", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "timestamp_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "tagids_curated", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "tagids_filtered", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "website_title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "website_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "discussion_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "show_broadcast", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CCuratorPreferences>): CCuratorPreferences {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagidsCurated = [];
        message.tagidsFiltered = [];
        if (value !== undefined)
            reflectionMergePartial<CCuratorPreferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCuratorPreferences): CCuratorPreferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 supported_languages */ 1:
                    message.supportedLanguages = reader.uint32();
                    break;
                case /* optional bool platform_windows */ 2:
                    message.platformWindows = reader.bool();
                    break;
                case /* optional bool platform_mac */ 3:
                    message.platformMac = reader.bool();
                    break;
                case /* optional bool platform_linux */ 4:
                    message.platformLinux = reader.bool();
                    break;
                case /* optional bool vr_content */ 5:
                    message.vrContent = reader.bool();
                    break;
                case /* optional bool adult_content_violence */ 6:
                    message.adultContentViolence = reader.bool();
                    break;
                case /* optional bool adult_content_sex */ 7:
                    message.adultContentSex = reader.bool();
                    break;
                case /* optional uint32 timestamp_updated */ 8:
                    message.timestampUpdated = reader.uint32();
                    break;
                case /* repeated uint32 tagids_curated */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tagidsCurated.push(reader.uint32());
                    else
                        message.tagidsCurated.push(reader.uint32());
                    break;
                case /* repeated uint32 tagids_filtered */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tagidsFiltered.push(reader.uint32());
                    else
                        message.tagidsFiltered.push(reader.uint32());
                    break;
                case /* optional string website_title */ 11:
                    message.websiteTitle = reader.string();
                    break;
                case /* optional string website_url */ 12:
                    message.websiteUrl = reader.string();
                    break;
                case /* optional string discussion_url */ 13:
                    message.discussionUrl = reader.string();
                    break;
                case /* optional bool show_broadcast */ 14:
                    message.showBroadcast = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCuratorPreferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 supported_languages = 1; */
        if (message.supportedLanguages !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.supportedLanguages);
        /* optional bool platform_windows = 2; */
        if (message.platformWindows !== undefined)
            writer.tag(2, WireType.Varint).bool(message.platformWindows);
        /* optional bool platform_mac = 3; */
        if (message.platformMac !== undefined)
            writer.tag(3, WireType.Varint).bool(message.platformMac);
        /* optional bool platform_linux = 4; */
        if (message.platformLinux !== undefined)
            writer.tag(4, WireType.Varint).bool(message.platformLinux);
        /* optional bool vr_content = 5; */
        if (message.vrContent !== undefined)
            writer.tag(5, WireType.Varint).bool(message.vrContent);
        /* optional bool adult_content_violence = 6; */
        if (message.adultContentViolence !== undefined)
            writer.tag(6, WireType.Varint).bool(message.adultContentViolence);
        /* optional bool adult_content_sex = 7; */
        if (message.adultContentSex !== undefined)
            writer.tag(7, WireType.Varint).bool(message.adultContentSex);
        /* optional uint32 timestamp_updated = 8; */
        if (message.timestampUpdated !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.timestampUpdated);
        /* repeated uint32 tagids_curated = 9; */
        for (let i = 0; i < message.tagidsCurated.length; i++)
            writer.tag(9, WireType.Varint).uint32(message.tagidsCurated[i]);
        /* repeated uint32 tagids_filtered = 10; */
        for (let i = 0; i < message.tagidsFiltered.length; i++)
            writer.tag(10, WireType.Varint).uint32(message.tagidsFiltered[i]);
        /* optional string website_title = 11; */
        if (message.websiteTitle !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.websiteTitle);
        /* optional string website_url = 12; */
        if (message.websiteUrl !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.websiteUrl);
        /* optional string discussion_url = 13; */
        if (message.discussionUrl !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.discussionUrl);
        /* optional bool show_broadcast = 14; */
        if (message.showBroadcast !== undefined)
            writer.tag(14, WireType.Varint).bool(message.showBroadcast);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCuratorPreferences
 */
export const CCuratorPreferences = new CCuratorPreferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGameNetworkingUI_AppSummary$Type extends MessageType<CGameNetworkingUI_AppSummary> {
    constructor() {
        super("CGameNetworkingUI_AppSummary", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "ip_was_shared_with_friend", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "ip_was_shared_with_nonfriend", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "active_connections", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 30, name: "main_cxn", kind: "message", T: () => CGameNetworkingUI_ConnectionSummary }
        ]);
    }
    create(value?: PartialMessage<CGameNetworkingUI_AppSummary>): CGameNetworkingUI_AppSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGameNetworkingUI_AppSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGameNetworkingUI_AppSummary): CGameNetworkingUI_AppSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional bool ip_was_shared_with_friend */ 10:
                    message.ipWasSharedWithFriend = reader.bool();
                    break;
                case /* optional bool ip_was_shared_with_nonfriend */ 11:
                    message.ipWasSharedWithNonfriend = reader.bool();
                    break;
                case /* optional uint32 active_connections */ 20:
                    message.activeConnections = reader.uint32();
                    break;
                case /* optional CGameNetworkingUI_ConnectionSummary main_cxn */ 30:
                    message.mainCxn = CGameNetworkingUI_ConnectionSummary.internalBinaryRead(reader, reader.uint32(), options, message.mainCxn);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGameNetworkingUI_AppSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional bool ip_was_shared_with_friend = 10; */
        if (message.ipWasSharedWithFriend !== undefined)
            writer.tag(10, WireType.Varint).bool(message.ipWasSharedWithFriend);
        /* optional bool ip_was_shared_with_nonfriend = 11; */
        if (message.ipWasSharedWithNonfriend !== undefined)
            writer.tag(11, WireType.Varint).bool(message.ipWasSharedWithNonfriend);
        /* optional uint32 active_connections = 20; */
        if (message.activeConnections !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.activeConnections);
        /* optional CGameNetworkingUI_ConnectionSummary main_cxn = 30; */
        if (message.mainCxn)
            CGameNetworkingUI_ConnectionSummary.internalBinaryWrite(message.mainCxn, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGameNetworkingUI_AppSummary
 */
export const CGameNetworkingUI_AppSummary = new CGameNetworkingUI_AppSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGameNetworkingUI_ConnectionState$Type extends MessageType<CGameNetworkingUI_ConnectionState> {
    constructor() {
        super("CGameNetworkingUI_ConnectionState", [
            { no: 1, name: "connection_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "connection_id_local", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "identity_local", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "identity_remote", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "connection_state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "start_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "close_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "close_reason", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "close_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "status_loc_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "transport_kind", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "sdrpopid_local", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "sdrpopid_remote", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "address_remote", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "p2p_routing", kind: "message", jsonName: "p2pRouting", T: () => CMsgSteamDatagramP2PRoutingSummary },
            { no: 25, name: "ping_interior", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "ping_remote_front", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 27, name: "ping_default_internet_route", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 30, name: "e2e_quality_local", kind: "message", jsonName: "e2eQualityLocal", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 31, name: "e2e_quality_remote", kind: "message", jsonName: "e2eQualityRemote", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 32, name: "e2e_quality_remote_instantaneous_time", kind: "scalar", jsonName: "e2eQualityRemoteInstantaneousTime", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 33, name: "e2e_quality_remote_lifetime_time", kind: "scalar", jsonName: "e2eQualityRemoteLifetimeTime", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 40, name: "front_quality_local", kind: "message", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 41, name: "front_quality_remote", kind: "message", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 42, name: "front_quality_remote_instantaneous_time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 43, name: "front_quality_remote_lifetime_time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CGameNetworkingUI_ConnectionState>): CGameNetworkingUI_ConnectionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGameNetworkingUI_ConnectionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGameNetworkingUI_ConnectionState): CGameNetworkingUI_ConnectionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string connection_key */ 1:
                    message.connectionKey = reader.string();
                    break;
                case /* optional uint32 appid */ 2:
                    message.appid = reader.uint32();
                    break;
                case /* optional fixed32 connection_id_local */ 3:
                    message.connectionIdLocal = reader.fixed32();
                    break;
                case /* optional string identity_local */ 4:
                    message.identityLocal = reader.string();
                    break;
                case /* optional string identity_remote */ 5:
                    message.identityRemote = reader.string();
                    break;
                case /* optional uint32 connection_state */ 10:
                    message.connectionState = reader.uint32();
                    break;
                case /* optional uint32 start_time */ 12:
                    message.startTime = reader.uint32();
                    break;
                case /* optional uint32 close_time */ 13:
                    message.closeTime = reader.uint32();
                    break;
                case /* optional uint32 close_reason */ 14:
                    message.closeReason = reader.uint32();
                    break;
                case /* optional string close_message */ 15:
                    message.closeMessage = reader.string();
                    break;
                case /* optional string status_loc_token */ 16:
                    message.statusLocToken = reader.string();
                    break;
                case /* optional uint32 transport_kind */ 20:
                    message.transportKind = reader.uint32();
                    break;
                case /* optional string sdrpopid_local */ 21:
                    message.sdrpopidLocal = reader.string();
                    break;
                case /* optional string sdrpopid_remote */ 22:
                    message.sdrpopidRemote = reader.string();
                    break;
                case /* optional string address_remote */ 23:
                    message.addressRemote = reader.string();
                    break;
                case /* optional CMsgSteamDatagramP2PRoutingSummary p2p_routing */ 24:
                    message.p2PRouting = CMsgSteamDatagramP2PRoutingSummary.internalBinaryRead(reader, reader.uint32(), options, message.p2PRouting);
                    break;
                case /* optional uint32 ping_interior */ 25:
                    message.pingInterior = reader.uint32();
                    break;
                case /* optional uint32 ping_remote_front */ 26:
                    message.pingRemoteFront = reader.uint32();
                    break;
                case /* optional uint32 ping_default_internet_route */ 27:
                    message.pingDefaultInternetRoute = reader.uint32();
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality e2e_quality_local */ 30:
                    message.e2EQualityLocal = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.e2EQualityLocal);
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality e2e_quality_remote */ 31:
                    message.e2EQualityRemote = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.e2EQualityRemote);
                    break;
                case /* optional uint64 e2e_quality_remote_instantaneous_time */ 32:
                    message.e2EQualityRemoteInstantaneousTime = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 e2e_quality_remote_lifetime_time */ 33:
                    message.e2EQualityRemoteLifetimeTime = reader.uint64().toBigInt();
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality front_quality_local */ 40:
                    message.frontQualityLocal = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.frontQualityLocal);
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality front_quality_remote */ 41:
                    message.frontQualityRemote = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.frontQualityRemote);
                    break;
                case /* optional uint64 front_quality_remote_instantaneous_time */ 42:
                    message.frontQualityRemoteInstantaneousTime = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 front_quality_remote_lifetime_time */ 43:
                    message.frontQualityRemoteLifetimeTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGameNetworkingUI_ConnectionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string connection_key = 1; */
        if (message.connectionKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.connectionKey);
        /* optional uint32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appid);
        /* optional fixed32 connection_id_local = 3; */
        if (message.connectionIdLocal !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.connectionIdLocal);
        /* optional string identity_local = 4; */
        if (message.identityLocal !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.identityLocal);
        /* optional string identity_remote = 5; */
        if (message.identityRemote !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.identityRemote);
        /* optional uint32 connection_state = 10; */
        if (message.connectionState !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.connectionState);
        /* optional uint32 start_time = 12; */
        if (message.startTime !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.startTime);
        /* optional uint32 close_time = 13; */
        if (message.closeTime !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.closeTime);
        /* optional uint32 close_reason = 14; */
        if (message.closeReason !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.closeReason);
        /* optional string close_message = 15; */
        if (message.closeMessage !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.closeMessage);
        /* optional string status_loc_token = 16; */
        if (message.statusLocToken !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.statusLocToken);
        /* optional uint32 transport_kind = 20; */
        if (message.transportKind !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.transportKind);
        /* optional string sdrpopid_local = 21; */
        if (message.sdrpopidLocal !== undefined)
            writer.tag(21, WireType.LengthDelimited).string(message.sdrpopidLocal);
        /* optional string sdrpopid_remote = 22; */
        if (message.sdrpopidRemote !== undefined)
            writer.tag(22, WireType.LengthDelimited).string(message.sdrpopidRemote);
        /* optional string address_remote = 23; */
        if (message.addressRemote !== undefined)
            writer.tag(23, WireType.LengthDelimited).string(message.addressRemote);
        /* optional CMsgSteamDatagramP2PRoutingSummary p2p_routing = 24; */
        if (message.p2PRouting)
            CMsgSteamDatagramP2PRoutingSummary.internalBinaryWrite(message.p2PRouting, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 ping_interior = 25; */
        if (message.pingInterior !== undefined)
            writer.tag(25, WireType.Varint).uint32(message.pingInterior);
        /* optional uint32 ping_remote_front = 26; */
        if (message.pingRemoteFront !== undefined)
            writer.tag(26, WireType.Varint).uint32(message.pingRemoteFront);
        /* optional uint32 ping_default_internet_route = 27; */
        if (message.pingDefaultInternetRoute !== undefined)
            writer.tag(27, WireType.Varint).uint32(message.pingDefaultInternetRoute);
        /* optional CMsgSteamDatagramConnectionQuality e2e_quality_local = 30; */
        if (message.e2EQualityLocal)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.e2EQualityLocal, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramConnectionQuality e2e_quality_remote = 31; */
        if (message.e2EQualityRemote)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.e2EQualityRemote, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 e2e_quality_remote_instantaneous_time = 32; */
        if (message.e2EQualityRemoteInstantaneousTime !== undefined)
            writer.tag(32, WireType.Varint).uint64(message.e2EQualityRemoteInstantaneousTime);
        /* optional uint64 e2e_quality_remote_lifetime_time = 33; */
        if (message.e2EQualityRemoteLifetimeTime !== undefined)
            writer.tag(33, WireType.Varint).uint64(message.e2EQualityRemoteLifetimeTime);
        /* optional CMsgSteamDatagramConnectionQuality front_quality_local = 40; */
        if (message.frontQualityLocal)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.frontQualityLocal, writer.tag(40, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramConnectionQuality front_quality_remote = 41; */
        if (message.frontQualityRemote)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.frontQualityRemote, writer.tag(41, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 front_quality_remote_instantaneous_time = 42; */
        if (message.frontQualityRemoteInstantaneousTime !== undefined)
            writer.tag(42, WireType.Varint).uint64(message.frontQualityRemoteInstantaneousTime);
        /* optional uint64 front_quality_remote_lifetime_time = 43; */
        if (message.frontQualityRemoteLifetimeTime !== undefined)
            writer.tag(43, WireType.Varint).uint64(message.frontQualityRemoteLifetimeTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGameNetworkingUI_ConnectionState
 */
export const CGameNetworkingUI_ConnectionState = new CGameNetworkingUI_ConnectionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGameNetworkingUI_ConnectionSummary$Type extends MessageType<CGameNetworkingUI_ConnectionSummary> {
    constructor() {
        super("CGameNetworkingUI_ConnectionSummary", [
            { no: 1, name: "transport_kind", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "sdrpop_local", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sdrpop_remote", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "packet_loss", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "ping_default_internet_route", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "ip_was_shared", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "connection_state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CGameNetworkingUI_ConnectionSummary>): CGameNetworkingUI_ConnectionSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGameNetworkingUI_ConnectionSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGameNetworkingUI_ConnectionSummary): CGameNetworkingUI_ConnectionSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 transport_kind */ 1:
                    message.transportKind = reader.uint32();
                    break;
                case /* optional string sdrpop_local */ 2:
                    message.sdrpopLocal = reader.string();
                    break;
                case /* optional string sdrpop_remote */ 3:
                    message.sdrpopRemote = reader.string();
                    break;
                case /* optional uint32 ping_ms */ 4:
                    message.pingMs = reader.uint32();
                    break;
                case /* optional float packet_loss */ 5:
                    message.packetLoss = reader.float();
                    break;
                case /* optional uint32 ping_default_internet_route */ 6:
                    message.pingDefaultInternetRoute = reader.uint32();
                    break;
                case /* optional bool ip_was_shared */ 7:
                    message.ipWasShared = reader.bool();
                    break;
                case /* optional uint32 connection_state */ 8:
                    message.connectionState = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGameNetworkingUI_ConnectionSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 transport_kind = 1; */
        if (message.transportKind !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.transportKind);
        /* optional string sdrpop_local = 2; */
        if (message.sdrpopLocal !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.sdrpopLocal);
        /* optional string sdrpop_remote = 3; */
        if (message.sdrpopRemote !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.sdrpopRemote);
        /* optional uint32 ping_ms = 4; */
        if (message.pingMs !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.pingMs);
        /* optional float packet_loss = 5; */
        if (message.packetLoss !== undefined)
            writer.tag(5, WireType.Bit32).float(message.packetLoss);
        /* optional uint32 ping_default_internet_route = 6; */
        if (message.pingDefaultInternetRoute !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.pingDefaultInternetRoute);
        /* optional bool ip_was_shared = 7; */
        if (message.ipWasShared !== undefined)
            writer.tag(7, WireType.Varint).bool(message.ipWasShared);
        /* optional uint32 connection_state = 8; */
        if (message.connectionState !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.connectionState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGameNetworkingUI_ConnectionSummary
 */
export const CGameNetworkingUI_ConnectionSummary = new CGameNetworkingUI_ConnectionSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGameRecording_AudioSessionsChanged_Notification$Type extends MessageType<CGameRecording_AudioSessionsChanged_Notification> {
    constructor() {
        super("CGameRecording_AudioSessionsChanged_Notification", [
            { no: 1, name: "sessions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CGameRecording_AudioSessionsChanged_Notification_Session }
        ]);
    }
    create(value?: PartialMessage<CGameRecording_AudioSessionsChanged_Notification>): CGameRecording_AudioSessionsChanged_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessions = [];
        if (value !== undefined)
            reflectionMergePartial<CGameRecording_AudioSessionsChanged_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGameRecording_AudioSessionsChanged_Notification): CGameRecording_AudioSessionsChanged_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CGameRecording_AudioSessionsChanged_Notification_Session sessions */ 1:
                    message.sessions.push(CGameRecording_AudioSessionsChanged_Notification_Session.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGameRecording_AudioSessionsChanged_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CGameRecording_AudioSessionsChanged_Notification_Session sessions = 1; */
        for (let i = 0; i < message.sessions.length; i++)
            CGameRecording_AudioSessionsChanged_Notification_Session.internalBinaryWrite(message.sessions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGameRecording_AudioSessionsChanged_Notification
 */
export const CGameRecording_AudioSessionsChanged_Notification = new CGameRecording_AudioSessionsChanged_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGameRecording_AudioSessionsChanged_Notification_Session$Type extends MessageType<CGameRecording_AudioSessionsChanged_Notification_Session> {
    constructor() {
        super("CGameRecording_AudioSessionsChanged_Notification_Session", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_system", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_muted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_captured", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "recent_peak", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "is_game", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "is_steam", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "is_saved", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CGameRecording_AudioSessionsChanged_Notification_Session>): CGameRecording_AudioSessionsChanged_Notification_Session {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGameRecording_AudioSessionsChanged_Notification_Session>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGameRecording_AudioSessionsChanged_Notification_Session): CGameRecording_AudioSessionsChanged_Notification_Session {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional bool is_system */ 3:
                    message.isSystem = reader.bool();
                    break;
                case /* optional bool is_muted */ 4:
                    message.isMuted = reader.bool();
                    break;
                case /* optional bool is_active */ 5:
                    message.isActive = reader.bool();
                    break;
                case /* optional bool is_captured */ 6:
                    message.isCaptured = reader.bool();
                    break;
                case /* optional float recent_peak */ 7:
                    message.recentPeak = reader.float();
                    break;
                case /* optional bool is_game */ 8:
                    message.isGame = reader.bool();
                    break;
                case /* optional bool is_steam */ 9:
                    message.isSteam = reader.bool();
                    break;
                case /* optional bool is_saved */ 10:
                    message.isSaved = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGameRecording_AudioSessionsChanged_Notification_Session, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional bool is_system = 3; */
        if (message.isSystem !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isSystem);
        /* optional bool is_muted = 4; */
        if (message.isMuted !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isMuted);
        /* optional bool is_active = 5; */
        if (message.isActive !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isActive);
        /* optional bool is_captured = 6; */
        if (message.isCaptured !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isCaptured);
        /* optional float recent_peak = 7; */
        if (message.recentPeak !== undefined)
            writer.tag(7, WireType.Bit32).float(message.recentPeak);
        /* optional bool is_game = 8; */
        if (message.isGame !== undefined)
            writer.tag(8, WireType.Varint).bool(message.isGame);
        /* optional bool is_steam = 9; */
        if (message.isSteam !== undefined)
            writer.tag(9, WireType.Varint).bool(message.isSteam);
        /* optional bool is_saved = 10; */
        if (message.isSaved !== undefined)
            writer.tag(10, WireType.Varint).bool(message.isSaved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGameRecording_AudioSessionsChanged_Notification_Session
 */
export const CGameRecording_AudioSessionsChanged_Notification_Session = new CGameRecording_AudioSessionsChanged_Notification_Session$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CLibraryBootstrapData$Type extends MessageType<CLibraryBootstrapData> {
    constructor() {
        super("CLibraryBootstrapData", [
            { no: 1, name: "app_data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CAppBootstrapData }
        ]);
    }
    create(value?: PartialMessage<CLibraryBootstrapData>): CLibraryBootstrapData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appData = [];
        if (value !== undefined)
            reflectionMergePartial<CLibraryBootstrapData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CLibraryBootstrapData): CLibraryBootstrapData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CAppBootstrapData app_data */ 1:
                    message.appData.push(CAppBootstrapData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CLibraryBootstrapData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CAppBootstrapData app_data = 1; */
        for (let i = 0; i < message.appData.length; i++)
            CAppBootstrapData.internalBinaryWrite(message.appData[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CLibraryBootstrapData
 */
export const CLibraryBootstrapData = new CLibraryBootstrapData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CLocalizationToken$Type extends MessageType<CLocalizationToken> {
    constructor() {
        super("CLocalizationToken", [
            { no: 1, name: "language", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "localized_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CLocalizationToken>): CLocalizationToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CLocalizationToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CLocalizationToken): CLocalizationToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 language */ 1:
                    message.language = reader.uint32();
                    break;
                case /* optional string localized_string */ 2:
                    message.localizedString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CLocalizationToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 language = 1; */
        if (message.language !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.language);
        /* optional string localized_string = 2; */
        if (message.localizedString !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.localizedString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CLocalizationToken
 */
export const CLocalizationToken = new CLocalizationToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAchievementChange$Type extends MessageType<CMsgAchievementChange> {
    constructor() {
        super("CMsgAchievementChange", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAchievementChange>): CMsgAchievementChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAchievementChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAchievementChange): CMsgAchievementChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAchievementChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAchievementChange
 */
export const CMsgAchievementChange = new CMsgAchievementChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMUnlockHEVC$Type extends MessageType<CMsgAMUnlockHEVC> {
    constructor() {
        super("CMsgAMUnlockHEVC", []);
    }
    create(value?: PartialMessage<CMsgAMUnlockHEVC>): CMsgAMUnlockHEVC {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMUnlockHEVC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMUnlockHEVC): CMsgAMUnlockHEVC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMUnlockHEVC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMUnlockHEVC
 */
export const CMsgAMUnlockHEVC = new CMsgAMUnlockHEVC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMUnlockHEVCResponse$Type extends MessageType<CMsgAMUnlockHEVCResponse> {
    constructor() {
        super("CMsgAMUnlockHEVCResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMUnlockHEVCResponse>): CMsgAMUnlockHEVCResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMUnlockHEVCResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMUnlockHEVCResponse): CMsgAMUnlockHEVCResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMUnlockHEVCResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMUnlockHEVCResponse
 */
export const CMsgAMUnlockHEVCResponse = new CMsgAMUnlockHEVCResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMUnlockStreaming$Type extends MessageType<CMsgAMUnlockStreaming> {
    constructor() {
        super("CMsgAMUnlockStreaming", []);
    }
    create(value?: PartialMessage<CMsgAMUnlockStreaming>): CMsgAMUnlockStreaming {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMUnlockStreaming>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMUnlockStreaming): CMsgAMUnlockStreaming {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMUnlockStreaming, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMUnlockStreaming
 */
export const CMsgAMUnlockStreaming = new CMsgAMUnlockStreaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMUnlockStreamingResponse$Type extends MessageType<CMsgAMUnlockStreamingResponse> {
    constructor() {
        super("CMsgAMUnlockStreamingResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "encryption_key", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMUnlockStreamingResponse>): CMsgAMUnlockStreamingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMUnlockStreamingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMUnlockStreamingResponse): CMsgAMUnlockStreamingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional bytes encryption_key */ 2:
                    message.encryptionKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMUnlockStreamingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional bytes encryption_key = 2; */
        if (message.encryptionKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.encryptionKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMUnlockStreamingResponse
 */
export const CMsgAMUnlockStreamingResponse = new CMsgAMUnlockStreamingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAppRights$Type extends MessageType<CMsgAppRights> {
    constructor() {
        super("CMsgAppRights", [
            { no: 1, name: "edit_info", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "publish", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "view_error_data", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "download", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "upload_cdkeys", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "generate_cdkeys", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "view_financials", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "manage_ceg", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "manage_signing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "manage_cdkeys", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "edit_marketing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "economy_support", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "economy_support_supervisor", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "manage_pricing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "broadcast_live", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "view_marketing_traffic", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAppRights>): CMsgAppRights {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAppRights>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAppRights): CMsgAppRights {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool edit_info */ 1:
                    message.editInfo = reader.bool();
                    break;
                case /* optional bool publish */ 2:
                    message.publish = reader.bool();
                    break;
                case /* optional bool view_error_data */ 3:
                    message.viewErrorData = reader.bool();
                    break;
                case /* optional bool download */ 4:
                    message.download = reader.bool();
                    break;
                case /* optional bool upload_cdkeys */ 5:
                    message.uploadCdkeys = reader.bool();
                    break;
                case /* optional bool generate_cdkeys */ 6:
                    message.generateCdkeys = reader.bool();
                    break;
                case /* optional bool view_financials */ 7:
                    message.viewFinancials = reader.bool();
                    break;
                case /* optional bool manage_ceg */ 8:
                    message.manageCeg = reader.bool();
                    break;
                case /* optional bool manage_signing */ 9:
                    message.manageSigning = reader.bool();
                    break;
                case /* optional bool manage_cdkeys */ 10:
                    message.manageCdkeys = reader.bool();
                    break;
                case /* optional bool edit_marketing */ 11:
                    message.editMarketing = reader.bool();
                    break;
                case /* optional bool economy_support */ 12:
                    message.economySupport = reader.bool();
                    break;
                case /* optional bool economy_support_supervisor */ 13:
                    message.economySupportSupervisor = reader.bool();
                    break;
                case /* optional bool manage_pricing */ 14:
                    message.managePricing = reader.bool();
                    break;
                case /* optional bool broadcast_live */ 15:
                    message.broadcastLive = reader.bool();
                    break;
                case /* optional bool view_marketing_traffic */ 16:
                    message.viewMarketingTraffic = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAppRights, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool edit_info = 1; */
        if (message.editInfo !== undefined)
            writer.tag(1, WireType.Varint).bool(message.editInfo);
        /* optional bool publish = 2; */
        if (message.publish !== undefined)
            writer.tag(2, WireType.Varint).bool(message.publish);
        /* optional bool view_error_data = 3; */
        if (message.viewErrorData !== undefined)
            writer.tag(3, WireType.Varint).bool(message.viewErrorData);
        /* optional bool download = 4; */
        if (message.download !== undefined)
            writer.tag(4, WireType.Varint).bool(message.download);
        /* optional bool upload_cdkeys = 5; */
        if (message.uploadCdkeys !== undefined)
            writer.tag(5, WireType.Varint).bool(message.uploadCdkeys);
        /* optional bool generate_cdkeys = 6; */
        if (message.generateCdkeys !== undefined)
            writer.tag(6, WireType.Varint).bool(message.generateCdkeys);
        /* optional bool view_financials = 7; */
        if (message.viewFinancials !== undefined)
            writer.tag(7, WireType.Varint).bool(message.viewFinancials);
        /* optional bool manage_ceg = 8; */
        if (message.manageCeg !== undefined)
            writer.tag(8, WireType.Varint).bool(message.manageCeg);
        /* optional bool manage_signing = 9; */
        if (message.manageSigning !== undefined)
            writer.tag(9, WireType.Varint).bool(message.manageSigning);
        /* optional bool manage_cdkeys = 10; */
        if (message.manageCdkeys !== undefined)
            writer.tag(10, WireType.Varint).bool(message.manageCdkeys);
        /* optional bool edit_marketing = 11; */
        if (message.editMarketing !== undefined)
            writer.tag(11, WireType.Varint).bool(message.editMarketing);
        /* optional bool economy_support = 12; */
        if (message.economySupport !== undefined)
            writer.tag(12, WireType.Varint).bool(message.economySupport);
        /* optional bool economy_support_supervisor = 13; */
        if (message.economySupportSupervisor !== undefined)
            writer.tag(13, WireType.Varint).bool(message.economySupportSupervisor);
        /* optional bool manage_pricing = 14; */
        if (message.managePricing !== undefined)
            writer.tag(14, WireType.Varint).bool(message.managePricing);
        /* optional bool broadcast_live = 15; */
        if (message.broadcastLive !== undefined)
            writer.tag(15, WireType.Varint).bool(message.broadcastLive);
        /* optional bool view_marketing_traffic = 16; */
        if (message.viewMarketingTraffic !== undefined)
            writer.tag(16, WireType.Varint).bool(message.viewMarketingTraffic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAppRights
 */
export const CMsgAppRights = new CMsgAppRights$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAuthTicket$Type extends MessageType<CMsgAuthTicket> {
    constructor() {
        super("CMsgAuthTicket", [
            { no: 1, name: "estate", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "gameid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "h_steam_pipe", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "ticket_crc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "ticket", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "server_secret", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "ticket_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAuthTicket>): CMsgAuthTicket {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAuthTicket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAuthTicket): CMsgAuthTicket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 estate */ 1:
                    message.estate = reader.uint32();
                    break;
                case /* optional uint32 eresult = 2 [default = 2] */ 2:
                    message.eresult = reader.uint32();
                    break;
                case /* optional fixed64 steamid */ 3:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 gameid */ 4:
                    message.gameid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 h_steam_pipe */ 5:
                    message.hSteamPipe = reader.uint32();
                    break;
                case /* optional uint32 ticket_crc */ 6:
                    message.ticketCrc = reader.uint32();
                    break;
                case /* optional bytes ticket */ 7:
                    message.ticket = reader.bytes();
                    break;
                case /* optional bytes server_secret */ 8:
                    message.serverSecret = reader.bytes();
                    break;
                case /* optional uint32 ticket_type */ 9:
                    message.ticketType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAuthTicket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 estate = 1; */
        if (message.estate !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.estate);
        /* optional uint32 eresult = 2 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eresult);
        /* optional fixed64 steamid = 3; */
        if (message.steamid !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamid);
        /* optional fixed64 gameid = 4; */
        if (message.gameid !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.gameid);
        /* optional uint32 h_steam_pipe = 5; */
        if (message.hSteamPipe !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.hSteamPipe);
        /* optional uint32 ticket_crc = 6; */
        if (message.ticketCrc !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.ticketCrc);
        /* optional bytes ticket = 7; */
        if (message.ticket !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.ticket);
        /* optional bytes server_secret = 8; */
        if (message.serverSecret !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.serverSecret);
        /* optional uint32 ticket_type = 9; */
        if (message.ticketType !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.ticketType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAuthTicket
 */
export const CMsgAuthTicket = new CMsgAuthTicket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgBadgeCraftedNotification$Type extends MessageType<CMsgBadgeCraftedNotification> {
    constructor() {
        super("CMsgBadgeCraftedNotification", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "badge_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgBadgeCraftedNotification>): CMsgBadgeCraftedNotification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgBadgeCraftedNotification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgBadgeCraftedNotification): CMsgBadgeCraftedNotification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 badge_level */ 2:
                    message.badgeLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgBadgeCraftedNotification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 badge_level = 2; */
        if (message.badgeLevel !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.badgeLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgBadgeCraftedNotification
 */
export const CMsgBadgeCraftedNotification = new CMsgBadgeCraftedNotification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAccountInfo$Type extends MessageType<CMsgClientAccountInfo> {
    constructor() {
        super("CMsgClientAccountInfo", [
            { no: 1, name: "persona_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ip_country", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "count_authed_computers", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "account_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "facebook_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "facebook_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "steamguard_notify_newmachines", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "steamguard_machine_name_user_chosen", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "is_phone_verified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "two_factor_state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "is_phone_identifying", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "is_phone_needing_reverify", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAccountInfo>): CMsgClientAccountInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAccountInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAccountInfo): CMsgClientAccountInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string persona_name */ 1:
                    message.personaName = reader.string();
                    break;
                case /* optional string ip_country */ 2:
                    message.ipCountry = reader.string();
                    break;
                case /* optional int32 count_authed_computers */ 5:
                    message.countAuthedComputers = reader.int32();
                    break;
                case /* optional uint32 account_flags */ 7:
                    message.accountFlags = reader.uint32();
                    break;
                case /* optional uint64 facebook_id */ 8:
                    message.facebookId = reader.uint64().toBigInt();
                    break;
                case /* optional string facebook_name */ 9:
                    message.facebookName = reader.string();
                    break;
                case /* optional bool steamguard_notify_newmachines */ 14:
                    message.steamguardNotifyNewmachines = reader.bool();
                    break;
                case /* optional string steamguard_machine_name_user_chosen */ 15:
                    message.steamguardMachineNameUserChosen = reader.string();
                    break;
                case /* optional bool is_phone_verified */ 16:
                    message.isPhoneVerified = reader.bool();
                    break;
                case /* optional uint32 two_factor_state */ 17:
                    message.twoFactorState = reader.uint32();
                    break;
                case /* optional bool is_phone_identifying */ 18:
                    message.isPhoneIdentifying = reader.bool();
                    break;
                case /* optional bool is_phone_needing_reverify */ 19:
                    message.isPhoneNeedingReverify = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAccountInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string persona_name = 1; */
        if (message.personaName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.personaName);
        /* optional string ip_country = 2; */
        if (message.ipCountry !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.ipCountry);
        /* optional int32 count_authed_computers = 5; */
        if (message.countAuthedComputers !== undefined)
            writer.tag(5, WireType.Varint).int32(message.countAuthedComputers);
        /* optional uint32 account_flags = 7; */
        if (message.accountFlags !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.accountFlags);
        /* optional uint64 facebook_id = 8; */
        if (message.facebookId !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.facebookId);
        /* optional string facebook_name = 9; */
        if (message.facebookName !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.facebookName);
        /* optional bool steamguard_notify_newmachines = 14; */
        if (message.steamguardNotifyNewmachines !== undefined)
            writer.tag(14, WireType.Varint).bool(message.steamguardNotifyNewmachines);
        /* optional string steamguard_machine_name_user_chosen = 15; */
        if (message.steamguardMachineNameUserChosen !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.steamguardMachineNameUserChosen);
        /* optional bool is_phone_verified = 16; */
        if (message.isPhoneVerified !== undefined)
            writer.tag(16, WireType.Varint).bool(message.isPhoneVerified);
        /* optional uint32 two_factor_state = 17; */
        if (message.twoFactorState !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.twoFactorState);
        /* optional bool is_phone_identifying = 18; */
        if (message.isPhoneIdentifying !== undefined)
            writer.tag(18, WireType.Varint).bool(message.isPhoneIdentifying);
        /* optional bool is_phone_needing_reverify = 19; */
        if (message.isPhoneNeedingReverify !== undefined)
            writer.tag(19, WireType.Varint).bool(message.isPhoneNeedingReverify);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAccountInfo
 */
export const CMsgClientAccountInfo = new CMsgClientAccountInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientActivateOEMLicense$Type extends MessageType<CMsgClientActivateOEMLicense> {
    constructor() {
        super("CMsgClientActivateOEMLicense", [
            { no: 1, name: "bios_manufacturer", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bios_serialnumber", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "license_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "mainboard_manufacturer", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "mainboard_product", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "mainboard_serialnumber", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientActivateOEMLicense>): CMsgClientActivateOEMLicense {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientActivateOEMLicense>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientActivateOEMLicense): CMsgClientActivateOEMLicense {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string bios_manufacturer */ 1:
                    message.biosManufacturer = reader.string();
                    break;
                case /* optional string bios_serialnumber */ 2:
                    message.biosSerialnumber = reader.string();
                    break;
                case /* optional bytes license_file */ 3:
                    message.licenseFile = reader.bytes();
                    break;
                case /* optional string mainboard_manufacturer */ 4:
                    message.mainboardManufacturer = reader.string();
                    break;
                case /* optional string mainboard_product */ 5:
                    message.mainboardProduct = reader.string();
                    break;
                case /* optional string mainboard_serialnumber */ 6:
                    message.mainboardSerialnumber = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientActivateOEMLicense, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string bios_manufacturer = 1; */
        if (message.biosManufacturer !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.biosManufacturer);
        /* optional string bios_serialnumber = 2; */
        if (message.biosSerialnumber !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.biosSerialnumber);
        /* optional bytes license_file = 3; */
        if (message.licenseFile !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.licenseFile);
        /* optional string mainboard_manufacturer = 4; */
        if (message.mainboardManufacturer !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.mainboardManufacturer);
        /* optional string mainboard_product = 5; */
        if (message.mainboardProduct !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.mainboardProduct);
        /* optional string mainboard_serialnumber = 6; */
        if (message.mainboardSerialnumber !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.mainboardSerialnumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientActivateOEMLicense
 */
export const CMsgClientActivateOEMLicense = new CMsgClientActivateOEMLicense$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAddFriend$Type extends MessageType<CMsgClientAddFriend> {
    constructor() {
        super("CMsgClientAddFriend", [
            { no: 1, name: "steamid_to_add", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "accountname_or_email_to_add", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAddFriend>): CMsgClientAddFriend {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAddFriend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAddFriend): CMsgClientAddFriend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_to_add */ 1:
                    message.steamidToAdd = reader.fixed64().toBigInt();
                    break;
                case /* optional string accountname_or_email_to_add */ 2:
                    message.accountnameOrEmailToAdd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAddFriend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_to_add = 1; */
        if (message.steamidToAdd !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidToAdd);
        /* optional string accountname_or_email_to_add = 2; */
        if (message.accountnameOrEmailToAdd !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.accountnameOrEmailToAdd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAddFriend
 */
export const CMsgClientAddFriend = new CMsgClientAddFriend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAddFriendResponse$Type extends MessageType<CMsgClientAddFriendResponse> {
    constructor() {
        super("CMsgClientAddFriendResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "steam_id_added", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "persona_name_added", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAddFriendResponse>): CMsgClientAddFriendResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAddFriendResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAddFriendResponse): CMsgClientAddFriendResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional fixed64 steam_id_added */ 2:
                    message.steamIdAdded = reader.fixed64().toBigInt();
                    break;
                case /* optional string persona_name_added */ 3:
                    message.personaNameAdded = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAddFriendResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional fixed64 steam_id_added = 2; */
        if (message.steamIdAdded !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdAdded);
        /* optional string persona_name_added = 3; */
        if (message.personaNameAdded !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.personaNameAdded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAddFriendResponse
 */
export const CMsgClientAddFriendResponse = new CMsgClientAddFriendResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAddFriendToGroup$Type extends MessageType<CMsgClientAddFriendToGroup> {
    constructor() {
        super("CMsgClientAddFriendToGroup", [
            { no: 1, name: "groupid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "steamiduser", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAddFriendToGroup>): CMsgClientAddFriendToGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAddFriendToGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAddFriendToGroup): CMsgClientAddFriendToGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 groupid */ 1:
                    message.groupid = reader.int32();
                    break;
                case /* optional fixed64 steamiduser */ 2:
                    message.steamiduser = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAddFriendToGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 groupid = 1; */
        if (message.groupid !== undefined)
            writer.tag(1, WireType.Varint).int32(message.groupid);
        /* optional fixed64 steamiduser = 2; */
        if (message.steamiduser !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamiduser);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAddFriendToGroup
 */
export const CMsgClientAddFriendToGroup = new CMsgClientAddFriendToGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAddFriendToGroupResponse$Type extends MessageType<CMsgClientAddFriendToGroupResponse> {
    constructor() {
        super("CMsgClientAddFriendToGroupResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAddFriendToGroupResponse>): CMsgClientAddFriendToGroupResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAddFriendToGroupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAddFriendToGroupResponse): CMsgClientAddFriendToGroupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAddFriendToGroupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAddFriendToGroupResponse
 */
export const CMsgClientAddFriendToGroupResponse = new CMsgClientAddFriendToGroupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAMGetClanOfficers$Type extends MessageType<CMsgClientAMGetClanOfficers> {
    constructor() {
        super("CMsgClientAMGetClanOfficers", [
            { no: 1, name: "steamid_clan", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAMGetClanOfficers>): CMsgClientAMGetClanOfficers {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAMGetClanOfficers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAMGetClanOfficers): CMsgClientAMGetClanOfficers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_clan */ 1:
                    message.steamidClan = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAMGetClanOfficers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_clan = 1; */
        if (message.steamidClan !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidClan);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAMGetClanOfficers
 */
export const CMsgClientAMGetClanOfficers = new CMsgClientAMGetClanOfficers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAMGetClanOfficersResponse$Type extends MessageType<CMsgClientAMGetClanOfficersResponse> {
    constructor() {
        super("CMsgClientAMGetClanOfficersResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "steamid_clan", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "officer_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAMGetClanOfficersResponse>): CMsgClientAMGetClanOfficersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAMGetClanOfficersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAMGetClanOfficersResponse): CMsgClientAMGetClanOfficersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional fixed64 steamid_clan */ 2:
                    message.steamidClan = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 officer_count */ 3:
                    message.officerCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAMGetClanOfficersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional fixed64 steamid_clan = 2; */
        if (message.steamidClan !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamidClan);
        /* optional int32 officer_count = 3; */
        if (message.officerCount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.officerCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAMGetClanOfficersResponse
 */
export const CMsgClientAMGetClanOfficersResponse = new CMsgClientAMGetClanOfficersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAMGetPersonaNameHistory$Type extends MessageType<CMsgClientAMGetPersonaNameHistory> {
    constructor() {
        super("CMsgClientAMGetPersonaNameHistory", [
            { no: 1, name: "id_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "Ids", kind: "message", jsonName: "Ids", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientAMGetPersonaNameHistory_IdInstance }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAMGetPersonaNameHistory>): CMsgClientAMGetPersonaNameHistory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAMGetPersonaNameHistory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAMGetPersonaNameHistory): CMsgClientAMGetPersonaNameHistory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id_count */ 1:
                    message.idCount = reader.int32();
                    break;
                case /* repeated CMsgClientAMGetPersonaNameHistory_IdInstance Ids */ 2:
                    message.ids.push(CMsgClientAMGetPersonaNameHistory_IdInstance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAMGetPersonaNameHistory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id_count = 1; */
        if (message.idCount !== undefined)
            writer.tag(1, WireType.Varint).int32(message.idCount);
        /* repeated CMsgClientAMGetPersonaNameHistory_IdInstance Ids = 2; */
        for (let i = 0; i < message.ids.length; i++)
            CMsgClientAMGetPersonaNameHistory_IdInstance.internalBinaryWrite(message.ids[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAMGetPersonaNameHistory
 */
export const CMsgClientAMGetPersonaNameHistory = new CMsgClientAMGetPersonaNameHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAMGetPersonaNameHistory_IdInstance$Type extends MessageType<CMsgClientAMGetPersonaNameHistory_IdInstance> {
    constructor() {
        super("CMsgClientAMGetPersonaNameHistory_IdInstance", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAMGetPersonaNameHistory_IdInstance>): CMsgClientAMGetPersonaNameHistory_IdInstance {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAMGetPersonaNameHistory_IdInstance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAMGetPersonaNameHistory_IdInstance): CMsgClientAMGetPersonaNameHistory_IdInstance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAMGetPersonaNameHistory_IdInstance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAMGetPersonaNameHistory_IdInstance
 */
export const CMsgClientAMGetPersonaNameHistory_IdInstance = new CMsgClientAMGetPersonaNameHistory_IdInstance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAMGetPersonaNameHistoryResponse$Type extends MessageType<CMsgClientAMGetPersonaNameHistoryResponse> {
    constructor() {
        super("CMsgClientAMGetPersonaNameHistoryResponse", [
            { no: 2, name: "responses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAMGetPersonaNameHistoryResponse>): CMsgClientAMGetPersonaNameHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.responses = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAMGetPersonaNameHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAMGetPersonaNameHistoryResponse): CMsgClientAMGetPersonaNameHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance responses */ 2:
                    message.responses.push(CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAMGetPersonaNameHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance responses = 2; */
        for (let i = 0; i < message.responses.length; i++)
            CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance.internalBinaryWrite(message.responses[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAMGetPersonaNameHistoryResponse
 */
export const CMsgClientAMGetPersonaNameHistoryResponse = new CMsgClientAMGetPersonaNameHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance$Type extends MessageType<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance> {
    constructor() {
        super("CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "names", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>): CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.names = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance): CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional fixed64 steamid */ 2:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* repeated CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance names */ 3:
                    message.names.push(CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional fixed64 steamid = 2; */
        if (message.steamid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamid);
        /* repeated CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance names = 3; */
        for (let i = 0; i < message.names.length; i++)
            CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance.internalBinaryWrite(message.names[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance
 */
export const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance = new CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance$Type extends MessageType<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance> {
    constructor() {
        super("CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance", [
            { no: 1, name: "name_since", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>): CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance): CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 name_since */ 1:
                    message.nameSince = reader.fixed32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 name_since = 1; */
        if (message.nameSince !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.nameSince);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance
 */
export const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance = new CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAppInfoChanges$Type extends MessageType<CMsgClientAppInfoChanges> {
    constructor() {
        super("CMsgClientAppInfoChanges", [
            { no: 1, name: "current_change_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "force_full_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "appIDs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAppInfoChanges>): CMsgClientAppInfoChanges {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appIDs = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAppInfoChanges>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAppInfoChanges): CMsgClientAppInfoChanges {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 current_change_number */ 1:
                    message.currentChangeNumber = reader.uint32();
                    break;
                case /* optional bool force_full_update */ 2:
                    message.forceFullUpdate = reader.bool();
                    break;
                case /* repeated uint32 appIDs */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.appIDs.push(reader.uint32());
                    else
                        message.appIDs.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAppInfoChanges, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 current_change_number = 1; */
        if (message.currentChangeNumber !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.currentChangeNumber);
        /* optional bool force_full_update = 2; */
        if (message.forceFullUpdate !== undefined)
            writer.tag(2, WireType.Varint).bool(message.forceFullUpdate);
        /* repeated uint32 appIDs = 3; */
        for (let i = 0; i < message.appIDs.length; i++)
            writer.tag(3, WireType.Varint).uint32(message.appIDs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAppInfoChanges
 */
export const CMsgClientAppInfoChanges = new CMsgClientAppInfoChanges$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAppInfoRequest$Type extends MessageType<CMsgClientAppInfoRequest> {
    constructor() {
        super("CMsgClientAppInfoRequest", [
            { no: 1, name: "apps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientAppInfoRequest_App },
            { no: 2, name: "supports_batches", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAppInfoRequest>): CMsgClientAppInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apps = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAppInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAppInfoRequest): CMsgClientAppInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientAppInfoRequest_App apps */ 1:
                    message.apps.push(CMsgClientAppInfoRequest_App.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool supports_batches = 2 [default = false] */ 2:
                    message.supportsBatches = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAppInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientAppInfoRequest_App apps = 1; */
        for (let i = 0; i < message.apps.length; i++)
            CMsgClientAppInfoRequest_App.internalBinaryWrite(message.apps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool supports_batches = 2 [default = false]; */
        if (message.supportsBatches !== undefined)
            writer.tag(2, WireType.Varint).bool(message.supportsBatches);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAppInfoRequest
 */
export const CMsgClientAppInfoRequest = new CMsgClientAppInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAppInfoRequest_App$Type extends MessageType<CMsgClientAppInfoRequest_App> {
    constructor() {
        super("CMsgClientAppInfoRequest_App", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "section_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "section_CRC", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAppInfoRequest_App>): CMsgClientAppInfoRequest_App {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sectionCRC = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAppInfoRequest_App>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAppInfoRequest_App): CMsgClientAppInfoRequest_App {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 section_flags */ 2:
                    message.sectionFlags = reader.uint32();
                    break;
                case /* repeated uint32 section_CRC */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sectionCRC.push(reader.uint32());
                    else
                        message.sectionCRC.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAppInfoRequest_App, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 section_flags = 2; */
        if (message.sectionFlags !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.sectionFlags);
        /* repeated uint32 section_CRC = 3; */
        for (let i = 0; i < message.sectionCRC.length; i++)
            writer.tag(3, WireType.Varint).uint32(message.sectionCRC[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAppInfoRequest_App
 */
export const CMsgClientAppInfoRequest_App = new CMsgClientAppInfoRequest_App$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAppInfoResponse$Type extends MessageType<CMsgClientAppInfoResponse> {
    constructor() {
        super("CMsgClientAppInfoResponse", [
            { no: 1, name: "apps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientAppInfoResponse_App },
            { no: 2, name: "apps_unknown", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "apps_pending", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAppInfoResponse>): CMsgClientAppInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apps = [];
        message.appsUnknown = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAppInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAppInfoResponse): CMsgClientAppInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientAppInfoResponse_App apps */ 1:
                    message.apps.push(CMsgClientAppInfoResponse_App.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 apps_unknown */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.appsUnknown.push(reader.uint32());
                    else
                        message.appsUnknown.push(reader.uint32());
                    break;
                case /* optional uint32 apps_pending */ 3:
                    message.appsPending = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAppInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientAppInfoResponse_App apps = 1; */
        for (let i = 0; i < message.apps.length; i++)
            CMsgClientAppInfoResponse_App.internalBinaryWrite(message.apps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 apps_unknown = 2; */
        for (let i = 0; i < message.appsUnknown.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.appsUnknown[i]);
        /* optional uint32 apps_pending = 3; */
        if (message.appsPending !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.appsPending);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAppInfoResponse
 */
export const CMsgClientAppInfoResponse = new CMsgClientAppInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAppInfoResponse_App$Type extends MessageType<CMsgClientAppInfoResponse_App> {
    constructor() {
        super("CMsgClientAppInfoResponse_App", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "change_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sections", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientAppInfoResponse_App_Section }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAppInfoResponse_App>): CMsgClientAppInfoResponse_App {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sections = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAppInfoResponse_App>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAppInfoResponse_App): CMsgClientAppInfoResponse_App {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 change_number */ 2:
                    message.changeNumber = reader.uint32();
                    break;
                case /* repeated CMsgClientAppInfoResponse_App_Section sections */ 3:
                    message.sections.push(CMsgClientAppInfoResponse_App_Section.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAppInfoResponse_App, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 change_number = 2; */
        if (message.changeNumber !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.changeNumber);
        /* repeated CMsgClientAppInfoResponse_App_Section sections = 3; */
        for (let i = 0; i < message.sections.length; i++)
            CMsgClientAppInfoResponse_App_Section.internalBinaryWrite(message.sections[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAppInfoResponse_App
 */
export const CMsgClientAppInfoResponse_App = new CMsgClientAppInfoResponse_App$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAppInfoResponse_App_Section$Type extends MessageType<CMsgClientAppInfoResponse_App_Section> {
    constructor() {
        super("CMsgClientAppInfoResponse_App_Section", [
            { no: 1, name: "section_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "section_kv", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAppInfoResponse_App_Section>): CMsgClientAppInfoResponse_App_Section {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAppInfoResponse_App_Section>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAppInfoResponse_App_Section): CMsgClientAppInfoResponse_App_Section {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 section_id */ 1:
                    message.sectionId = reader.uint32();
                    break;
                case /* optional bytes section_kv */ 2:
                    message.sectionKv = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAppInfoResponse_App_Section, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 section_id = 1; */
        if (message.sectionId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.sectionId);
        /* optional bytes section_kv = 2; */
        if (message.sectionKv !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.sectionKv);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAppInfoResponse_App_Section
 */
export const CMsgClientAppInfoResponse_App_Section = new CMsgClientAppInfoResponse_App_Section$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAppInfoUpdate$Type extends MessageType<CMsgClientAppInfoUpdate> {
    constructor() {
        super("CMsgClientAppInfoUpdate", [
            { no: 1, name: "last_changenumber", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "send_changelist", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAppInfoUpdate>): CMsgClientAppInfoUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAppInfoUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAppInfoUpdate): CMsgClientAppInfoUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 last_changenumber */ 1:
                    message.lastChangenumber = reader.uint32();
                    break;
                case /* optional bool send_changelist */ 2:
                    message.sendChangelist = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAppInfoUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 last_changenumber = 1; */
        if (message.lastChangenumber !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.lastChangenumber);
        /* optional bool send_changelist = 2; */
        if (message.sendChangelist !== undefined)
            writer.tag(2, WireType.Varint).bool(message.sendChangelist);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAppInfoUpdate
 */
export const CMsgClientAppInfoUpdate = new CMsgClientAppInfoUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAuthList$Type extends MessageType<CMsgClientAuthList> {
    constructor() {
        super("CMsgClientAuthList", [
            { no: 1, name: "tokens_left", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "last_request_seq", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "last_request_seq_from_server", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "tickets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgAuthTicket },
            { no: 5, name: "app_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "message_sequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAuthList>): CMsgClientAuthList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tickets = [];
        message.appIds = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAuthList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAuthList): CMsgClientAuthList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 tokens_left */ 1:
                    message.tokensLeft = reader.uint32();
                    break;
                case /* optional uint32 last_request_seq */ 2:
                    message.lastRequestSeq = reader.uint32();
                    break;
                case /* optional uint32 last_request_seq_from_server */ 3:
                    message.lastRequestSeqFromServer = reader.uint32();
                    break;
                case /* repeated CMsgAuthTicket tickets */ 4:
                    message.tickets.push(CMsgAuthTicket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 app_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.appIds.push(reader.uint32());
                    else
                        message.appIds.push(reader.uint32());
                    break;
                case /* optional uint32 message_sequence */ 6:
                    message.messageSequence = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAuthList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 tokens_left = 1; */
        if (message.tokensLeft !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.tokensLeft);
        /* optional uint32 last_request_seq = 2; */
        if (message.lastRequestSeq !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.lastRequestSeq);
        /* optional uint32 last_request_seq_from_server = 3; */
        if (message.lastRequestSeqFromServer !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.lastRequestSeqFromServer);
        /* repeated CMsgAuthTicket tickets = 4; */
        for (let i = 0; i < message.tickets.length; i++)
            CMsgAuthTicket.internalBinaryWrite(message.tickets[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 app_ids = 5; */
        for (let i = 0; i < message.appIds.length; i++)
            writer.tag(5, WireType.Varint).uint32(message.appIds[i]);
        /* optional uint32 message_sequence = 6; */
        if (message.messageSequence !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.messageSequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAuthList
 */
export const CMsgClientAuthList = new CMsgClientAuthList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAuthListAck$Type extends MessageType<CMsgClientAuthListAck> {
    constructor() {
        super("CMsgClientAuthListAck", [
            { no: 1, name: "ticket_crc", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "app_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "message_sequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAuthListAck>): CMsgClientAuthListAck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ticketCrc = [];
        message.appIds = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAuthListAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAuthListAck): CMsgClientAuthListAck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 ticket_crc */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ticketCrc.push(reader.uint32());
                    else
                        message.ticketCrc.push(reader.uint32());
                    break;
                case /* repeated uint32 app_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.appIds.push(reader.uint32());
                    else
                        message.appIds.push(reader.uint32());
                    break;
                case /* optional uint32 message_sequence */ 3:
                    message.messageSequence = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAuthListAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 ticket_crc = 1; */
        for (let i = 0; i < message.ticketCrc.length; i++)
            writer.tag(1, WireType.Varint).uint32(message.ticketCrc[i]);
        /* repeated uint32 app_ids = 2; */
        for (let i = 0; i < message.appIds.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.appIds[i]);
        /* optional uint32 message_sequence = 3; */
        if (message.messageSequence !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.messageSequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAuthListAck
 */
export const CMsgClientAuthListAck = new CMsgClientAuthListAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAuthorizeLocalDevice$Type extends MessageType<CMsgClientAuthorizeLocalDevice> {
    constructor() {
        super("CMsgClientAuthorizeLocalDevice", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "owner_account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "authed_device_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAuthorizeLocalDevice>): CMsgClientAuthorizeLocalDevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAuthorizeLocalDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAuthorizeLocalDevice): CMsgClientAuthorizeLocalDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 owner_account_id */ 2:
                    message.ownerAccountId = reader.uint32();
                    break;
                case /* optional uint64 authed_device_token */ 3:
                    message.authedDeviceToken = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAuthorizeLocalDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional uint32 owner_account_id = 2; */
        if (message.ownerAccountId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.ownerAccountId);
        /* optional uint64 authed_device_token = 3; */
        if (message.authedDeviceToken !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.authedDeviceToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAuthorizeLocalDevice
 */
export const CMsgClientAuthorizeLocalDevice = new CMsgClientAuthorizeLocalDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAuthorizeLocalDeviceNotification$Type extends MessageType<CMsgClientAuthorizeLocalDeviceNotification> {
    constructor() {
        super("CMsgClientAuthorizeLocalDeviceNotification", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "owner_account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "local_device_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAuthorizeLocalDeviceNotification>): CMsgClientAuthorizeLocalDeviceNotification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAuthorizeLocalDeviceNotification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAuthorizeLocalDeviceNotification): CMsgClientAuthorizeLocalDeviceNotification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 owner_account_id */ 2:
                    message.ownerAccountId = reader.uint32();
                    break;
                case /* optional uint64 local_device_token */ 3:
                    message.localDeviceToken = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAuthorizeLocalDeviceNotification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional uint32 owner_account_id = 2; */
        if (message.ownerAccountId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.ownerAccountId);
        /* optional uint64 local_device_token = 3; */
        if (message.localDeviceToken !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.localDeviceToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAuthorizeLocalDeviceNotification
 */
export const CMsgClientAuthorizeLocalDeviceNotification = new CMsgClientAuthorizeLocalDeviceNotification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientAuthorizeLocalDeviceRequest$Type extends MessageType<CMsgClientAuthorizeLocalDeviceRequest> {
    constructor() {
        super("CMsgClientAuthorizeLocalDeviceRequest", [
            { no: 1, name: "device_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "local_device_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientAuthorizeLocalDeviceRequest>): CMsgClientAuthorizeLocalDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientAuthorizeLocalDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientAuthorizeLocalDeviceRequest): CMsgClientAuthorizeLocalDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string device_description */ 1:
                    message.deviceDescription = reader.string();
                    break;
                case /* optional uint32 owner_account_id */ 2:
                    message.ownerAccountId = reader.uint32();
                    break;
                case /* optional uint64 local_device_token */ 3:
                    message.localDeviceToken = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientAuthorizeLocalDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string device_description = 1; */
        if (message.deviceDescription !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.deviceDescription);
        /* optional uint32 owner_account_id = 2; */
        if (message.ownerAccountId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.ownerAccountId);
        /* optional uint64 local_device_token = 3; */
        if (message.localDeviceToken !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.localDeviceToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientAuthorizeLocalDeviceRequest
 */
export const CMsgClientAuthorizeLocalDeviceRequest = new CMsgClientAuthorizeLocalDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientChallengeRequest$Type extends MessageType<CMsgClientChallengeRequest> {
    constructor() {
        super("CMsgClientChallengeRequest", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientChallengeRequest>): CMsgClientChallengeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientChallengeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientChallengeRequest): CMsgClientChallengeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientChallengeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientChallengeRequest
 */
export const CMsgClientChallengeRequest = new CMsgClientChallengeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientChallengeResponse$Type extends MessageType<CMsgClientChallengeResponse> {
    constructor() {
        super("CMsgClientChallengeResponse", [
            { no: 1, name: "challenge", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientChallengeResponse>): CMsgClientChallengeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientChallengeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientChallengeResponse): CMsgClientChallengeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 challenge */ 1:
                    message.challenge = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientChallengeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 challenge = 1; */
        if (message.challenge !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.challenge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientChallengeResponse
 */
export const CMsgClientChallengeResponse = new CMsgClientChallengeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientChangeStatus$Type extends MessageType<CMsgClientChangeStatus> {
    constructor() {
        super("CMsgClientChangeStatus", [
            { no: 1, name: "persona_state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "player_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_auto_generated_name", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "high_priority", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "persona_set_by_user", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "persona_state_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "need_persona_response", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "is_client_idle", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientChangeStatus>): CMsgClientChangeStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientChangeStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientChangeStatus): CMsgClientChangeStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 persona_state */ 1:
                    message.personaState = reader.uint32();
                    break;
                case /* optional string player_name */ 2:
                    message.playerName = reader.string();
                    break;
                case /* optional bool is_auto_generated_name */ 3:
                    message.isAutoGeneratedName = reader.bool();
                    break;
                case /* optional bool high_priority */ 4:
                    message.highPriority = reader.bool();
                    break;
                case /* optional bool persona_set_by_user */ 5:
                    message.personaSetByUser = reader.bool();
                    break;
                case /* optional uint32 persona_state_flags = 6 [default = 0] */ 6:
                    message.personaStateFlags = reader.uint32();
                    break;
                case /* optional bool need_persona_response */ 7:
                    message.needPersonaResponse = reader.bool();
                    break;
                case /* optional bool is_client_idle */ 8:
                    message.isClientIdle = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientChangeStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 persona_state = 1; */
        if (message.personaState !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.personaState);
        /* optional string player_name = 2; */
        if (message.playerName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.playerName);
        /* optional bool is_auto_generated_name = 3; */
        if (message.isAutoGeneratedName !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isAutoGeneratedName);
        /* optional bool high_priority = 4; */
        if (message.highPriority !== undefined)
            writer.tag(4, WireType.Varint).bool(message.highPriority);
        /* optional bool persona_set_by_user = 5; */
        if (message.personaSetByUser !== undefined)
            writer.tag(5, WireType.Varint).bool(message.personaSetByUser);
        /* optional uint32 persona_state_flags = 6 [default = 0]; */
        if (message.personaStateFlags !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.personaStateFlags);
        /* optional bool need_persona_response = 7; */
        if (message.needPersonaResponse !== undefined)
            writer.tag(7, WireType.Varint).bool(message.needPersonaResponse);
        /* optional bool is_client_idle = 8; */
        if (message.isClientIdle !== undefined)
            writer.tag(8, WireType.Varint).bool(message.isClientIdle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientChangeStatus
 */
export const CMsgClientChangeStatus = new CMsgClientChangeStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientChatGetFriendMessageHistory$Type extends MessageType<CMsgClientChatGetFriendMessageHistory> {
    constructor() {
        super("CMsgClientChatGetFriendMessageHistory", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientChatGetFriendMessageHistory>): CMsgClientChatGetFriendMessageHistory {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientChatGetFriendMessageHistory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientChatGetFriendMessageHistory): CMsgClientChatGetFriendMessageHistory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientChatGetFriendMessageHistory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientChatGetFriendMessageHistory
 */
export const CMsgClientChatGetFriendMessageHistory = new CMsgClientChatGetFriendMessageHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientChatGetFriendMessageHistoryForOfflineMessages$Type extends MessageType<CMsgClientChatGetFriendMessageHistoryForOfflineMessages> {
    constructor() {
        super("CMsgClientChatGetFriendMessageHistoryForOfflineMessages", []);
    }
    create(value?: PartialMessage<CMsgClientChatGetFriendMessageHistoryForOfflineMessages>): CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientChatGetFriendMessageHistoryForOfflineMessages>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientChatGetFriendMessageHistoryForOfflineMessages): CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientChatGetFriendMessageHistoryForOfflineMessages, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientChatGetFriendMessageHistoryForOfflineMessages
 */
export const CMsgClientChatGetFriendMessageHistoryForOfflineMessages = new CMsgClientChatGetFriendMessageHistoryForOfflineMessages$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientChatGetFriendMessageHistoryResponse$Type extends MessageType<CMsgClientChatGetFriendMessageHistoryResponse> {
    constructor() {
        super("CMsgClientChatGetFriendMessageHistoryResponse", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "success", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "messages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage }
        ]);
    }
    create(value?: PartialMessage<CMsgClientChatGetFriendMessageHistoryResponse>): CMsgClientChatGetFriendMessageHistoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messages = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientChatGetFriendMessageHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientChatGetFriendMessageHistoryResponse): CMsgClientChatGetFriendMessageHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 success */ 2:
                    message.success = reader.uint32();
                    break;
                case /* repeated CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage messages */ 3:
                    message.messages.push(CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientChatGetFriendMessageHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional uint32 success = 2; */
        if (message.success !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.success);
        /* repeated CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage messages = 3; */
        for (let i = 0; i < message.messages.length; i++)
            CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage.internalBinaryWrite(message.messages[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientChatGetFriendMessageHistoryResponse
 */
export const CMsgClientChatGetFriendMessageHistoryResponse = new CMsgClientChatGetFriendMessageHistoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage$Type extends MessageType<CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage> {
    constructor() {
        super("CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage", [
            { no: 1, name: "accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "timestamp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unread", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage>): CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage): CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 accountid */ 1:
                    message.accountid = reader.uint32();
                    break;
                case /* optional uint32 timestamp */ 2:
                    message.timestamp = reader.uint32();
                    break;
                case /* optional string message */ 3:
                    message.message = reader.string();
                    break;
                case /* optional bool unread */ 4:
                    message.unread = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 accountid = 1; */
        if (message.accountid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.accountid);
        /* optional uint32 timestamp = 2; */
        if (message.timestamp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.timestamp);
        /* optional string message = 3; */
        if (message.message !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* optional bool unread = 4; */
        if (message.unread !== undefined)
            writer.tag(4, WireType.Varint).bool(message.unread);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage
 */
export const CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage = new CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientChatInvite$Type extends MessageType<CMsgClientChatInvite> {
    constructor() {
        super("CMsgClientChatInvite", [
            { no: 1, name: "steam_id_invited", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "steam_id_chat", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "steam_id_patron", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "chatroom_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "steam_id_friend_chat", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "chat_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientChatInvite>): CMsgClientChatInvite {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientChatInvite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientChatInvite): CMsgClientChatInvite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_invited */ 1:
                    message.steamIdInvited = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_chat */ 2:
                    message.steamIdChat = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_patron */ 3:
                    message.steamIdPatron = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 chatroom_type */ 4:
                    message.chatroomType = reader.int32();
                    break;
                case /* optional fixed64 steam_id_friend_chat */ 5:
                    message.steamIdFriendChat = reader.fixed64().toBigInt();
                    break;
                case /* optional string chat_name */ 6:
                    message.chatName = reader.string();
                    break;
                case /* optional fixed64 game_id */ 7:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientChatInvite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_invited = 1; */
        if (message.steamIdInvited !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdInvited);
        /* optional fixed64 steam_id_chat = 2; */
        if (message.steamIdChat !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdChat);
        /* optional fixed64 steam_id_patron = 3; */
        if (message.steamIdPatron !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamIdPatron);
        /* optional int32 chatroom_type = 4; */
        if (message.chatroomType !== undefined)
            writer.tag(4, WireType.Varint).int32(message.chatroomType);
        /* optional fixed64 steam_id_friend_chat = 5; */
        if (message.steamIdFriendChat !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.steamIdFriendChat);
        /* optional string chat_name = 6; */
        if (message.chatName !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.chatName);
        /* optional fixed64 game_id = 7; */
        if (message.gameId !== undefined)
            writer.tag(7, WireType.Bit64).fixed64(message.gameId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientChatInvite
 */
export const CMsgClientChatInvite = new CMsgClientChatInvite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientCheckAppBetaPassword$Type extends MessageType<CMsgClientCheckAppBetaPassword> {
    constructor() {
        super("CMsgClientCheckAppBetaPassword", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "betapassword", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientCheckAppBetaPassword>): CMsgClientCheckAppBetaPassword {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientCheckAppBetaPassword>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientCheckAppBetaPassword): CMsgClientCheckAppBetaPassword {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional string betapassword */ 2:
                    message.betapassword = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientCheckAppBetaPassword, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional string betapassword = 2; */
        if (message.betapassword !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.betapassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientCheckAppBetaPassword
 */
export const CMsgClientCheckAppBetaPassword = new CMsgClientCheckAppBetaPassword$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientCheckAppBetaPasswordResponse$Type extends MessageType<CMsgClientCheckAppBetaPasswordResponse> {
    constructor() {
        super("CMsgClientCheckAppBetaPasswordResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "betapasswords", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientCheckAppBetaPasswordResponse_BetaPassword }
        ]);
    }
    create(value?: PartialMessage<CMsgClientCheckAppBetaPasswordResponse>): CMsgClientCheckAppBetaPasswordResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.betapasswords = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientCheckAppBetaPasswordResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientCheckAppBetaPasswordResponse): CMsgClientCheckAppBetaPasswordResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgClientCheckAppBetaPasswordResponse_BetaPassword betapasswords */ 4:
                    message.betapasswords.push(CMsgClientCheckAppBetaPasswordResponse_BetaPassword.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientCheckAppBetaPasswordResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* repeated CMsgClientCheckAppBetaPasswordResponse_BetaPassword betapasswords = 4; */
        for (let i = 0; i < message.betapasswords.length; i++)
            CMsgClientCheckAppBetaPasswordResponse_BetaPassword.internalBinaryWrite(message.betapasswords[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientCheckAppBetaPasswordResponse
 */
export const CMsgClientCheckAppBetaPasswordResponse = new CMsgClientCheckAppBetaPasswordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientCheckAppBetaPasswordResponse_BetaPassword$Type extends MessageType<CMsgClientCheckAppBetaPasswordResponse_BetaPassword> {
    constructor() {
        super("CMsgClientCheckAppBetaPasswordResponse_BetaPassword", [
            { no: 1, name: "betaname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "betapassword", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientCheckAppBetaPasswordResponse_BetaPassword>): CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientCheckAppBetaPasswordResponse_BetaPassword>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientCheckAppBetaPasswordResponse_BetaPassword): CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string betaname */ 1:
                    message.betaname = reader.string();
                    break;
                case /* optional string betapassword */ 2:
                    message.betapassword = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientCheckAppBetaPasswordResponse_BetaPassword, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string betaname = 1; */
        if (message.betaname !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.betaname);
        /* optional string betapassword = 2; */
        if (message.betapassword !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.betapassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientCheckAppBetaPasswordResponse_BetaPassword
 */
export const CMsgClientCheckAppBetaPasswordResponse_BetaPassword = new CMsgClientCheckAppBetaPasswordResponse_BetaPassword$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientCheckFileSignature$Type extends MessageType<CMsgClientCheckFileSignature> {
    constructor() {
        super("CMsgClientCheckFileSignature", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientCheckFileSignature>): CMsgClientCheckFileSignature {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientCheckFileSignature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientCheckFileSignature): CMsgClientCheckFileSignature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientCheckFileSignature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientCheckFileSignature
 */
export const CMsgClientCheckFileSignature = new CMsgClientCheckFileSignature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientCheckFileSignatureResponse$Type extends MessageType<CMsgClientCheckFileSignatureResponse> {
    constructor() {
        super("CMsgClientCheckFileSignatureResponse", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "pid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "esignatureresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "signatureheader", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "filesize", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "getlasterror", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "evalvesignaturecheckdetail", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientCheckFileSignatureResponse>): CMsgClientCheckFileSignatureResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientCheckFileSignatureResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientCheckFileSignatureResponse): CMsgClientCheckFileSignatureResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 pid */ 2:
                    message.pid = reader.uint32();
                    break;
                case /* optional uint32 eresult */ 3:
                    message.eresult = reader.uint32();
                    break;
                case /* optional string filename */ 4:
                    message.filename = reader.string();
                    break;
                case /* optional uint32 esignatureresult */ 5:
                    message.esignatureresult = reader.uint32();
                    break;
                case /* optional bytes sha_file */ 6:
                    message.shaFile = reader.bytes();
                    break;
                case /* optional bytes signatureheader */ 7:
                    message.signatureheader = reader.bytes();
                    break;
                case /* optional uint32 filesize */ 8:
                    message.filesize = reader.uint32();
                    break;
                case /* optional uint32 getlasterror */ 9:
                    message.getlasterror = reader.uint32();
                    break;
                case /* optional uint32 evalvesignaturecheckdetail */ 10:
                    message.evalvesignaturecheckdetail = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientCheckFileSignatureResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 pid = 2; */
        if (message.pid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.pid);
        /* optional uint32 eresult = 3; */
        if (message.eresult !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.eresult);
        /* optional string filename = 4; */
        if (message.filename !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.filename);
        /* optional uint32 esignatureresult = 5; */
        if (message.esignatureresult !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.esignatureresult);
        /* optional bytes sha_file = 6; */
        if (message.shaFile !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.shaFile);
        /* optional bytes signatureheader = 7; */
        if (message.signatureheader !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.signatureheader);
        /* optional uint32 filesize = 8; */
        if (message.filesize !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.filesize);
        /* optional uint32 getlasterror = 9; */
        if (message.getlasterror !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.getlasterror);
        /* optional uint32 evalvesignaturecheckdetail = 10; */
        if (message.evalvesignaturecheckdetail !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.evalvesignaturecheckdetail);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientCheckFileSignatureResponse
 */
export const CMsgClientCheckFileSignatureResponse = new CMsgClientCheckFileSignatureResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientClanState$Type extends MessageType<CMsgClientClanState> {
    constructor() {
        super("CMsgClientClanState", [
            { no: 1, name: "steamid_clan", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "clan_account_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "name_info", kind: "message", T: () => CMsgClientClanState_NameInfo },
            { no: 5, name: "user_counts", kind: "message", T: () => CMsgClientClanState_UserCounts },
            { no: 6, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientClanState_Event },
            { no: 7, name: "announcements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientClanState_Event },
            { no: 8, name: "chat_room_private", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientClanState>): CMsgClientClanState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        message.announcements = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientClanState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientClanState): CMsgClientClanState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_clan */ 1:
                    message.steamidClan = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 clan_account_flags */ 3:
                    message.clanAccountFlags = reader.uint32();
                    break;
                case /* optional CMsgClientClanState_NameInfo name_info */ 4:
                    message.nameInfo = CMsgClientClanState_NameInfo.internalBinaryRead(reader, reader.uint32(), options, message.nameInfo);
                    break;
                case /* optional CMsgClientClanState_UserCounts user_counts */ 5:
                    message.userCounts = CMsgClientClanState_UserCounts.internalBinaryRead(reader, reader.uint32(), options, message.userCounts);
                    break;
                case /* repeated CMsgClientClanState_Event events */ 6:
                    message.events.push(CMsgClientClanState_Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgClientClanState_Event announcements */ 7:
                    message.announcements.push(CMsgClientClanState_Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool chat_room_private */ 8:
                    message.chatRoomPrivate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientClanState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_clan = 1; */
        if (message.steamidClan !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidClan);
        /* optional uint32 clan_account_flags = 3; */
        if (message.clanAccountFlags !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.clanAccountFlags);
        /* optional CMsgClientClanState_NameInfo name_info = 4; */
        if (message.nameInfo)
            CMsgClientClanState_NameInfo.internalBinaryWrite(message.nameInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgClientClanState_UserCounts user_counts = 5; */
        if (message.userCounts)
            CMsgClientClanState_UserCounts.internalBinaryWrite(message.userCounts, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgClientClanState_Event events = 6; */
        for (let i = 0; i < message.events.length; i++)
            CMsgClientClanState_Event.internalBinaryWrite(message.events[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgClientClanState_Event announcements = 7; */
        for (let i = 0; i < message.announcements.length; i++)
            CMsgClientClanState_Event.internalBinaryWrite(message.announcements[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional bool chat_room_private = 8; */
        if (message.chatRoomPrivate !== undefined)
            writer.tag(8, WireType.Varint).bool(message.chatRoomPrivate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientClanState
 */
export const CMsgClientClanState = new CMsgClientClanState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientClanState_Event$Type extends MessageType<CMsgClientClanState_Event> {
    constructor() {
        super("CMsgClientClanState_Event", [
            { no: 1, name: "gid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "event_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "headline", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "just_posted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientClanState_Event>): CMsgClientClanState_Event {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientClanState_Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientClanState_Event): CMsgClientClanState_Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 gid */ 1:
                    message.gid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 event_time */ 2:
                    message.eventTime = reader.uint32();
                    break;
                case /* optional string headline */ 3:
                    message.headline = reader.string();
                    break;
                case /* optional fixed64 game_id */ 4:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional bool just_posted */ 5:
                    message.justPosted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientClanState_Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 gid = 1; */
        if (message.gid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gid);
        /* optional uint32 event_time = 2; */
        if (message.eventTime !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eventTime);
        /* optional string headline = 3; */
        if (message.headline !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.headline);
        /* optional fixed64 game_id = 4; */
        if (message.gameId !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.gameId);
        /* optional bool just_posted = 5; */
        if (message.justPosted !== undefined)
            writer.tag(5, WireType.Varint).bool(message.justPosted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientClanState_Event
 */
export const CMsgClientClanState_Event = new CMsgClientClanState_Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientClanState_NameInfo$Type extends MessageType<CMsgClientClanState_NameInfo> {
    constructor() {
        super("CMsgClientClanState_NameInfo", [
            { no: 1, name: "clan_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sha_avatar", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientClanState_NameInfo>): CMsgClientClanState_NameInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientClanState_NameInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientClanState_NameInfo): CMsgClientClanState_NameInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string clan_name */ 1:
                    message.clanName = reader.string();
                    break;
                case /* optional bytes sha_avatar */ 2:
                    message.shaAvatar = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientClanState_NameInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string clan_name = 1; */
        if (message.clanName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.clanName);
        /* optional bytes sha_avatar = 2; */
        if (message.shaAvatar !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.shaAvatar);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientClanState_NameInfo
 */
export const CMsgClientClanState_NameInfo = new CMsgClientClanState_NameInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientClanState_UserCounts$Type extends MessageType<CMsgClientClanState_UserCounts> {
    constructor() {
        super("CMsgClientClanState_UserCounts", [
            { no: 1, name: "members", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "online", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "chatting", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "in_game", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "chat_room_members", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientClanState_UserCounts>): CMsgClientClanState_UserCounts {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientClanState_UserCounts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientClanState_UserCounts): CMsgClientClanState_UserCounts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 members */ 1:
                    message.members = reader.uint32();
                    break;
                case /* optional uint32 online */ 2:
                    message.online = reader.uint32();
                    break;
                case /* optional uint32 chatting */ 3:
                    message.chatting = reader.uint32();
                    break;
                case /* optional uint32 in_game */ 4:
                    message.inGame = reader.uint32();
                    break;
                case /* optional uint32 chat_room_members */ 5:
                    message.chatRoomMembers = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientClanState_UserCounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 members = 1; */
        if (message.members !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.members);
        /* optional uint32 online = 2; */
        if (message.online !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.online);
        /* optional uint32 chatting = 3; */
        if (message.chatting !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.chatting);
        /* optional uint32 in_game = 4; */
        if (message.inGame !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.inGame);
        /* optional uint32 chat_room_members = 5; */
        if (message.chatRoomMembers !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.chatRoomMembers);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientClanState_UserCounts
 */
export const CMsgClientClanState_UserCounts = new CMsgClientClanState_UserCounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientCMList$Type extends MessageType<CMsgClientCMList> {
    constructor() {
        super("CMsgClientCMList", [
            { no: 1, name: "cm_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cm_ports", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cm_websocket_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "percent_default_to_websocket", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientCMList>): CMsgClientCMList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cmAddresses = [];
        message.cmPorts = [];
        message.cmWebsocketAddresses = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientCMList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientCMList): CMsgClientCMList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 cm_addresses */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cmAddresses.push(reader.uint32());
                    else
                        message.cmAddresses.push(reader.uint32());
                    break;
                case /* repeated uint32 cm_ports */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cmPorts.push(reader.uint32());
                    else
                        message.cmPorts.push(reader.uint32());
                    break;
                case /* repeated string cm_websocket_addresses */ 3:
                    message.cmWebsocketAddresses.push(reader.string());
                    break;
                case /* optional uint32 percent_default_to_websocket */ 4:
                    message.percentDefaultToWebsocket = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientCMList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 cm_addresses = 1; */
        for (let i = 0; i < message.cmAddresses.length; i++)
            writer.tag(1, WireType.Varint).uint32(message.cmAddresses[i]);
        /* repeated uint32 cm_ports = 2; */
        for (let i = 0; i < message.cmPorts.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.cmPorts[i]);
        /* repeated string cm_websocket_addresses = 3; */
        for (let i = 0; i < message.cmWebsocketAddresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cmWebsocketAddresses[i]);
        /* optional uint32 percent_default_to_websocket = 4; */
        if (message.percentDefaultToWebsocket !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.percentDefaultToWebsocket);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientCMList
 */
export const CMsgClientCMList = new CMsgClientCMList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientCommentNotifications$Type extends MessageType<CMsgClientCommentNotifications> {
    constructor() {
        super("CMsgClientCommentNotifications", [
            { no: 1, name: "count_new_comments", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "count_new_comments_owner", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "count_new_comments_subscriptions", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientCommentNotifications>): CMsgClientCommentNotifications {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientCommentNotifications>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientCommentNotifications): CMsgClientCommentNotifications {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 count_new_comments */ 1:
                    message.countNewComments = reader.uint32();
                    break;
                case /* optional uint32 count_new_comments_owner */ 2:
                    message.countNewCommentsOwner = reader.uint32();
                    break;
                case /* optional uint32 count_new_comments_subscriptions */ 3:
                    message.countNewCommentsSubscriptions = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientCommentNotifications, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 count_new_comments = 1; */
        if (message.countNewComments !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.countNewComments);
        /* optional uint32 count_new_comments_owner = 2; */
        if (message.countNewCommentsOwner !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.countNewCommentsOwner);
        /* optional uint32 count_new_comments_subscriptions = 3; */
        if (message.countNewCommentsSubscriptions !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.countNewCommentsSubscriptions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientCommentNotifications
 */
export const CMsgClientCommentNotifications = new CMsgClientCommentNotifications$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientConnectionStats$Type extends MessageType<CMsgClientConnectionStats> {
    constructor() {
        super("CMsgClientConnectionStats", [
            { no: 1, name: "stats_logon", kind: "message", T: () => CMsgClientConnectionStats_Stats_Logon },
            { no: 2, name: "stats_vconn", kind: "message", T: () => CMsgClientConnectionStats_Stats_VConn }
        ]);
    }
    create(value?: PartialMessage<CMsgClientConnectionStats>): CMsgClientConnectionStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientConnectionStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientConnectionStats): CMsgClientConnectionStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgClientConnectionStats_Stats_Logon stats_logon */ 1:
                    message.statsLogon = CMsgClientConnectionStats_Stats_Logon.internalBinaryRead(reader, reader.uint32(), options, message.statsLogon);
                    break;
                case /* optional CMsgClientConnectionStats_Stats_VConn stats_vconn */ 2:
                    message.statsVconn = CMsgClientConnectionStats_Stats_VConn.internalBinaryRead(reader, reader.uint32(), options, message.statsVconn);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientConnectionStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgClientConnectionStats_Stats_Logon stats_logon = 1; */
        if (message.statsLogon)
            CMsgClientConnectionStats_Stats_Logon.internalBinaryWrite(message.statsLogon, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgClientConnectionStats_Stats_VConn stats_vconn = 2; */
        if (message.statsVconn)
            CMsgClientConnectionStats_Stats_VConn.internalBinaryWrite(message.statsVconn, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientConnectionStats
 */
export const CMsgClientConnectionStats = new CMsgClientConnectionStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientConnectionStats_Stats_Logon$Type extends MessageType<CMsgClientConnectionStats_Stats_Logon> {
    constructor() {
        super("CMsgClientConnectionStats_Stats_Logon", [
            { no: 1, name: "connect_attempts", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "connect_successes", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "connect_failures", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "connections_dropped", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "seconds_running", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "msec_tologonthistime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "count_bad_cms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientConnectionStats_Stats_Logon>): CMsgClientConnectionStats_Stats_Logon {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientConnectionStats_Stats_Logon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientConnectionStats_Stats_Logon): CMsgClientConnectionStats_Stats_Logon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 connect_attempts */ 1:
                    message.connectAttempts = reader.int32();
                    break;
                case /* optional int32 connect_successes */ 2:
                    message.connectSuccesses = reader.int32();
                    break;
                case /* optional int32 connect_failures */ 3:
                    message.connectFailures = reader.int32();
                    break;
                case /* optional int32 connections_dropped */ 4:
                    message.connectionsDropped = reader.int32();
                    break;
                case /* optional uint32 seconds_running */ 5:
                    message.secondsRunning = reader.uint32();
                    break;
                case /* optional uint32 msec_tologonthistime */ 6:
                    message.msecTologonthistime = reader.uint32();
                    break;
                case /* optional uint32 count_bad_cms */ 7:
                    message.countBadCms = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientConnectionStats_Stats_Logon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 connect_attempts = 1; */
        if (message.connectAttempts !== undefined)
            writer.tag(1, WireType.Varint).int32(message.connectAttempts);
        /* optional int32 connect_successes = 2; */
        if (message.connectSuccesses !== undefined)
            writer.tag(2, WireType.Varint).int32(message.connectSuccesses);
        /* optional int32 connect_failures = 3; */
        if (message.connectFailures !== undefined)
            writer.tag(3, WireType.Varint).int32(message.connectFailures);
        /* optional int32 connections_dropped = 4; */
        if (message.connectionsDropped !== undefined)
            writer.tag(4, WireType.Varint).int32(message.connectionsDropped);
        /* optional uint32 seconds_running = 5; */
        if (message.secondsRunning !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.secondsRunning);
        /* optional uint32 msec_tologonthistime = 6; */
        if (message.msecTologonthistime !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.msecTologonthistime);
        /* optional uint32 count_bad_cms = 7; */
        if (message.countBadCms !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.countBadCms);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientConnectionStats_Stats_Logon
 */
export const CMsgClientConnectionStats_Stats_Logon = new CMsgClientConnectionStats_Stats_Logon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientConnectionStats_Stats_UDP$Type extends MessageType<CMsgClientConnectionStats_Stats_UDP> {
    constructor() {
        super("CMsgClientConnectionStats_Stats_UDP", [
            { no: 1, name: "pkts_sent", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "bytes_sent", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "pkts_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "pkts_processed", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "bytes_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientConnectionStats_Stats_UDP>): CMsgClientConnectionStats_Stats_UDP {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientConnectionStats_Stats_UDP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientConnectionStats_Stats_UDP): CMsgClientConnectionStats_Stats_UDP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 pkts_sent */ 1:
                    message.pktsSent = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes_sent */ 2:
                    message.bytesSent = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 pkts_recv */ 3:
                    message.pktsRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 pkts_processed */ 4:
                    message.pktsProcessed = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes_recv */ 5:
                    message.bytesRecv = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientConnectionStats_Stats_UDP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 pkts_sent = 1; */
        if (message.pktsSent !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.pktsSent);
        /* optional uint64 bytes_sent = 2; */
        if (message.bytesSent !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.bytesSent);
        /* optional uint64 pkts_recv = 3; */
        if (message.pktsRecv !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.pktsRecv);
        /* optional uint64 pkts_processed = 4; */
        if (message.pktsProcessed !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.pktsProcessed);
        /* optional uint64 bytes_recv = 5; */
        if (message.bytesRecv !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.bytesRecv);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientConnectionStats_Stats_UDP
 */
export const CMsgClientConnectionStats_Stats_UDP = new CMsgClientConnectionStats_Stats_UDP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientConnectionStats_Stats_VConn$Type extends MessageType<CMsgClientConnectionStats_Stats_VConn> {
    constructor() {
        super("CMsgClientConnectionStats_Stats_VConn", [
            { no: 1, name: "connections_udp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "connections_tcp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "stats_udp", kind: "message", T: () => CMsgClientConnectionStats_Stats_UDP },
            { no: 4, name: "pkts_abandoned", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "conn_req_received", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "pkts_resent", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "msgs_sent", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "msgs_sent_failed", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "msgs_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "datagrams_sent", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "datagrams_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "bad_pkts_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "unknown_conn_pkts_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "missed_pkts_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "dup_pkts_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "failed_connect_challenges", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "micro_sec_avg_latency", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "micro_sec_min_latency", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "micro_sec_max_latency", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "mem_pool_msg_in_use", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientConnectionStats_Stats_VConn>): CMsgClientConnectionStats_Stats_VConn {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientConnectionStats_Stats_VConn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientConnectionStats_Stats_VConn): CMsgClientConnectionStats_Stats_VConn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 connections_udp */ 1:
                    message.connectionsUdp = reader.uint32();
                    break;
                case /* optional uint32 connections_tcp */ 2:
                    message.connectionsTcp = reader.uint32();
                    break;
                case /* optional CMsgClientConnectionStats_Stats_UDP stats_udp */ 3:
                    message.statsUdp = CMsgClientConnectionStats_Stats_UDP.internalBinaryRead(reader, reader.uint32(), options, message.statsUdp);
                    break;
                case /* optional uint64 pkts_abandoned */ 4:
                    message.pktsAbandoned = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 conn_req_received */ 5:
                    message.connReqReceived = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 pkts_resent */ 6:
                    message.pktsResent = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 msgs_sent */ 7:
                    message.msgsSent = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 msgs_sent_failed */ 8:
                    message.msgsSentFailed = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 msgs_recv */ 9:
                    message.msgsRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 datagrams_sent */ 10:
                    message.datagramsSent = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 datagrams_recv */ 11:
                    message.datagramsRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bad_pkts_recv */ 12:
                    message.badPktsRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 unknown_conn_pkts_recv */ 13:
                    message.unknownConnPktsRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 missed_pkts_recv */ 14:
                    message.missedPktsRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 dup_pkts_recv */ 15:
                    message.dupPktsRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 failed_connect_challenges */ 16:
                    message.failedConnectChallenges = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 micro_sec_avg_latency */ 17:
                    message.microSecAvgLatency = reader.uint32();
                    break;
                case /* optional uint32 micro_sec_min_latency */ 18:
                    message.microSecMinLatency = reader.uint32();
                    break;
                case /* optional uint32 micro_sec_max_latency */ 19:
                    message.microSecMaxLatency = reader.uint32();
                    break;
                case /* optional uint32 mem_pool_msg_in_use */ 20:
                    message.memPoolMsgInUse = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientConnectionStats_Stats_VConn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 connections_udp = 1; */
        if (message.connectionsUdp !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.connectionsUdp);
        /* optional uint32 connections_tcp = 2; */
        if (message.connectionsTcp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.connectionsTcp);
        /* optional CMsgClientConnectionStats_Stats_UDP stats_udp = 3; */
        if (message.statsUdp)
            CMsgClientConnectionStats_Stats_UDP.internalBinaryWrite(message.statsUdp, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 pkts_abandoned = 4; */
        if (message.pktsAbandoned !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.pktsAbandoned);
        /* optional uint64 conn_req_received = 5; */
        if (message.connReqReceived !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.connReqReceived);
        /* optional uint64 pkts_resent = 6; */
        if (message.pktsResent !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.pktsResent);
        /* optional uint64 msgs_sent = 7; */
        if (message.msgsSent !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.msgsSent);
        /* optional uint64 msgs_sent_failed = 8; */
        if (message.msgsSentFailed !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.msgsSentFailed);
        /* optional uint64 msgs_recv = 9; */
        if (message.msgsRecv !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.msgsRecv);
        /* optional uint64 datagrams_sent = 10; */
        if (message.datagramsSent !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.datagramsSent);
        /* optional uint64 datagrams_recv = 11; */
        if (message.datagramsRecv !== undefined)
            writer.tag(11, WireType.Varint).uint64(message.datagramsRecv);
        /* optional uint64 bad_pkts_recv = 12; */
        if (message.badPktsRecv !== undefined)
            writer.tag(12, WireType.Varint).uint64(message.badPktsRecv);
        /* optional uint64 unknown_conn_pkts_recv = 13; */
        if (message.unknownConnPktsRecv !== undefined)
            writer.tag(13, WireType.Varint).uint64(message.unknownConnPktsRecv);
        /* optional uint64 missed_pkts_recv = 14; */
        if (message.missedPktsRecv !== undefined)
            writer.tag(14, WireType.Varint).uint64(message.missedPktsRecv);
        /* optional uint64 dup_pkts_recv = 15; */
        if (message.dupPktsRecv !== undefined)
            writer.tag(15, WireType.Varint).uint64(message.dupPktsRecv);
        /* optional uint64 failed_connect_challenges = 16; */
        if (message.failedConnectChallenges !== undefined)
            writer.tag(16, WireType.Varint).uint64(message.failedConnectChallenges);
        /* optional uint32 micro_sec_avg_latency = 17; */
        if (message.microSecAvgLatency !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.microSecAvgLatency);
        /* optional uint32 micro_sec_min_latency = 18; */
        if (message.microSecMinLatency !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.microSecMinLatency);
        /* optional uint32 micro_sec_max_latency = 19; */
        if (message.microSecMaxLatency !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.microSecMaxLatency);
        /* optional uint32 mem_pool_msg_in_use = 20; */
        if (message.memPoolMsgInUse !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.memPoolMsgInUse);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientConnectionStats_Stats_VConn
 */
export const CMsgClientConnectionStats_Stats_VConn = new CMsgClientConnectionStats_Stats_VConn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientCreateFriendsGroup$Type extends MessageType<CMsgClientCreateFriendsGroup> {
    constructor() {
        super("CMsgClientCreateFriendsGroup", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "groupname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "steamid_friends", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientCreateFriendsGroup>): CMsgClientCreateFriendsGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamidFriends = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientCreateFriendsGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientCreateFriendsGroup): CMsgClientCreateFriendsGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string groupname */ 2:
                    message.groupname = reader.string();
                    break;
                case /* repeated fixed64 steamid_friends */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamidFriends.push(reader.fixed64().toBigInt());
                    else
                        message.steamidFriends.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientCreateFriendsGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional string groupname = 2; */
        if (message.groupname !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.groupname);
        /* repeated fixed64 steamid_friends = 3; */
        for (let i = 0; i < message.steamidFriends.length; i++)
            writer.tag(3, WireType.Bit64).fixed64(message.steamidFriends[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientCreateFriendsGroup
 */
export const CMsgClientCreateFriendsGroup = new CMsgClientCreateFriendsGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientCreateFriendsGroupResponse$Type extends MessageType<CMsgClientCreateFriendsGroupResponse> {
    constructor() {
        super("CMsgClientCreateFriendsGroupResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "groupid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientCreateFriendsGroupResponse>): CMsgClientCreateFriendsGroupResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientCreateFriendsGroupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientCreateFriendsGroupResponse): CMsgClientCreateFriendsGroupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                case /* optional int32 groupid */ 2:
                    message.groupid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientCreateFriendsGroupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        /* optional int32 groupid = 2; */
        if (message.groupid !== undefined)
            writer.tag(2, WireType.Varint).int32(message.groupid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientCreateFriendsGroupResponse
 */
export const CMsgClientCreateFriendsGroupResponse = new CMsgClientCreateFriendsGroupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientDeauthorizeDevice$Type extends MessageType<CMsgClientDeauthorizeDevice> {
    constructor() {
        super("CMsgClientDeauthorizeDevice", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "deauthorization_account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientDeauthorizeDevice>): CMsgClientDeauthorizeDevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientDeauthorizeDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientDeauthorizeDevice): CMsgClientDeauthorizeDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 deauthorization_account_id */ 2:
                    message.deauthorizationAccountId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientDeauthorizeDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional uint32 deauthorization_account_id = 2; */
        if (message.deauthorizationAccountId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.deauthorizationAccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientDeauthorizeDevice
 */
export const CMsgClientDeauthorizeDevice = new CMsgClientDeauthorizeDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientDeauthorizeDeviceRequest$Type extends MessageType<CMsgClientDeauthorizeDeviceRequest> {
    constructor() {
        super("CMsgClientDeauthorizeDeviceRequest", [
            { no: 1, name: "deauthorization_account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "deauthorization_device_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientDeauthorizeDeviceRequest>): CMsgClientDeauthorizeDeviceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientDeauthorizeDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientDeauthorizeDeviceRequest): CMsgClientDeauthorizeDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 deauthorization_account_id */ 1:
                    message.deauthorizationAccountId = reader.uint32();
                    break;
                case /* optional uint64 deauthorization_device_token */ 2:
                    message.deauthorizationDeviceToken = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientDeauthorizeDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 deauthorization_account_id = 1; */
        if (message.deauthorizationAccountId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.deauthorizationAccountId);
        /* optional uint64 deauthorization_device_token = 2; */
        if (message.deauthorizationDeviceToken !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.deauthorizationDeviceToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientDeauthorizeDeviceRequest
 */
export const CMsgClientDeauthorizeDeviceRequest = new CMsgClientDeauthorizeDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientDeleteFriendsGroup$Type extends MessageType<CMsgClientDeleteFriendsGroup> {
    constructor() {
        super("CMsgClientDeleteFriendsGroup", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "groupid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientDeleteFriendsGroup>): CMsgClientDeleteFriendsGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientDeleteFriendsGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientDeleteFriendsGroup): CMsgClientDeleteFriendsGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 groupid */ 2:
                    message.groupid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientDeleteFriendsGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional int32 groupid = 2; */
        if (message.groupid !== undefined)
            writer.tag(2, WireType.Varint).int32(message.groupid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientDeleteFriendsGroup
 */
export const CMsgClientDeleteFriendsGroup = new CMsgClientDeleteFriendsGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientDeleteFriendsGroupResponse$Type extends MessageType<CMsgClientDeleteFriendsGroupResponse> {
    constructor() {
        super("CMsgClientDeleteFriendsGroupResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientDeleteFriendsGroupResponse>): CMsgClientDeleteFriendsGroupResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientDeleteFriendsGroupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientDeleteFriendsGroupResponse): CMsgClientDeleteFriendsGroupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientDeleteFriendsGroupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientDeleteFriendsGroupResponse
 */
export const CMsgClientDeleteFriendsGroupResponse = new CMsgClientDeleteFriendsGroupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientDeregisterWithServer$Type extends MessageType<CMsgClientDeregisterWithServer> {
    constructor() {
        super("CMsgClientDeregisterWithServer", [
            { no: 1, name: "eservertype", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientDeregisterWithServer>): CMsgClientDeregisterWithServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientDeregisterWithServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientDeregisterWithServer): CMsgClientDeregisterWithServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eservertype */ 1:
                    message.eservertype = reader.uint32();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientDeregisterWithServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eservertype = 1; */
        if (message.eservertype !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eservertype);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientDeregisterWithServer
 */
export const CMsgClientDeregisterWithServer = new CMsgClientDeregisterWithServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientDPCheckSpecialSurvey$Type extends MessageType<CMsgClientDPCheckSpecialSurvey> {
    constructor() {
        super("CMsgClientDPCheckSpecialSurvey", [
            { no: 1, name: "survey_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientDPCheckSpecialSurvey>): CMsgClientDPCheckSpecialSurvey {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientDPCheckSpecialSurvey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientDPCheckSpecialSurvey): CMsgClientDPCheckSpecialSurvey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 survey_id */ 1:
                    message.surveyId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientDPCheckSpecialSurvey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 survey_id = 1; */
        if (message.surveyId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.surveyId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientDPCheckSpecialSurvey
 */
export const CMsgClientDPCheckSpecialSurvey = new CMsgClientDPCheckSpecialSurvey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientDPCheckSpecialSurveyResponse$Type extends MessageType<CMsgClientDPCheckSpecialSurveyResponse> {
    constructor() {
        super("CMsgClientDPCheckSpecialSurveyResponse", [
            { no: 1, name: "eResult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "custom_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "include_software", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientDPCheckSpecialSurveyResponse>): CMsgClientDPCheckSpecialSurveyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientDPCheckSpecialSurveyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientDPCheckSpecialSurveyResponse): CMsgClientDPCheckSpecialSurveyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eResult = 1 [default = 2] */ 1:
                    message.eResult = reader.uint32();
                    break;
                case /* optional uint32 state */ 2:
                    message.state = reader.uint32();
                    break;
                case /* optional string name */ 3:
                    message.name = reader.string();
                    break;
                case /* optional string custom_url */ 4:
                    message.customUrl = reader.string();
                    break;
                case /* optional bool include_software */ 5:
                    message.includeSoftware = reader.bool();
                    break;
                case /* optional bytes token */ 6:
                    message.token = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientDPCheckSpecialSurveyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eResult = 1 [default = 2]; */
        if (message.eResult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eResult);
        /* optional uint32 state = 2; */
        if (message.state !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.state);
        /* optional string name = 3; */
        if (message.name !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* optional string custom_url = 4; */
        if (message.customUrl !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.customUrl);
        /* optional bool include_software = 5; */
        if (message.includeSoftware !== undefined)
            writer.tag(5, WireType.Varint).bool(message.includeSoftware);
        /* optional bytes token = 6; */
        if (message.token !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientDPCheckSpecialSurveyResponse
 */
export const CMsgClientDPCheckSpecialSurveyResponse = new CMsgClientDPCheckSpecialSurveyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientDPContentStatsReport$Type extends MessageType<CMsgClientDPContentStatsReport> {
    constructor() {
        super("CMsgClientDPContentStatsReport", [
            { no: 1, name: "stats_machine_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "os_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "language", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "num_install_folders", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "num_installed_games", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "size_installed_games", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientDPContentStatsReport>): CMsgClientDPContentStatsReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientDPContentStatsReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientDPContentStatsReport): CMsgClientDPContentStatsReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 stats_machine_id */ 1:
                    message.statsMachineId = reader.fixed64().toBigInt();
                    break;
                case /* optional string country_code */ 2:
                    message.countryCode = reader.string();
                    break;
                case /* optional int32 os_type */ 3:
                    message.osType = reader.int32();
                    break;
                case /* optional int32 language */ 4:
                    message.language = reader.int32();
                    break;
                case /* optional uint32 num_install_folders */ 5:
                    message.numInstallFolders = reader.uint32();
                    break;
                case /* optional uint32 num_installed_games */ 6:
                    message.numInstalledGames = reader.uint32();
                    break;
                case /* optional uint64 size_installed_games */ 7:
                    message.sizeInstalledGames = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientDPContentStatsReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 stats_machine_id = 1; */
        if (message.statsMachineId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.statsMachineId);
        /* optional string country_code = 2; */
        if (message.countryCode !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.countryCode);
        /* optional int32 os_type = 3; */
        if (message.osType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.osType);
        /* optional int32 language = 4; */
        if (message.language !== undefined)
            writer.tag(4, WireType.Varint).int32(message.language);
        /* optional uint32 num_install_folders = 5; */
        if (message.numInstallFolders !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.numInstallFolders);
        /* optional uint32 num_installed_games = 6; */
        if (message.numInstalledGames !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.numInstalledGames);
        /* optional uint64 size_installed_games = 7; */
        if (message.sizeInstalledGames !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.sizeInstalledGames);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientDPContentStatsReport
 */
export const CMsgClientDPContentStatsReport = new CMsgClientDPContentStatsReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientDPSendSpecialSurveyResponse$Type extends MessageType<CMsgClientDPSendSpecialSurveyResponse> {
    constructor() {
        super("CMsgClientDPSendSpecialSurveyResponse", [
            { no: 1, name: "survey_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientDPSendSpecialSurveyResponse>): CMsgClientDPSendSpecialSurveyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientDPSendSpecialSurveyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientDPSendSpecialSurveyResponse): CMsgClientDPSendSpecialSurveyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 survey_id */ 1:
                    message.surveyId = reader.uint32();
                    break;
                case /* optional bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientDPSendSpecialSurveyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 survey_id = 1; */
        if (message.surveyId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.surveyId);
        /* optional bytes data = 2; */
        if (message.data !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientDPSendSpecialSurveyResponse
 */
export const CMsgClientDPSendSpecialSurveyResponse = new CMsgClientDPSendSpecialSurveyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientDPSendSpecialSurveyResponseReply$Type extends MessageType<CMsgClientDPSendSpecialSurveyResponseReply> {
    constructor() {
        super("CMsgClientDPSendSpecialSurveyResponseReply", [
            { no: 1, name: "eResult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientDPSendSpecialSurveyResponseReply>): CMsgClientDPSendSpecialSurveyResponseReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientDPSendSpecialSurveyResponseReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientDPSendSpecialSurveyResponseReply): CMsgClientDPSendSpecialSurveyResponseReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eResult = 1 [default = 2] */ 1:
                    message.eResult = reader.uint32();
                    break;
                case /* optional bytes token */ 2:
                    message.token = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientDPSendSpecialSurveyResponseReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eResult = 1 [default = 2]; */
        if (message.eResult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eResult);
        /* optional bytes token = 2; */
        if (message.token !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientDPSendSpecialSurveyResponseReply
 */
export const CMsgClientDPSendSpecialSurveyResponseReply = new CMsgClientDPSendSpecialSurveyResponseReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientEmailAddrInfo$Type extends MessageType<CMsgClientEmailAddrInfo> {
    constructor() {
        super("CMsgClientEmailAddrInfo", [
            { no: 1, name: "email_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email_is_validated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "email_validation_changed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "credential_change_requires_code", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "password_or_secretqa_change_requires_code", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "remind_user_about_email", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientEmailAddrInfo>): CMsgClientEmailAddrInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientEmailAddrInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientEmailAddrInfo): CMsgClientEmailAddrInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string email_address */ 1:
                    message.emailAddress = reader.string();
                    break;
                case /* optional bool email_is_validated */ 2:
                    message.emailIsValidated = reader.bool();
                    break;
                case /* optional bool email_validation_changed */ 3:
                    message.emailValidationChanged = reader.bool();
                    break;
                case /* optional bool credential_change_requires_code */ 4:
                    message.credentialChangeRequiresCode = reader.bool();
                    break;
                case /* optional bool password_or_secretqa_change_requires_code */ 5:
                    message.passwordOrSecretqaChangeRequiresCode = reader.bool();
                    break;
                case /* optional bool remind_user_about_email */ 6:
                    message.remindUserAboutEmail = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientEmailAddrInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string email_address = 1; */
        if (message.emailAddress !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.emailAddress);
        /* optional bool email_is_validated = 2; */
        if (message.emailIsValidated !== undefined)
            writer.tag(2, WireType.Varint).bool(message.emailIsValidated);
        /* optional bool email_validation_changed = 3; */
        if (message.emailValidationChanged !== undefined)
            writer.tag(3, WireType.Varint).bool(message.emailValidationChanged);
        /* optional bool credential_change_requires_code = 4; */
        if (message.credentialChangeRequiresCode !== undefined)
            writer.tag(4, WireType.Varint).bool(message.credentialChangeRequiresCode);
        /* optional bool password_or_secretqa_change_requires_code = 5; */
        if (message.passwordOrSecretqaChangeRequiresCode !== undefined)
            writer.tag(5, WireType.Varint).bool(message.passwordOrSecretqaChangeRequiresCode);
        /* optional bool remind_user_about_email = 6; */
        if (message.remindUserAboutEmail !== undefined)
            writer.tag(6, WireType.Varint).bool(message.remindUserAboutEmail);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientEmailAddrInfo
 */
export const CMsgClientEmailAddrInfo = new CMsgClientEmailAddrInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientEmoticonList$Type extends MessageType<CMsgClientEmoticonList> {
    constructor() {
        super("CMsgClientEmoticonList", [
            { no: 1, name: "emoticons", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientEmoticonList_Emoticon },
            { no: 2, name: "stickers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientEmoticonList_Sticker },
            { no: 3, name: "effects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientEmoticonList_Effect }
        ]);
    }
    create(value?: PartialMessage<CMsgClientEmoticonList>): CMsgClientEmoticonList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.emoticons = [];
        message.stickers = [];
        message.effects = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientEmoticonList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientEmoticonList): CMsgClientEmoticonList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientEmoticonList_Emoticon emoticons */ 1:
                    message.emoticons.push(CMsgClientEmoticonList_Emoticon.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgClientEmoticonList_Sticker stickers */ 2:
                    message.stickers.push(CMsgClientEmoticonList_Sticker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgClientEmoticonList_Effect effects */ 3:
                    message.effects.push(CMsgClientEmoticonList_Effect.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientEmoticonList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientEmoticonList_Emoticon emoticons = 1; */
        for (let i = 0; i < message.emoticons.length; i++)
            CMsgClientEmoticonList_Emoticon.internalBinaryWrite(message.emoticons[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgClientEmoticonList_Sticker stickers = 2; */
        for (let i = 0; i < message.stickers.length; i++)
            CMsgClientEmoticonList_Sticker.internalBinaryWrite(message.stickers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgClientEmoticonList_Effect effects = 3; */
        for (let i = 0; i < message.effects.length; i++)
            CMsgClientEmoticonList_Effect.internalBinaryWrite(message.effects[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientEmoticonList
 */
export const CMsgClientEmoticonList = new CMsgClientEmoticonList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientEmoticonList_Effect$Type extends MessageType<CMsgClientEmoticonList_Effect> {
    constructor() {
        super("CMsgClientEmoticonList_Effect", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "time_received", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "infinite_use", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientEmoticonList_Effect>): CMsgClientEmoticonList_Effect {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientEmoticonList_Effect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientEmoticonList_Effect): CMsgClientEmoticonList_Effect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional int32 count */ 2:
                    message.count = reader.int32();
                    break;
                case /* optional uint32 time_received */ 3:
                    message.timeReceived = reader.uint32();
                    break;
                case /* optional bool infinite_use */ 4:
                    message.infiniteUse = reader.bool();
                    break;
                case /* optional uint32 appid */ 5:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientEmoticonList_Effect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional int32 count = 2; */
        if (message.count !== undefined)
            writer.tag(2, WireType.Varint).int32(message.count);
        /* optional uint32 time_received = 3; */
        if (message.timeReceived !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.timeReceived);
        /* optional bool infinite_use = 4; */
        if (message.infiniteUse !== undefined)
            writer.tag(4, WireType.Varint).bool(message.infiniteUse);
        /* optional uint32 appid = 5; */
        if (message.appid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientEmoticonList_Effect
 */
export const CMsgClientEmoticonList_Effect = new CMsgClientEmoticonList_Effect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientEmoticonList_Emoticon$Type extends MessageType<CMsgClientEmoticonList_Emoticon> {
    constructor() {
        super("CMsgClientEmoticonList_Emoticon", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "time_last_used", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "use_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "time_received", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientEmoticonList_Emoticon>): CMsgClientEmoticonList_Emoticon {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientEmoticonList_Emoticon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientEmoticonList_Emoticon): CMsgClientEmoticonList_Emoticon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional int32 count */ 2:
                    message.count = reader.int32();
                    break;
                case /* optional uint32 time_last_used */ 3:
                    message.timeLastUsed = reader.uint32();
                    break;
                case /* optional uint32 use_count */ 4:
                    message.useCount = reader.uint32();
                    break;
                case /* optional uint32 time_received */ 5:
                    message.timeReceived = reader.uint32();
                    break;
                case /* optional uint32 appid */ 6:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientEmoticonList_Emoticon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional int32 count = 2; */
        if (message.count !== undefined)
            writer.tag(2, WireType.Varint).int32(message.count);
        /* optional uint32 time_last_used = 3; */
        if (message.timeLastUsed !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.timeLastUsed);
        /* optional uint32 use_count = 4; */
        if (message.useCount !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.useCount);
        /* optional uint32 time_received = 5; */
        if (message.timeReceived !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.timeReceived);
        /* optional uint32 appid = 6; */
        if (message.appid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientEmoticonList_Emoticon
 */
export const CMsgClientEmoticonList_Emoticon = new CMsgClientEmoticonList_Emoticon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientEmoticonList_Sticker$Type extends MessageType<CMsgClientEmoticonList_Sticker> {
    constructor() {
        super("CMsgClientEmoticonList_Sticker", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "time_received", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "time_last_used", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "use_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientEmoticonList_Sticker>): CMsgClientEmoticonList_Sticker {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientEmoticonList_Sticker>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientEmoticonList_Sticker): CMsgClientEmoticonList_Sticker {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional int32 count */ 2:
                    message.count = reader.int32();
                    break;
                case /* optional uint32 time_received */ 3:
                    message.timeReceived = reader.uint32();
                    break;
                case /* optional uint32 appid */ 4:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 time_last_used */ 5:
                    message.timeLastUsed = reader.uint32();
                    break;
                case /* optional uint32 use_count */ 6:
                    message.useCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientEmoticonList_Sticker, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional int32 count = 2; */
        if (message.count !== undefined)
            writer.tag(2, WireType.Varint).int32(message.count);
        /* optional uint32 time_received = 3; */
        if (message.timeReceived !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.timeReceived);
        /* optional uint32 appid = 4; */
        if (message.appid !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.appid);
        /* optional uint32 time_last_used = 5; */
        if (message.timeLastUsed !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.timeLastUsed);
        /* optional uint32 use_count = 6; */
        if (message.useCount !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.useCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientEmoticonList_Sticker
 */
export const CMsgClientEmoticonList_Sticker = new CMsgClientEmoticonList_Sticker$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFriendMsg$Type extends MessageType<CMsgClientFriendMsg> {
    constructor() {
        super("CMsgClientFriendMsg", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "chat_entry_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "message", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "rtime32_server_timestamp", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "echo_to_sender", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFriendMsg>): CMsgClientFriendMsg {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFriendMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFriendMsg): CMsgClientFriendMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 chat_entry_type */ 2:
                    message.chatEntryType = reader.int32();
                    break;
                case /* optional bytes message */ 3:
                    message.message = reader.bytes();
                    break;
                case /* optional fixed32 rtime32_server_timestamp */ 4:
                    message.rtime32ServerTimestamp = reader.fixed32();
                    break;
                case /* optional bool echo_to_sender */ 5:
                    message.echoToSender = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFriendMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional int32 chat_entry_type = 2; */
        if (message.chatEntryType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.chatEntryType);
        /* optional bytes message = 3; */
        if (message.message !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.message);
        /* optional fixed32 rtime32_server_timestamp = 4; */
        if (message.rtime32ServerTimestamp !== undefined)
            writer.tag(4, WireType.Bit32).fixed32(message.rtime32ServerTimestamp);
        /* optional bool echo_to_sender = 5; */
        if (message.echoToSender !== undefined)
            writer.tag(5, WireType.Varint).bool(message.echoToSender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFriendMsg
 */
export const CMsgClientFriendMsg = new CMsgClientFriendMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFriendMsgIncoming$Type extends MessageType<CMsgClientFriendMsgIncoming> {
    constructor() {
        super("CMsgClientFriendMsgIncoming", [
            { no: 1, name: "steamid_from", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "chat_entry_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "from_limited_account", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "message", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "rtime32_server_timestamp", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFriendMsgIncoming>): CMsgClientFriendMsgIncoming {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFriendMsgIncoming>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFriendMsgIncoming): CMsgClientFriendMsgIncoming {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_from */ 1:
                    message.steamidFrom = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 chat_entry_type */ 2:
                    message.chatEntryType = reader.int32();
                    break;
                case /* optional bool from_limited_account */ 3:
                    message.fromLimitedAccount = reader.bool();
                    break;
                case /* optional bytes message */ 4:
                    message.message = reader.bytes();
                    break;
                case /* optional fixed32 rtime32_server_timestamp */ 5:
                    message.rtime32ServerTimestamp = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFriendMsgIncoming, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_from = 1; */
        if (message.steamidFrom !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidFrom);
        /* optional int32 chat_entry_type = 2; */
        if (message.chatEntryType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.chatEntryType);
        /* optional bool from_limited_account = 3; */
        if (message.fromLimitedAccount !== undefined)
            writer.tag(3, WireType.Varint).bool(message.fromLimitedAccount);
        /* optional bytes message = 4; */
        if (message.message !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.message);
        /* optional fixed32 rtime32_server_timestamp = 5; */
        if (message.rtime32ServerTimestamp !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.rtime32ServerTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFriendMsgIncoming
 */
export const CMsgClientFriendMsgIncoming = new CMsgClientFriendMsgIncoming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFriendProfileInfo$Type extends MessageType<CMsgClientFriendProfileInfo> {
    constructor() {
        super("CMsgClientFriendProfileInfo", [
            { no: 1, name: "steamid_friend", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFriendProfileInfo>): CMsgClientFriendProfileInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFriendProfileInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFriendProfileInfo): CMsgClientFriendProfileInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_friend */ 1:
                    message.steamidFriend = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFriendProfileInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_friend = 1; */
        if (message.steamidFriend !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidFriend);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFriendProfileInfo
 */
export const CMsgClientFriendProfileInfo = new CMsgClientFriendProfileInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFriendProfileInfoResponse$Type extends MessageType<CMsgClientFriendProfileInfoResponse> {
    constructor() {
        super("CMsgClientFriendProfileInfoResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "steamid_friend", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "time_created", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "real_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "city_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "state_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "country_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "headline", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "summary", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFriendProfileInfoResponse>): CMsgClientFriendProfileInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFriendProfileInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFriendProfileInfoResponse): CMsgClientFriendProfileInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional fixed64 steamid_friend */ 2:
                    message.steamidFriend = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 time_created */ 3:
                    message.timeCreated = reader.uint32();
                    break;
                case /* optional string real_name */ 4:
                    message.realName = reader.string();
                    break;
                case /* optional string city_name */ 5:
                    message.cityName = reader.string();
                    break;
                case /* optional string state_name */ 6:
                    message.stateName = reader.string();
                    break;
                case /* optional string country_name */ 7:
                    message.countryName = reader.string();
                    break;
                case /* optional string headline */ 8:
                    message.headline = reader.string();
                    break;
                case /* optional string summary */ 9:
                    message.summary = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFriendProfileInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional fixed64 steamid_friend = 2; */
        if (message.steamidFriend !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamidFriend);
        /* optional uint32 time_created = 3; */
        if (message.timeCreated !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.timeCreated);
        /* optional string real_name = 4; */
        if (message.realName !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.realName);
        /* optional string city_name = 5; */
        if (message.cityName !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.cityName);
        /* optional string state_name = 6; */
        if (message.stateName !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.stateName);
        /* optional string country_name = 7; */
        if (message.countryName !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.countryName);
        /* optional string headline = 8; */
        if (message.headline !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.headline);
        /* optional string summary = 9; */
        if (message.summary !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.summary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFriendProfileInfoResponse
 */
export const CMsgClientFriendProfileInfoResponse = new CMsgClientFriendProfileInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFriendsGroupsList$Type extends MessageType<CMsgClientFriendsGroupsList> {
    constructor() {
        super("CMsgClientFriendsGroupsList", [
            { no: 1, name: "bremoval", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "bincremental", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "friendGroups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientFriendsGroupsList_FriendGroup },
            { no: 4, name: "memberships", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientFriendsGroupsList_FriendGroupsMembership }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFriendsGroupsList>): CMsgClientFriendsGroupsList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.friendGroups = [];
        message.memberships = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFriendsGroupsList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFriendsGroupsList): CMsgClientFriendsGroupsList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool bremoval */ 1:
                    message.bremoval = reader.bool();
                    break;
                case /* optional bool bincremental */ 2:
                    message.bincremental = reader.bool();
                    break;
                case /* repeated CMsgClientFriendsGroupsList_FriendGroup friendGroups */ 3:
                    message.friendGroups.push(CMsgClientFriendsGroupsList_FriendGroup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgClientFriendsGroupsList_FriendGroupsMembership memberships */ 4:
                    message.memberships.push(CMsgClientFriendsGroupsList_FriendGroupsMembership.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFriendsGroupsList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool bremoval = 1; */
        if (message.bremoval !== undefined)
            writer.tag(1, WireType.Varint).bool(message.bremoval);
        /* optional bool bincremental = 2; */
        if (message.bincremental !== undefined)
            writer.tag(2, WireType.Varint).bool(message.bincremental);
        /* repeated CMsgClientFriendsGroupsList_FriendGroup friendGroups = 3; */
        for (let i = 0; i < message.friendGroups.length; i++)
            CMsgClientFriendsGroupsList_FriendGroup.internalBinaryWrite(message.friendGroups[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgClientFriendsGroupsList_FriendGroupsMembership memberships = 4; */
        for (let i = 0; i < message.memberships.length; i++)
            CMsgClientFriendsGroupsList_FriendGroupsMembership.internalBinaryWrite(message.memberships[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFriendsGroupsList
 */
export const CMsgClientFriendsGroupsList = new CMsgClientFriendsGroupsList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFriendsGroupsList_FriendGroup$Type extends MessageType<CMsgClientFriendsGroupsList_FriendGroup> {
    constructor() {
        super("CMsgClientFriendsGroupsList_FriendGroup", [
            { no: 1, name: "nGroupID", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "strGroupName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFriendsGroupsList_FriendGroup>): CMsgClientFriendsGroupsList_FriendGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFriendsGroupsList_FriendGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFriendsGroupsList_FriendGroup): CMsgClientFriendsGroupsList_FriendGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 nGroupID */ 1:
                    message.nGroupID = reader.int32();
                    break;
                case /* optional string strGroupName */ 2:
                    message.strGroupName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFriendsGroupsList_FriendGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 nGroupID = 1; */
        if (message.nGroupID !== undefined)
            writer.tag(1, WireType.Varint).int32(message.nGroupID);
        /* optional string strGroupName = 2; */
        if (message.strGroupName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.strGroupName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFriendsGroupsList_FriendGroup
 */
export const CMsgClientFriendsGroupsList_FriendGroup = new CMsgClientFriendsGroupsList_FriendGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFriendsGroupsList_FriendGroupsMembership$Type extends MessageType<CMsgClientFriendsGroupsList_FriendGroupsMembership> {
    constructor() {
        super("CMsgClientFriendsGroupsList_FriendGroupsMembership", [
            { no: 1, name: "ulSteamID", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "nGroupID", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFriendsGroupsList_FriendGroupsMembership>): CMsgClientFriendsGroupsList_FriendGroupsMembership {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFriendsGroupsList_FriendGroupsMembership>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFriendsGroupsList_FriendGroupsMembership): CMsgClientFriendsGroupsList_FriendGroupsMembership {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 ulSteamID */ 1:
                    message.ulSteamID = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 nGroupID */ 2:
                    message.nGroupID = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFriendsGroupsList_FriendGroupsMembership, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 ulSteamID = 1; */
        if (message.ulSteamID !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.ulSteamID);
        /* optional int32 nGroupID = 2; */
        if (message.nGroupID !== undefined)
            writer.tag(2, WireType.Varint).int32(message.nGroupID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFriendsGroupsList_FriendGroupsMembership
 */
export const CMsgClientFriendsGroupsList_FriendGroupsMembership = new CMsgClientFriendsGroupsList_FriendGroupsMembership$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFriendUserStatusPublished$Type extends MessageType<CMsgClientFriendUserStatusPublished> {
    constructor() {
        super("CMsgClientFriendUserStatusPublished", [
            { no: 1, name: "friend_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "status_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFriendUserStatusPublished>): CMsgClientFriendUserStatusPublished {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFriendUserStatusPublished>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFriendUserStatusPublished): CMsgClientFriendUserStatusPublished {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 friend_steamid */ 1:
                    message.friendSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 appid */ 2:
                    message.appid = reader.uint32();
                    break;
                case /* optional string status_text */ 3:
                    message.statusText = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFriendUserStatusPublished, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 friend_steamid = 1; */
        if (message.friendSteamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.friendSteamid);
        /* optional uint32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appid);
        /* optional string status_text = 3; */
        if (message.statusText !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.statusText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFriendUserStatusPublished
 */
export const CMsgClientFriendUserStatusPublished = new CMsgClientFriendUserStatusPublished$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFSGetFriendsSteamLevels$Type extends MessageType<CMsgClientFSGetFriendsSteamLevels> {
    constructor() {
        super("CMsgClientFSGetFriendsSteamLevels", [
            { no: 1, name: "accountids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFSGetFriendsSteamLevels>): CMsgClientFSGetFriendsSteamLevels {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFSGetFriendsSteamLevels>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFSGetFriendsSteamLevels): CMsgClientFSGetFriendsSteamLevels {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 accountids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.accountids.push(reader.uint32());
                    else
                        message.accountids.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFSGetFriendsSteamLevels, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 accountids = 1; */
        for (let i = 0; i < message.accountids.length; i++)
            writer.tag(1, WireType.Varint).uint32(message.accountids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFSGetFriendsSteamLevels
 */
export const CMsgClientFSGetFriendsSteamLevels = new CMsgClientFSGetFriendsSteamLevels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFSGetFriendsSteamLevelsResponse$Type extends MessageType<CMsgClientFSGetFriendsSteamLevelsResponse> {
    constructor() {
        super("CMsgClientFSGetFriendsSteamLevelsResponse", [
            { no: 1, name: "friends", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientFSGetFriendsSteamLevelsResponse_Friend }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFSGetFriendsSteamLevelsResponse>): CMsgClientFSGetFriendsSteamLevelsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.friends = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFSGetFriendsSteamLevelsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFSGetFriendsSteamLevelsResponse): CMsgClientFSGetFriendsSteamLevelsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientFSGetFriendsSteamLevelsResponse_Friend friends */ 1:
                    message.friends.push(CMsgClientFSGetFriendsSteamLevelsResponse_Friend.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFSGetFriendsSteamLevelsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientFSGetFriendsSteamLevelsResponse_Friend friends = 1; */
        for (let i = 0; i < message.friends.length; i++)
            CMsgClientFSGetFriendsSteamLevelsResponse_Friend.internalBinaryWrite(message.friends[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFSGetFriendsSteamLevelsResponse
 */
export const CMsgClientFSGetFriendsSteamLevelsResponse = new CMsgClientFSGetFriendsSteamLevelsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientFSGetFriendsSteamLevelsResponse_Friend$Type extends MessageType<CMsgClientFSGetFriendsSteamLevelsResponse_Friend> {
    constructor() {
        super("CMsgClientFSGetFriendsSteamLevelsResponse_Friend", [
            { no: 1, name: "accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientFSGetFriendsSteamLevelsResponse_Friend>): CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientFSGetFriendsSteamLevelsResponse_Friend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientFSGetFriendsSteamLevelsResponse_Friend): CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 accountid */ 1:
                    message.accountid = reader.uint32();
                    break;
                case /* optional uint32 level */ 2:
                    message.level = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientFSGetFriendsSteamLevelsResponse_Friend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 accountid = 1; */
        if (message.accountid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.accountid);
        /* optional uint32 level = 2; */
        if (message.level !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientFSGetFriendsSteamLevelsResponse_Friend
 */
export const CMsgClientFSGetFriendsSteamLevelsResponse_Friend = new CMsgClientFSGetFriendsSteamLevelsResponse_Friend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGameConnectTokens$Type extends MessageType<CMsgClientGameConnectTokens> {
    constructor() {
        super("CMsgClientGameConnectTokens", [
            { no: 1, name: "max_tokens_to_keep", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "tokens", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGameConnectTokens>): CMsgClientGameConnectTokens {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tokens = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGameConnectTokens>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGameConnectTokens): CMsgClientGameConnectTokens {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 max_tokens_to_keep = 1 [default = 10] */ 1:
                    message.maxTokensToKeep = reader.uint32();
                    break;
                case /* repeated bytes tokens */ 2:
                    message.tokens.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGameConnectTokens, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 max_tokens_to_keep = 1 [default = 10]; */
        if (message.maxTokensToKeep !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.maxTokensToKeep);
        /* repeated bytes tokens = 2; */
        for (let i = 0; i < message.tokens.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.tokens[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGameConnectTokens
 */
export const CMsgClientGameConnectTokens = new CMsgClientGameConnectTokens$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGamesPlayed$Type extends MessageType<CMsgClientGamesPlayed> {
    constructor() {
        super("CMsgClientGamesPlayed", [
            { no: 1, name: "games_played", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientGamesPlayed_GamePlayed },
            { no: 2, name: "client_os_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cloud_gaming_platform", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGamesPlayed>): CMsgClientGamesPlayed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gamesPlayed = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGamesPlayed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGamesPlayed): CMsgClientGamesPlayed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientGamesPlayed_GamePlayed games_played */ 1:
                    message.gamesPlayed.push(CMsgClientGamesPlayed_GamePlayed.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 client_os_type */ 2:
                    message.clientOsType = reader.uint32();
                    break;
                case /* optional uint32 cloud_gaming_platform */ 3:
                    message.cloudGamingPlatform = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGamesPlayed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientGamesPlayed_GamePlayed games_played = 1; */
        for (let i = 0; i < message.gamesPlayed.length; i++)
            CMsgClientGamesPlayed_GamePlayed.internalBinaryWrite(message.gamesPlayed[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 client_os_type = 2; */
        if (message.clientOsType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.clientOsType);
        /* optional uint32 cloud_gaming_platform = 3; */
        if (message.cloudGamingPlatform !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.cloudGamingPlatform);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGamesPlayed
 */
export const CMsgClientGamesPlayed = new CMsgClientGamesPlayed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGamesPlayed_GamePlayed$Type extends MessageType<CMsgClientGamesPlayed_GamePlayed> {
    constructor() {
        super("CMsgClientGamesPlayed_GamePlayed", [
            { no: 1, name: "steam_id_gs", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "deprecated_game_ip_address", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "game_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_secure", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "game_extra_info", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "game_data_blob", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "process_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "streaming_provider_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "game_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "owner_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "vr_hmd_vendor", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "vr_hmd_model", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "launch_option_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "primary_controller_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "primary_steam_controller_serial", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "total_steam_controller_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "total_non_steam_controller_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "controller_workshop_file_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "launch_source", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "vr_hmd_runtime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "game_ip_address", kind: "message", T: () => CMsgIPAddress },
            { no: 24, name: "controller_connection_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGamesPlayed_GamePlayed>): CMsgClientGamesPlayed_GamePlayed {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGamesPlayed_GamePlayed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGamesPlayed_GamePlayed): CMsgClientGamesPlayed_GamePlayed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 steam_id_gs */ 1:
                    message.steamIdGs = reader.uint64().toBigInt();
                    break;
                case /* optional fixed64 game_id */ 2:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 deprecated_game_ip_address */ 3:
                    message.deprecatedGameIpAddress = reader.uint32();
                    break;
                case /* optional uint32 game_port */ 4:
                    message.gamePort = reader.uint32();
                    break;
                case /* optional bool is_secure */ 5:
                    message.isSecure = reader.bool();
                    break;
                case /* optional bytes token */ 6:
                    message.token = reader.bytes();
                    break;
                case /* optional string game_extra_info */ 7:
                    message.gameExtraInfo = reader.string();
                    break;
                case /* optional bytes game_data_blob */ 8:
                    message.gameDataBlob = reader.bytes();
                    break;
                case /* optional uint32 process_id */ 9:
                    message.processId = reader.uint32();
                    break;
                case /* optional uint32 streaming_provider_id */ 10:
                    message.streamingProviderId = reader.uint32();
                    break;
                case /* optional uint32 game_flags */ 11:
                    message.gameFlags = reader.uint32();
                    break;
                case /* optional uint32 owner_id */ 12:
                    message.ownerId = reader.uint32();
                    break;
                case /* optional string vr_hmd_vendor */ 13:
                    message.vrHmdVendor = reader.string();
                    break;
                case /* optional string vr_hmd_model */ 14:
                    message.vrHmdModel = reader.string();
                    break;
                case /* optional uint32 launch_option_type = 15 [default = 0] */ 15:
                    message.launchOptionType = reader.uint32();
                    break;
                case /* optional int32 primary_controller_type = 16 [default = -1] */ 16:
                    message.primaryControllerType = reader.int32();
                    break;
                case /* optional string primary_steam_controller_serial = 17 [default = ""] */ 17:
                    message.primarySteamControllerSerial = reader.string();
                    break;
                case /* optional uint32 total_steam_controller_count = 18 [default = 0] */ 18:
                    message.totalSteamControllerCount = reader.uint32();
                    break;
                case /* optional uint32 total_non_steam_controller_count = 19 [default = 0] */ 19:
                    message.totalNonSteamControllerCount = reader.uint32();
                    break;
                case /* optional uint64 controller_workshop_file_id = 20 [default = 0] */ 20:
                    message.controllerWorkshopFileId = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 launch_source = 21 [default = 0] */ 21:
                    message.launchSource = reader.uint32();
                    break;
                case /* optional uint32 vr_hmd_runtime */ 22:
                    message.vrHmdRuntime = reader.uint32();
                    break;
                case /* optional CMsgIPAddress game_ip_address */ 23:
                    message.gameIpAddress = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.gameIpAddress);
                    break;
                case /* optional uint32 controller_connection_type = 24 [default = 0] */ 24:
                    message.controllerConnectionType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGamesPlayed_GamePlayed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 steam_id_gs = 1; */
        if (message.steamIdGs !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.steamIdGs);
        /* optional fixed64 game_id = 2; */
        if (message.gameId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.gameId);
        /* optional uint32 deprecated_game_ip_address = 3; */
        if (message.deprecatedGameIpAddress !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.deprecatedGameIpAddress);
        /* optional uint32 game_port = 4; */
        if (message.gamePort !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.gamePort);
        /* optional bool is_secure = 5; */
        if (message.isSecure !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isSecure);
        /* optional bytes token = 6; */
        if (message.token !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.token);
        /* optional string game_extra_info = 7; */
        if (message.gameExtraInfo !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.gameExtraInfo);
        /* optional bytes game_data_blob = 8; */
        if (message.gameDataBlob !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.gameDataBlob);
        /* optional uint32 process_id = 9; */
        if (message.processId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.processId);
        /* optional uint32 streaming_provider_id = 10; */
        if (message.streamingProviderId !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.streamingProviderId);
        /* optional uint32 game_flags = 11; */
        if (message.gameFlags !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.gameFlags);
        /* optional uint32 owner_id = 12; */
        if (message.ownerId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.ownerId);
        /* optional string vr_hmd_vendor = 13; */
        if (message.vrHmdVendor !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.vrHmdVendor);
        /* optional string vr_hmd_model = 14; */
        if (message.vrHmdModel !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.vrHmdModel);
        /* optional uint32 launch_option_type = 15 [default = 0]; */
        if (message.launchOptionType !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.launchOptionType);
        /* optional int32 primary_controller_type = 16 [default = -1]; */
        if (message.primaryControllerType !== undefined)
            writer.tag(16, WireType.Varint).int32(message.primaryControllerType);
        /* optional string primary_steam_controller_serial = 17 [default = ""]; */
        if (message.primarySteamControllerSerial !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.primarySteamControllerSerial);
        /* optional uint32 total_steam_controller_count = 18 [default = 0]; */
        if (message.totalSteamControllerCount !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.totalSteamControllerCount);
        /* optional uint32 total_non_steam_controller_count = 19 [default = 0]; */
        if (message.totalNonSteamControllerCount !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.totalNonSteamControllerCount);
        /* optional uint64 controller_workshop_file_id = 20 [default = 0]; */
        if (message.controllerWorkshopFileId !== undefined)
            writer.tag(20, WireType.Varint).uint64(message.controllerWorkshopFileId);
        /* optional uint32 launch_source = 21 [default = 0]; */
        if (message.launchSource !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.launchSource);
        /* optional uint32 vr_hmd_runtime = 22; */
        if (message.vrHmdRuntime !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.vrHmdRuntime);
        /* optional CMsgIPAddress game_ip_address = 23; */
        if (message.gameIpAddress)
            CMsgIPAddress.internalBinaryWrite(message.gameIpAddress, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 controller_connection_type = 24 [default = 0]; */
        if (message.controllerConnectionType !== undefined)
            writer.tag(24, WireType.Varint).uint32(message.controllerConnectionType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGamesPlayed_GamePlayed
 */
export const CMsgClientGamesPlayed_GamePlayed = new CMsgClientGamesPlayed_GamePlayed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetAppOwnershipTicket$Type extends MessageType<CMsgClientGetAppOwnershipTicket> {
    constructor() {
        super("CMsgClientGetAppOwnershipTicket", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetAppOwnershipTicket>): CMsgClientGetAppOwnershipTicket {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetAppOwnershipTicket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetAppOwnershipTicket): CMsgClientGetAppOwnershipTicket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetAppOwnershipTicket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetAppOwnershipTicket
 */
export const CMsgClientGetAppOwnershipTicket = new CMsgClientGetAppOwnershipTicket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetAppOwnershipTicketResponse$Type extends MessageType<CMsgClientGetAppOwnershipTicketResponse> {
    constructor() {
        super("CMsgClientGetAppOwnershipTicketResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "ticket", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetAppOwnershipTicketResponse>): CMsgClientGetAppOwnershipTicketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetAppOwnershipTicketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetAppOwnershipTicketResponse): CMsgClientGetAppOwnershipTicketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.uint32();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional bytes ticket */ 3:
                    message.ticket = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetAppOwnershipTicketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional bytes ticket = 3; */
        if (message.ticket !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.ticket);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetAppOwnershipTicketResponse
 */
export const CMsgClientGetAppOwnershipTicketResponse = new CMsgClientGetAppOwnershipTicketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetAuthorizedDevices$Type extends MessageType<CMsgClientGetAuthorizedDevices> {
    constructor() {
        super("CMsgClientGetAuthorizedDevices", []);
    }
    create(value?: PartialMessage<CMsgClientGetAuthorizedDevices>): CMsgClientGetAuthorizedDevices {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetAuthorizedDevices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetAuthorizedDevices): CMsgClientGetAuthorizedDevices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetAuthorizedDevices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetAuthorizedDevices
 */
export const CMsgClientGetAuthorizedDevices = new CMsgClientGetAuthorizedDevices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetAuthorizedDevicesResponse$Type extends MessageType<CMsgClientGetAuthorizedDevicesResponse> {
    constructor() {
        super("CMsgClientGetAuthorizedDevicesResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "authorized_device", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetAuthorizedDevicesResponse>): CMsgClientGetAuthorizedDevicesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorizedDevice = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetAuthorizedDevicesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetAuthorizedDevicesResponse): CMsgClientGetAuthorizedDevicesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice authorized_device */ 2:
                    message.authorizedDevice.push(CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetAuthorizedDevicesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* repeated CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice authorized_device = 2; */
        for (let i = 0; i < message.authorizedDevice.length; i++)
            CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice.internalBinaryWrite(message.authorizedDevice[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetAuthorizedDevicesResponse
 */
export const CMsgClientGetAuthorizedDevicesResponse = new CMsgClientGetAuthorizedDevicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice$Type extends MessageType<CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice> {
    constructor() {
        super("CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice", [
            { no: 1, name: "auth_device_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "device_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_access_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "borrower_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_pending", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "app_played", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice>): CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice): CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 auth_device_token */ 1:
                    message.authDeviceToken = reader.uint64().toBigInt();
                    break;
                case /* optional string device_name */ 2:
                    message.deviceName = reader.string();
                    break;
                case /* optional uint32 last_access_time */ 3:
                    message.lastAccessTime = reader.uint32();
                    break;
                case /* optional uint32 borrower_id */ 4:
                    message.borrowerId = reader.uint32();
                    break;
                case /* optional bool is_pending */ 5:
                    message.isPending = reader.bool();
                    break;
                case /* optional uint32 app_played */ 6:
                    message.appPlayed = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 auth_device_token = 1; */
        if (message.authDeviceToken !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.authDeviceToken);
        /* optional string device_name = 2; */
        if (message.deviceName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.deviceName);
        /* optional uint32 last_access_time = 3; */
        if (message.lastAccessTime !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.lastAccessTime);
        /* optional uint32 borrower_id = 4; */
        if (message.borrowerId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.borrowerId);
        /* optional bool is_pending = 5; */
        if (message.isPending !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isPending);
        /* optional uint32 app_played = 6; */
        if (message.appPlayed !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.appPlayed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice
 */
export const CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice = new CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetCDNAuthToken$Type extends MessageType<CMsgClientGetCDNAuthToken> {
    constructor() {
        super("CMsgClientGetCDNAuthToken", [
            { no: 1, name: "depot_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "host_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetCDNAuthToken>): CMsgClientGetCDNAuthToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetCDNAuthToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetCDNAuthToken): CMsgClientGetCDNAuthToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 depot_id */ 1:
                    message.depotId = reader.uint32();
                    break;
                case /* optional string host_name */ 2:
                    message.hostName = reader.string();
                    break;
                case /* optional uint32 app_id */ 3:
                    message.appId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetCDNAuthToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 depot_id = 1; */
        if (message.depotId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.depotId);
        /* optional string host_name = 2; */
        if (message.hostName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.hostName);
        /* optional uint32 app_id = 3; */
        if (message.appId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.appId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetCDNAuthToken
 */
export const CMsgClientGetCDNAuthToken = new CMsgClientGetCDNAuthToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetCDNAuthTokenResponse$Type extends MessageType<CMsgClientGetCDNAuthTokenResponse> {
    constructor() {
        super("CMsgClientGetCDNAuthTokenResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expiration_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetCDNAuthTokenResponse>): CMsgClientGetCDNAuthTokenResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetCDNAuthTokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetCDNAuthTokenResponse): CMsgClientGetCDNAuthTokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.uint32();
                    break;
                case /* optional string token */ 2:
                    message.token = reader.string();
                    break;
                case /* optional uint32 expiration_time */ 3:
                    message.expirationTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetCDNAuthTokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        /* optional string token = 2; */
        if (message.token !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        /* optional uint32 expiration_time = 3; */
        if (message.expirationTime !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.expirationTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetCDNAuthTokenResponse
 */
export const CMsgClientGetCDNAuthTokenResponse = new CMsgClientGetCDNAuthTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetClanActivityCounts$Type extends MessageType<CMsgClientGetClanActivityCounts> {
    constructor() {
        super("CMsgClientGetClanActivityCounts", [
            { no: 1, name: "steamid_clans", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetClanActivityCounts>): CMsgClientGetClanActivityCounts {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamidClans = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetClanActivityCounts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetClanActivityCounts): CMsgClientGetClanActivityCounts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 steamid_clans */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamidClans.push(reader.uint64().toBigInt());
                    else
                        message.steamidClans.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetClanActivityCounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 steamid_clans = 1; */
        for (let i = 0; i < message.steamidClans.length; i++)
            writer.tag(1, WireType.Varint).uint64(message.steamidClans[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetClanActivityCounts
 */
export const CMsgClientGetClanActivityCounts = new CMsgClientGetClanActivityCounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetClanActivityCountsResponse$Type extends MessageType<CMsgClientGetClanActivityCountsResponse> {
    constructor() {
        super("CMsgClientGetClanActivityCountsResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetClanActivityCountsResponse>): CMsgClientGetClanActivityCountsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetClanActivityCountsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetClanActivityCountsResponse): CMsgClientGetClanActivityCountsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetClanActivityCountsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetClanActivityCountsResponse
 */
export const CMsgClientGetClanActivityCountsResponse = new CMsgClientGetClanActivityCountsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetClientAppList$Type extends MessageType<CMsgClientGetClientAppList> {
    constructor() {
        super("CMsgClientGetClientAppList", [
            { no: 1, name: "media", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "tools", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "games", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "only_installed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "only_changing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "comics", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetClientAppList>): CMsgClientGetClientAppList {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetClientAppList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetClientAppList): CMsgClientGetClientAppList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool media */ 1:
                    message.media = reader.bool();
                    break;
                case /* optional bool tools */ 2:
                    message.tools = reader.bool();
                    break;
                case /* optional bool games */ 3:
                    message.games = reader.bool();
                    break;
                case /* optional bool only_installed */ 4:
                    message.onlyInstalled = reader.bool();
                    break;
                case /* optional bool only_changing */ 5:
                    message.onlyChanging = reader.bool();
                    break;
                case /* optional bool comics */ 6:
                    message.comics = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetClientAppList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool media = 1; */
        if (message.media !== undefined)
            writer.tag(1, WireType.Varint).bool(message.media);
        /* optional bool tools = 2; */
        if (message.tools !== undefined)
            writer.tag(2, WireType.Varint).bool(message.tools);
        /* optional bool games = 3; */
        if (message.games !== undefined)
            writer.tag(3, WireType.Varint).bool(message.games);
        /* optional bool only_installed = 4; */
        if (message.onlyInstalled !== undefined)
            writer.tag(4, WireType.Varint).bool(message.onlyInstalled);
        /* optional bool only_changing = 5; */
        if (message.onlyChanging !== undefined)
            writer.tag(5, WireType.Varint).bool(message.onlyChanging);
        /* optional bool comics = 6; */
        if (message.comics !== undefined)
            writer.tag(6, WireType.Varint).bool(message.comics);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetClientAppList
 */
export const CMsgClientGetClientAppList = new CMsgClientGetClientAppList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetClientAppListResponse$Type extends MessageType<CMsgClientGetClientAppListResponse> {
    constructor() {
        super("CMsgClientGetClientAppListResponse", [
            { no: 1, name: "apps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientGetClientAppListResponse_App },
            { no: 2, name: "bytes_available", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetClientAppListResponse>): CMsgClientGetClientAppListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apps = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetClientAppListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetClientAppListResponse): CMsgClientGetClientAppListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientGetClientAppListResponse_App apps */ 1:
                    message.apps.push(CMsgClientGetClientAppListResponse_App.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 bytes_available */ 2:
                    message.bytesAvailable = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetClientAppListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientGetClientAppListResponse_App apps = 1; */
        for (let i = 0; i < message.apps.length; i++)
            CMsgClientGetClientAppListResponse_App.internalBinaryWrite(message.apps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 bytes_available = 2; */
        if (message.bytesAvailable !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.bytesAvailable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetClientAppListResponse
 */
export const CMsgClientGetClientAppListResponse = new CMsgClientGetClientAppListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetClientAppListResponse_App$Type extends MessageType<CMsgClientGetClientAppListResponse_App> {
    constructor() {
        super("CMsgClientGetClientAppListResponse_App", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "category", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "favorite", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "installed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "auto_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "bytes_downloaded", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "bytes_needed", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "bytes_download_rate", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "dlcs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientGetClientAppListResponse_App_DLC },
            { no: 10, name: "app_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "download_paused", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "num_downloading", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "num_paused", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "changing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "available_on_platform", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetClientAppListResponse_App>): CMsgClientGetClientAppListResponse_App {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dlcs = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetClientAppListResponse_App>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetClientAppListResponse_App): CMsgClientGetClientAppListResponse_App {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional string category */ 2:
                    message.category = reader.string();
                    break;
                case /* optional bool favorite */ 3:
                    message.favorite = reader.bool();
                    break;
                case /* optional bool installed */ 4:
                    message.installed = reader.bool();
                    break;
                case /* optional bool auto_update */ 5:
                    message.autoUpdate = reader.bool();
                    break;
                case /* optional uint64 bytes_downloaded */ 6:
                    message.bytesDownloaded = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes_needed */ 7:
                    message.bytesNeeded = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 bytes_download_rate */ 8:
                    message.bytesDownloadRate = reader.uint32();
                    break;
                case /* repeated CMsgClientGetClientAppListResponse_App_DLC dlcs */ 9:
                    message.dlcs.push(CMsgClientGetClientAppListResponse_App_DLC.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string app_type */ 10:
                    message.appType = reader.string();
                    break;
                case /* optional bool download_paused */ 11:
                    message.downloadPaused = reader.bool();
                    break;
                case /* optional uint32 num_downloading */ 12:
                    message.numDownloading = reader.uint32();
                    break;
                case /* optional uint32 num_paused */ 13:
                    message.numPaused = reader.uint32();
                    break;
                case /* optional bool changing */ 14:
                    message.changing = reader.bool();
                    break;
                case /* optional bool available_on_platform */ 15:
                    message.availableOnPlatform = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetClientAppListResponse_App, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional string category = 2; */
        if (message.category !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.category);
        /* optional bool favorite = 3; */
        if (message.favorite !== undefined)
            writer.tag(3, WireType.Varint).bool(message.favorite);
        /* optional bool installed = 4; */
        if (message.installed !== undefined)
            writer.tag(4, WireType.Varint).bool(message.installed);
        /* optional bool auto_update = 5; */
        if (message.autoUpdate !== undefined)
            writer.tag(5, WireType.Varint).bool(message.autoUpdate);
        /* optional uint64 bytes_downloaded = 6; */
        if (message.bytesDownloaded !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.bytesDownloaded);
        /* optional uint64 bytes_needed = 7; */
        if (message.bytesNeeded !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.bytesNeeded);
        /* optional uint32 bytes_download_rate = 8; */
        if (message.bytesDownloadRate !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.bytesDownloadRate);
        /* repeated CMsgClientGetClientAppListResponse_App_DLC dlcs = 9; */
        for (let i = 0; i < message.dlcs.length; i++)
            CMsgClientGetClientAppListResponse_App_DLC.internalBinaryWrite(message.dlcs[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional string app_type = 10; */
        if (message.appType !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.appType);
        /* optional bool download_paused = 11; */
        if (message.downloadPaused !== undefined)
            writer.tag(11, WireType.Varint).bool(message.downloadPaused);
        /* optional uint32 num_downloading = 12; */
        if (message.numDownloading !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.numDownloading);
        /* optional uint32 num_paused = 13; */
        if (message.numPaused !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.numPaused);
        /* optional bool changing = 14; */
        if (message.changing !== undefined)
            writer.tag(14, WireType.Varint).bool(message.changing);
        /* optional bool available_on_platform = 15; */
        if (message.availableOnPlatform !== undefined)
            writer.tag(15, WireType.Varint).bool(message.availableOnPlatform);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetClientAppListResponse_App
 */
export const CMsgClientGetClientAppListResponse_App = new CMsgClientGetClientAppListResponse_App$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetClientAppListResponse_App_DLC$Type extends MessageType<CMsgClientGetClientAppListResponse_App_DLC> {
    constructor() {
        super("CMsgClientGetClientAppListResponse_App_DLC", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "installed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetClientAppListResponse_App_DLC>): CMsgClientGetClientAppListResponse_App_DLC {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetClientAppListResponse_App_DLC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetClientAppListResponse_App_DLC): CMsgClientGetClientAppListResponse_App_DLC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional bool installed */ 2:
                    message.installed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetClientAppListResponse_App_DLC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional bool installed = 2; */
        if (message.installed !== undefined)
            writer.tag(2, WireType.Varint).bool(message.installed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetClientAppListResponse_App_DLC
 */
export const CMsgClientGetClientAppListResponse_App_DLC = new CMsgClientGetClientAppListResponse_App_DLC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetClientDetails$Type extends MessageType<CMsgClientGetClientDetails> {
    constructor() {
        super("CMsgClientGetClientDetails", []);
    }
    create(value?: PartialMessage<CMsgClientGetClientDetails>): CMsgClientGetClientDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetClientDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetClientDetails): CMsgClientGetClientDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetClientDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetClientDetails
 */
export const CMsgClientGetClientDetails = new CMsgClientGetClientDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetClientDetailsResponse$Type extends MessageType<CMsgClientGetClientDetailsResponse> {
    constructor() {
        super("CMsgClientGetClientDetailsResponse", [
            { no: 1, name: "package_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "os", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "machine_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ip_public", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "ip_private", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "games_running", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientGetClientDetailsResponse_Game },
            { no: 7, name: "bytes_available", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "protocol_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetClientDetailsResponse>): CMsgClientGetClientDetailsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gamesRunning = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetClientDetailsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetClientDetailsResponse): CMsgClientGetClientDetailsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 package_version */ 1:
                    message.packageVersion = reader.uint32();
                    break;
                case /* optional string os */ 2:
                    message.os = reader.string();
                    break;
                case /* optional string machine_name */ 3:
                    message.machineName = reader.string();
                    break;
                case /* optional string ip_public */ 4:
                    message.ipPublic = reader.string();
                    break;
                case /* optional string ip_private */ 5:
                    message.ipPrivate = reader.string();
                    break;
                case /* repeated CMsgClientGetClientDetailsResponse_Game games_running */ 6:
                    message.gamesRunning.push(CMsgClientGetClientDetailsResponse_Game.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 bytes_available */ 7:
                    message.bytesAvailable = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 protocol_version */ 8:
                    message.protocolVersion = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetClientDetailsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 package_version = 1; */
        if (message.packageVersion !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageVersion);
        /* optional string os = 2; */
        if (message.os !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.os);
        /* optional string machine_name = 3; */
        if (message.machineName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.machineName);
        /* optional string ip_public = 4; */
        if (message.ipPublic !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.ipPublic);
        /* optional string ip_private = 5; */
        if (message.ipPrivate !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.ipPrivate);
        /* repeated CMsgClientGetClientDetailsResponse_Game games_running = 6; */
        for (let i = 0; i < message.gamesRunning.length; i++)
            CMsgClientGetClientDetailsResponse_Game.internalBinaryWrite(message.gamesRunning[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 bytes_available = 7; */
        if (message.bytesAvailable !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.bytesAvailable);
        /* optional uint32 protocol_version = 8; */
        if (message.protocolVersion !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.protocolVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetClientDetailsResponse
 */
export const CMsgClientGetClientDetailsResponse = new CMsgClientGetClientDetailsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetClientDetailsResponse_Game$Type extends MessageType<CMsgClientGetClientDetailsResponse_Game> {
    constructor() {
        super("CMsgClientGetClientDetailsResponse_Game", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "extra_info", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "time_running_sec", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetClientDetailsResponse_Game>): CMsgClientGetClientDetailsResponse_Game {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetClientDetailsResponse_Game>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetClientDetailsResponse_Game): CMsgClientGetClientDetailsResponse_Game {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional string extra_info */ 2:
                    message.extraInfo = reader.string();
                    break;
                case /* optional uint32 time_running_sec */ 3:
                    message.timeRunningSec = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetClientDetailsResponse_Game, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional string extra_info = 2; */
        if (message.extraInfo !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.extraInfo);
        /* optional uint32 time_running_sec = 3; */
        if (message.timeRunningSec !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.timeRunningSec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetClientDetailsResponse_Game
 */
export const CMsgClientGetClientDetailsResponse_Game = new CMsgClientGetClientDetailsResponse_Game$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetDepotDecryptionKey$Type extends MessageType<CMsgClientGetDepotDecryptionKey> {
    constructor() {
        super("CMsgClientGetDepotDecryptionKey", [
            { no: 1, name: "depot_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetDepotDecryptionKey>): CMsgClientGetDepotDecryptionKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetDepotDecryptionKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetDepotDecryptionKey): CMsgClientGetDepotDecryptionKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 depot_id */ 1:
                    message.depotId = reader.uint32();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetDepotDecryptionKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 depot_id = 1; */
        if (message.depotId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.depotId);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetDepotDecryptionKey
 */
export const CMsgClientGetDepotDecryptionKey = new CMsgClientGetDepotDecryptionKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetDepotDecryptionKeyResponse$Type extends MessageType<CMsgClientGetDepotDecryptionKeyResponse> {
    constructor() {
        super("CMsgClientGetDepotDecryptionKeyResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "depot_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "depot_encryption_key", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetDepotDecryptionKeyResponse>): CMsgClientGetDepotDecryptionKeyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetDepotDecryptionKeyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetDepotDecryptionKeyResponse): CMsgClientGetDepotDecryptionKeyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 depot_id */ 2:
                    message.depotId = reader.uint32();
                    break;
                case /* optional bytes depot_encryption_key */ 3:
                    message.depotEncryptionKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetDepotDecryptionKeyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional uint32 depot_id = 2; */
        if (message.depotId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.depotId);
        /* optional bytes depot_encryption_key = 3; */
        if (message.depotEncryptionKey !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.depotEncryptionKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetDepotDecryptionKeyResponse
 */
export const CMsgClientGetDepotDecryptionKeyResponse = new CMsgClientGetDepotDecryptionKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetEmoticonList$Type extends MessageType<CMsgClientGetEmoticonList> {
    constructor() {
        super("CMsgClientGetEmoticonList", []);
    }
    create(value?: PartialMessage<CMsgClientGetEmoticonList>): CMsgClientGetEmoticonList {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetEmoticonList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetEmoticonList): CMsgClientGetEmoticonList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetEmoticonList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetEmoticonList
 */
export const CMsgClientGetEmoticonList = new CMsgClientGetEmoticonList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetUserStats$Type extends MessageType<CMsgClientGetUserStats> {
    constructor() {
        super("CMsgClientGetUserStats", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "crc_stats", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "schema_local_version", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "steam_id_for_user", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetUserStats>): CMsgClientGetUserStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetUserStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetUserStats): CMsgClientGetUserStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 game_id */ 1:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 crc_stats */ 2:
                    message.crcStats = reader.uint32();
                    break;
                case /* optional int32 schema_local_version */ 3:
                    message.schemaLocalVersion = reader.int32();
                    break;
                case /* optional fixed64 steam_id_for_user */ 4:
                    message.steamIdForUser = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetUserStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameId);
        /* optional uint32 crc_stats = 2; */
        if (message.crcStats !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.crcStats);
        /* optional int32 schema_local_version = 3; */
        if (message.schemaLocalVersion !== undefined)
            writer.tag(3, WireType.Varint).int32(message.schemaLocalVersion);
        /* optional fixed64 steam_id_for_user = 4; */
        if (message.steamIdForUser !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.steamIdForUser);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetUserStats
 */
export const CMsgClientGetUserStats = new CMsgClientGetUserStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetUserStatsResponse$Type extends MessageType<CMsgClientGetUserStatsResponse> {
    constructor() {
        super("CMsgClientGetUserStatsResponse", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "crc_stats", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "schema", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "stats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientGetUserStatsResponse_Stats },
            { no: 6, name: "achievement_blocks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientGetUserStatsResponse_Achievement_Blocks }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetUserStatsResponse>): CMsgClientGetUserStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stats = [];
        message.achievementBlocks = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetUserStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetUserStatsResponse): CMsgClientGetUserStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 game_id */ 1:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 eresult = 2 [default = 2] */ 2:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 crc_stats */ 3:
                    message.crcStats = reader.uint32();
                    break;
                case /* optional bytes schema */ 4:
                    message.schema = reader.bytes();
                    break;
                case /* repeated CMsgClientGetUserStatsResponse_Stats stats */ 5:
                    message.stats.push(CMsgClientGetUserStatsResponse_Stats.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgClientGetUserStatsResponse_Achievement_Blocks achievement_blocks */ 6:
                    message.achievementBlocks.push(CMsgClientGetUserStatsResponse_Achievement_Blocks.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetUserStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameId);
        /* optional int32 eresult = 2 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).int32(message.eresult);
        /* optional uint32 crc_stats = 3; */
        if (message.crcStats !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.crcStats);
        /* optional bytes schema = 4; */
        if (message.schema !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.schema);
        /* repeated CMsgClientGetUserStatsResponse_Stats stats = 5; */
        for (let i = 0; i < message.stats.length; i++)
            CMsgClientGetUserStatsResponse_Stats.internalBinaryWrite(message.stats[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgClientGetUserStatsResponse_Achievement_Blocks achievement_blocks = 6; */
        for (let i = 0; i < message.achievementBlocks.length; i++)
            CMsgClientGetUserStatsResponse_Achievement_Blocks.internalBinaryWrite(message.achievementBlocks[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetUserStatsResponse
 */
export const CMsgClientGetUserStatsResponse = new CMsgClientGetUserStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetUserStatsResponse_Achievement_Blocks$Type extends MessageType<CMsgClientGetUserStatsResponse_Achievement_Blocks> {
    constructor() {
        super("CMsgClientGetUserStatsResponse_Achievement_Blocks", [
            { no: 1, name: "achievement_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "unlock_time", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetUserStatsResponse_Achievement_Blocks>): CMsgClientGetUserStatsResponse_Achievement_Blocks {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unlockTime = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetUserStatsResponse_Achievement_Blocks>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetUserStatsResponse_Achievement_Blocks): CMsgClientGetUserStatsResponse_Achievement_Blocks {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 achievement_id */ 1:
                    message.achievementId = reader.uint32();
                    break;
                case /* repeated fixed32 unlock_time */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockTime.push(reader.fixed32());
                    else
                        message.unlockTime.push(reader.fixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetUserStatsResponse_Achievement_Blocks, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 achievement_id = 1; */
        if (message.achievementId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.achievementId);
        /* repeated fixed32 unlock_time = 2; */
        for (let i = 0; i < message.unlockTime.length; i++)
            writer.tag(2, WireType.Bit32).fixed32(message.unlockTime[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetUserStatsResponse_Achievement_Blocks
 */
export const CMsgClientGetUserStatsResponse_Achievement_Blocks = new CMsgClientGetUserStatsResponse_Achievement_Blocks$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGetUserStatsResponse_Stats$Type extends MessageType<CMsgClientGetUserStatsResponse_Stats> {
    constructor() {
        super("CMsgClientGetUserStatsResponse_Stats", [
            { no: 1, name: "stat_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stat_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGetUserStatsResponse_Stats>): CMsgClientGetUserStatsResponse_Stats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGetUserStatsResponse_Stats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGetUserStatsResponse_Stats): CMsgClientGetUserStatsResponse_Stats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 stat_id */ 1:
                    message.statId = reader.uint32();
                    break;
                case /* optional uint32 stat_value */ 2:
                    message.statValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGetUserStatsResponse_Stats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 stat_id = 1; */
        if (message.statId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.statId);
        /* optional uint32 stat_value = 2; */
        if (message.statValue !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.statValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGetUserStatsResponse_Stats
 */
export const CMsgClientGetUserStatsResponse_Stats = new CMsgClientGetUserStatsResponse_Stats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientGMSServerQuery$Type extends MessageType<CMsgClientGMSServerQuery> {
    constructor() {
        super("CMsgClientGMSServerQuery", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "geo_location_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "region_code", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "filter_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "max_servers", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientGMSServerQuery>): CMsgClientGMSServerQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientGMSServerQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientGMSServerQuery): CMsgClientGMSServerQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 geo_location_ip */ 2:
                    message.geoLocationIp = reader.uint32();
                    break;
                case /* optional uint32 region_code */ 3:
                    message.regionCode = reader.uint32();
                    break;
                case /* optional string filter_text */ 4:
                    message.filterText = reader.string();
                    break;
                case /* optional uint32 max_servers */ 5:
                    message.maxServers = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientGMSServerQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 geo_location_ip = 2; */
        if (message.geoLocationIp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.geoLocationIp);
        /* optional uint32 region_code = 3; */
        if (message.regionCode !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.regionCode);
        /* optional string filter_text = 4; */
        if (message.filterText !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.filterText);
        /* optional uint32 max_servers = 5; */
        if (message.maxServers !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.maxServers);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientGMSServerQuery
 */
export const CMsgClientGMSServerQuery = new CMsgClientGMSServerQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientHeartBeat$Type extends MessageType<CMsgClientHeartBeat> {
    constructor() {
        super("CMsgClientHeartBeat", [
            { no: 1, name: "send_reply", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientHeartBeat>): CMsgClientHeartBeat {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientHeartBeat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientHeartBeat): CMsgClientHeartBeat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool send_reply */ 1:
                    message.sendReply = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientHeartBeat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool send_reply = 1; */
        if (message.sendReply !== undefined)
            writer.tag(1, WireType.Varint).bool(message.sendReply);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientHeartBeat
 */
export const CMsgClientHeartBeat = new CMsgClientHeartBeat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientHideFriend$Type extends MessageType<CMsgClientHideFriend> {
    constructor() {
        super("CMsgClientHideFriend", [
            { no: 1, name: "friendid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "hide", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientHideFriend>): CMsgClientHideFriend {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientHideFriend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientHideFriend): CMsgClientHideFriend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 friendid */ 1:
                    message.friendid = reader.fixed64().toBigInt();
                    break;
                case /* optional bool hide */ 2:
                    message.hide = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientHideFriend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 friendid = 1; */
        if (message.friendid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.friendid);
        /* optional bool hide = 2; */
        if (message.hide !== undefined)
            writer.tag(2, WireType.Varint).bool(message.hide);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientHideFriend
 */
export const CMsgClientHideFriend = new CMsgClientHideFriend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientInstallClientApp$Type extends MessageType<CMsgClientInstallClientApp> {
    constructor() {
        super("CMsgClientInstallClientApp", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientInstallClientApp>): CMsgClientInstallClientApp {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientInstallClientApp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientInstallClientApp): CMsgClientInstallClientApp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientInstallClientApp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientInstallClientApp
 */
export const CMsgClientInstallClientApp = new CMsgClientInstallClientApp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientInstallClientAppResponse$Type extends MessageType<CMsgClientInstallClientAppResponse> {
    constructor() {
        super("CMsgClientInstallClientAppResponse", [
            { no: 1, name: "result", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientInstallClientAppResponse>): CMsgClientInstallClientAppResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientInstallClientAppResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientInstallClientAppResponse): CMsgClientInstallClientAppResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 result */ 1:
                    message.result = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientInstallClientAppResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 result = 1; */
        if (message.result !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientInstallClientAppResponse
 */
export const CMsgClientInstallClientAppResponse = new CMsgClientInstallClientAppResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientInviteToGame$Type extends MessageType<CMsgClientInviteToGame> {
    constructor() {
        super("CMsgClientInviteToGame", [
            { no: 1, name: "steam_id_dest", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "steam_id_src", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "connect_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "remote_play", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientInviteToGame>): CMsgClientInviteToGame {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientInviteToGame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientInviteToGame): CMsgClientInviteToGame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_dest */ 1:
                    message.steamIdDest = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_src */ 2:
                    message.steamIdSrc = reader.fixed64().toBigInt();
                    break;
                case /* optional string connect_string */ 3:
                    message.connectString = reader.string();
                    break;
                case /* optional string remote_play */ 4:
                    message.remotePlay = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientInviteToGame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_dest = 1; */
        if (message.steamIdDest !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdDest);
        /* optional fixed64 steam_id_src = 2; */
        if (message.steamIdSrc !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdSrc);
        /* optional string connect_string = 3; */
        if (message.connectString !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.connectString);
        /* optional string remote_play = 4; */
        if (message.remotePlay !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.remotePlay);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientInviteToGame
 */
export const CMsgClientInviteToGame = new CMsgClientInviteToGame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientIsLimitedAccount$Type extends MessageType<CMsgClientIsLimitedAccount> {
    constructor() {
        super("CMsgClientIsLimitedAccount", [
            { no: 1, name: "bis_limited_account", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "bis_community_banned", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "bis_locked_account", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "bis_limited_account_allowed_to_invite_friends", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientIsLimitedAccount>): CMsgClientIsLimitedAccount {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientIsLimitedAccount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientIsLimitedAccount): CMsgClientIsLimitedAccount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool bis_limited_account */ 1:
                    message.bisLimitedAccount = reader.bool();
                    break;
                case /* optional bool bis_community_banned */ 2:
                    message.bisCommunityBanned = reader.bool();
                    break;
                case /* optional bool bis_locked_account */ 3:
                    message.bisLockedAccount = reader.bool();
                    break;
                case /* optional bool bis_limited_account_allowed_to_invite_friends */ 4:
                    message.bisLimitedAccountAllowedToInviteFriends = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientIsLimitedAccount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool bis_limited_account = 1; */
        if (message.bisLimitedAccount !== undefined)
            writer.tag(1, WireType.Varint).bool(message.bisLimitedAccount);
        /* optional bool bis_community_banned = 2; */
        if (message.bisCommunityBanned !== undefined)
            writer.tag(2, WireType.Varint).bool(message.bisCommunityBanned);
        /* optional bool bis_locked_account = 3; */
        if (message.bisLockedAccount !== undefined)
            writer.tag(3, WireType.Varint).bool(message.bisLockedAccount);
        /* optional bool bis_limited_account_allowed_to_invite_friends = 4; */
        if (message.bisLimitedAccountAllowedToInviteFriends !== undefined)
            writer.tag(4, WireType.Varint).bool(message.bisLimitedAccountAllowedToInviteFriends);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientIsLimitedAccount
 */
export const CMsgClientIsLimitedAccount = new CMsgClientIsLimitedAccount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientItemAnnouncements$Type extends MessageType<CMsgClientItemAnnouncements> {
    constructor() {
        super("CMsgClientItemAnnouncements", [
            { no: 1, name: "count_new_items", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "unseen_items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientItemAnnouncements_UnseenItem }
        ]);
    }
    create(value?: PartialMessage<CMsgClientItemAnnouncements>): CMsgClientItemAnnouncements {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unseenItems = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientItemAnnouncements>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientItemAnnouncements): CMsgClientItemAnnouncements {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 count_new_items */ 1:
                    message.countNewItems = reader.uint32();
                    break;
                case /* repeated CMsgClientItemAnnouncements_UnseenItem unseen_items */ 2:
                    message.unseenItems.push(CMsgClientItemAnnouncements_UnseenItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientItemAnnouncements, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 count_new_items = 1; */
        if (message.countNewItems !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.countNewItems);
        /* repeated CMsgClientItemAnnouncements_UnseenItem unseen_items = 2; */
        for (let i = 0; i < message.unseenItems.length; i++)
            CMsgClientItemAnnouncements_UnseenItem.internalBinaryWrite(message.unseenItems[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientItemAnnouncements
 */
export const CMsgClientItemAnnouncements = new CMsgClientItemAnnouncements$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientItemAnnouncements_UnseenItem$Type extends MessageType<CMsgClientItemAnnouncements_UnseenItem> {
    constructor() {
        super("CMsgClientItemAnnouncements_UnseenItem", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "context_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "asset_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "amount", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "rtime32_gained", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "source_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientItemAnnouncements_UnseenItem>): CMsgClientItemAnnouncements_UnseenItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientItemAnnouncements_UnseenItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientItemAnnouncements_UnseenItem): CMsgClientItemAnnouncements_UnseenItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint64 context_id */ 2:
                    message.contextId = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 asset_id */ 3:
                    message.assetId = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 amount */ 4:
                    message.amount = reader.uint64().toBigInt();
                    break;
                case /* optional fixed32 rtime32_gained */ 5:
                    message.rtime32Gained = reader.fixed32();
                    break;
                case /* optional uint32 source_appid */ 6:
                    message.sourceAppid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientItemAnnouncements_UnseenItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint64 context_id = 2; */
        if (message.contextId !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.contextId);
        /* optional uint64 asset_id = 3; */
        if (message.assetId !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.assetId);
        /* optional uint64 amount = 4; */
        if (message.amount !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.amount);
        /* optional fixed32 rtime32_gained = 5; */
        if (message.rtime32Gained !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.rtime32Gained);
        /* optional uint32 source_appid = 6; */
        if (message.sourceAppid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.sourceAppid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientItemAnnouncements_UnseenItem
 */
export const CMsgClientItemAnnouncements_UnseenItem = new CMsgClientItemAnnouncements_UnseenItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientKickPlayingSession$Type extends MessageType<CMsgClientKickPlayingSession> {
    constructor() {
        super("CMsgClientKickPlayingSession", [
            { no: 1, name: "only_stop_game", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientKickPlayingSession>): CMsgClientKickPlayingSession {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientKickPlayingSession>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientKickPlayingSession): CMsgClientKickPlayingSession {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool only_stop_game */ 1:
                    message.onlyStopGame = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientKickPlayingSession, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool only_stop_game = 1; */
        if (message.onlyStopGame !== undefined)
            writer.tag(1, WireType.Varint).bool(message.onlyStopGame);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientKickPlayingSession
 */
export const CMsgClientKickPlayingSession = new CMsgClientKickPlayingSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLBSFindOrCreateLB$Type extends MessageType<CMsgClientLBSFindOrCreateLB> {
    constructor() {
        super("CMsgClientLBSFindOrCreateLB", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "leaderboard_sort_method", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "leaderboard_display_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "create_if_not_found", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "leaderboard_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLBSFindOrCreateLB>): CMsgClientLBSFindOrCreateLB {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLBSFindOrCreateLB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLBSFindOrCreateLB): CMsgClientLBSFindOrCreateLB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional int32 leaderboard_sort_method */ 2:
                    message.leaderboardSortMethod = reader.int32();
                    break;
                case /* optional int32 leaderboard_display_type */ 3:
                    message.leaderboardDisplayType = reader.int32();
                    break;
                case /* optional bool create_if_not_found */ 4:
                    message.createIfNotFound = reader.bool();
                    break;
                case /* optional string leaderboard_name */ 5:
                    message.leaderboardName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLBSFindOrCreateLB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional int32 leaderboard_sort_method = 2; */
        if (message.leaderboardSortMethod !== undefined)
            writer.tag(2, WireType.Varint).int32(message.leaderboardSortMethod);
        /* optional int32 leaderboard_display_type = 3; */
        if (message.leaderboardDisplayType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.leaderboardDisplayType);
        /* optional bool create_if_not_found = 4; */
        if (message.createIfNotFound !== undefined)
            writer.tag(4, WireType.Varint).bool(message.createIfNotFound);
        /* optional string leaderboard_name = 5; */
        if (message.leaderboardName !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.leaderboardName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLBSFindOrCreateLB
 */
export const CMsgClientLBSFindOrCreateLB = new CMsgClientLBSFindOrCreateLB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLBSFindOrCreateLBResponse$Type extends MessageType<CMsgClientLBSFindOrCreateLBResponse> {
    constructor() {
        super("CMsgClientLBSFindOrCreateLBResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "leaderboard_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "leaderboard_entry_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "leaderboard_sort_method", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "leaderboard_display_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "leaderboard_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLBSFindOrCreateLBResponse>): CMsgClientLBSFindOrCreateLBResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLBSFindOrCreateLBResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLBSFindOrCreateLBResponse): CMsgClientLBSFindOrCreateLBResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 leaderboard_id */ 2:
                    message.leaderboardId = reader.int32();
                    break;
                case /* optional int32 leaderboard_entry_count */ 3:
                    message.leaderboardEntryCount = reader.int32();
                    break;
                case /* optional int32 leaderboard_sort_method = 4 [default = 0] */ 4:
                    message.leaderboardSortMethod = reader.int32();
                    break;
                case /* optional int32 leaderboard_display_type = 5 [default = 0] */ 5:
                    message.leaderboardDisplayType = reader.int32();
                    break;
                case /* optional string leaderboard_name */ 6:
                    message.leaderboardName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLBSFindOrCreateLBResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 leaderboard_id = 2; */
        if (message.leaderboardId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.leaderboardId);
        /* optional int32 leaderboard_entry_count = 3; */
        if (message.leaderboardEntryCount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.leaderboardEntryCount);
        /* optional int32 leaderboard_sort_method = 4 [default = 0]; */
        if (message.leaderboardSortMethod !== undefined)
            writer.tag(4, WireType.Varint).int32(message.leaderboardSortMethod);
        /* optional int32 leaderboard_display_type = 5 [default = 0]; */
        if (message.leaderboardDisplayType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.leaderboardDisplayType);
        /* optional string leaderboard_name = 6; */
        if (message.leaderboardName !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.leaderboardName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLBSFindOrCreateLBResponse
 */
export const CMsgClientLBSFindOrCreateLBResponse = new CMsgClientLBSFindOrCreateLBResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLBSGetLBEntries$Type extends MessageType<CMsgClientLBSGetLBEntries> {
    constructor() {
        super("CMsgClientLBSGetLBEntries", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "leaderboard_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "range_start", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "range_end", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "leaderboard_data_request", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "steamids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLBSGetLBEntries>): CMsgClientLBSGetLBEntries {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLBSGetLBEntries>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLBSGetLBEntries): CMsgClientLBSGetLBEntries {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 app_id */ 1:
                    message.appId = reader.int32();
                    break;
                case /* optional int32 leaderboard_id */ 2:
                    message.leaderboardId = reader.int32();
                    break;
                case /* optional int32 range_start */ 3:
                    message.rangeStart = reader.int32();
                    break;
                case /* optional int32 range_end */ 4:
                    message.rangeEnd = reader.int32();
                    break;
                case /* optional int32 leaderboard_data_request */ 5:
                    message.leaderboardDataRequest = reader.int32();
                    break;
                case /* repeated fixed64 steamids */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamids.push(reader.fixed64().toBigInt());
                    else
                        message.steamids.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLBSGetLBEntries, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.appId);
        /* optional int32 leaderboard_id = 2; */
        if (message.leaderboardId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.leaderboardId);
        /* optional int32 range_start = 3; */
        if (message.rangeStart !== undefined)
            writer.tag(3, WireType.Varint).int32(message.rangeStart);
        /* optional int32 range_end = 4; */
        if (message.rangeEnd !== undefined)
            writer.tag(4, WireType.Varint).int32(message.rangeEnd);
        /* optional int32 leaderboard_data_request = 5; */
        if (message.leaderboardDataRequest !== undefined)
            writer.tag(5, WireType.Varint).int32(message.leaderboardDataRequest);
        /* repeated fixed64 steamids = 6; */
        for (let i = 0; i < message.steamids.length; i++)
            writer.tag(6, WireType.Bit64).fixed64(message.steamids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLBSGetLBEntries
 */
export const CMsgClientLBSGetLBEntries = new CMsgClientLBSGetLBEntries$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLBSGetLBEntriesResponse$Type extends MessageType<CMsgClientLBSGetLBEntriesResponse> {
    constructor() {
        super("CMsgClientLBSGetLBEntriesResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "leaderboard_entry_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientLBSGetLBEntriesResponse_Entry }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLBSGetLBEntriesResponse>): CMsgClientLBSGetLBEntriesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLBSGetLBEntriesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLBSGetLBEntriesResponse): CMsgClientLBSGetLBEntriesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 leaderboard_entry_count */ 2:
                    message.leaderboardEntryCount = reader.int32();
                    break;
                case /* repeated CMsgClientLBSGetLBEntriesResponse_Entry entries */ 3:
                    message.entries.push(CMsgClientLBSGetLBEntriesResponse_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLBSGetLBEntriesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 leaderboard_entry_count = 2; */
        if (message.leaderboardEntryCount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.leaderboardEntryCount);
        /* repeated CMsgClientLBSGetLBEntriesResponse_Entry entries = 3; */
        for (let i = 0; i < message.entries.length; i++)
            CMsgClientLBSGetLBEntriesResponse_Entry.internalBinaryWrite(message.entries[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLBSGetLBEntriesResponse
 */
export const CMsgClientLBSGetLBEntriesResponse = new CMsgClientLBSGetLBEntriesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLBSGetLBEntriesResponse_Entry$Type extends MessageType<CMsgClientLBSGetLBEntriesResponse_Entry> {
    constructor() {
        super("CMsgClientLBSGetLBEntriesResponse_Entry", [
            { no: 1, name: "steam_id_user", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "global_rank", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "score", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "details", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "ugc_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLBSGetLBEntriesResponse_Entry>): CMsgClientLBSGetLBEntriesResponse_Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLBSGetLBEntriesResponse_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLBSGetLBEntriesResponse_Entry): CMsgClientLBSGetLBEntriesResponse_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_user */ 1:
                    message.steamIdUser = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 global_rank */ 2:
                    message.globalRank = reader.int32();
                    break;
                case /* optional int32 score */ 3:
                    message.score = reader.int32();
                    break;
                case /* optional bytes details */ 4:
                    message.details = reader.bytes();
                    break;
                case /* optional fixed64 ugc_id */ 5:
                    message.ugcId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLBSGetLBEntriesResponse_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_user = 1; */
        if (message.steamIdUser !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdUser);
        /* optional int32 global_rank = 2; */
        if (message.globalRank !== undefined)
            writer.tag(2, WireType.Varint).int32(message.globalRank);
        /* optional int32 score = 3; */
        if (message.score !== undefined)
            writer.tag(3, WireType.Varint).int32(message.score);
        /* optional bytes details = 4; */
        if (message.details !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.details);
        /* optional fixed64 ugc_id = 5; */
        if (message.ugcId !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.ugcId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLBSGetLBEntriesResponse_Entry
 */
export const CMsgClientLBSGetLBEntriesResponse_Entry = new CMsgClientLBSGetLBEntriesResponse_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLBSSetScore$Type extends MessageType<CMsgClientLBSSetScore> {
    constructor() {
        super("CMsgClientLBSSetScore", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "leaderboard_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "score", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "details", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "upload_score_method", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLBSSetScore>): CMsgClientLBSSetScore {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLBSSetScore>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLBSSetScore): CMsgClientLBSSetScore {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional int32 leaderboard_id */ 2:
                    message.leaderboardId = reader.int32();
                    break;
                case /* optional int32 score */ 3:
                    message.score = reader.int32();
                    break;
                case /* optional bytes details */ 4:
                    message.details = reader.bytes();
                    break;
                case /* optional int32 upload_score_method */ 5:
                    message.uploadScoreMethod = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLBSSetScore, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional int32 leaderboard_id = 2; */
        if (message.leaderboardId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.leaderboardId);
        /* optional int32 score = 3; */
        if (message.score !== undefined)
            writer.tag(3, WireType.Varint).int32(message.score);
        /* optional bytes details = 4; */
        if (message.details !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.details);
        /* optional int32 upload_score_method = 5; */
        if (message.uploadScoreMethod !== undefined)
            writer.tag(5, WireType.Varint).int32(message.uploadScoreMethod);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLBSSetScore
 */
export const CMsgClientLBSSetScore = new CMsgClientLBSSetScore$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLBSSetScoreResponse$Type extends MessageType<CMsgClientLBSSetScoreResponse> {
    constructor() {
        super("CMsgClientLBSSetScoreResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "leaderboard_entry_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "score_changed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "global_rank_previous", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "global_rank_new", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLBSSetScoreResponse>): CMsgClientLBSSetScoreResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLBSSetScoreResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLBSSetScoreResponse): CMsgClientLBSSetScoreResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 leaderboard_entry_count */ 2:
                    message.leaderboardEntryCount = reader.int32();
                    break;
                case /* optional bool score_changed */ 3:
                    message.scoreChanged = reader.bool();
                    break;
                case /* optional int32 global_rank_previous */ 4:
                    message.globalRankPrevious = reader.int32();
                    break;
                case /* optional int32 global_rank_new */ 5:
                    message.globalRankNew = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLBSSetScoreResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 leaderboard_entry_count = 2; */
        if (message.leaderboardEntryCount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.leaderboardEntryCount);
        /* optional bool score_changed = 3; */
        if (message.scoreChanged !== undefined)
            writer.tag(3, WireType.Varint).bool(message.scoreChanged);
        /* optional int32 global_rank_previous = 4; */
        if (message.globalRankPrevious !== undefined)
            writer.tag(4, WireType.Varint).int32(message.globalRankPrevious);
        /* optional int32 global_rank_new = 5; */
        if (message.globalRankNew !== undefined)
            writer.tag(5, WireType.Varint).int32(message.globalRankNew);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLBSSetScoreResponse
 */
export const CMsgClientLBSSetScoreResponse = new CMsgClientLBSSetScoreResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLBSSetUGC$Type extends MessageType<CMsgClientLBSSetUGC> {
    constructor() {
        super("CMsgClientLBSSetUGC", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "leaderboard_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "ugc_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLBSSetUGC>): CMsgClientLBSSetUGC {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLBSSetUGC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLBSSetUGC): CMsgClientLBSSetUGC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional int32 leaderboard_id */ 2:
                    message.leaderboardId = reader.int32();
                    break;
                case /* optional fixed64 ugc_id */ 3:
                    message.ugcId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLBSSetUGC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional int32 leaderboard_id = 2; */
        if (message.leaderboardId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.leaderboardId);
        /* optional fixed64 ugc_id = 3; */
        if (message.ugcId !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.ugcId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLBSSetUGC
 */
export const CMsgClientLBSSetUGC = new CMsgClientLBSSetUGC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLBSSetUGCResponse$Type extends MessageType<CMsgClientLBSSetUGCResponse> {
    constructor() {
        super("CMsgClientLBSSetUGCResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLBSSetUGCResponse>): CMsgClientLBSSetUGCResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLBSSetUGCResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLBSSetUGCResponse): CMsgClientLBSSetUGCResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLBSSetUGCResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLBSSetUGCResponse
 */
export const CMsgClientLBSSetUGCResponse = new CMsgClientLBSSetUGCResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLicenseList$Type extends MessageType<CMsgClientLicenseList> {
    constructor() {
        super("CMsgClientLicenseList", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "licenses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientLicenseList_License }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLicenseList>): CMsgClientLicenseList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.licenses = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLicenseList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLicenseList): CMsgClientLicenseList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgClientLicenseList_License licenses */ 2:
                    message.licenses.push(CMsgClientLicenseList_License.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLicenseList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* repeated CMsgClientLicenseList_License licenses = 2; */
        for (let i = 0; i < message.licenses.length; i++)
            CMsgClientLicenseList_License.internalBinaryWrite(message.licenses[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLicenseList
 */
export const CMsgClientLicenseList = new CMsgClientLicenseList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLicenseList_License$Type extends MessageType<CMsgClientLicenseList_License> {
    constructor() {
        super("CMsgClientLicenseList_License", [
            { no: 1, name: "package_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "time_created", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "time_next_process", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "minute_limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "minutes_used", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "payment_method", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "purchase_country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "license_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "territory_code", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "change_number", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "owner_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "initial_period", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "initial_time_unit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "renewal_period", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "renewal_time_unit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "access_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 18, name: "master_package_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLicenseList_License>): CMsgClientLicenseList_License {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLicenseList_License>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLicenseList_License): CMsgClientLicenseList_License {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 package_id */ 1:
                    message.packageId = reader.uint32();
                    break;
                case /* optional fixed32 time_created */ 2:
                    message.timeCreated = reader.fixed32();
                    break;
                case /* optional fixed32 time_next_process */ 3:
                    message.timeNextProcess = reader.fixed32();
                    break;
                case /* optional int32 minute_limit */ 4:
                    message.minuteLimit = reader.int32();
                    break;
                case /* optional int32 minutes_used */ 5:
                    message.minutesUsed = reader.int32();
                    break;
                case /* optional uint32 payment_method */ 6:
                    message.paymentMethod = reader.uint32();
                    break;
                case /* optional uint32 flags */ 7:
                    message.flags = reader.uint32();
                    break;
                case /* optional string purchase_country_code */ 8:
                    message.purchaseCountryCode = reader.string();
                    break;
                case /* optional uint32 license_type */ 9:
                    message.licenseType = reader.uint32();
                    break;
                case /* optional int32 territory_code */ 10:
                    message.territoryCode = reader.int32();
                    break;
                case /* optional int32 change_number */ 11:
                    message.changeNumber = reader.int32();
                    break;
                case /* optional uint32 owner_id */ 12:
                    message.ownerId = reader.uint32();
                    break;
                case /* optional uint32 initial_period */ 13:
                    message.initialPeriod = reader.uint32();
                    break;
                case /* optional uint32 initial_time_unit */ 14:
                    message.initialTimeUnit = reader.uint32();
                    break;
                case /* optional uint32 renewal_period */ 15:
                    message.renewalPeriod = reader.uint32();
                    break;
                case /* optional uint32 renewal_time_unit */ 16:
                    message.renewalTimeUnit = reader.uint32();
                    break;
                case /* optional uint64 access_token */ 17:
                    message.accessToken = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 master_package_id */ 18:
                    message.masterPackageId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLicenseList_License, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 package_id = 1; */
        if (message.packageId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageId);
        /* optional fixed32 time_created = 2; */
        if (message.timeCreated !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.timeCreated);
        /* optional fixed32 time_next_process = 3; */
        if (message.timeNextProcess !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.timeNextProcess);
        /* optional int32 minute_limit = 4; */
        if (message.minuteLimit !== undefined)
            writer.tag(4, WireType.Varint).int32(message.minuteLimit);
        /* optional int32 minutes_used = 5; */
        if (message.minutesUsed !== undefined)
            writer.tag(5, WireType.Varint).int32(message.minutesUsed);
        /* optional uint32 payment_method = 6; */
        if (message.paymentMethod !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.paymentMethod);
        /* optional uint32 flags = 7; */
        if (message.flags !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.flags);
        /* optional string purchase_country_code = 8; */
        if (message.purchaseCountryCode !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.purchaseCountryCode);
        /* optional uint32 license_type = 9; */
        if (message.licenseType !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.licenseType);
        /* optional int32 territory_code = 10; */
        if (message.territoryCode !== undefined)
            writer.tag(10, WireType.Varint).int32(message.territoryCode);
        /* optional int32 change_number = 11; */
        if (message.changeNumber !== undefined)
            writer.tag(11, WireType.Varint).int32(message.changeNumber);
        /* optional uint32 owner_id = 12; */
        if (message.ownerId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.ownerId);
        /* optional uint32 initial_period = 13; */
        if (message.initialPeriod !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.initialPeriod);
        /* optional uint32 initial_time_unit = 14; */
        if (message.initialTimeUnit !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.initialTimeUnit);
        /* optional uint32 renewal_period = 15; */
        if (message.renewalPeriod !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.renewalPeriod);
        /* optional uint32 renewal_time_unit = 16; */
        if (message.renewalTimeUnit !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.renewalTimeUnit);
        /* optional uint64 access_token = 17; */
        if (message.accessToken !== undefined)
            writer.tag(17, WireType.Varint).uint64(message.accessToken);
        /* optional uint32 master_package_id = 18; */
        if (message.masterPackageId !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.masterPackageId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLicenseList_License
 */
export const CMsgClientLicenseList_License = new CMsgClientLicenseList_License$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLoggedOff$Type extends MessageType<CMsgClientLoggedOff> {
    constructor() {
        super("CMsgClientLoggedOff", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLoggedOff>): CMsgClientLoggedOff {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLoggedOff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLoggedOff): CMsgClientLoggedOff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLoggedOff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLoggedOff
 */
export const CMsgClientLoggedOff = new CMsgClientLoggedOff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLogOff$Type extends MessageType<CMsgClientLogOff> {
    constructor() {
        super("CMsgClientLogOff", []);
    }
    create(value?: PartialMessage<CMsgClientLogOff>): CMsgClientLogOff {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLogOff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLogOff): CMsgClientLogOff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLogOff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLogOff
 */
export const CMsgClientLogOff = new CMsgClientLogOff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLogon$Type extends MessageType<CMsgClientLogon> {
    constructor() {
        super("CMsgClientLogon", [
            { no: 1, name: "protocol_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "deprecated_obfustucated_private_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "last_session_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "client_package_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "client_language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "client_os_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "should_remember_password", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "wine_version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "deprecated_10", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "obfuscated_private_ip", kind: "message", T: () => CMsgIPAddress },
            { no: 20, name: "deprecated_public_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "qos_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "client_supplied_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 23, name: "public_ip", kind: "message", T: () => CMsgIPAddress },
            { no: 30, name: "machine_id", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 31, name: "launcher_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 32, name: "ui_mode", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 33, name: "chat_mode", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 41, name: "steam2_auth_ticket", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 42, name: "email_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 43, name: "rtime32_account_creation", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 50, name: "account_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 51, name: "password", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 52, name: "game_server_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 60, name: "login_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 70, name: "was_converted_deprecated_msg", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 80, name: "anon_user_target_account_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 81, name: "resolved_user_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 82, name: "eresult_sentryfile", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 83, name: "sha_sentryfile", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 84, name: "auth_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 85, name: "otp_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 86, name: "otp_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 87, name: "otp_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 88, name: "steam2_ticket_request", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 90, name: "sony_psn_ticket", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 91, name: "sony_psn_service_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 92, name: "create_new_psn_linked_account_if_needed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 93, name: "sony_psn_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 94, name: "game_server_app_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 95, name: "steamguard_dont_remember_computer", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 96, name: "machine_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 97, name: "machine_name_userchosen", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 98, name: "country_override", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 99, name: "is_steam_box", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 100, name: "client_instance_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 101, name: "two_factor_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 102, name: "supports_rate_limit_response", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 103, name: "web_logon_nonce", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 104, name: "priority_reason", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 105, name: "embedded_client_secret", kind: "message", T: () => CMsgClientSecret },
            { no: 106, name: "disable_partner_autogrants", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 107, name: "is_steam_deck", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 108, name: "access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 109, name: "is_chrome_os", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 110, name: "is_tesla", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLogon>): CMsgClientLogon {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLogon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLogon): CMsgClientLogon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 protocol_version */ 1:
                    message.protocolVersion = reader.uint32();
                    break;
                case /* optional uint32 deprecated_obfustucated_private_ip */ 2:
                    message.deprecatedObfustucatedPrivateIp = reader.uint32();
                    break;
                case /* optional uint32 cell_id */ 3:
                    message.cellId = reader.uint32();
                    break;
                case /* optional uint32 last_session_id */ 4:
                    message.lastSessionId = reader.uint32();
                    break;
                case /* optional uint32 client_package_version */ 5:
                    message.clientPackageVersion = reader.uint32();
                    break;
                case /* optional string client_language */ 6:
                    message.clientLanguage = reader.string();
                    break;
                case /* optional uint32 client_os_type */ 7:
                    message.clientOsType = reader.uint32();
                    break;
                case /* optional bool should_remember_password = 8 [default = false] */ 8:
                    message.shouldRememberPassword = reader.bool();
                    break;
                case /* optional string wine_version */ 9:
                    message.wineVersion = reader.string();
                    break;
                case /* optional uint32 deprecated_10 */ 10:
                    message.deprecated10 = reader.uint32();
                    break;
                case /* optional CMsgIPAddress obfuscated_private_ip */ 11:
                    message.obfuscatedPrivateIp = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.obfuscatedPrivateIp);
                    break;
                case /* optional uint32 deprecated_public_ip */ 20:
                    message.deprecatedPublicIp = reader.uint32();
                    break;
                case /* optional uint32 qos_level */ 21:
                    message.qosLevel = reader.uint32();
                    break;
                case /* optional fixed64 client_supplied_steam_id */ 22:
                    message.clientSuppliedSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional CMsgIPAddress public_ip */ 23:
                    message.publicIp = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.publicIp);
                    break;
                case /* optional bytes machine_id */ 30:
                    message.machineId = reader.bytes();
                    break;
                case /* optional uint32 launcher_type = 31 [default = 0] */ 31:
                    message.launcherType = reader.uint32();
                    break;
                case /* optional uint32 ui_mode = 32 [default = 0] */ 32:
                    message.uiMode = reader.uint32();
                    break;
                case /* optional uint32 chat_mode = 33 [default = 0] */ 33:
                    message.chatMode = reader.uint32();
                    break;
                case /* optional bytes steam2_auth_ticket */ 41:
                    message.steam2AuthTicket = reader.bytes();
                    break;
                case /* optional string email_address */ 42:
                    message.emailAddress = reader.string();
                    break;
                case /* optional fixed32 rtime32_account_creation */ 43:
                    message.rtime32AccountCreation = reader.fixed32();
                    break;
                case /* optional string account_name */ 50:
                    message.accountName = reader.string();
                    break;
                case /* optional string password */ 51:
                    message.password = reader.string();
                    break;
                case /* optional string game_server_token */ 52:
                    message.gameServerToken = reader.string();
                    break;
                case /* optional string login_key */ 60:
                    message.loginKey = reader.string();
                    break;
                case /* optional bool was_converted_deprecated_msg = 70 [default = false] */ 70:
                    message.wasConvertedDeprecatedMsg = reader.bool();
                    break;
                case /* optional string anon_user_target_account_name */ 80:
                    message.anonUserTargetAccountName = reader.string();
                    break;
                case /* optional fixed64 resolved_user_steam_id */ 81:
                    message.resolvedUserSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 eresult_sentryfile */ 82:
                    message.eresultSentryfile = reader.int32();
                    break;
                case /* optional bytes sha_sentryfile */ 83:
                    message.shaSentryfile = reader.bytes();
                    break;
                case /* optional string auth_code */ 84:
                    message.authCode = reader.string();
                    break;
                case /* optional int32 otp_type */ 85:
                    message.otpType = reader.int32();
                    break;
                case /* optional uint32 otp_value */ 86:
                    message.otpValue = reader.uint32();
                    break;
                case /* optional string otp_identifier */ 87:
                    message.otpIdentifier = reader.string();
                    break;
                case /* optional bool steam2_ticket_request */ 88:
                    message.steam2TicketRequest = reader.bool();
                    break;
                case /* optional bytes sony_psn_ticket */ 90:
                    message.sonyPsnTicket = reader.bytes();
                    break;
                case /* optional string sony_psn_service_id */ 91:
                    message.sonyPsnServiceId = reader.string();
                    break;
                case /* optional bool create_new_psn_linked_account_if_needed = 92 [default = false] */ 92:
                    message.createNewPsnLinkedAccountIfNeeded = reader.bool();
                    break;
                case /* optional string sony_psn_name */ 93:
                    message.sonyPsnName = reader.string();
                    break;
                case /* optional int32 game_server_app_id */ 94:
                    message.gameServerAppId = reader.int32();
                    break;
                case /* optional bool steamguard_dont_remember_computer */ 95:
                    message.steamguardDontRememberComputer = reader.bool();
                    break;
                case /* optional string machine_name */ 96:
                    message.machineName = reader.string();
                    break;
                case /* optional string machine_name_userchosen */ 97:
                    message.machineNameUserchosen = reader.string();
                    break;
                case /* optional string country_override */ 98:
                    message.countryOverride = reader.string();
                    break;
                case /* optional bool is_steam_box */ 99:
                    message.isSteamBox = reader.bool();
                    break;
                case /* optional uint64 client_instance_id */ 100:
                    message.clientInstanceId = reader.uint64().toBigInt();
                    break;
                case /* optional string two_factor_code */ 101:
                    message.twoFactorCode = reader.string();
                    break;
                case /* optional bool supports_rate_limit_response */ 102:
                    message.supportsRateLimitResponse = reader.bool();
                    break;
                case /* optional string web_logon_nonce */ 103:
                    message.webLogonNonce = reader.string();
                    break;
                case /* optional int32 priority_reason */ 104:
                    message.priorityReason = reader.int32();
                    break;
                case /* optional CMsgClientSecret embedded_client_secret */ 105:
                    message.embeddedClientSecret = CMsgClientSecret.internalBinaryRead(reader, reader.uint32(), options, message.embeddedClientSecret);
                    break;
                case /* optional bool disable_partner_autogrants */ 106:
                    message.disablePartnerAutogrants = reader.bool();
                    break;
                case /* optional bool is_steam_deck */ 107:
                    message.isSteamDeck = reader.bool();
                    break;
                case /* optional string access_token */ 108:
                    message.accessToken = reader.string();
                    break;
                case /* optional bool is_chrome_os */ 109:
                    message.isChromeOs = reader.bool();
                    break;
                case /* optional bool is_tesla */ 110:
                    message.isTesla = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLogon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 protocol_version = 1; */
        if (message.protocolVersion !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.protocolVersion);
        /* optional uint32 deprecated_obfustucated_private_ip = 2; */
        if (message.deprecatedObfustucatedPrivateIp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.deprecatedObfustucatedPrivateIp);
        /* optional uint32 cell_id = 3; */
        if (message.cellId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.cellId);
        /* optional uint32 last_session_id = 4; */
        if (message.lastSessionId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.lastSessionId);
        /* optional uint32 client_package_version = 5; */
        if (message.clientPackageVersion !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.clientPackageVersion);
        /* optional string client_language = 6; */
        if (message.clientLanguage !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.clientLanguage);
        /* optional uint32 client_os_type = 7; */
        if (message.clientOsType !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.clientOsType);
        /* optional bool should_remember_password = 8 [default = false]; */
        if (message.shouldRememberPassword !== undefined)
            writer.tag(8, WireType.Varint).bool(message.shouldRememberPassword);
        /* optional string wine_version = 9; */
        if (message.wineVersion !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.wineVersion);
        /* optional uint32 deprecated_10 = 10; */
        if (message.deprecated10 !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.deprecated10);
        /* optional CMsgIPAddress obfuscated_private_ip = 11; */
        if (message.obfuscatedPrivateIp)
            CMsgIPAddress.internalBinaryWrite(message.obfuscatedPrivateIp, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 deprecated_public_ip = 20; */
        if (message.deprecatedPublicIp !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.deprecatedPublicIp);
        /* optional uint32 qos_level = 21; */
        if (message.qosLevel !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.qosLevel);
        /* optional fixed64 client_supplied_steam_id = 22; */
        if (message.clientSuppliedSteamId !== undefined)
            writer.tag(22, WireType.Bit64).fixed64(message.clientSuppliedSteamId);
        /* optional CMsgIPAddress public_ip = 23; */
        if (message.publicIp)
            CMsgIPAddress.internalBinaryWrite(message.publicIp, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes machine_id = 30; */
        if (message.machineId !== undefined)
            writer.tag(30, WireType.LengthDelimited).bytes(message.machineId);
        /* optional uint32 launcher_type = 31 [default = 0]; */
        if (message.launcherType !== undefined)
            writer.tag(31, WireType.Varint).uint32(message.launcherType);
        /* optional uint32 ui_mode = 32 [default = 0]; */
        if (message.uiMode !== undefined)
            writer.tag(32, WireType.Varint).uint32(message.uiMode);
        /* optional uint32 chat_mode = 33 [default = 0]; */
        if (message.chatMode !== undefined)
            writer.tag(33, WireType.Varint).uint32(message.chatMode);
        /* optional bytes steam2_auth_ticket = 41; */
        if (message.steam2AuthTicket !== undefined)
            writer.tag(41, WireType.LengthDelimited).bytes(message.steam2AuthTicket);
        /* optional string email_address = 42; */
        if (message.emailAddress !== undefined)
            writer.tag(42, WireType.LengthDelimited).string(message.emailAddress);
        /* optional fixed32 rtime32_account_creation = 43; */
        if (message.rtime32AccountCreation !== undefined)
            writer.tag(43, WireType.Bit32).fixed32(message.rtime32AccountCreation);
        /* optional string account_name = 50; */
        if (message.accountName !== undefined)
            writer.tag(50, WireType.LengthDelimited).string(message.accountName);
        /* optional string password = 51; */
        if (message.password !== undefined)
            writer.tag(51, WireType.LengthDelimited).string(message.password);
        /* optional string game_server_token = 52; */
        if (message.gameServerToken !== undefined)
            writer.tag(52, WireType.LengthDelimited).string(message.gameServerToken);
        /* optional string login_key = 60; */
        if (message.loginKey !== undefined)
            writer.tag(60, WireType.LengthDelimited).string(message.loginKey);
        /* optional bool was_converted_deprecated_msg = 70 [default = false]; */
        if (message.wasConvertedDeprecatedMsg !== undefined)
            writer.tag(70, WireType.Varint).bool(message.wasConvertedDeprecatedMsg);
        /* optional string anon_user_target_account_name = 80; */
        if (message.anonUserTargetAccountName !== undefined)
            writer.tag(80, WireType.LengthDelimited).string(message.anonUserTargetAccountName);
        /* optional fixed64 resolved_user_steam_id = 81; */
        if (message.resolvedUserSteamId !== undefined)
            writer.tag(81, WireType.Bit64).fixed64(message.resolvedUserSteamId);
        /* optional int32 eresult_sentryfile = 82; */
        if (message.eresultSentryfile !== undefined)
            writer.tag(82, WireType.Varint).int32(message.eresultSentryfile);
        /* optional bytes sha_sentryfile = 83; */
        if (message.shaSentryfile !== undefined)
            writer.tag(83, WireType.LengthDelimited).bytes(message.shaSentryfile);
        /* optional string auth_code = 84; */
        if (message.authCode !== undefined)
            writer.tag(84, WireType.LengthDelimited).string(message.authCode);
        /* optional int32 otp_type = 85; */
        if (message.otpType !== undefined)
            writer.tag(85, WireType.Varint).int32(message.otpType);
        /* optional uint32 otp_value = 86; */
        if (message.otpValue !== undefined)
            writer.tag(86, WireType.Varint).uint32(message.otpValue);
        /* optional string otp_identifier = 87; */
        if (message.otpIdentifier !== undefined)
            writer.tag(87, WireType.LengthDelimited).string(message.otpIdentifier);
        /* optional bool steam2_ticket_request = 88; */
        if (message.steam2TicketRequest !== undefined)
            writer.tag(88, WireType.Varint).bool(message.steam2TicketRequest);
        /* optional bytes sony_psn_ticket = 90; */
        if (message.sonyPsnTicket !== undefined)
            writer.tag(90, WireType.LengthDelimited).bytes(message.sonyPsnTicket);
        /* optional string sony_psn_service_id = 91; */
        if (message.sonyPsnServiceId !== undefined)
            writer.tag(91, WireType.LengthDelimited).string(message.sonyPsnServiceId);
        /* optional bool create_new_psn_linked_account_if_needed = 92 [default = false]; */
        if (message.createNewPsnLinkedAccountIfNeeded !== undefined)
            writer.tag(92, WireType.Varint).bool(message.createNewPsnLinkedAccountIfNeeded);
        /* optional string sony_psn_name = 93; */
        if (message.sonyPsnName !== undefined)
            writer.tag(93, WireType.LengthDelimited).string(message.sonyPsnName);
        /* optional int32 game_server_app_id = 94; */
        if (message.gameServerAppId !== undefined)
            writer.tag(94, WireType.Varint).int32(message.gameServerAppId);
        /* optional bool steamguard_dont_remember_computer = 95; */
        if (message.steamguardDontRememberComputer !== undefined)
            writer.tag(95, WireType.Varint).bool(message.steamguardDontRememberComputer);
        /* optional string machine_name = 96; */
        if (message.machineName !== undefined)
            writer.tag(96, WireType.LengthDelimited).string(message.machineName);
        /* optional string machine_name_userchosen = 97; */
        if (message.machineNameUserchosen !== undefined)
            writer.tag(97, WireType.LengthDelimited).string(message.machineNameUserchosen);
        /* optional string country_override = 98; */
        if (message.countryOverride !== undefined)
            writer.tag(98, WireType.LengthDelimited).string(message.countryOverride);
        /* optional bool is_steam_box = 99; */
        if (message.isSteamBox !== undefined)
            writer.tag(99, WireType.Varint).bool(message.isSteamBox);
        /* optional uint64 client_instance_id = 100; */
        if (message.clientInstanceId !== undefined)
            writer.tag(100, WireType.Varint).uint64(message.clientInstanceId);
        /* optional string two_factor_code = 101; */
        if (message.twoFactorCode !== undefined)
            writer.tag(101, WireType.LengthDelimited).string(message.twoFactorCode);
        /* optional bool supports_rate_limit_response = 102; */
        if (message.supportsRateLimitResponse !== undefined)
            writer.tag(102, WireType.Varint).bool(message.supportsRateLimitResponse);
        /* optional string web_logon_nonce = 103; */
        if (message.webLogonNonce !== undefined)
            writer.tag(103, WireType.LengthDelimited).string(message.webLogonNonce);
        /* optional int32 priority_reason = 104; */
        if (message.priorityReason !== undefined)
            writer.tag(104, WireType.Varint).int32(message.priorityReason);
        /* optional CMsgClientSecret embedded_client_secret = 105; */
        if (message.embeddedClientSecret)
            CMsgClientSecret.internalBinaryWrite(message.embeddedClientSecret, writer.tag(105, WireType.LengthDelimited).fork(), options).join();
        /* optional bool disable_partner_autogrants = 106; */
        if (message.disablePartnerAutogrants !== undefined)
            writer.tag(106, WireType.Varint).bool(message.disablePartnerAutogrants);
        /* optional bool is_steam_deck = 107; */
        if (message.isSteamDeck !== undefined)
            writer.tag(107, WireType.Varint).bool(message.isSteamDeck);
        /* optional string access_token = 108; */
        if (message.accessToken !== undefined)
            writer.tag(108, WireType.LengthDelimited).string(message.accessToken);
        /* optional bool is_chrome_os = 109; */
        if (message.isChromeOs !== undefined)
            writer.tag(109, WireType.Varint).bool(message.isChromeOs);
        /* optional bool is_tesla = 110; */
        if (message.isTesla !== undefined)
            writer.tag(110, WireType.Varint).bool(message.isTesla);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLogon
 */
export const CMsgClientLogon = new CMsgClientLogon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientLogonResponse$Type extends MessageType<CMsgClientLogonResponse> {
    constructor() {
        super("CMsgClientLogonResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "legacy_out_of_game_heartbeat_seconds", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "heartbeat_seconds", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "deprecated_public_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "rtime32_server_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "account_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "email_domain", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "steam2_ticket", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "eresult_extended", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "webapi_authenticate_user_nonce", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "cell_id_ping_threshold", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "deprecated_use_pics", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "vanity_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "public_ip", kind: "message", T: () => CMsgIPAddress },
            { no: 16, name: "user_country", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "client_supplied_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "ip_country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "parental_settings", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 23, name: "parental_setting_signature", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 24, name: "count_loginfailures_to_migrate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 25, name: "count_disconnects_to_migrate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 26, name: "ogs_data_report_time_window", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 27, name: "client_instance_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 28, name: "force_client_update_check", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "agreement_session_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "token_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 31, name: "family_group_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientLogonResponse>): CMsgClientLogonResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientLogonResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientLogonResponse): CMsgClientLogonResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 legacy_out_of_game_heartbeat_seconds */ 2:
                    message.legacyOutOfGameHeartbeatSeconds = reader.int32();
                    break;
                case /* optional int32 heartbeat_seconds */ 3:
                    message.heartbeatSeconds = reader.int32();
                    break;
                case /* optional uint32 deprecated_public_ip */ 4:
                    message.deprecatedPublicIp = reader.uint32();
                    break;
                case /* optional fixed32 rtime32_server_time */ 5:
                    message.rtime32ServerTime = reader.fixed32();
                    break;
                case /* optional uint32 account_flags */ 6:
                    message.accountFlags = reader.uint32();
                    break;
                case /* optional uint32 cell_id */ 7:
                    message.cellId = reader.uint32();
                    break;
                case /* optional string email_domain */ 8:
                    message.emailDomain = reader.string();
                    break;
                case /* optional bytes steam2_ticket */ 9:
                    message.steam2Ticket = reader.bytes();
                    break;
                case /* optional int32 eresult_extended */ 10:
                    message.eresultExtended = reader.int32();
                    break;
                case /* optional string webapi_authenticate_user_nonce */ 11:
                    message.webapiAuthenticateUserNonce = reader.string();
                    break;
                case /* optional uint32 cell_id_ping_threshold */ 12:
                    message.cellIdPingThreshold = reader.uint32();
                    break;
                case /* optional bool deprecated_use_pics */ 13:
                    message.deprecatedUsePics = reader.bool();
                    break;
                case /* optional string vanity_url */ 14:
                    message.vanityUrl = reader.string();
                    break;
                case /* optional CMsgIPAddress public_ip */ 15:
                    message.publicIp = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.publicIp);
                    break;
                case /* optional string user_country */ 16:
                    message.userCountry = reader.string();
                    break;
                case /* optional fixed64 client_supplied_steamid */ 20:
                    message.clientSuppliedSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string ip_country_code */ 21:
                    message.ipCountryCode = reader.string();
                    break;
                case /* optional bytes parental_settings */ 22:
                    message.parentalSettings = reader.bytes();
                    break;
                case /* optional bytes parental_setting_signature */ 23:
                    message.parentalSettingSignature = reader.bytes();
                    break;
                case /* optional int32 count_loginfailures_to_migrate */ 24:
                    message.countLoginfailuresToMigrate = reader.int32();
                    break;
                case /* optional int32 count_disconnects_to_migrate */ 25:
                    message.countDisconnectsToMigrate = reader.int32();
                    break;
                case /* optional int32 ogs_data_report_time_window */ 26:
                    message.ogsDataReportTimeWindow = reader.int32();
                    break;
                case /* optional uint64 client_instance_id */ 27:
                    message.clientInstanceId = reader.uint64().toBigInt();
                    break;
                case /* optional bool force_client_update_check */ 28:
                    message.forceClientUpdateCheck = reader.bool();
                    break;
                case /* optional string agreement_session_url */ 29:
                    message.agreementSessionUrl = reader.string();
                    break;
                case /* optional uint64 token_id */ 30:
                    message.tokenId = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 family_group_id */ 31:
                    message.familyGroupId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientLogonResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 legacy_out_of_game_heartbeat_seconds = 2; */
        if (message.legacyOutOfGameHeartbeatSeconds !== undefined)
            writer.tag(2, WireType.Varint).int32(message.legacyOutOfGameHeartbeatSeconds);
        /* optional int32 heartbeat_seconds = 3; */
        if (message.heartbeatSeconds !== undefined)
            writer.tag(3, WireType.Varint).int32(message.heartbeatSeconds);
        /* optional uint32 deprecated_public_ip = 4; */
        if (message.deprecatedPublicIp !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.deprecatedPublicIp);
        /* optional fixed32 rtime32_server_time = 5; */
        if (message.rtime32ServerTime !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.rtime32ServerTime);
        /* optional uint32 account_flags = 6; */
        if (message.accountFlags !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.accountFlags);
        /* optional uint32 cell_id = 7; */
        if (message.cellId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.cellId);
        /* optional string email_domain = 8; */
        if (message.emailDomain !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.emailDomain);
        /* optional bytes steam2_ticket = 9; */
        if (message.steam2Ticket !== undefined)
            writer.tag(9, WireType.LengthDelimited).bytes(message.steam2Ticket);
        /* optional int32 eresult_extended = 10; */
        if (message.eresultExtended !== undefined)
            writer.tag(10, WireType.Varint).int32(message.eresultExtended);
        /* optional string webapi_authenticate_user_nonce = 11; */
        if (message.webapiAuthenticateUserNonce !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.webapiAuthenticateUserNonce);
        /* optional uint32 cell_id_ping_threshold = 12; */
        if (message.cellIdPingThreshold !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.cellIdPingThreshold);
        /* optional bool deprecated_use_pics = 13; */
        if (message.deprecatedUsePics !== undefined)
            writer.tag(13, WireType.Varint).bool(message.deprecatedUsePics);
        /* optional string vanity_url = 14; */
        if (message.vanityUrl !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.vanityUrl);
        /* optional CMsgIPAddress public_ip = 15; */
        if (message.publicIp)
            CMsgIPAddress.internalBinaryWrite(message.publicIp, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional string user_country = 16; */
        if (message.userCountry !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.userCountry);
        /* optional fixed64 client_supplied_steamid = 20; */
        if (message.clientSuppliedSteamid !== undefined)
            writer.tag(20, WireType.Bit64).fixed64(message.clientSuppliedSteamid);
        /* optional string ip_country_code = 21; */
        if (message.ipCountryCode !== undefined)
            writer.tag(21, WireType.LengthDelimited).string(message.ipCountryCode);
        /* optional bytes parental_settings = 22; */
        if (message.parentalSettings !== undefined)
            writer.tag(22, WireType.LengthDelimited).bytes(message.parentalSettings);
        /* optional bytes parental_setting_signature = 23; */
        if (message.parentalSettingSignature !== undefined)
            writer.tag(23, WireType.LengthDelimited).bytes(message.parentalSettingSignature);
        /* optional int32 count_loginfailures_to_migrate = 24; */
        if (message.countLoginfailuresToMigrate !== undefined)
            writer.tag(24, WireType.Varint).int32(message.countLoginfailuresToMigrate);
        /* optional int32 count_disconnects_to_migrate = 25; */
        if (message.countDisconnectsToMigrate !== undefined)
            writer.tag(25, WireType.Varint).int32(message.countDisconnectsToMigrate);
        /* optional int32 ogs_data_report_time_window = 26; */
        if (message.ogsDataReportTimeWindow !== undefined)
            writer.tag(26, WireType.Varint).int32(message.ogsDataReportTimeWindow);
        /* optional uint64 client_instance_id = 27; */
        if (message.clientInstanceId !== undefined)
            writer.tag(27, WireType.Varint).uint64(message.clientInstanceId);
        /* optional bool force_client_update_check = 28; */
        if (message.forceClientUpdateCheck !== undefined)
            writer.tag(28, WireType.Varint).bool(message.forceClientUpdateCheck);
        /* optional string agreement_session_url = 29; */
        if (message.agreementSessionUrl !== undefined)
            writer.tag(29, WireType.LengthDelimited).string(message.agreementSessionUrl);
        /* optional uint64 token_id = 30; */
        if (message.tokenId !== undefined)
            writer.tag(30, WireType.Varint).uint64(message.tokenId);
        /* optional uint64 family_group_id = 31; */
        if (message.familyGroupId !== undefined)
            writer.tag(31, WireType.Varint).uint64(message.familyGroupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientLogonResponse
 */
export const CMsgClientLogonResponse = new CMsgClientLogonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientManageFriendsGroup$Type extends MessageType<CMsgClientManageFriendsGroup> {
    constructor() {
        super("CMsgClientManageFriendsGroup", [
            { no: 1, name: "groupid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "groupname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "steamid_friends_added", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "steamid_friends_removed", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientManageFriendsGroup>): CMsgClientManageFriendsGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamidFriendsAdded = [];
        message.steamidFriendsRemoved = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientManageFriendsGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientManageFriendsGroup): CMsgClientManageFriendsGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 groupid */ 1:
                    message.groupid = reader.int32();
                    break;
                case /* optional string groupname */ 2:
                    message.groupname = reader.string();
                    break;
                case /* repeated fixed64 steamid_friends_added */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamidFriendsAdded.push(reader.fixed64().toBigInt());
                    else
                        message.steamidFriendsAdded.push(reader.fixed64().toBigInt());
                    break;
                case /* repeated fixed64 steamid_friends_removed */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamidFriendsRemoved.push(reader.fixed64().toBigInt());
                    else
                        message.steamidFriendsRemoved.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientManageFriendsGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 groupid = 1; */
        if (message.groupid !== undefined)
            writer.tag(1, WireType.Varint).int32(message.groupid);
        /* optional string groupname = 2; */
        if (message.groupname !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.groupname);
        /* repeated fixed64 steamid_friends_added = 3; */
        for (let i = 0; i < message.steamidFriendsAdded.length; i++)
            writer.tag(3, WireType.Bit64).fixed64(message.steamidFriendsAdded[i]);
        /* repeated fixed64 steamid_friends_removed = 4; */
        for (let i = 0; i < message.steamidFriendsRemoved.length; i++)
            writer.tag(4, WireType.Bit64).fixed64(message.steamidFriendsRemoved[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientManageFriendsGroup
 */
export const CMsgClientManageFriendsGroup = new CMsgClientManageFriendsGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientManageFriendsGroupResponse$Type extends MessageType<CMsgClientManageFriendsGroupResponse> {
    constructor() {
        super("CMsgClientManageFriendsGroupResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientManageFriendsGroupResponse>): CMsgClientManageFriendsGroupResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientManageFriendsGroupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientManageFriendsGroupResponse): CMsgClientManageFriendsGroupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientManageFriendsGroupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientManageFriendsGroupResponse
 */
export const CMsgClientManageFriendsGroupResponse = new CMsgClientManageFriendsGroupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSCreateLobby$Type extends MessageType<CMsgClientMMSCreateLobby> {
    constructor() {
        super("CMsgClientMMSCreateLobby", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "max_members", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "lobby_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "lobby_flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "deprecated_public_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "metadata", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "persona_name_owner", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "public_ip", kind: "message", T: () => CMsgIPAddress }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSCreateLobby>): CMsgClientMMSCreateLobby {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSCreateLobby>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSCreateLobby): CMsgClientMMSCreateLobby {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional int32 max_members */ 2:
                    message.maxMembers = reader.int32();
                    break;
                case /* optional int32 lobby_type */ 3:
                    message.lobbyType = reader.int32();
                    break;
                case /* optional int32 lobby_flags */ 4:
                    message.lobbyFlags = reader.int32();
                    break;
                case /* optional uint32 cell_id */ 5:
                    message.cellId = reader.uint32();
                    break;
                case /* optional uint32 deprecated_public_ip */ 6:
                    message.deprecatedPublicIp = reader.uint32();
                    break;
                case /* optional bytes metadata */ 7:
                    message.metadata = reader.bytes();
                    break;
                case /* optional string persona_name_owner */ 8:
                    message.personaNameOwner = reader.string();
                    break;
                case /* optional CMsgIPAddress public_ip */ 9:
                    message.publicIp = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.publicIp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSCreateLobby, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional int32 max_members = 2; */
        if (message.maxMembers !== undefined)
            writer.tag(2, WireType.Varint).int32(message.maxMembers);
        /* optional int32 lobby_type = 3; */
        if (message.lobbyType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.lobbyType);
        /* optional int32 lobby_flags = 4; */
        if (message.lobbyFlags !== undefined)
            writer.tag(4, WireType.Varint).int32(message.lobbyFlags);
        /* optional uint32 cell_id = 5; */
        if (message.cellId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.cellId);
        /* optional uint32 deprecated_public_ip = 6; */
        if (message.deprecatedPublicIp !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.deprecatedPublicIp);
        /* optional bytes metadata = 7; */
        if (message.metadata !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.metadata);
        /* optional string persona_name_owner = 8; */
        if (message.personaNameOwner !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.personaNameOwner);
        /* optional CMsgIPAddress public_ip = 9; */
        if (message.publicIp)
            CMsgIPAddress.internalBinaryWrite(message.publicIp, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSCreateLobby
 */
export const CMsgClientMMSCreateLobby = new CMsgClientMMSCreateLobby$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSCreateLobbyResponse$Type extends MessageType<CMsgClientMMSCreateLobbyResponse> {
    constructor() {
        super("CMsgClientMMSCreateLobbyResponse", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSCreateLobbyResponse>): CMsgClientMMSCreateLobbyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSCreateLobbyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSCreateLobbyResponse): CMsgClientMMSCreateLobbyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 eresult = 3 [default = 2] */ 3:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSCreateLobbyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional int32 eresult = 3 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(3, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSCreateLobbyResponse
 */
export const CMsgClientMMSCreateLobbyResponse = new CMsgClientMMSCreateLobbyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSGetLobbyData$Type extends MessageType<CMsgClientMMSGetLobbyData> {
    constructor() {
        super("CMsgClientMMSGetLobbyData", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSGetLobbyData>): CMsgClientMMSGetLobbyData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSGetLobbyData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSGetLobbyData): CMsgClientMMSGetLobbyData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSGetLobbyData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSGetLobbyData
 */
export const CMsgClientMMSGetLobbyData = new CMsgClientMMSGetLobbyData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSGetLobbyList$Type extends MessageType<CMsgClientMMSGetLobbyList> {
    constructor() {
        super("CMsgClientMMSGetLobbyList", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "num_lobbies_requested", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "deprecated_public_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientMMSGetLobbyList_Filter },
            { no: 7, name: "public_ip", kind: "message", T: () => CMsgIPAddress }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSGetLobbyList>): CMsgClientMMSGetLobbyList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSGetLobbyList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSGetLobbyList): CMsgClientMMSGetLobbyList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional int32 num_lobbies_requested */ 3:
                    message.numLobbiesRequested = reader.int32();
                    break;
                case /* optional uint32 cell_id */ 4:
                    message.cellId = reader.uint32();
                    break;
                case /* optional uint32 deprecated_public_ip */ 5:
                    message.deprecatedPublicIp = reader.uint32();
                    break;
                case /* repeated CMsgClientMMSGetLobbyList_Filter filters */ 6:
                    message.filters.push(CMsgClientMMSGetLobbyList_Filter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional CMsgIPAddress public_ip */ 7:
                    message.publicIp = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.publicIp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSGetLobbyList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional int32 num_lobbies_requested = 3; */
        if (message.numLobbiesRequested !== undefined)
            writer.tag(3, WireType.Varint).int32(message.numLobbiesRequested);
        /* optional uint32 cell_id = 4; */
        if (message.cellId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.cellId);
        /* optional uint32 deprecated_public_ip = 5; */
        if (message.deprecatedPublicIp !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.deprecatedPublicIp);
        /* repeated CMsgClientMMSGetLobbyList_Filter filters = 6; */
        for (let i = 0; i < message.filters.length; i++)
            CMsgClientMMSGetLobbyList_Filter.internalBinaryWrite(message.filters[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgIPAddress public_ip = 7; */
        if (message.publicIp)
            CMsgIPAddress.internalBinaryWrite(message.publicIp, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSGetLobbyList
 */
export const CMsgClientMMSGetLobbyList = new CMsgClientMMSGetLobbyList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSGetLobbyList_Filter$Type extends MessageType<CMsgClientMMSGetLobbyList_Filter> {
    constructor() {
        super("CMsgClientMMSGetLobbyList_Filter", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "comparision", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "filter_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSGetLobbyList_Filter>): CMsgClientMMSGetLobbyList_Filter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSGetLobbyList_Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSGetLobbyList_Filter): CMsgClientMMSGetLobbyList_Filter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string key */ 1:
                    message.key = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                case /* optional int32 comparision */ 3:
                    message.comparision = reader.int32();
                    break;
                case /* optional int32 filter_type */ 4:
                    message.filterType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSGetLobbyList_Filter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* optional int32 comparision = 3; */
        if (message.comparision !== undefined)
            writer.tag(3, WireType.Varint).int32(message.comparision);
        /* optional int32 filter_type = 4; */
        if (message.filterType !== undefined)
            writer.tag(4, WireType.Varint).int32(message.filterType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSGetLobbyList_Filter
 */
export const CMsgClientMMSGetLobbyList_Filter = new CMsgClientMMSGetLobbyList_Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSGetLobbyListResponse$Type extends MessageType<CMsgClientMMSGetLobbyListResponse> {
    constructor() {
        super("CMsgClientMMSGetLobbyListResponse", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "lobbies", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientMMSGetLobbyListResponse_Lobby }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSGetLobbyListResponse>): CMsgClientMMSGetLobbyListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lobbies = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSGetLobbyListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSGetLobbyListResponse): CMsgClientMMSGetLobbyListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional int32 eresult = 3 [default = 2] */ 3:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgClientMMSGetLobbyListResponse_Lobby lobbies */ 4:
                    message.lobbies.push(CMsgClientMMSGetLobbyListResponse_Lobby.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSGetLobbyListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional int32 eresult = 3 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(3, WireType.Varint).int32(message.eresult);
        /* repeated CMsgClientMMSGetLobbyListResponse_Lobby lobbies = 4; */
        for (let i = 0; i < message.lobbies.length; i++)
            CMsgClientMMSGetLobbyListResponse_Lobby.internalBinaryWrite(message.lobbies[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSGetLobbyListResponse
 */
export const CMsgClientMMSGetLobbyListResponse = new CMsgClientMMSGetLobbyListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSGetLobbyListResponse_Lobby$Type extends MessageType<CMsgClientMMSGetLobbyListResponse_Lobby> {
    constructor() {
        super("CMsgClientMMSGetLobbyListResponse_Lobby", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_members", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "lobby_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "lobby_flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "metadata", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "num_members", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "distance", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "weight", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSGetLobbyListResponse_Lobby>): CMsgClientMMSGetLobbyListResponse_Lobby {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSGetLobbyListResponse_Lobby>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSGetLobbyListResponse_Lobby): CMsgClientMMSGetLobbyListResponse_Lobby {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 max_members */ 2:
                    message.maxMembers = reader.int32();
                    break;
                case /* optional int32 lobby_type */ 3:
                    message.lobbyType = reader.int32();
                    break;
                case /* optional int32 lobby_flags */ 4:
                    message.lobbyFlags = reader.int32();
                    break;
                case /* optional bytes metadata */ 5:
                    message.metadata = reader.bytes();
                    break;
                case /* optional int32 num_members */ 6:
                    message.numMembers = reader.int32();
                    break;
                case /* optional float distance */ 7:
                    message.distance = reader.float();
                    break;
                case /* optional int64 weight */ 8:
                    message.weight = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSGetLobbyListResponse_Lobby, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional int32 max_members = 2; */
        if (message.maxMembers !== undefined)
            writer.tag(2, WireType.Varint).int32(message.maxMembers);
        /* optional int32 lobby_type = 3; */
        if (message.lobbyType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.lobbyType);
        /* optional int32 lobby_flags = 4; */
        if (message.lobbyFlags !== undefined)
            writer.tag(4, WireType.Varint).int32(message.lobbyFlags);
        /* optional bytes metadata = 5; */
        if (message.metadata !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.metadata);
        /* optional int32 num_members = 6; */
        if (message.numMembers !== undefined)
            writer.tag(6, WireType.Varint).int32(message.numMembers);
        /* optional float distance = 7; */
        if (message.distance !== undefined)
            writer.tag(7, WireType.Bit32).float(message.distance);
        /* optional int64 weight = 8; */
        if (message.weight !== undefined)
            writer.tag(8, WireType.Varint).int64(message.weight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSGetLobbyListResponse_Lobby
 */
export const CMsgClientMMSGetLobbyListResponse_Lobby = new CMsgClientMMSGetLobbyListResponse_Lobby$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSGetLobbyStatus$Type extends MessageType<CMsgClientMMSGetLobbyStatus> {
    constructor() {
        super("CMsgClientMMSGetLobbyStatus", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "claim_membership", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "claim_ownership", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSGetLobbyStatus>): CMsgClientMMSGetLobbyStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSGetLobbyStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSGetLobbyStatus): CMsgClientMMSGetLobbyStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional bool claim_membership */ 3:
                    message.claimMembership = reader.bool();
                    break;
                case /* optional bool claim_ownership */ 4:
                    message.claimOwnership = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSGetLobbyStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional bool claim_membership = 3; */
        if (message.claimMembership !== undefined)
            writer.tag(3, WireType.Varint).bool(message.claimMembership);
        /* optional bool claim_ownership = 4; */
        if (message.claimOwnership !== undefined)
            writer.tag(4, WireType.Varint).bool(message.claimOwnership);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSGetLobbyStatus
 */
export const CMsgClientMMSGetLobbyStatus = new CMsgClientMMSGetLobbyStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSGetLobbyStatusResponse$Type extends MessageType<CMsgClientMMSGetLobbyStatusResponse> {
    constructor() {
        super("CMsgClientMMSGetLobbyStatusResponse", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "lobby_status", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSGetLobbyStatusResponse>): CMsgClientMMSGetLobbyStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSGetLobbyStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSGetLobbyStatusResponse): CMsgClientMMSGetLobbyStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 lobby_status */ 3:
                    message.lobbyStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSGetLobbyStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional int32 lobby_status = 3; */
        if (message.lobbyStatus !== undefined)
            writer.tag(3, WireType.Varint).int32(message.lobbyStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSGetLobbyStatusResponse
 */
export const CMsgClientMMSGetLobbyStatusResponse = new CMsgClientMMSGetLobbyStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSInviteToLobby$Type extends MessageType<CMsgClientMMSInviteToLobby> {
    constructor() {
        super("CMsgClientMMSInviteToLobby", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "steam_id_user_invited", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSInviteToLobby>): CMsgClientMMSInviteToLobby {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSInviteToLobby>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSInviteToLobby): CMsgClientMMSInviteToLobby {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_user_invited */ 3:
                    message.steamIdUserInvited = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSInviteToLobby, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional fixed64 steam_id_user_invited = 3; */
        if (message.steamIdUserInvited !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamIdUserInvited);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSInviteToLobby
 */
export const CMsgClientMMSInviteToLobby = new CMsgClientMMSInviteToLobby$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSJoinLobby$Type extends MessageType<CMsgClientMMSJoinLobby> {
    constructor() {
        super("CMsgClientMMSJoinLobby", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "persona_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSJoinLobby>): CMsgClientMMSJoinLobby {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSJoinLobby>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSJoinLobby): CMsgClientMMSJoinLobby {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional string persona_name */ 3:
                    message.personaName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSJoinLobby, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional string persona_name = 3; */
        if (message.personaName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.personaName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSJoinLobby
 */
export const CMsgClientMMSJoinLobby = new CMsgClientMMSJoinLobby$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSJoinLobbyResponse$Type extends MessageType<CMsgClientMMSJoinLobbyResponse> {
    constructor() {
        super("CMsgClientMMSJoinLobbyResponse", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "chat_room_enter_response", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "max_members", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "lobby_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "lobby_flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "steam_id_owner", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "metadata", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "members", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientMMSJoinLobbyResponse_Member }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSJoinLobbyResponse>): CMsgClientMMSJoinLobbyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.members = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSJoinLobbyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSJoinLobbyResponse): CMsgClientMMSJoinLobbyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 chat_room_enter_response */ 3:
                    message.chatRoomEnterResponse = reader.int32();
                    break;
                case /* optional int32 max_members */ 4:
                    message.maxMembers = reader.int32();
                    break;
                case /* optional int32 lobby_type */ 5:
                    message.lobbyType = reader.int32();
                    break;
                case /* optional int32 lobby_flags */ 6:
                    message.lobbyFlags = reader.int32();
                    break;
                case /* optional fixed64 steam_id_owner */ 7:
                    message.steamIdOwner = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes metadata */ 8:
                    message.metadata = reader.bytes();
                    break;
                case /* repeated CMsgClientMMSJoinLobbyResponse_Member members */ 9:
                    message.members.push(CMsgClientMMSJoinLobbyResponse_Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSJoinLobbyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional int32 chat_room_enter_response = 3; */
        if (message.chatRoomEnterResponse !== undefined)
            writer.tag(3, WireType.Varint).int32(message.chatRoomEnterResponse);
        /* optional int32 max_members = 4; */
        if (message.maxMembers !== undefined)
            writer.tag(4, WireType.Varint).int32(message.maxMembers);
        /* optional int32 lobby_type = 5; */
        if (message.lobbyType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.lobbyType);
        /* optional int32 lobby_flags = 6; */
        if (message.lobbyFlags !== undefined)
            writer.tag(6, WireType.Varint).int32(message.lobbyFlags);
        /* optional fixed64 steam_id_owner = 7; */
        if (message.steamIdOwner !== undefined)
            writer.tag(7, WireType.Bit64).fixed64(message.steamIdOwner);
        /* optional bytes metadata = 8; */
        if (message.metadata !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.metadata);
        /* repeated CMsgClientMMSJoinLobbyResponse_Member members = 9; */
        for (let i = 0; i < message.members.length; i++)
            CMsgClientMMSJoinLobbyResponse_Member.internalBinaryWrite(message.members[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSJoinLobbyResponse
 */
export const CMsgClientMMSJoinLobbyResponse = new CMsgClientMMSJoinLobbyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSJoinLobbyResponse_Member$Type extends MessageType<CMsgClientMMSJoinLobbyResponse_Member> {
    constructor() {
        super("CMsgClientMMSJoinLobbyResponse_Member", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "persona_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "metadata", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSJoinLobbyResponse_Member>): CMsgClientMMSJoinLobbyResponse_Member {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSJoinLobbyResponse_Member>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSJoinLobbyResponse_Member): CMsgClientMMSJoinLobbyResponse_Member {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional string persona_name */ 2:
                    message.personaName = reader.string();
                    break;
                case /* optional bytes metadata */ 3:
                    message.metadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSJoinLobbyResponse_Member, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional string persona_name = 2; */
        if (message.personaName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.personaName);
        /* optional bytes metadata = 3; */
        if (message.metadata !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSJoinLobbyResponse_Member
 */
export const CMsgClientMMSJoinLobbyResponse_Member = new CMsgClientMMSJoinLobbyResponse_Member$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSLeaveLobby$Type extends MessageType<CMsgClientMMSLeaveLobby> {
    constructor() {
        super("CMsgClientMMSLeaveLobby", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSLeaveLobby>): CMsgClientMMSLeaveLobby {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSLeaveLobby>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSLeaveLobby): CMsgClientMMSLeaveLobby {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSLeaveLobby, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSLeaveLobby
 */
export const CMsgClientMMSLeaveLobby = new CMsgClientMMSLeaveLobby$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSLeaveLobbyResponse$Type extends MessageType<CMsgClientMMSLeaveLobbyResponse> {
    constructor() {
        super("CMsgClientMMSLeaveLobbyResponse", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSLeaveLobbyResponse>): CMsgClientMMSLeaveLobbyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSLeaveLobbyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSLeaveLobbyResponse): CMsgClientMMSLeaveLobbyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 eresult = 3 [default = 2] */ 3:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSLeaveLobbyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional int32 eresult = 3 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(3, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSLeaveLobbyResponse
 */
export const CMsgClientMMSLeaveLobbyResponse = new CMsgClientMMSLeaveLobbyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSLobbyChatMsg$Type extends MessageType<CMsgClientMMSLobbyChatMsg> {
    constructor() {
        super("CMsgClientMMSLobbyChatMsg", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "steam_id_sender", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "lobby_message", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSLobbyChatMsg>): CMsgClientMMSLobbyChatMsg {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSLobbyChatMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSLobbyChatMsg): CMsgClientMMSLobbyChatMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_sender */ 3:
                    message.steamIdSender = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes lobby_message */ 4:
                    message.lobbyMessage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSLobbyChatMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional fixed64 steam_id_sender = 3; */
        if (message.steamIdSender !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamIdSender);
        /* optional bytes lobby_message = 4; */
        if (message.lobbyMessage !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.lobbyMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSLobbyChatMsg
 */
export const CMsgClientMMSLobbyChatMsg = new CMsgClientMMSLobbyChatMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSLobbyData$Type extends MessageType<CMsgClientMMSLobbyData> {
    constructor() {
        super("CMsgClientMMSLobbyData", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "num_members", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "max_members", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "lobby_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "lobby_flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "steam_id_owner", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "metadata", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "members", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientMMSLobbyData_Member },
            { no: 10, name: "lobby_cellid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "owner_should_accept_changes", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSLobbyData>): CMsgClientMMSLobbyData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.members = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSLobbyData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSLobbyData): CMsgClientMMSLobbyData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 num_members */ 3:
                    message.numMembers = reader.int32();
                    break;
                case /* optional int32 max_members */ 4:
                    message.maxMembers = reader.int32();
                    break;
                case /* optional int32 lobby_type */ 5:
                    message.lobbyType = reader.int32();
                    break;
                case /* optional int32 lobby_flags */ 6:
                    message.lobbyFlags = reader.int32();
                    break;
                case /* optional fixed64 steam_id_owner */ 7:
                    message.steamIdOwner = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes metadata */ 8:
                    message.metadata = reader.bytes();
                    break;
                case /* repeated CMsgClientMMSLobbyData_Member members */ 9:
                    message.members.push(CMsgClientMMSLobbyData_Member.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 lobby_cellid */ 10:
                    message.lobbyCellid = reader.uint32();
                    break;
                case /* optional bool owner_should_accept_changes */ 11:
                    message.ownerShouldAcceptChanges = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSLobbyData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional int32 num_members = 3; */
        if (message.numMembers !== undefined)
            writer.tag(3, WireType.Varint).int32(message.numMembers);
        /* optional int32 max_members = 4; */
        if (message.maxMembers !== undefined)
            writer.tag(4, WireType.Varint).int32(message.maxMembers);
        /* optional int32 lobby_type = 5; */
        if (message.lobbyType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.lobbyType);
        /* optional int32 lobby_flags = 6; */
        if (message.lobbyFlags !== undefined)
            writer.tag(6, WireType.Varint).int32(message.lobbyFlags);
        /* optional fixed64 steam_id_owner = 7; */
        if (message.steamIdOwner !== undefined)
            writer.tag(7, WireType.Bit64).fixed64(message.steamIdOwner);
        /* optional bytes metadata = 8; */
        if (message.metadata !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.metadata);
        /* repeated CMsgClientMMSLobbyData_Member members = 9; */
        for (let i = 0; i < message.members.length; i++)
            CMsgClientMMSLobbyData_Member.internalBinaryWrite(message.members[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 lobby_cellid = 10; */
        if (message.lobbyCellid !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.lobbyCellid);
        /* optional bool owner_should_accept_changes = 11; */
        if (message.ownerShouldAcceptChanges !== undefined)
            writer.tag(11, WireType.Varint).bool(message.ownerShouldAcceptChanges);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSLobbyData
 */
export const CMsgClientMMSLobbyData = new CMsgClientMMSLobbyData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSLobbyData_Member$Type extends MessageType<CMsgClientMMSLobbyData_Member> {
    constructor() {
        super("CMsgClientMMSLobbyData_Member", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "persona_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "metadata", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSLobbyData_Member>): CMsgClientMMSLobbyData_Member {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSLobbyData_Member>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSLobbyData_Member): CMsgClientMMSLobbyData_Member {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional string persona_name */ 2:
                    message.personaName = reader.string();
                    break;
                case /* optional bytes metadata */ 3:
                    message.metadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSLobbyData_Member, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional string persona_name = 2; */
        if (message.personaName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.personaName);
        /* optional bytes metadata = 3; */
        if (message.metadata !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSLobbyData_Member
 */
export const CMsgClientMMSLobbyData_Member = new CMsgClientMMSLobbyData_Member$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSLobbyGameServerSet$Type extends MessageType<CMsgClientMMSLobbyGameServerSet> {
    constructor() {
        super("CMsgClientMMSLobbyGameServerSet", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "deprecated_game_server_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "game_server_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "game_server_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "game_server_ip", kind: "message", T: () => CMsgIPAddress }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSLobbyGameServerSet>): CMsgClientMMSLobbyGameServerSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSLobbyGameServerSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSLobbyGameServerSet): CMsgClientMMSLobbyGameServerSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 deprecated_game_server_ip */ 3:
                    message.deprecatedGameServerIp = reader.uint32();
                    break;
                case /* optional uint32 game_server_port */ 4:
                    message.gameServerPort = reader.uint32();
                    break;
                case /* optional fixed64 game_server_steam_id */ 5:
                    message.gameServerSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional CMsgIPAddress game_server_ip */ 6:
                    message.gameServerIp = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.gameServerIp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSLobbyGameServerSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional uint32 deprecated_game_server_ip = 3; */
        if (message.deprecatedGameServerIp !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.deprecatedGameServerIp);
        /* optional uint32 game_server_port = 4; */
        if (message.gameServerPort !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.gameServerPort);
        /* optional fixed64 game_server_steam_id = 5; */
        if (message.gameServerSteamId !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.gameServerSteamId);
        /* optional CMsgIPAddress game_server_ip = 6; */
        if (message.gameServerIp)
            CMsgIPAddress.internalBinaryWrite(message.gameServerIp, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSLobbyGameServerSet
 */
export const CMsgClientMMSLobbyGameServerSet = new CMsgClientMMSLobbyGameServerSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSSendLobbyChatMsg$Type extends MessageType<CMsgClientMMSSendLobbyChatMsg> {
    constructor() {
        super("CMsgClientMMSSendLobbyChatMsg", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "steam_id_target", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "lobby_message", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSSendLobbyChatMsg>): CMsgClientMMSSendLobbyChatMsg {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSSendLobbyChatMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSSendLobbyChatMsg): CMsgClientMMSSendLobbyChatMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_target */ 3:
                    message.steamIdTarget = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes lobby_message */ 4:
                    message.lobbyMessage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSSendLobbyChatMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional fixed64 steam_id_target = 3; */
        if (message.steamIdTarget !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamIdTarget);
        /* optional bytes lobby_message = 4; */
        if (message.lobbyMessage !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.lobbyMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSSendLobbyChatMsg
 */
export const CMsgClientMMSSendLobbyChatMsg = new CMsgClientMMSSendLobbyChatMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSSetLobbyData$Type extends MessageType<CMsgClientMMSSetLobbyData> {
    constructor() {
        super("CMsgClientMMSSetLobbyData", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "steam_id_member", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "max_members", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "lobby_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "lobby_flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "metadata", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSSetLobbyData>): CMsgClientMMSSetLobbyData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSSetLobbyData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSSetLobbyData): CMsgClientMMSSetLobbyData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_member */ 3:
                    message.steamIdMember = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 max_members */ 4:
                    message.maxMembers = reader.int32();
                    break;
                case /* optional int32 lobby_type */ 5:
                    message.lobbyType = reader.int32();
                    break;
                case /* optional int32 lobby_flags */ 6:
                    message.lobbyFlags = reader.int32();
                    break;
                case /* optional bytes metadata */ 7:
                    message.metadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSSetLobbyData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional fixed64 steam_id_member = 3; */
        if (message.steamIdMember !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamIdMember);
        /* optional int32 max_members = 4; */
        if (message.maxMembers !== undefined)
            writer.tag(4, WireType.Varint).int32(message.maxMembers);
        /* optional int32 lobby_type = 5; */
        if (message.lobbyType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.lobbyType);
        /* optional int32 lobby_flags = 6; */
        if (message.lobbyFlags !== undefined)
            writer.tag(6, WireType.Varint).int32(message.lobbyFlags);
        /* optional bytes metadata = 7; */
        if (message.metadata !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSSetLobbyData
 */
export const CMsgClientMMSSetLobbyData = new CMsgClientMMSSetLobbyData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSSetLobbyDataResponse$Type extends MessageType<CMsgClientMMSSetLobbyDataResponse> {
    constructor() {
        super("CMsgClientMMSSetLobbyDataResponse", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSSetLobbyDataResponse>): CMsgClientMMSSetLobbyDataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSSetLobbyDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSSetLobbyDataResponse): CMsgClientMMSSetLobbyDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 eresult = 3 [default = 2] */ 3:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSSetLobbyDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional int32 eresult = 3 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(3, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSSetLobbyDataResponse
 */
export const CMsgClientMMSSetLobbyDataResponse = new CMsgClientMMSSetLobbyDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSSetLobbyGameServer$Type extends MessageType<CMsgClientMMSSetLobbyGameServer> {
    constructor() {
        super("CMsgClientMMSSetLobbyGameServer", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "deprecated_game_server_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "game_server_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "game_server_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "game_server_ip", kind: "message", T: () => CMsgIPAddress }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSSetLobbyGameServer>): CMsgClientMMSSetLobbyGameServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSSetLobbyGameServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSSetLobbyGameServer): CMsgClientMMSSetLobbyGameServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 deprecated_game_server_ip */ 3:
                    message.deprecatedGameServerIp = reader.uint32();
                    break;
                case /* optional uint32 game_server_port */ 4:
                    message.gameServerPort = reader.uint32();
                    break;
                case /* optional fixed64 game_server_steam_id */ 5:
                    message.gameServerSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional CMsgIPAddress game_server_ip */ 6:
                    message.gameServerIp = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.gameServerIp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSSetLobbyGameServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional uint32 deprecated_game_server_ip = 3; */
        if (message.deprecatedGameServerIp !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.deprecatedGameServerIp);
        /* optional uint32 game_server_port = 4; */
        if (message.gameServerPort !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.gameServerPort);
        /* optional fixed64 game_server_steam_id = 5; */
        if (message.gameServerSteamId !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.gameServerSteamId);
        /* optional CMsgIPAddress game_server_ip = 6; */
        if (message.gameServerIp)
            CMsgIPAddress.internalBinaryWrite(message.gameServerIp, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSSetLobbyGameServer
 */
export const CMsgClientMMSSetLobbyGameServer = new CMsgClientMMSSetLobbyGameServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSSetLobbyLinked$Type extends MessageType<CMsgClientMMSSetLobbyLinked> {
    constructor() {
        super("CMsgClientMMSSetLobbyLinked", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "steam_id_lobby2", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSSetLobbyLinked>): CMsgClientMMSSetLobbyLinked {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSSetLobbyLinked>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSSetLobbyLinked): CMsgClientMMSSetLobbyLinked {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_lobby2 */ 3:
                    message.steamIdLobby2 = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSSetLobbyLinked, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional fixed64 steam_id_lobby2 = 3; */
        if (message.steamIdLobby2 !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamIdLobby2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSSetLobbyLinked
 */
export const CMsgClientMMSSetLobbyLinked = new CMsgClientMMSSetLobbyLinked$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSSetLobbyOwner$Type extends MessageType<CMsgClientMMSSetLobbyOwner> {
    constructor() {
        super("CMsgClientMMSSetLobbyOwner", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "steam_id_new_owner", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSSetLobbyOwner>): CMsgClientMMSSetLobbyOwner {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSSetLobbyOwner>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSSetLobbyOwner): CMsgClientMMSSetLobbyOwner {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_new_owner */ 3:
                    message.steamIdNewOwner = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSSetLobbyOwner, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional fixed64 steam_id_new_owner = 3; */
        if (message.steamIdNewOwner !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamIdNewOwner);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSSetLobbyOwner
 */
export const CMsgClientMMSSetLobbyOwner = new CMsgClientMMSSetLobbyOwner$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSSetLobbyOwnerResponse$Type extends MessageType<CMsgClientMMSSetLobbyOwnerResponse> {
    constructor() {
        super("CMsgClientMMSSetLobbyOwnerResponse", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSSetLobbyOwnerResponse>): CMsgClientMMSSetLobbyOwnerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSSetLobbyOwnerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSSetLobbyOwnerResponse): CMsgClientMMSSetLobbyOwnerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 eresult = 3 [default = 2] */ 3:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSSetLobbyOwnerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional int32 eresult = 3 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(3, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSSetLobbyOwnerResponse
 */
export const CMsgClientMMSSetLobbyOwnerResponse = new CMsgClientMMSSetLobbyOwnerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSSetRatelimitPolicyOnClient$Type extends MessageType<CMsgClientMMSSetRatelimitPolicyOnClient> {
    constructor() {
        super("CMsgClientMMSSetRatelimitPolicyOnClient", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "enable_rate_limits", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "seconds_per_message", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "milliseconds_per_data_update", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSSetRatelimitPolicyOnClient>): CMsgClientMMSSetRatelimitPolicyOnClient {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSSetRatelimitPolicyOnClient>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSSetRatelimitPolicyOnClient): CMsgClientMMSSetRatelimitPolicyOnClient {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional bool enable_rate_limits */ 2:
                    message.enableRateLimits = reader.bool();
                    break;
                case /* optional int32 seconds_per_message */ 3:
                    message.secondsPerMessage = reader.int32();
                    break;
                case /* optional int32 milliseconds_per_data_update */ 4:
                    message.millisecondsPerDataUpdate = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSSetRatelimitPolicyOnClient, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional bool enable_rate_limits = 2; */
        if (message.enableRateLimits !== undefined)
            writer.tag(2, WireType.Varint).bool(message.enableRateLimits);
        /* optional int32 seconds_per_message = 3; */
        if (message.secondsPerMessage !== undefined)
            writer.tag(3, WireType.Varint).int32(message.secondsPerMessage);
        /* optional int32 milliseconds_per_data_update = 4; */
        if (message.millisecondsPerDataUpdate !== undefined)
            writer.tag(4, WireType.Varint).int32(message.millisecondsPerDataUpdate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSSetRatelimitPolicyOnClient
 */
export const CMsgClientMMSSetRatelimitPolicyOnClient = new CMsgClientMMSSetRatelimitPolicyOnClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSUserJoinedLobby$Type extends MessageType<CMsgClientMMSUserJoinedLobby> {
    constructor() {
        super("CMsgClientMMSUserJoinedLobby", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "steam_id_user", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "persona_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSUserJoinedLobby>): CMsgClientMMSUserJoinedLobby {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSUserJoinedLobby>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSUserJoinedLobby): CMsgClientMMSUserJoinedLobby {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_user */ 3:
                    message.steamIdUser = reader.fixed64().toBigInt();
                    break;
                case /* optional string persona_name */ 4:
                    message.personaName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSUserJoinedLobby, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional fixed64 steam_id_user = 3; */
        if (message.steamIdUser !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamIdUser);
        /* optional string persona_name = 4; */
        if (message.personaName !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.personaName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSUserJoinedLobby
 */
export const CMsgClientMMSUserJoinedLobby = new CMsgClientMMSUserJoinedLobby$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientMMSUserLeftLobby$Type extends MessageType<CMsgClientMMSUserLeftLobby> {
    constructor() {
        super("CMsgClientMMSUserLeftLobby", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steam_id_lobby", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "steam_id_user", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "persona_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientMMSUserLeftLobby>): CMsgClientMMSUserLeftLobby {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientMMSUserLeftLobby>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientMMSUserLeftLobby): CMsgClientMMSUserLeftLobby {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 steam_id_lobby */ 2:
                    message.steamIdLobby = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_user */ 3:
                    message.steamIdUser = reader.fixed64().toBigInt();
                    break;
                case /* optional string persona_name */ 4:
                    message.personaName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientMMSUserLeftLobby, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 steam_id_lobby = 2; */
        if (message.steamIdLobby !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdLobby);
        /* optional fixed64 steam_id_user = 3; */
        if (message.steamIdUser !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamIdUser);
        /* optional string persona_name = 4; */
        if (message.personaName !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.personaName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientMMSUserLeftLobby
 */
export const CMsgClientMMSUserLeftLobby = new CMsgClientMMSUserLeftLobby$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientNetworkingCertReply$Type extends MessageType<CMsgClientNetworkingCertReply> {
    constructor() {
        super("CMsgClientNetworkingCertReply", [
            { no: 4, name: "cert", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "ca_key_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "ca_signature", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientNetworkingCertReply>): CMsgClientNetworkingCertReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientNetworkingCertReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientNetworkingCertReply): CMsgClientNetworkingCertReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes cert */ 4:
                    message.cert = reader.bytes();
                    break;
                case /* optional fixed64 ca_key_id */ 5:
                    message.caKeyId = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes ca_signature */ 6:
                    message.caSignature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientNetworkingCertReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes cert = 4; */
        if (message.cert !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.cert);
        /* optional fixed64 ca_key_id = 5; */
        if (message.caKeyId !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.caKeyId);
        /* optional bytes ca_signature = 6; */
        if (message.caSignature !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.caSignature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientNetworkingCertReply
 */
export const CMsgClientNetworkingCertReply = new CMsgClientNetworkingCertReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientNetworkingCertRequest$Type extends MessageType<CMsgClientNetworkingCertRequest> {
    constructor() {
        super("CMsgClientNetworkingCertRequest", [
            { no: 2, name: "key_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientNetworkingCertRequest>): CMsgClientNetworkingCertRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientNetworkingCertRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientNetworkingCertRequest): CMsgClientNetworkingCertRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes key_data */ 2:
                    message.keyData = reader.bytes();
                    break;
                case /* optional uint32 app_id */ 3:
                    message.appId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientNetworkingCertRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes key_data = 2; */
        if (message.keyData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.keyData);
        /* optional uint32 app_id = 3; */
        if (message.appId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.appId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientNetworkingCertRequest
 */
export const CMsgClientNetworkingCertRequest = new CMsgClientNetworkingCertRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientNetworkingMobileCertReply$Type extends MessageType<CMsgClientNetworkingMobileCertReply> {
    constructor() {
        super("CMsgClientNetworkingMobileCertReply", [
            { no: 1, name: "encoded_cert", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientNetworkingMobileCertReply>): CMsgClientNetworkingMobileCertReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientNetworkingMobileCertReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientNetworkingMobileCertReply): CMsgClientNetworkingMobileCertReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string encoded_cert */ 1:
                    message.encodedCert = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientNetworkingMobileCertReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string encoded_cert = 1; */
        if (message.encodedCert !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.encodedCert);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientNetworkingMobileCertReply
 */
export const CMsgClientNetworkingMobileCertReply = new CMsgClientNetworkingMobileCertReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientNetworkingMobileCertRequest$Type extends MessageType<CMsgClientNetworkingMobileCertRequest> {
    constructor() {
        super("CMsgClientNetworkingMobileCertRequest", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientNetworkingMobileCertRequest>): CMsgClientNetworkingMobileCertRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientNetworkingMobileCertRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientNetworkingMobileCertRequest): CMsgClientNetworkingMobileCertRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientNetworkingMobileCertRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientNetworkingMobileCertRequest
 */
export const CMsgClientNetworkingMobileCertRequest = new CMsgClientNetworkingMobileCertRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientNewLoginKey$Type extends MessageType<CMsgClientNewLoginKey> {
    constructor() {
        super("CMsgClientNewLoginKey", [
            { no: 1, name: "unique_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "login_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientNewLoginKey>): CMsgClientNewLoginKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientNewLoginKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientNewLoginKey): CMsgClientNewLoginKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 unique_id */ 1:
                    message.uniqueId = reader.uint32();
                    break;
                case /* optional string login_key */ 2:
                    message.loginKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientNewLoginKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 unique_id = 1; */
        if (message.uniqueId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.uniqueId);
        /* optional string login_key = 2; */
        if (message.loginKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.loginKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientNewLoginKey
 */
export const CMsgClientNewLoginKey = new CMsgClientNewLoginKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientNewLoginKeyAccepted$Type extends MessageType<CMsgClientNewLoginKeyAccepted> {
    constructor() {
        super("CMsgClientNewLoginKeyAccepted", [
            { no: 1, name: "unique_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientNewLoginKeyAccepted>): CMsgClientNewLoginKeyAccepted {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientNewLoginKeyAccepted>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientNewLoginKeyAccepted): CMsgClientNewLoginKeyAccepted {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 unique_id */ 1:
                    message.uniqueId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientNewLoginKeyAccepted, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 unique_id = 1; */
        if (message.uniqueId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.uniqueId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientNewLoginKeyAccepted
 */
export const CMsgClientNewLoginKeyAccepted = new CMsgClientNewLoginKeyAccepted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientOfflineMessageNotification$Type extends MessageType<CMsgClientOfflineMessageNotification> {
    constructor() {
        super("CMsgClientOfflineMessageNotification", [
            { no: 1, name: "offline_messages", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "friends_with_offline_messages", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientOfflineMessageNotification>): CMsgClientOfflineMessageNotification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.friendsWithOfflineMessages = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientOfflineMessageNotification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientOfflineMessageNotification): CMsgClientOfflineMessageNotification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 offline_messages */ 1:
                    message.offlineMessages = reader.uint32();
                    break;
                case /* repeated uint32 friends_with_offline_messages */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.friendsWithOfflineMessages.push(reader.uint32());
                    else
                        message.friendsWithOfflineMessages.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientOfflineMessageNotification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 offline_messages = 1; */
        if (message.offlineMessages !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.offlineMessages);
        /* repeated uint32 friends_with_offline_messages = 2; */
        for (let i = 0; i < message.friendsWithOfflineMessages.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.friendsWithOfflineMessages[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientOfflineMessageNotification
 */
export const CMsgClientOfflineMessageNotification = new CMsgClientOfflineMessageNotification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientOGSReportBug$Type extends MessageType<CMsgClientOGSReportBug> {
    constructor() {
        super("CMsgClientOGSReportBug", [
            { no: 1, name: "sessionid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "bugtext", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "screenshot", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientOGSReportBug>): CMsgClientOGSReportBug {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientOGSReportBug>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientOGSReportBug): CMsgClientOGSReportBug {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 sessionid */ 1:
                    message.sessionid = reader.uint64().toBigInt();
                    break;
                case /* optional string bugtext */ 2:
                    message.bugtext = reader.string();
                    break;
                case /* optional bytes screenshot */ 3:
                    message.screenshot = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientOGSReportBug, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 sessionid = 1; */
        if (message.sessionid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.sessionid);
        /* optional string bugtext = 2; */
        if (message.bugtext !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.bugtext);
        /* optional bytes screenshot = 3; */
        if (message.screenshot !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.screenshot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientOGSReportBug
 */
export const CMsgClientOGSReportBug = new CMsgClientOGSReportBug$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientOGSReportString$Type extends MessageType<CMsgClientOGSReportString> {
    constructor() {
        super("CMsgClientOGSReportString", [
            { no: 1, name: "accumulated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "sessionid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "severity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "formatter", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "varargs", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientOGSReportString>): CMsgClientOGSReportString {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientOGSReportString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientOGSReportString): CMsgClientOGSReportString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool accumulated */ 1:
                    message.accumulated = reader.bool();
                    break;
                case /* optional uint64 sessionid */ 2:
                    message.sessionid = reader.uint64().toBigInt();
                    break;
                case /* optional int32 severity */ 3:
                    message.severity = reader.int32();
                    break;
                case /* optional string formatter */ 4:
                    message.formatter = reader.string();
                    break;
                case /* optional bytes varargs */ 5:
                    message.varargs = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientOGSReportString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool accumulated = 1; */
        if (message.accumulated !== undefined)
            writer.tag(1, WireType.Varint).bool(message.accumulated);
        /* optional uint64 sessionid = 2; */
        if (message.sessionid !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.sessionid);
        /* optional int32 severity = 3; */
        if (message.severity !== undefined)
            writer.tag(3, WireType.Varint).int32(message.severity);
        /* optional string formatter = 4; */
        if (message.formatter !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.formatter);
        /* optional bytes varargs = 5; */
        if (message.varargs !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.varargs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientOGSReportString
 */
export const CMsgClientOGSReportString = new CMsgClientOGSReportString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientP2PConnectionFailInfo$Type extends MessageType<CMsgClientP2PConnectionFailInfo> {
    constructor() {
        super("CMsgClientP2PConnectionFailInfo", [
            { no: 1, name: "steam_id_dest", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "steam_id_src", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "ep2p_session_error", kind: "scalar", jsonName: "ep2pSessionError", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "connection_id_dest", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "close_reason", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "close_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientP2PConnectionFailInfo>): CMsgClientP2PConnectionFailInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientP2PConnectionFailInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientP2PConnectionFailInfo): CMsgClientP2PConnectionFailInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_dest */ 1:
                    message.steamIdDest = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_src */ 2:
                    message.steamIdSrc = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 app_id */ 3:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 ep2p_session_error */ 4:
                    message.ep2PSessionError = reader.uint32();
                    break;
                case /* optional fixed64 connection_id_dest */ 5:
                    message.connectionIdDest = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 close_reason */ 7:
                    message.closeReason = reader.uint32();
                    break;
                case /* optional string close_message */ 8:
                    message.closeMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientP2PConnectionFailInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_dest = 1; */
        if (message.steamIdDest !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdDest);
        /* optional fixed64 steam_id_src = 2; */
        if (message.steamIdSrc !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdSrc);
        /* optional uint32 app_id = 3; */
        if (message.appId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.appId);
        /* optional uint32 ep2p_session_error = 4; */
        if (message.ep2PSessionError !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.ep2PSessionError);
        /* optional fixed64 connection_id_dest = 5; */
        if (message.connectionIdDest !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.connectionIdDest);
        /* optional uint32 close_reason = 7; */
        if (message.closeReason !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.closeReason);
        /* optional string close_message = 8; */
        if (message.closeMessage !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.closeMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientP2PConnectionFailInfo
 */
export const CMsgClientP2PConnectionFailInfo = new CMsgClientP2PConnectionFailInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientP2PConnectionInfo$Type extends MessageType<CMsgClientP2PConnectionInfo> {
    constructor() {
        super("CMsgClientP2PConnectionInfo", [
            { no: 1, name: "steam_id_dest", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "steam_id_src", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "candidate", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "connection_id_src", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "rendezvous", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientP2PConnectionInfo>): CMsgClientP2PConnectionInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientP2PConnectionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientP2PConnectionInfo): CMsgClientP2PConnectionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_dest */ 1:
                    message.steamIdDest = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steam_id_src */ 2:
                    message.steamIdSrc = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 app_id */ 3:
                    message.appId = reader.uint32();
                    break;
                case /* optional bytes candidate */ 4:
                    message.candidate = reader.bytes();
                    break;
                case /* optional fixed64 connection_id_src */ 5:
                    message.connectionIdSrc = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes rendezvous */ 6:
                    message.rendezvous = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientP2PConnectionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_dest = 1; */
        if (message.steamIdDest !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdDest);
        /* optional fixed64 steam_id_src = 2; */
        if (message.steamIdSrc !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamIdSrc);
        /* optional uint32 app_id = 3; */
        if (message.appId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.appId);
        /* optional bytes candidate = 4; */
        if (message.candidate !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.candidate);
        /* optional fixed64 connection_id_src = 5; */
        if (message.connectionIdSrc !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.connectionIdSrc);
        /* optional bytes rendezvous = 6; */
        if (message.rendezvous !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.rendezvous);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientP2PConnectionInfo
 */
export const CMsgClientP2PConnectionInfo = new CMsgClientP2PConnectionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPackageInfoRequest$Type extends MessageType<CMsgClientPackageInfoRequest> {
    constructor() {
        super("CMsgClientPackageInfoRequest", [
            { no: 1, name: "package_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "meta_data_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPackageInfoRequest>): CMsgClientPackageInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.packageIds = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPackageInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPackageInfoRequest): CMsgClientPackageInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 package_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packageIds.push(reader.uint32());
                    else
                        message.packageIds.push(reader.uint32());
                    break;
                case /* optional bool meta_data_only */ 2:
                    message.metaDataOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPackageInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 package_ids = 1; */
        for (let i = 0; i < message.packageIds.length; i++)
            writer.tag(1, WireType.Varint).uint32(message.packageIds[i]);
        /* optional bool meta_data_only = 2; */
        if (message.metaDataOnly !== undefined)
            writer.tag(2, WireType.Varint).bool(message.metaDataOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPackageInfoRequest
 */
export const CMsgClientPackageInfoRequest = new CMsgClientPackageInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPackageInfoResponse$Type extends MessageType<CMsgClientPackageInfoResponse> {
    constructor() {
        super("CMsgClientPackageInfoResponse", [
            { no: 1, name: "packages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPackageInfoResponse_Package },
            { no: 2, name: "packages_unknown", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "packages_pending", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPackageInfoResponse>): CMsgClientPackageInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.packages = [];
        message.packagesUnknown = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPackageInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPackageInfoResponse): CMsgClientPackageInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientPackageInfoResponse_Package packages */ 1:
                    message.packages.push(CMsgClientPackageInfoResponse_Package.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 packages_unknown */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packagesUnknown.push(reader.uint32());
                    else
                        message.packagesUnknown.push(reader.uint32());
                    break;
                case /* optional uint32 packages_pending */ 3:
                    message.packagesPending = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPackageInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientPackageInfoResponse_Package packages = 1; */
        for (let i = 0; i < message.packages.length; i++)
            CMsgClientPackageInfoResponse_Package.internalBinaryWrite(message.packages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 packages_unknown = 2; */
        for (let i = 0; i < message.packagesUnknown.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.packagesUnknown[i]);
        /* optional uint32 packages_pending = 3; */
        if (message.packagesPending !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.packagesPending);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPackageInfoResponse
 */
export const CMsgClientPackageInfoResponse = new CMsgClientPackageInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPackageInfoResponse_Package$Type extends MessageType<CMsgClientPackageInfoResponse_Package> {
    constructor() {
        super("CMsgClientPackageInfoResponse_Package", [
            { no: 1, name: "package_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "change_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sha", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "buffer", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPackageInfoResponse_Package>): CMsgClientPackageInfoResponse_Package {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPackageInfoResponse_Package>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPackageInfoResponse_Package): CMsgClientPackageInfoResponse_Package {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 package_id */ 1:
                    message.packageId = reader.uint32();
                    break;
                case /* optional uint32 change_number */ 2:
                    message.changeNumber = reader.uint32();
                    break;
                case /* optional bytes sha */ 3:
                    message.sha = reader.bytes();
                    break;
                case /* optional bytes buffer */ 4:
                    message.buffer = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPackageInfoResponse_Package, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 package_id = 1; */
        if (message.packageId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageId);
        /* optional uint32 change_number = 2; */
        if (message.changeNumber !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.changeNumber);
        /* optional bytes sha = 3; */
        if (message.sha !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.sha);
        /* optional bytes buffer = 4; */
        if (message.buffer !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.buffer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPackageInfoResponse_Package
 */
export const CMsgClientPackageInfoResponse_Package = new CMsgClientPackageInfoResponse_Package$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPersonaState$Type extends MessageType<CMsgClientPersonaState> {
    constructor() {
        super("CMsgClientPersonaState", [
            { no: 1, name: "status_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "friends", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPersonaState_Friend }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPersonaState>): CMsgClientPersonaState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.friends = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPersonaState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPersonaState): CMsgClientPersonaState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 status_flags */ 1:
                    message.statusFlags = reader.uint32();
                    break;
                case /* repeated CMsgClientPersonaState_Friend friends */ 2:
                    message.friends.push(CMsgClientPersonaState_Friend.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPersonaState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 status_flags = 1; */
        if (message.statusFlags !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.statusFlags);
        /* repeated CMsgClientPersonaState_Friend friends = 2; */
        for (let i = 0; i < message.friends.length; i++)
            CMsgClientPersonaState_Friend.internalBinaryWrite(message.friends[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPersonaState
 */
export const CMsgClientPersonaState = new CMsgClientPersonaState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPersonaState_Friend$Type extends MessageType<CMsgClientPersonaState_Friend> {
    constructor() {
        super("CMsgClientPersonaState_Friend", [
            { no: 1, name: "friendid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "persona_state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "game_played_app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "game_server_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "game_server_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "persona_state_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "online_session_instances", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "persona_set_by_user", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "player_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "query_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "steamid_source", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 31, name: "avatar_hash", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 45, name: "last_logoff", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 46, name: "last_logon", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 47, name: "last_seen_online", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 50, name: "clan_rank", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 55, name: "game_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 56, name: "gameid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 60, name: "game_data_blob", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 64, name: "clan_data", kind: "message", T: () => CMsgClientPersonaState_Friend_ClanData },
            { no: 65, name: "clan_tag", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 71, name: "rich_presence", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPersonaState_Friend_KV },
            { no: 72, name: "broadcast_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 73, name: "game_lobby_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 74, name: "watching_broadcast_accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 75, name: "watching_broadcast_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 76, name: "watching_broadcast_viewers", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 77, name: "watching_broadcast_title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 78, name: "is_community_banned", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 79, name: "player_name_pending_review", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 80, name: "avatar_pending_review", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 81, name: "on_steam_deck", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 82, name: "other_game_data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPersonaState_Friend_OtherGameData }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPersonaState_Friend>): CMsgClientPersonaState_Friend {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.richPresence = [];
        message.otherGameData = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPersonaState_Friend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPersonaState_Friend): CMsgClientPersonaState_Friend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 friendid */ 1:
                    message.friendid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 persona_state */ 2:
                    message.personaState = reader.uint32();
                    break;
                case /* optional uint32 game_played_app_id */ 3:
                    message.gamePlayedAppId = reader.uint32();
                    break;
                case /* optional uint32 game_server_ip */ 4:
                    message.gameServerIp = reader.uint32();
                    break;
                case /* optional uint32 game_server_port */ 5:
                    message.gameServerPort = reader.uint32();
                    break;
                case /* optional uint32 persona_state_flags */ 6:
                    message.personaStateFlags = reader.uint32();
                    break;
                case /* optional uint32 online_session_instances */ 7:
                    message.onlineSessionInstances = reader.uint32();
                    break;
                case /* optional bool persona_set_by_user */ 10:
                    message.personaSetByUser = reader.bool();
                    break;
                case /* optional string player_name */ 15:
                    message.playerName = reader.string();
                    break;
                case /* optional uint32 query_port */ 20:
                    message.queryPort = reader.uint32();
                    break;
                case /* optional fixed64 steamid_source */ 25:
                    message.steamidSource = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes avatar_hash */ 31:
                    message.avatarHash = reader.bytes();
                    break;
                case /* optional uint32 last_logoff */ 45:
                    message.lastLogoff = reader.uint32();
                    break;
                case /* optional uint32 last_logon */ 46:
                    message.lastLogon = reader.uint32();
                    break;
                case /* optional uint32 last_seen_online */ 47:
                    message.lastSeenOnline = reader.uint32();
                    break;
                case /* optional uint32 clan_rank */ 50:
                    message.clanRank = reader.uint32();
                    break;
                case /* optional string game_name */ 55:
                    message.gameName = reader.string();
                    break;
                case /* optional fixed64 gameid */ 56:
                    message.gameid = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes game_data_blob */ 60:
                    message.gameDataBlob = reader.bytes();
                    break;
                case /* optional CMsgClientPersonaState_Friend_ClanData clan_data */ 64:
                    message.clanData = CMsgClientPersonaState_Friend_ClanData.internalBinaryRead(reader, reader.uint32(), options, message.clanData);
                    break;
                case /* optional string clan_tag */ 65:
                    message.clanTag = reader.string();
                    break;
                case /* repeated CMsgClientPersonaState_Friend_KV rich_presence */ 71:
                    message.richPresence.push(CMsgClientPersonaState_Friend_KV.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional fixed64 broadcast_id */ 72:
                    message.broadcastId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 game_lobby_id */ 73:
                    message.gameLobbyId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 watching_broadcast_accountid */ 74:
                    message.watchingBroadcastAccountid = reader.uint32();
                    break;
                case /* optional uint32 watching_broadcast_appid */ 75:
                    message.watchingBroadcastAppid = reader.uint32();
                    break;
                case /* optional uint32 watching_broadcast_viewers */ 76:
                    message.watchingBroadcastViewers = reader.uint32();
                    break;
                case /* optional string watching_broadcast_title */ 77:
                    message.watchingBroadcastTitle = reader.string();
                    break;
                case /* optional bool is_community_banned */ 78:
                    message.isCommunityBanned = reader.bool();
                    break;
                case /* optional bool player_name_pending_review */ 79:
                    message.playerNamePendingReview = reader.bool();
                    break;
                case /* optional bool avatar_pending_review */ 80:
                    message.avatarPendingReview = reader.bool();
                    break;
                case /* optional bool on_steam_deck */ 81:
                    message.onSteamDeck = reader.bool();
                    break;
                case /* repeated CMsgClientPersonaState_Friend_OtherGameData other_game_data */ 82:
                    message.otherGameData.push(CMsgClientPersonaState_Friend_OtherGameData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPersonaState_Friend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 friendid = 1; */
        if (message.friendid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.friendid);
        /* optional uint32 persona_state = 2; */
        if (message.personaState !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.personaState);
        /* optional uint32 game_played_app_id = 3; */
        if (message.gamePlayedAppId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.gamePlayedAppId);
        /* optional uint32 game_server_ip = 4; */
        if (message.gameServerIp !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.gameServerIp);
        /* optional uint32 game_server_port = 5; */
        if (message.gameServerPort !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.gameServerPort);
        /* optional uint32 persona_state_flags = 6; */
        if (message.personaStateFlags !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.personaStateFlags);
        /* optional uint32 online_session_instances = 7; */
        if (message.onlineSessionInstances !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.onlineSessionInstances);
        /* optional bool persona_set_by_user = 10; */
        if (message.personaSetByUser !== undefined)
            writer.tag(10, WireType.Varint).bool(message.personaSetByUser);
        /* optional string player_name = 15; */
        if (message.playerName !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.playerName);
        /* optional uint32 query_port = 20; */
        if (message.queryPort !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.queryPort);
        /* optional fixed64 steamid_source = 25; */
        if (message.steamidSource !== undefined)
            writer.tag(25, WireType.Bit64).fixed64(message.steamidSource);
        /* optional bytes avatar_hash = 31; */
        if (message.avatarHash !== undefined)
            writer.tag(31, WireType.LengthDelimited).bytes(message.avatarHash);
        /* optional uint32 last_logoff = 45; */
        if (message.lastLogoff !== undefined)
            writer.tag(45, WireType.Varint).uint32(message.lastLogoff);
        /* optional uint32 last_logon = 46; */
        if (message.lastLogon !== undefined)
            writer.tag(46, WireType.Varint).uint32(message.lastLogon);
        /* optional uint32 last_seen_online = 47; */
        if (message.lastSeenOnline !== undefined)
            writer.tag(47, WireType.Varint).uint32(message.lastSeenOnline);
        /* optional uint32 clan_rank = 50; */
        if (message.clanRank !== undefined)
            writer.tag(50, WireType.Varint).uint32(message.clanRank);
        /* optional string game_name = 55; */
        if (message.gameName !== undefined)
            writer.tag(55, WireType.LengthDelimited).string(message.gameName);
        /* optional fixed64 gameid = 56; */
        if (message.gameid !== undefined)
            writer.tag(56, WireType.Bit64).fixed64(message.gameid);
        /* optional bytes game_data_blob = 60; */
        if (message.gameDataBlob !== undefined)
            writer.tag(60, WireType.LengthDelimited).bytes(message.gameDataBlob);
        /* optional CMsgClientPersonaState_Friend_ClanData clan_data = 64; */
        if (message.clanData)
            CMsgClientPersonaState_Friend_ClanData.internalBinaryWrite(message.clanData, writer.tag(64, WireType.LengthDelimited).fork(), options).join();
        /* optional string clan_tag = 65; */
        if (message.clanTag !== undefined)
            writer.tag(65, WireType.LengthDelimited).string(message.clanTag);
        /* repeated CMsgClientPersonaState_Friend_KV rich_presence = 71; */
        for (let i = 0; i < message.richPresence.length; i++)
            CMsgClientPersonaState_Friend_KV.internalBinaryWrite(message.richPresence[i], writer.tag(71, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 broadcast_id = 72; */
        if (message.broadcastId !== undefined)
            writer.tag(72, WireType.Bit64).fixed64(message.broadcastId);
        /* optional fixed64 game_lobby_id = 73; */
        if (message.gameLobbyId !== undefined)
            writer.tag(73, WireType.Bit64).fixed64(message.gameLobbyId);
        /* optional uint32 watching_broadcast_accountid = 74; */
        if (message.watchingBroadcastAccountid !== undefined)
            writer.tag(74, WireType.Varint).uint32(message.watchingBroadcastAccountid);
        /* optional uint32 watching_broadcast_appid = 75; */
        if (message.watchingBroadcastAppid !== undefined)
            writer.tag(75, WireType.Varint).uint32(message.watchingBroadcastAppid);
        /* optional uint32 watching_broadcast_viewers = 76; */
        if (message.watchingBroadcastViewers !== undefined)
            writer.tag(76, WireType.Varint).uint32(message.watchingBroadcastViewers);
        /* optional string watching_broadcast_title = 77; */
        if (message.watchingBroadcastTitle !== undefined)
            writer.tag(77, WireType.LengthDelimited).string(message.watchingBroadcastTitle);
        /* optional bool is_community_banned = 78; */
        if (message.isCommunityBanned !== undefined)
            writer.tag(78, WireType.Varint).bool(message.isCommunityBanned);
        /* optional bool player_name_pending_review = 79; */
        if (message.playerNamePendingReview !== undefined)
            writer.tag(79, WireType.Varint).bool(message.playerNamePendingReview);
        /* optional bool avatar_pending_review = 80; */
        if (message.avatarPendingReview !== undefined)
            writer.tag(80, WireType.Varint).bool(message.avatarPendingReview);
        /* optional bool on_steam_deck = 81; */
        if (message.onSteamDeck !== undefined)
            writer.tag(81, WireType.Varint).bool(message.onSteamDeck);
        /* repeated CMsgClientPersonaState_Friend_OtherGameData other_game_data = 82; */
        for (let i = 0; i < message.otherGameData.length; i++)
            CMsgClientPersonaState_Friend_OtherGameData.internalBinaryWrite(message.otherGameData[i], writer.tag(82, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPersonaState_Friend
 */
export const CMsgClientPersonaState_Friend = new CMsgClientPersonaState_Friend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPersonaState_Friend_ClanData$Type extends MessageType<CMsgClientPersonaState_Friend_ClanData> {
    constructor() {
        super("CMsgClientPersonaState_Friend_ClanData", [
            { no: 1, name: "ogg_app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "chat_group_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPersonaState_Friend_ClanData>): CMsgClientPersonaState_Friend_ClanData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPersonaState_Friend_ClanData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPersonaState_Friend_ClanData): CMsgClientPersonaState_Friend_ClanData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 ogg_app_id */ 1:
                    message.oggAppId = reader.uint32();
                    break;
                case /* optional uint64 chat_group_id */ 2:
                    message.chatGroupId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPersonaState_Friend_ClanData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 ogg_app_id = 1; */
        if (message.oggAppId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.oggAppId);
        /* optional uint64 chat_group_id = 2; */
        if (message.chatGroupId !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.chatGroupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPersonaState_Friend_ClanData
 */
export const CMsgClientPersonaState_Friend_ClanData = new CMsgClientPersonaState_Friend_ClanData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPersonaState_Friend_KV$Type extends MessageType<CMsgClientPersonaState_Friend_KV> {
    constructor() {
        super("CMsgClientPersonaState_Friend_KV", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPersonaState_Friend_KV>): CMsgClientPersonaState_Friend_KV {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPersonaState_Friend_KV>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPersonaState_Friend_KV): CMsgClientPersonaState_Friend_KV {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string key */ 1:
                    message.key = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPersonaState_Friend_KV, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPersonaState_Friend_KV
 */
export const CMsgClientPersonaState_Friend_KV = new CMsgClientPersonaState_Friend_KV$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPersonaState_Friend_OtherGameData$Type extends MessageType<CMsgClientPersonaState_Friend_OtherGameData> {
    constructor() {
        super("CMsgClientPersonaState_Friend_OtherGameData", [
            { no: 1, name: "gameid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "rich_presence", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPersonaState_Friend_KV }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPersonaState_Friend_OtherGameData>): CMsgClientPersonaState_Friend_OtherGameData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.richPresence = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPersonaState_Friend_OtherGameData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPersonaState_Friend_OtherGameData): CMsgClientPersonaState_Friend_OtherGameData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 gameid */ 1:
                    message.gameid = reader.uint64().toBigInt();
                    break;
                case /* repeated CMsgClientPersonaState_Friend_KV rich_presence */ 2:
                    message.richPresence.push(CMsgClientPersonaState_Friend_KV.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPersonaState_Friend_OtherGameData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 gameid = 1; */
        if (message.gameid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.gameid);
        /* repeated CMsgClientPersonaState_Friend_KV rich_presence = 2; */
        for (let i = 0; i < message.richPresence.length; i++)
            CMsgClientPersonaState_Friend_KV.internalBinaryWrite(message.richPresence[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPersonaState_Friend_OtherGameData
 */
export const CMsgClientPersonaState_Friend_OtherGameData = new CMsgClientPersonaState_Friend_OtherGameData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSAccessTokenRequest$Type extends MessageType<CMsgClientPICSAccessTokenRequest> {
    constructor() {
        super("CMsgClientPICSAccessTokenRequest", [
            { no: 1, name: "packageids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "appids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSAccessTokenRequest>): CMsgClientPICSAccessTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.packageids = [];
        message.appids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSAccessTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSAccessTokenRequest): CMsgClientPICSAccessTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 packageids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packageids.push(reader.uint32());
                    else
                        message.packageids.push(reader.uint32());
                    break;
                case /* repeated uint32 appids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.appids.push(reader.uint32());
                    else
                        message.appids.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSAccessTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 packageids = 1; */
        for (let i = 0; i < message.packageids.length; i++)
            writer.tag(1, WireType.Varint).uint32(message.packageids[i]);
        /* repeated uint32 appids = 2; */
        for (let i = 0; i < message.appids.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.appids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSAccessTokenRequest
 */
export const CMsgClientPICSAccessTokenRequest = new CMsgClientPICSAccessTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSAccessTokenResponse$Type extends MessageType<CMsgClientPICSAccessTokenResponse> {
    constructor() {
        super("CMsgClientPICSAccessTokenResponse", [
            { no: 1, name: "package_access_tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPICSAccessTokenResponse_PackageToken },
            { no: 2, name: "package_denied_tokens", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "app_access_tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPICSAccessTokenResponse_AppToken },
            { no: 4, name: "app_denied_tokens", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSAccessTokenResponse>): CMsgClientPICSAccessTokenResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.packageAccessTokens = [];
        message.packageDeniedTokens = [];
        message.appAccessTokens = [];
        message.appDeniedTokens = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSAccessTokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSAccessTokenResponse): CMsgClientPICSAccessTokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientPICSAccessTokenResponse_PackageToken package_access_tokens */ 1:
                    message.packageAccessTokens.push(CMsgClientPICSAccessTokenResponse_PackageToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 package_denied_tokens */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packageDeniedTokens.push(reader.uint32());
                    else
                        message.packageDeniedTokens.push(reader.uint32());
                    break;
                case /* repeated CMsgClientPICSAccessTokenResponse_AppToken app_access_tokens */ 3:
                    message.appAccessTokens.push(CMsgClientPICSAccessTokenResponse_AppToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 app_denied_tokens */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.appDeniedTokens.push(reader.uint32());
                    else
                        message.appDeniedTokens.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSAccessTokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientPICSAccessTokenResponse_PackageToken package_access_tokens = 1; */
        for (let i = 0; i < message.packageAccessTokens.length; i++)
            CMsgClientPICSAccessTokenResponse_PackageToken.internalBinaryWrite(message.packageAccessTokens[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 package_denied_tokens = 2; */
        for (let i = 0; i < message.packageDeniedTokens.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.packageDeniedTokens[i]);
        /* repeated CMsgClientPICSAccessTokenResponse_AppToken app_access_tokens = 3; */
        for (let i = 0; i < message.appAccessTokens.length; i++)
            CMsgClientPICSAccessTokenResponse_AppToken.internalBinaryWrite(message.appAccessTokens[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 app_denied_tokens = 4; */
        for (let i = 0; i < message.appDeniedTokens.length; i++)
            writer.tag(4, WireType.Varint).uint32(message.appDeniedTokens[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSAccessTokenResponse
 */
export const CMsgClientPICSAccessTokenResponse = new CMsgClientPICSAccessTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSAccessTokenResponse_AppToken$Type extends MessageType<CMsgClientPICSAccessTokenResponse_AppToken> {
    constructor() {
        super("CMsgClientPICSAccessTokenResponse_AppToken", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "access_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSAccessTokenResponse_AppToken>): CMsgClientPICSAccessTokenResponse_AppToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSAccessTokenResponse_AppToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSAccessTokenResponse_AppToken): CMsgClientPICSAccessTokenResponse_AppToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint64 access_token */ 2:
                    message.accessToken = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSAccessTokenResponse_AppToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint64 access_token = 2; */
        if (message.accessToken !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.accessToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSAccessTokenResponse_AppToken
 */
export const CMsgClientPICSAccessTokenResponse_AppToken = new CMsgClientPICSAccessTokenResponse_AppToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSAccessTokenResponse_PackageToken$Type extends MessageType<CMsgClientPICSAccessTokenResponse_PackageToken> {
    constructor() {
        super("CMsgClientPICSAccessTokenResponse_PackageToken", [
            { no: 1, name: "packageid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "access_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSAccessTokenResponse_PackageToken>): CMsgClientPICSAccessTokenResponse_PackageToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSAccessTokenResponse_PackageToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSAccessTokenResponse_PackageToken): CMsgClientPICSAccessTokenResponse_PackageToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 packageid */ 1:
                    message.packageid = reader.uint32();
                    break;
                case /* optional uint64 access_token */ 2:
                    message.accessToken = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSAccessTokenResponse_PackageToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 packageid = 1; */
        if (message.packageid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageid);
        /* optional uint64 access_token = 2; */
        if (message.accessToken !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.accessToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSAccessTokenResponse_PackageToken
 */
export const CMsgClientPICSAccessTokenResponse_PackageToken = new CMsgClientPICSAccessTokenResponse_PackageToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSChangesSinceRequest$Type extends MessageType<CMsgClientPICSChangesSinceRequest> {
    constructor() {
        super("CMsgClientPICSChangesSinceRequest", [
            { no: 1, name: "since_change_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "send_app_info_changes", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "send_package_info_changes", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "num_app_info_cached", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "num_package_info_cached", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSChangesSinceRequest>): CMsgClientPICSChangesSinceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSChangesSinceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSChangesSinceRequest): CMsgClientPICSChangesSinceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 since_change_number */ 1:
                    message.sinceChangeNumber = reader.uint32();
                    break;
                case /* optional bool send_app_info_changes */ 2:
                    message.sendAppInfoChanges = reader.bool();
                    break;
                case /* optional bool send_package_info_changes */ 3:
                    message.sendPackageInfoChanges = reader.bool();
                    break;
                case /* optional uint32 num_app_info_cached */ 4:
                    message.numAppInfoCached = reader.uint32();
                    break;
                case /* optional uint32 num_package_info_cached */ 5:
                    message.numPackageInfoCached = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSChangesSinceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 since_change_number = 1; */
        if (message.sinceChangeNumber !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.sinceChangeNumber);
        /* optional bool send_app_info_changes = 2; */
        if (message.sendAppInfoChanges !== undefined)
            writer.tag(2, WireType.Varint).bool(message.sendAppInfoChanges);
        /* optional bool send_package_info_changes = 3; */
        if (message.sendPackageInfoChanges !== undefined)
            writer.tag(3, WireType.Varint).bool(message.sendPackageInfoChanges);
        /* optional uint32 num_app_info_cached = 4; */
        if (message.numAppInfoCached !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.numAppInfoCached);
        /* optional uint32 num_package_info_cached = 5; */
        if (message.numPackageInfoCached !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.numPackageInfoCached);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSChangesSinceRequest
 */
export const CMsgClientPICSChangesSinceRequest = new CMsgClientPICSChangesSinceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSChangesSinceResponse$Type extends MessageType<CMsgClientPICSChangesSinceResponse> {
    constructor() {
        super("CMsgClientPICSChangesSinceResponse", [
            { no: 1, name: "current_change_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "since_change_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "force_full_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "package_changes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPICSChangesSinceResponse_PackageChange },
            { no: 5, name: "app_changes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPICSChangesSinceResponse_AppChange },
            { no: 6, name: "force_full_app_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "force_full_package_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSChangesSinceResponse>): CMsgClientPICSChangesSinceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.packageChanges = [];
        message.appChanges = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSChangesSinceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSChangesSinceResponse): CMsgClientPICSChangesSinceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 current_change_number */ 1:
                    message.currentChangeNumber = reader.uint32();
                    break;
                case /* optional uint32 since_change_number */ 2:
                    message.sinceChangeNumber = reader.uint32();
                    break;
                case /* optional bool force_full_update */ 3:
                    message.forceFullUpdate = reader.bool();
                    break;
                case /* repeated CMsgClientPICSChangesSinceResponse_PackageChange package_changes */ 4:
                    message.packageChanges.push(CMsgClientPICSChangesSinceResponse_PackageChange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgClientPICSChangesSinceResponse_AppChange app_changes */ 5:
                    message.appChanges.push(CMsgClientPICSChangesSinceResponse_AppChange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool force_full_app_update */ 6:
                    message.forceFullAppUpdate = reader.bool();
                    break;
                case /* optional bool force_full_package_update */ 7:
                    message.forceFullPackageUpdate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSChangesSinceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 current_change_number = 1; */
        if (message.currentChangeNumber !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.currentChangeNumber);
        /* optional uint32 since_change_number = 2; */
        if (message.sinceChangeNumber !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.sinceChangeNumber);
        /* optional bool force_full_update = 3; */
        if (message.forceFullUpdate !== undefined)
            writer.tag(3, WireType.Varint).bool(message.forceFullUpdate);
        /* repeated CMsgClientPICSChangesSinceResponse_PackageChange package_changes = 4; */
        for (let i = 0; i < message.packageChanges.length; i++)
            CMsgClientPICSChangesSinceResponse_PackageChange.internalBinaryWrite(message.packageChanges[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgClientPICSChangesSinceResponse_AppChange app_changes = 5; */
        for (let i = 0; i < message.appChanges.length; i++)
            CMsgClientPICSChangesSinceResponse_AppChange.internalBinaryWrite(message.appChanges[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional bool force_full_app_update = 6; */
        if (message.forceFullAppUpdate !== undefined)
            writer.tag(6, WireType.Varint).bool(message.forceFullAppUpdate);
        /* optional bool force_full_package_update = 7; */
        if (message.forceFullPackageUpdate !== undefined)
            writer.tag(7, WireType.Varint).bool(message.forceFullPackageUpdate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSChangesSinceResponse
 */
export const CMsgClientPICSChangesSinceResponse = new CMsgClientPICSChangesSinceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSChangesSinceResponse_AppChange$Type extends MessageType<CMsgClientPICSChangesSinceResponse_AppChange> {
    constructor() {
        super("CMsgClientPICSChangesSinceResponse_AppChange", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "change_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "needs_token", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSChangesSinceResponse_AppChange>): CMsgClientPICSChangesSinceResponse_AppChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSChangesSinceResponse_AppChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSChangesSinceResponse_AppChange): CMsgClientPICSChangesSinceResponse_AppChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 change_number */ 2:
                    message.changeNumber = reader.uint32();
                    break;
                case /* optional bool needs_token */ 3:
                    message.needsToken = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSChangesSinceResponse_AppChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 change_number = 2; */
        if (message.changeNumber !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.changeNumber);
        /* optional bool needs_token = 3; */
        if (message.needsToken !== undefined)
            writer.tag(3, WireType.Varint).bool(message.needsToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSChangesSinceResponse_AppChange
 */
export const CMsgClientPICSChangesSinceResponse_AppChange = new CMsgClientPICSChangesSinceResponse_AppChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSChangesSinceResponse_PackageChange$Type extends MessageType<CMsgClientPICSChangesSinceResponse_PackageChange> {
    constructor() {
        super("CMsgClientPICSChangesSinceResponse_PackageChange", [
            { no: 1, name: "packageid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "change_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "needs_token", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSChangesSinceResponse_PackageChange>): CMsgClientPICSChangesSinceResponse_PackageChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSChangesSinceResponse_PackageChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSChangesSinceResponse_PackageChange): CMsgClientPICSChangesSinceResponse_PackageChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 packageid */ 1:
                    message.packageid = reader.uint32();
                    break;
                case /* optional uint32 change_number */ 2:
                    message.changeNumber = reader.uint32();
                    break;
                case /* optional bool needs_token */ 3:
                    message.needsToken = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSChangesSinceResponse_PackageChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 packageid = 1; */
        if (message.packageid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageid);
        /* optional uint32 change_number = 2; */
        if (message.changeNumber !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.changeNumber);
        /* optional bool needs_token = 3; */
        if (message.needsToken !== undefined)
            writer.tag(3, WireType.Varint).bool(message.needsToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSChangesSinceResponse_PackageChange
 */
export const CMsgClientPICSChangesSinceResponse_PackageChange = new CMsgClientPICSChangesSinceResponse_PackageChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSProductInfoRequest$Type extends MessageType<CMsgClientPICSProductInfoRequest> {
    constructor() {
        super("CMsgClientPICSProductInfoRequest", [
            { no: 1, name: "packages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPICSProductInfoRequest_PackageInfo },
            { no: 2, name: "apps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPICSProductInfoRequest_AppInfo },
            { no: 3, name: "meta_data_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "num_prev_failed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "supports_package_tokens", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSProductInfoRequest>): CMsgClientPICSProductInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.packages = [];
        message.apps = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSProductInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSProductInfoRequest): CMsgClientPICSProductInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientPICSProductInfoRequest_PackageInfo packages */ 1:
                    message.packages.push(CMsgClientPICSProductInfoRequest_PackageInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgClientPICSProductInfoRequest_AppInfo apps */ 2:
                    message.apps.push(CMsgClientPICSProductInfoRequest_AppInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool meta_data_only */ 3:
                    message.metaDataOnly = reader.bool();
                    break;
                case /* optional uint32 num_prev_failed */ 4:
                    message.numPrevFailed = reader.uint32();
                    break;
                case /* optional uint32 supports_package_tokens */ 5:
                    message.supportsPackageTokens = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSProductInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientPICSProductInfoRequest_PackageInfo packages = 1; */
        for (let i = 0; i < message.packages.length; i++)
            CMsgClientPICSProductInfoRequest_PackageInfo.internalBinaryWrite(message.packages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgClientPICSProductInfoRequest_AppInfo apps = 2; */
        for (let i = 0; i < message.apps.length; i++)
            CMsgClientPICSProductInfoRequest_AppInfo.internalBinaryWrite(message.apps[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional bool meta_data_only = 3; */
        if (message.metaDataOnly !== undefined)
            writer.tag(3, WireType.Varint).bool(message.metaDataOnly);
        /* optional uint32 num_prev_failed = 4; */
        if (message.numPrevFailed !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.numPrevFailed);
        /* optional uint32 supports_package_tokens = 5; */
        if (message.supportsPackageTokens !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.supportsPackageTokens);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSProductInfoRequest
 */
export const CMsgClientPICSProductInfoRequest = new CMsgClientPICSProductInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSProductInfoRequest_AppInfo$Type extends MessageType<CMsgClientPICSProductInfoRequest_AppInfo> {
    constructor() {
        super("CMsgClientPICSProductInfoRequest_AppInfo", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "access_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "only_public_obsolete", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSProductInfoRequest_AppInfo>): CMsgClientPICSProductInfoRequest_AppInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSProductInfoRequest_AppInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSProductInfoRequest_AppInfo): CMsgClientPICSProductInfoRequest_AppInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint64 access_token */ 2:
                    message.accessToken = reader.uint64().toBigInt();
                    break;
                case /* optional bool only_public_obsolete */ 3:
                    message.onlyPublicObsolete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSProductInfoRequest_AppInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint64 access_token = 2; */
        if (message.accessToken !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.accessToken);
        /* optional bool only_public_obsolete = 3; */
        if (message.onlyPublicObsolete !== undefined)
            writer.tag(3, WireType.Varint).bool(message.onlyPublicObsolete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSProductInfoRequest_AppInfo
 */
export const CMsgClientPICSProductInfoRequest_AppInfo = new CMsgClientPICSProductInfoRequest_AppInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSProductInfoRequest_PackageInfo$Type extends MessageType<CMsgClientPICSProductInfoRequest_PackageInfo> {
    constructor() {
        super("CMsgClientPICSProductInfoRequest_PackageInfo", [
            { no: 1, name: "packageid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "access_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSProductInfoRequest_PackageInfo>): CMsgClientPICSProductInfoRequest_PackageInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSProductInfoRequest_PackageInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSProductInfoRequest_PackageInfo): CMsgClientPICSProductInfoRequest_PackageInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 packageid */ 1:
                    message.packageid = reader.uint32();
                    break;
                case /* optional uint64 access_token */ 2:
                    message.accessToken = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSProductInfoRequest_PackageInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 packageid = 1; */
        if (message.packageid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageid);
        /* optional uint64 access_token = 2; */
        if (message.accessToken !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.accessToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSProductInfoRequest_PackageInfo
 */
export const CMsgClientPICSProductInfoRequest_PackageInfo = new CMsgClientPICSProductInfoRequest_PackageInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSProductInfoResponse$Type extends MessageType<CMsgClientPICSProductInfoResponse> {
    constructor() {
        super("CMsgClientPICSProductInfoResponse", [
            { no: 1, name: "apps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPICSProductInfoResponse_AppInfo },
            { no: 2, name: "unknown_appids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "packages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPICSProductInfoResponse_PackageInfo },
            { no: 4, name: "unknown_packageids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "meta_data_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "response_pending", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "http_min_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "http_host", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSProductInfoResponse>): CMsgClientPICSProductInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apps = [];
        message.unknownAppids = [];
        message.packages = [];
        message.unknownPackageids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSProductInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSProductInfoResponse): CMsgClientPICSProductInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientPICSProductInfoResponse_AppInfo apps */ 1:
                    message.apps.push(CMsgClientPICSProductInfoResponse_AppInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 unknown_appids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unknownAppids.push(reader.uint32());
                    else
                        message.unknownAppids.push(reader.uint32());
                    break;
                case /* repeated CMsgClientPICSProductInfoResponse_PackageInfo packages */ 3:
                    message.packages.push(CMsgClientPICSProductInfoResponse_PackageInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 unknown_packageids */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unknownPackageids.push(reader.uint32());
                    else
                        message.unknownPackageids.push(reader.uint32());
                    break;
                case /* optional bool meta_data_only */ 5:
                    message.metaDataOnly = reader.bool();
                    break;
                case /* optional bool response_pending */ 6:
                    message.responsePending = reader.bool();
                    break;
                case /* optional uint32 http_min_size */ 7:
                    message.httpMinSize = reader.uint32();
                    break;
                case /* optional string http_host */ 8:
                    message.httpHost = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSProductInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientPICSProductInfoResponse_AppInfo apps = 1; */
        for (let i = 0; i < message.apps.length; i++)
            CMsgClientPICSProductInfoResponse_AppInfo.internalBinaryWrite(message.apps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 unknown_appids = 2; */
        for (let i = 0; i < message.unknownAppids.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.unknownAppids[i]);
        /* repeated CMsgClientPICSProductInfoResponse_PackageInfo packages = 3; */
        for (let i = 0; i < message.packages.length; i++)
            CMsgClientPICSProductInfoResponse_PackageInfo.internalBinaryWrite(message.packages[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 unknown_packageids = 4; */
        for (let i = 0; i < message.unknownPackageids.length; i++)
            writer.tag(4, WireType.Varint).uint32(message.unknownPackageids[i]);
        /* optional bool meta_data_only = 5; */
        if (message.metaDataOnly !== undefined)
            writer.tag(5, WireType.Varint).bool(message.metaDataOnly);
        /* optional bool response_pending = 6; */
        if (message.responsePending !== undefined)
            writer.tag(6, WireType.Varint).bool(message.responsePending);
        /* optional uint32 http_min_size = 7; */
        if (message.httpMinSize !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.httpMinSize);
        /* optional string http_host = 8; */
        if (message.httpHost !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.httpHost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSProductInfoResponse
 */
export const CMsgClientPICSProductInfoResponse = new CMsgClientPICSProductInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSProductInfoResponse_AppInfo$Type extends MessageType<CMsgClientPICSProductInfoResponse_AppInfo> {
    constructor() {
        super("CMsgClientPICSProductInfoResponse_AppInfo", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "change_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "missing_token", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "sha", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "buffer", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "only_public", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSProductInfoResponse_AppInfo>): CMsgClientPICSProductInfoResponse_AppInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSProductInfoResponse_AppInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSProductInfoResponse_AppInfo): CMsgClientPICSProductInfoResponse_AppInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 change_number */ 2:
                    message.changeNumber = reader.uint32();
                    break;
                case /* optional bool missing_token */ 3:
                    message.missingToken = reader.bool();
                    break;
                case /* optional bytes sha */ 4:
                    message.sha = reader.bytes();
                    break;
                case /* optional bytes buffer */ 5:
                    message.buffer = reader.bytes();
                    break;
                case /* optional bool only_public */ 6:
                    message.onlyPublic = reader.bool();
                    break;
                case /* optional uint32 size */ 7:
                    message.size = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSProductInfoResponse_AppInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 change_number = 2; */
        if (message.changeNumber !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.changeNumber);
        /* optional bool missing_token = 3; */
        if (message.missingToken !== undefined)
            writer.tag(3, WireType.Varint).bool(message.missingToken);
        /* optional bytes sha = 4; */
        if (message.sha !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.sha);
        /* optional bytes buffer = 5; */
        if (message.buffer !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.buffer);
        /* optional bool only_public = 6; */
        if (message.onlyPublic !== undefined)
            writer.tag(6, WireType.Varint).bool(message.onlyPublic);
        /* optional uint32 size = 7; */
        if (message.size !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSProductInfoResponse_AppInfo
 */
export const CMsgClientPICSProductInfoResponse_AppInfo = new CMsgClientPICSProductInfoResponse_AppInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPICSProductInfoResponse_PackageInfo$Type extends MessageType<CMsgClientPICSProductInfoResponse_PackageInfo> {
    constructor() {
        super("CMsgClientPICSProductInfoResponse_PackageInfo", [
            { no: 1, name: "packageid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "change_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "missing_token", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "sha", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "buffer", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPICSProductInfoResponse_PackageInfo>): CMsgClientPICSProductInfoResponse_PackageInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPICSProductInfoResponse_PackageInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPICSProductInfoResponse_PackageInfo): CMsgClientPICSProductInfoResponse_PackageInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 packageid */ 1:
                    message.packageid = reader.uint32();
                    break;
                case /* optional uint32 change_number */ 2:
                    message.changeNumber = reader.uint32();
                    break;
                case /* optional bool missing_token */ 3:
                    message.missingToken = reader.bool();
                    break;
                case /* optional bytes sha */ 4:
                    message.sha = reader.bytes();
                    break;
                case /* optional bytes buffer */ 5:
                    message.buffer = reader.bytes();
                    break;
                case /* optional uint32 size */ 6:
                    message.size = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPICSProductInfoResponse_PackageInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 packageid = 1; */
        if (message.packageid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageid);
        /* optional uint32 change_number = 2; */
        if (message.changeNumber !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.changeNumber);
        /* optional bool missing_token = 3; */
        if (message.missingToken !== undefined)
            writer.tag(3, WireType.Varint).bool(message.missingToken);
        /* optional bytes sha = 4; */
        if (message.sha !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.sha);
        /* optional bytes buffer = 5; */
        if (message.buffer !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.buffer);
        /* optional uint32 size = 6; */
        if (message.size !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPICSProductInfoResponse_PackageInfo
 */
export const CMsgClientPICSProductInfoResponse_PackageInfo = new CMsgClientPICSProductInfoResponse_PackageInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPlayerNicknameList$Type extends MessageType<CMsgClientPlayerNicknameList> {
    constructor() {
        super("CMsgClientPlayerNicknameList", [
            { no: 1, name: "removal", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "incremental", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "nicknames", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientPlayerNicknameList_PlayerNickname }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPlayerNicknameList>): CMsgClientPlayerNicknameList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nicknames = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPlayerNicknameList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPlayerNicknameList): CMsgClientPlayerNicknameList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool removal */ 1:
                    message.removal = reader.bool();
                    break;
                case /* optional bool incremental */ 2:
                    message.incremental = reader.bool();
                    break;
                case /* repeated CMsgClientPlayerNicknameList_PlayerNickname nicknames */ 3:
                    message.nicknames.push(CMsgClientPlayerNicknameList_PlayerNickname.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPlayerNicknameList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool removal = 1; */
        if (message.removal !== undefined)
            writer.tag(1, WireType.Varint).bool(message.removal);
        /* optional bool incremental = 2; */
        if (message.incremental !== undefined)
            writer.tag(2, WireType.Varint).bool(message.incremental);
        /* repeated CMsgClientPlayerNicknameList_PlayerNickname nicknames = 3; */
        for (let i = 0; i < message.nicknames.length; i++)
            CMsgClientPlayerNicknameList_PlayerNickname.internalBinaryWrite(message.nicknames[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPlayerNicknameList
 */
export const CMsgClientPlayerNicknameList = new CMsgClientPlayerNicknameList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPlayerNicknameList_PlayerNickname$Type extends MessageType<CMsgClientPlayerNicknameList_PlayerNickname> {
    constructor() {
        super("CMsgClientPlayerNicknameList_PlayerNickname", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "nickname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPlayerNicknameList_PlayerNickname>): CMsgClientPlayerNicknameList_PlayerNickname {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPlayerNicknameList_PlayerNickname>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPlayerNicknameList_PlayerNickname): CMsgClientPlayerNicknameList_PlayerNickname {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string nickname */ 3:
                    message.nickname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPlayerNicknameList_PlayerNickname, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional string nickname = 3; */
        if (message.nickname !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.nickname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPlayerNicknameList_PlayerNickname
 */
export const CMsgClientPlayerNicknameList_PlayerNickname = new CMsgClientPlayerNicknameList_PlayerNickname$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPlayingSessionState$Type extends MessageType<CMsgClientPlayingSessionState> {
    constructor() {
        super("CMsgClientPlayingSessionState", [
            { no: 2, name: "playing_blocked", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "playing_app", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPlayingSessionState>): CMsgClientPlayingSessionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPlayingSessionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPlayingSessionState): CMsgClientPlayingSessionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool playing_blocked */ 2:
                    message.playingBlocked = reader.bool();
                    break;
                case /* optional uint32 playing_app */ 3:
                    message.playingApp = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPlayingSessionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool playing_blocked = 2; */
        if (message.playingBlocked !== undefined)
            writer.tag(2, WireType.Varint).bool(message.playingBlocked);
        /* optional uint32 playing_app = 3; */
        if (message.playingApp !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.playingApp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPlayingSessionState
 */
export const CMsgClientPlayingSessionState = new CMsgClientPlayingSessionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPurchaseResponse$Type extends MessageType<CMsgClientPurchaseResponse> {
    constructor() {
        super("CMsgClientPurchaseResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "purchase_result_details", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "purchase_receipt_info", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPurchaseResponse>): CMsgClientPurchaseResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPurchaseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPurchaseResponse): CMsgClientPurchaseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 purchase_result_details */ 2:
                    message.purchaseResultDetails = reader.int32();
                    break;
                case /* optional bytes purchase_receipt_info */ 3:
                    message.purchaseReceiptInfo = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPurchaseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 purchase_result_details = 2; */
        if (message.purchaseResultDetails !== undefined)
            writer.tag(2, WireType.Varint).int32(message.purchaseResultDetails);
        /* optional bytes purchase_receipt_info = 3; */
        if (message.purchaseReceiptInfo !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.purchaseReceiptInfo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPurchaseResponse
 */
export const CMsgClientPurchaseResponse = new CMsgClientPurchaseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPurchaseWithMachineID$Type extends MessageType<CMsgClientPurchaseWithMachineID> {
    constructor() {
        super("CMsgClientPurchaseWithMachineID", [
            { no: 1, name: "package_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "machine_info", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientPurchaseWithMachineID>): CMsgClientPurchaseWithMachineID {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientPurchaseWithMachineID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientPurchaseWithMachineID): CMsgClientPurchaseWithMachineID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 package_id */ 1:
                    message.packageId = reader.uint32();
                    break;
                case /* optional bytes machine_info */ 2:
                    message.machineInfo = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientPurchaseWithMachineID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 package_id = 1; */
        if (message.packageId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageId);
        /* optional bytes machine_info = 2; */
        if (message.machineInfo !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.machineInfo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientPurchaseWithMachineID
 */
export const CMsgClientPurchaseWithMachineID = new CMsgClientPurchaseWithMachineID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientReadMachineAuth$Type extends MessageType<CMsgClientReadMachineAuth> {
    constructor() {
        super("CMsgClientReadMachineAuth", [
            { no: 1, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "offset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cubtoread", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientReadMachineAuth>): CMsgClientReadMachineAuth {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientReadMachineAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientReadMachineAuth): CMsgClientReadMachineAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string filename */ 1:
                    message.filename = reader.string();
                    break;
                case /* optional uint32 offset */ 2:
                    message.offset = reader.uint32();
                    break;
                case /* optional uint32 cubtoread */ 3:
                    message.cubtoread = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientReadMachineAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string filename = 1; */
        if (message.filename !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.filename);
        /* optional uint32 offset = 2; */
        if (message.offset !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.offset);
        /* optional uint32 cubtoread = 3; */
        if (message.cubtoread !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.cubtoread);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientReadMachineAuth
 */
export const CMsgClientReadMachineAuth = new CMsgClientReadMachineAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientReadMachineAuthResponse$Type extends MessageType<CMsgClientReadMachineAuthResponse> {
    constructor() {
        super("CMsgClientReadMachineAuthResponse", [
            { no: 1, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "filesize", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "getlasterror", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "offset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "cubread", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "bytes_read", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "filename_sentry", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientReadMachineAuthResponse>): CMsgClientReadMachineAuthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientReadMachineAuthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientReadMachineAuthResponse): CMsgClientReadMachineAuthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string filename */ 1:
                    message.filename = reader.string();
                    break;
                case /* optional uint32 eresult */ 2:
                    message.eresult = reader.uint32();
                    break;
                case /* optional uint32 filesize */ 3:
                    message.filesize = reader.uint32();
                    break;
                case /* optional bytes sha_file */ 4:
                    message.shaFile = reader.bytes();
                    break;
                case /* optional uint32 getlasterror */ 5:
                    message.getlasterror = reader.uint32();
                    break;
                case /* optional uint32 offset */ 6:
                    message.offset = reader.uint32();
                    break;
                case /* optional uint32 cubread */ 7:
                    message.cubread = reader.uint32();
                    break;
                case /* optional bytes bytes_read */ 8:
                    message.bytesRead = reader.bytes();
                    break;
                case /* optional string filename_sentry */ 9:
                    message.filenameSentry = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientReadMachineAuthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string filename = 1; */
        if (message.filename !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.filename);
        /* optional uint32 eresult = 2; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eresult);
        /* optional uint32 filesize = 3; */
        if (message.filesize !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.filesize);
        /* optional bytes sha_file = 4; */
        if (message.shaFile !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.shaFile);
        /* optional uint32 getlasterror = 5; */
        if (message.getlasterror !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.getlasterror);
        /* optional uint32 offset = 6; */
        if (message.offset !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.offset);
        /* optional uint32 cubread = 7; */
        if (message.cubread !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.cubread);
        /* optional bytes bytes_read = 8; */
        if (message.bytesRead !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.bytesRead);
        /* optional string filename_sentry = 9; */
        if (message.filenameSentry !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.filenameSentry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientReadMachineAuthResponse
 */
export const CMsgClientReadMachineAuthResponse = new CMsgClientReadMachineAuthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRedeemGuestPass$Type extends MessageType<CMsgClientRedeemGuestPass> {
    constructor() {
        super("CMsgClientRedeemGuestPass", [
            { no: 1, name: "guest_pass_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRedeemGuestPass>): CMsgClientRedeemGuestPass {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRedeemGuestPass>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRedeemGuestPass): CMsgClientRedeemGuestPass {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 guest_pass_id */ 1:
                    message.guestPassId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRedeemGuestPass, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 guest_pass_id = 1; */
        if (message.guestPassId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.guestPassId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRedeemGuestPass
 */
export const CMsgClientRedeemGuestPass = new CMsgClientRedeemGuestPass$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRedeemGuestPassResponse$Type extends MessageType<CMsgClientRedeemGuestPassResponse> {
    constructor() {
        super("CMsgClientRedeemGuestPassResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "package_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "must_own_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRedeemGuestPassResponse>): CMsgClientRedeemGuestPassResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRedeemGuestPassResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRedeemGuestPassResponse): CMsgClientRedeemGuestPassResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.uint32();
                    break;
                case /* optional uint32 package_id */ 2:
                    message.packageId = reader.uint32();
                    break;
                case /* optional uint32 must_own_appid */ 3:
                    message.mustOwnAppid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRedeemGuestPassResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        /* optional uint32 package_id = 2; */
        if (message.packageId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.packageId);
        /* optional uint32 must_own_appid = 3; */
        if (message.mustOwnAppid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.mustOwnAppid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRedeemGuestPassResponse
 */
export const CMsgClientRedeemGuestPassResponse = new CMsgClientRedeemGuestPassResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRegisterAuthTicketWithCM$Type extends MessageType<CMsgClientRegisterAuthTicketWithCM> {
    constructor() {
        super("CMsgClientRegisterAuthTicketWithCM", [
            { no: 1, name: "protocol_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "ticket", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "client_instance_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRegisterAuthTicketWithCM>): CMsgClientRegisterAuthTicketWithCM {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRegisterAuthTicketWithCM>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRegisterAuthTicketWithCM): CMsgClientRegisterAuthTicketWithCM {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 protocol_version */ 1:
                    message.protocolVersion = reader.uint32();
                    break;
                case /* optional bytes ticket */ 3:
                    message.ticket = reader.bytes();
                    break;
                case /* optional uint64 client_instance_id */ 4:
                    message.clientInstanceId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRegisterAuthTicketWithCM, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 protocol_version = 1; */
        if (message.protocolVersion !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.protocolVersion);
        /* optional bytes ticket = 3; */
        if (message.ticket !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.ticket);
        /* optional uint64 client_instance_id = 4; */
        if (message.clientInstanceId !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.clientInstanceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRegisterAuthTicketWithCM
 */
export const CMsgClientRegisterAuthTicketWithCM = new CMsgClientRegisterAuthTicketWithCM$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRegisterKey$Type extends MessageType<CMsgClientRegisterKey> {
    constructor() {
        super("CMsgClientRegisterKey", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRegisterKey>): CMsgClientRegisterKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRegisterKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRegisterKey): CMsgClientRegisterKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string key */ 1:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRegisterKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRegisterKey
 */
export const CMsgClientRegisterKey = new CMsgClientRegisterKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRegisterOEMMachine$Type extends MessageType<CMsgClientRegisterOEMMachine> {
    constructor() {
        super("CMsgClientRegisterOEMMachine", [
            { no: 1, name: "oem_register_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRegisterOEMMachine>): CMsgClientRegisterOEMMachine {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRegisterOEMMachine>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRegisterOEMMachine): CMsgClientRegisterOEMMachine {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes oem_register_file */ 1:
                    message.oemRegisterFile = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRegisterOEMMachine, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes oem_register_file = 1; */
        if (message.oemRegisterFile !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.oemRegisterFile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRegisterOEMMachine
 */
export const CMsgClientRegisterOEMMachine = new CMsgClientRegisterOEMMachine$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRegisterOEMMachineResponse$Type extends MessageType<CMsgClientRegisterOEMMachineResponse> {
    constructor() {
        super("CMsgClientRegisterOEMMachineResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRegisterOEMMachineResponse>): CMsgClientRegisterOEMMachineResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRegisterOEMMachineResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRegisterOEMMachineResponse): CMsgClientRegisterOEMMachineResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRegisterOEMMachineResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRegisterOEMMachineResponse
 */
export const CMsgClientRegisterOEMMachineResponse = new CMsgClientRegisterOEMMachineResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRemoveFriend$Type extends MessageType<CMsgClientRemoveFriend> {
    constructor() {
        super("CMsgClientRemoveFriend", [
            { no: 1, name: "friendid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRemoveFriend>): CMsgClientRemoveFriend {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRemoveFriend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRemoveFriend): CMsgClientRemoveFriend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 friendid */ 1:
                    message.friendid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRemoveFriend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 friendid = 1; */
        if (message.friendid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.friendid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRemoveFriend
 */
export const CMsgClientRemoveFriend = new CMsgClientRemoveFriend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRemoveFriendFromGroup$Type extends MessageType<CMsgClientRemoveFriendFromGroup> {
    constructor() {
        super("CMsgClientRemoveFriendFromGroup", [
            { no: 1, name: "groupid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "steamiduser", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRemoveFriendFromGroup>): CMsgClientRemoveFriendFromGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRemoveFriendFromGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRemoveFriendFromGroup): CMsgClientRemoveFriendFromGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 groupid */ 1:
                    message.groupid = reader.int32();
                    break;
                case /* optional fixed64 steamiduser */ 2:
                    message.steamiduser = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRemoveFriendFromGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 groupid = 1; */
        if (message.groupid !== undefined)
            writer.tag(1, WireType.Varint).int32(message.groupid);
        /* optional fixed64 steamiduser = 2; */
        if (message.steamiduser !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamiduser);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRemoveFriendFromGroup
 */
export const CMsgClientRemoveFriendFromGroup = new CMsgClientRemoveFriendFromGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRemoveFriendFromGroupResponse$Type extends MessageType<CMsgClientRemoveFriendFromGroupResponse> {
    constructor() {
        super("CMsgClientRemoveFriendFromGroupResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRemoveFriendFromGroupResponse>): CMsgClientRemoveFriendFromGroupResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRemoveFriendFromGroupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRemoveFriendFromGroupResponse): CMsgClientRemoveFriendFromGroupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRemoveFriendFromGroupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRemoveFriendFromGroupResponse
 */
export const CMsgClientRemoveFriendFromGroupResponse = new CMsgClientRemoveFriendFromGroupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientReportOverlayDetourFailure$Type extends MessageType<CMsgClientReportOverlayDetourFailure> {
    constructor() {
        super("CMsgClientReportOverlayDetourFailure", [
            { no: 1, name: "failure_strings", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientReportOverlayDetourFailure>): CMsgClientReportOverlayDetourFailure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.failureStrings = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientReportOverlayDetourFailure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientReportOverlayDetourFailure): CMsgClientReportOverlayDetourFailure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string failure_strings */ 1:
                    message.failureStrings.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientReportOverlayDetourFailure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string failure_strings = 1; */
        for (let i = 0; i < message.failureStrings.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.failureStrings[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientReportOverlayDetourFailure
 */
export const CMsgClientReportOverlayDetourFailure = new CMsgClientReportOverlayDetourFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestAccountData$Type extends MessageType<CMsgClientRequestAccountData> {
    constructor() {
        super("CMsgClientRequestAccountData", [
            { no: 1, name: "account_or_email", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestAccountData>): CMsgClientRequestAccountData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestAccountData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestAccountData): CMsgClientRequestAccountData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string account_or_email */ 1:
                    message.accountOrEmail = reader.string();
                    break;
                case /* optional uint32 action */ 2:
                    message.action = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestAccountData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string account_or_email = 1; */
        if (message.accountOrEmail !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.accountOrEmail);
        /* optional uint32 action = 2; */
        if (message.action !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestAccountData
 */
export const CMsgClientRequestAccountData = new CMsgClientRequestAccountData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestAccountDataResponse$Type extends MessageType<CMsgClientRequestAccountDataResponse> {
    constructor() {
        super("CMsgClientRequestAccountDataResponse", [
            { no: 1, name: "action", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "account_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ct_matches", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "account_name_suggestion1", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "account_name_suggestion2", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "account_name_suggestion3", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestAccountDataResponse>): CMsgClientRequestAccountDataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestAccountDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestAccountDataResponse): CMsgClientRequestAccountDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 action */ 1:
                    message.action = reader.uint32();
                    break;
                case /* optional uint32 eresult */ 2:
                    message.eresult = reader.uint32();
                    break;
                case /* optional string account_name */ 3:
                    message.accountName = reader.string();
                    break;
                case /* optional uint32 ct_matches */ 4:
                    message.ctMatches = reader.uint32();
                    break;
                case /* optional string account_name_suggestion1 */ 5:
                    message.accountNameSuggestion1 = reader.string();
                    break;
                case /* optional string account_name_suggestion2 */ 6:
                    message.accountNameSuggestion2 = reader.string();
                    break;
                case /* optional string account_name_suggestion3 */ 7:
                    message.accountNameSuggestion3 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestAccountDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 action = 1; */
        if (message.action !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.action);
        /* optional uint32 eresult = 2; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eresult);
        /* optional string account_name = 3; */
        if (message.accountName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.accountName);
        /* optional uint32 ct_matches = 4; */
        if (message.ctMatches !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.ctMatches);
        /* optional string account_name_suggestion1 = 5; */
        if (message.accountNameSuggestion1 !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.accountNameSuggestion1);
        /* optional string account_name_suggestion2 = 6; */
        if (message.accountNameSuggestion2 !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.accountNameSuggestion2);
        /* optional string account_name_suggestion3 = 7; */
        if (message.accountNameSuggestion3 !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.accountNameSuggestion3);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestAccountDataResponse
 */
export const CMsgClientRequestAccountDataResponse = new CMsgClientRequestAccountDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestCommentNotifications$Type extends MessageType<CMsgClientRequestCommentNotifications> {
    constructor() {
        super("CMsgClientRequestCommentNotifications", []);
    }
    create(value?: PartialMessage<CMsgClientRequestCommentNotifications>): CMsgClientRequestCommentNotifications {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestCommentNotifications>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestCommentNotifications): CMsgClientRequestCommentNotifications {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestCommentNotifications, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestCommentNotifications
 */
export const CMsgClientRequestCommentNotifications = new CMsgClientRequestCommentNotifications$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestedClientStats$Type extends MessageType<CMsgClientRequestedClientStats> {
    constructor() {
        super("CMsgClientRequestedClientStats", [
            { no: 1, name: "stats_to_send", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientRequestedClientStats_StatsToSend }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestedClientStats>): CMsgClientRequestedClientStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statsToSend = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestedClientStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestedClientStats): CMsgClientRequestedClientStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientRequestedClientStats_StatsToSend stats_to_send */ 1:
                    message.statsToSend.push(CMsgClientRequestedClientStats_StatsToSend.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestedClientStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientRequestedClientStats_StatsToSend stats_to_send = 1; */
        for (let i = 0; i < message.statsToSend.length; i++)
            CMsgClientRequestedClientStats_StatsToSend.internalBinaryWrite(message.statsToSend[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestedClientStats
 */
export const CMsgClientRequestedClientStats = new CMsgClientRequestedClientStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestedClientStats_StatsToSend$Type extends MessageType<CMsgClientRequestedClientStats_StatsToSend> {
    constructor() {
        super("CMsgClientRequestedClientStats_StatsToSend", [
            { no: 1, name: "client_stat", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stat_aggregate_method", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestedClientStats_StatsToSend>): CMsgClientRequestedClientStats_StatsToSend {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestedClientStats_StatsToSend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestedClientStats_StatsToSend): CMsgClientRequestedClientStats_StatsToSend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 client_stat */ 1:
                    message.clientStat = reader.uint32();
                    break;
                case /* optional uint32 stat_aggregate_method */ 2:
                    message.statAggregateMethod = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestedClientStats_StatsToSend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 client_stat = 1; */
        if (message.clientStat !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.clientStat);
        /* optional uint32 stat_aggregate_method = 2; */
        if (message.statAggregateMethod !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.statAggregateMethod);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestedClientStats_StatsToSend
 */
export const CMsgClientRequestedClientStats_StatsToSend = new CMsgClientRequestedClientStats_StatsToSend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestEncryptedAppTicket$Type extends MessageType<CMsgClientRequestEncryptedAppTicket> {
    constructor() {
        super("CMsgClientRequestEncryptedAppTicket", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "userdata", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestEncryptedAppTicket>): CMsgClientRequestEncryptedAppTicket {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestEncryptedAppTicket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestEncryptedAppTicket): CMsgClientRequestEncryptedAppTicket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional bytes userdata */ 2:
                    message.userdata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestEncryptedAppTicket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional bytes userdata = 2; */
        if (message.userdata !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.userdata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestEncryptedAppTicket
 */
export const CMsgClientRequestEncryptedAppTicket = new CMsgClientRequestEncryptedAppTicket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestEncryptedAppTicketResponse$Type extends MessageType<CMsgClientRequestEncryptedAppTicketResponse> {
    constructor() {
        super("CMsgClientRequestEncryptedAppTicketResponse", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "encrypted_app_ticket", kind: "message", T: () => EncryptedAppTicket }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestEncryptedAppTicketResponse>): CMsgClientRequestEncryptedAppTicketResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestEncryptedAppTicketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestEncryptedAppTicketResponse): CMsgClientRequestEncryptedAppTicketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional int32 eresult = 2 [default = 2] */ 2:
                    message.eresult = reader.int32();
                    break;
                case /* optional EncryptedAppTicket encrypted_app_ticket */ 3:
                    message.encryptedAppTicket = EncryptedAppTicket.internalBinaryRead(reader, reader.uint32(), options, message.encryptedAppTicket);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestEncryptedAppTicketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional int32 eresult = 2 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).int32(message.eresult);
        /* optional EncryptedAppTicket encrypted_app_ticket = 3; */
        if (message.encryptedAppTicket)
            EncryptedAppTicket.internalBinaryWrite(message.encryptedAppTicket, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestEncryptedAppTicketResponse
 */
export const CMsgClientRequestEncryptedAppTicketResponse = new CMsgClientRequestEncryptedAppTicketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestForgottenPasswordEmail$Type extends MessageType<CMsgClientRequestForgottenPasswordEmail> {
    constructor() {
        super("CMsgClientRequestForgottenPasswordEmail", [
            { no: 1, name: "account_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password_tried", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestForgottenPasswordEmail>): CMsgClientRequestForgottenPasswordEmail {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestForgottenPasswordEmail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestForgottenPasswordEmail): CMsgClientRequestForgottenPasswordEmail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string account_name */ 1:
                    message.accountName = reader.string();
                    break;
                case /* optional string password_tried */ 2:
                    message.passwordTried = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestForgottenPasswordEmail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string account_name = 1; */
        if (message.accountName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.accountName);
        /* optional string password_tried = 2; */
        if (message.passwordTried !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.passwordTried);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestForgottenPasswordEmail
 */
export const CMsgClientRequestForgottenPasswordEmail = new CMsgClientRequestForgottenPasswordEmail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestForgottenPasswordEmailResponse$Type extends MessageType<CMsgClientRequestForgottenPasswordEmailResponse> {
    constructor() {
        super("CMsgClientRequestForgottenPasswordEmailResponse", [
            { no: 1, name: "eResult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "use_secret_question", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestForgottenPasswordEmailResponse>): CMsgClientRequestForgottenPasswordEmailResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestForgottenPasswordEmailResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestForgottenPasswordEmailResponse): CMsgClientRequestForgottenPasswordEmailResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eResult */ 1:
                    message.eResult = reader.uint32();
                    break;
                case /* optional bool use_secret_question */ 2:
                    message.useSecretQuestion = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestForgottenPasswordEmailResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eResult = 1; */
        if (message.eResult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eResult);
        /* optional bool use_secret_question = 2; */
        if (message.useSecretQuestion !== undefined)
            writer.tag(2, WireType.Varint).bool(message.useSecretQuestion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestForgottenPasswordEmailResponse
 */
export const CMsgClientRequestForgottenPasswordEmailResponse = new CMsgClientRequestForgottenPasswordEmailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestFreeLicense$Type extends MessageType<CMsgClientRequestFreeLicense> {
    constructor() {
        super("CMsgClientRequestFreeLicense", [
            { no: 2, name: "appids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestFreeLicense>): CMsgClientRequestFreeLicense {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestFreeLicense>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestFreeLicense): CMsgClientRequestFreeLicense {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 appids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.appids.push(reader.uint32());
                    else
                        message.appids.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestFreeLicense, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 appids = 2; */
        for (let i = 0; i < message.appids.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.appids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestFreeLicense
 */
export const CMsgClientRequestFreeLicense = new CMsgClientRequestFreeLicense$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestFreeLicenseResponse$Type extends MessageType<CMsgClientRequestFreeLicenseResponse> {
    constructor() {
        super("CMsgClientRequestFreeLicenseResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "granted_packageids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "granted_appids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestFreeLicenseResponse>): CMsgClientRequestFreeLicenseResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grantedPackageids = [];
        message.grantedAppids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestFreeLicenseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestFreeLicenseResponse): CMsgClientRequestFreeLicenseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.uint32();
                    break;
                case /* repeated uint32 granted_packageids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.grantedPackageids.push(reader.uint32());
                    else
                        message.grantedPackageids.push(reader.uint32());
                    break;
                case /* repeated uint32 granted_appids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.grantedAppids.push(reader.uint32());
                    else
                        message.grantedAppids.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestFreeLicenseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        /* repeated uint32 granted_packageids = 2; */
        for (let i = 0; i < message.grantedPackageids.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.grantedPackageids[i]);
        /* repeated uint32 granted_appids = 3; */
        for (let i = 0; i < message.grantedAppids.length; i++)
            writer.tag(3, WireType.Varint).uint32(message.grantedAppids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestFreeLicenseResponse
 */
export const CMsgClientRequestFreeLicenseResponse = new CMsgClientRequestFreeLicenseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestFriendData$Type extends MessageType<CMsgClientRequestFriendData> {
    constructor() {
        super("CMsgClientRequestFriendData", [
            { no: 1, name: "persona_state_requested", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "friends", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestFriendData>): CMsgClientRequestFriendData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.friends = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestFriendData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestFriendData): CMsgClientRequestFriendData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 persona_state_requested */ 1:
                    message.personaStateRequested = reader.uint32();
                    break;
                case /* repeated fixed64 friends */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.friends.push(reader.fixed64().toBigInt());
                    else
                        message.friends.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestFriendData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 persona_state_requested = 1; */
        if (message.personaStateRequested !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.personaStateRequested);
        /* repeated fixed64 friends = 2; */
        for (let i = 0; i < message.friends.length; i++)
            writer.tag(2, WireType.Bit64).fixed64(message.friends[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestFriendData
 */
export const CMsgClientRequestFriendData = new CMsgClientRequestFriendData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestItemAnnouncements$Type extends MessageType<CMsgClientRequestItemAnnouncements> {
    constructor() {
        super("CMsgClientRequestItemAnnouncements", []);
    }
    create(value?: PartialMessage<CMsgClientRequestItemAnnouncements>): CMsgClientRequestItemAnnouncements {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestItemAnnouncements>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestItemAnnouncements): CMsgClientRequestItemAnnouncements {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestItemAnnouncements, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestItemAnnouncements
 */
export const CMsgClientRequestItemAnnouncements = new CMsgClientRequestItemAnnouncements$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestMachineAuth$Type extends MessageType<CMsgClientRequestMachineAuth> {
    constructor() {
        super("CMsgClientRequestMachineAuth", [
            { no: 1, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "eresult_sentryfile", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "filesize", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "sha_sentryfile", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "lock_account_action", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "otp_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "otp_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "otp_sharedsecret", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "otp_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "machine_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "machine_name_userchosen", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestMachineAuth>): CMsgClientRequestMachineAuth {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestMachineAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestMachineAuth): CMsgClientRequestMachineAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string filename */ 1:
                    message.filename = reader.string();
                    break;
                case /* optional uint32 eresult_sentryfile */ 2:
                    message.eresultSentryfile = reader.uint32();
                    break;
                case /* optional uint32 filesize */ 3:
                    message.filesize = reader.uint32();
                    break;
                case /* optional bytes sha_sentryfile */ 4:
                    message.shaSentryfile = reader.bytes();
                    break;
                case /* optional int32 lock_account_action */ 6:
                    message.lockAccountAction = reader.int32();
                    break;
                case /* optional uint32 otp_type */ 7:
                    message.otpType = reader.uint32();
                    break;
                case /* optional string otp_identifier */ 8:
                    message.otpIdentifier = reader.string();
                    break;
                case /* optional bytes otp_sharedsecret */ 9:
                    message.otpSharedsecret = reader.bytes();
                    break;
                case /* optional uint32 otp_value */ 10:
                    message.otpValue = reader.uint32();
                    break;
                case /* optional string machine_name */ 11:
                    message.machineName = reader.string();
                    break;
                case /* optional string machine_name_userchosen */ 12:
                    message.machineNameUserchosen = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestMachineAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string filename = 1; */
        if (message.filename !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.filename);
        /* optional uint32 eresult_sentryfile = 2; */
        if (message.eresultSentryfile !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eresultSentryfile);
        /* optional uint32 filesize = 3; */
        if (message.filesize !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.filesize);
        /* optional bytes sha_sentryfile = 4; */
        if (message.shaSentryfile !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.shaSentryfile);
        /* optional int32 lock_account_action = 6; */
        if (message.lockAccountAction !== undefined)
            writer.tag(6, WireType.Varint).int32(message.lockAccountAction);
        /* optional uint32 otp_type = 7; */
        if (message.otpType !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.otpType);
        /* optional string otp_identifier = 8; */
        if (message.otpIdentifier !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.otpIdentifier);
        /* optional bytes otp_sharedsecret = 9; */
        if (message.otpSharedsecret !== undefined)
            writer.tag(9, WireType.LengthDelimited).bytes(message.otpSharedsecret);
        /* optional uint32 otp_value = 10; */
        if (message.otpValue !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.otpValue);
        /* optional string machine_name = 11; */
        if (message.machineName !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.machineName);
        /* optional string machine_name_userchosen = 12; */
        if (message.machineNameUserchosen !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.machineNameUserchosen);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestMachineAuth
 */
export const CMsgClientRequestMachineAuth = new CMsgClientRequestMachineAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestMachineAuthResponse$Type extends MessageType<CMsgClientRequestMachineAuthResponse> {
    constructor() {
        super("CMsgClientRequestMachineAuthResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestMachineAuthResponse>): CMsgClientRequestMachineAuthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestMachineAuthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestMachineAuthResponse): CMsgClientRequestMachineAuthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestMachineAuthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestMachineAuthResponse
 */
export const CMsgClientRequestMachineAuthResponse = new CMsgClientRequestMachineAuthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestOfflineMessageCount$Type extends MessageType<CMsgClientRequestOfflineMessageCount> {
    constructor() {
        super("CMsgClientRequestOfflineMessageCount", []);
    }
    create(value?: PartialMessage<CMsgClientRequestOfflineMessageCount>): CMsgClientRequestOfflineMessageCount {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestOfflineMessageCount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestOfflineMessageCount): CMsgClientRequestOfflineMessageCount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestOfflineMessageCount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestOfflineMessageCount
 */
export const CMsgClientRequestOfflineMessageCount = new CMsgClientRequestOfflineMessageCount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestWebAPIAuthenticateUserNonce$Type extends MessageType<CMsgClientRequestWebAPIAuthenticateUserNonce> {
    constructor() {
        super("CMsgClientRequestWebAPIAuthenticateUserNonce", [
            { no: 1, name: "token_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestWebAPIAuthenticateUserNonce>): CMsgClientRequestWebAPIAuthenticateUserNonce {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestWebAPIAuthenticateUserNonce>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestWebAPIAuthenticateUserNonce): CMsgClientRequestWebAPIAuthenticateUserNonce {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 token_type = 1 [default = -1] */ 1:
                    message.tokenType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestWebAPIAuthenticateUserNonce, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 token_type = 1 [default = -1]; */
        if (message.tokenType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.tokenType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestWebAPIAuthenticateUserNonce
 */
export const CMsgClientRequestWebAPIAuthenticateUserNonce = new CMsgClientRequestWebAPIAuthenticateUserNonce$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRequestWebAPIAuthenticateUserNonceResponse$Type extends MessageType<CMsgClientRequestWebAPIAuthenticateUserNonceResponse> {
    constructor() {
        super("CMsgClientRequestWebAPIAuthenticateUserNonceResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "token_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "webapi_authenticate_user_nonce", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRequestWebAPIAuthenticateUserNonceResponse>): CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRequestWebAPIAuthenticateUserNonceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRequestWebAPIAuthenticateUserNonceResponse): CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 token_type = 3 [default = -1] */ 3:
                    message.tokenType = reader.int32();
                    break;
                case /* optional string webapi_authenticate_user_nonce */ 11:
                    message.webapiAuthenticateUserNonce = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRequestWebAPIAuthenticateUserNonceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 token_type = 3 [default = -1]; */
        if (message.tokenType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.tokenType);
        /* optional string webapi_authenticate_user_nonce = 11; */
        if (message.webapiAuthenticateUserNonce !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.webapiAuthenticateUserNonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRequestWebAPIAuthenticateUserNonceResponse
 */
export const CMsgClientRequestWebAPIAuthenticateUserNonceResponse = new CMsgClientRequestWebAPIAuthenticateUserNonceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRichPresenceInfo$Type extends MessageType<CMsgClientRichPresenceInfo> {
    constructor() {
        super("CMsgClientRichPresenceInfo", [
            { no: 1, name: "rich_presence", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientRichPresenceInfo_RichPresence }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRichPresenceInfo>): CMsgClientRichPresenceInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.richPresence = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRichPresenceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRichPresenceInfo): CMsgClientRichPresenceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientRichPresenceInfo_RichPresence rich_presence */ 1:
                    message.richPresence.push(CMsgClientRichPresenceInfo_RichPresence.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRichPresenceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientRichPresenceInfo_RichPresence rich_presence = 1; */
        for (let i = 0; i < message.richPresence.length; i++)
            CMsgClientRichPresenceInfo_RichPresence.internalBinaryWrite(message.richPresence[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRichPresenceInfo
 */
export const CMsgClientRichPresenceInfo = new CMsgClientRichPresenceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRichPresenceInfo_RichPresence$Type extends MessageType<CMsgClientRichPresenceInfo_RichPresence> {
    constructor() {
        super("CMsgClientRichPresenceInfo_RichPresence", [
            { no: 1, name: "steamid_user", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "rich_presence_kv", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRichPresenceInfo_RichPresence>): CMsgClientRichPresenceInfo_RichPresence {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRichPresenceInfo_RichPresence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRichPresenceInfo_RichPresence): CMsgClientRichPresenceInfo_RichPresence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_user */ 1:
                    message.steamidUser = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes rich_presence_kv */ 2:
                    message.richPresenceKv = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRichPresenceInfo_RichPresence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_user = 1; */
        if (message.steamidUser !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidUser);
        /* optional bytes rich_presence_kv = 2; */
        if (message.richPresenceKv !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.richPresenceKv);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRichPresenceInfo_RichPresence
 */
export const CMsgClientRichPresenceInfo_RichPresence = new CMsgClientRichPresenceInfo_RichPresence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRichPresenceRequest$Type extends MessageType<CMsgClientRichPresenceRequest> {
    constructor() {
        super("CMsgClientRichPresenceRequest", [
            { no: 1, name: "steamid_request", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRichPresenceRequest>): CMsgClientRichPresenceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamidRequest = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRichPresenceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRichPresenceRequest): CMsgClientRichPresenceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 steamid_request */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamidRequest.push(reader.fixed64().toBigInt());
                    else
                        message.steamidRequest.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRichPresenceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 steamid_request = 1; */
        for (let i = 0; i < message.steamidRequest.length; i++)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidRequest[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRichPresenceRequest
 */
export const CMsgClientRichPresenceRequest = new CMsgClientRichPresenceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientRichPresenceUpload$Type extends MessageType<CMsgClientRichPresenceUpload> {
    constructor() {
        super("CMsgClientRichPresenceUpload", [
            { no: 1, name: "rich_presence_kv", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "steamid_broadcast", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientRichPresenceUpload>): CMsgClientRichPresenceUpload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamidBroadcast = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientRichPresenceUpload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientRichPresenceUpload): CMsgClientRichPresenceUpload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes rich_presence_kv */ 1:
                    message.richPresenceKv = reader.bytes();
                    break;
                case /* repeated fixed64 steamid_broadcast */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamidBroadcast.push(reader.fixed64().toBigInt());
                    else
                        message.steamidBroadcast.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientRichPresenceUpload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes rich_presence_kv = 1; */
        if (message.richPresenceKv !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.richPresenceKv);
        /* repeated fixed64 steamid_broadcast = 2; */
        for (let i = 0; i < message.steamidBroadcast.length; i++)
            writer.tag(2, WireType.Bit64).fixed64(message.steamidBroadcast[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientRichPresenceUpload
 */
export const CMsgClientRichPresenceUpload = new CMsgClientRichPresenceUpload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientScreenshotsChanged$Type extends MessageType<CMsgClientScreenshotsChanged> {
    constructor() {
        super("CMsgClientScreenshotsChanged", []);
    }
    create(value?: PartialMessage<CMsgClientScreenshotsChanged>): CMsgClientScreenshotsChanged {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientScreenshotsChanged>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientScreenshotsChanged): CMsgClientScreenshotsChanged {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientScreenshotsChanged, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientScreenshotsChanged
 */
export const CMsgClientScreenshotsChanged = new CMsgClientScreenshotsChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSecret$Type extends MessageType<CMsgClientSecret> {
    constructor() {
        super("CMsgClientSecret", [
            { no: 1, name: "version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "deviceid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "nonce", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "hmac", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSecret>): CMsgClientSecret {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSecret>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSecret): CMsgClientSecret {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 version */ 1:
                    message.version = reader.uint32();
                    break;
                case /* optional uint32 appid */ 2:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 deviceid */ 3:
                    message.deviceid = reader.uint32();
                    break;
                case /* optional fixed64 nonce */ 4:
                    message.nonce = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes hmac */ 5:
                    message.hmac = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSecret, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 version = 1; */
        if (message.version !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.version);
        /* optional uint32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appid);
        /* optional uint32 deviceid = 3; */
        if (message.deviceid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.deviceid);
        /* optional fixed64 nonce = 4; */
        if (message.nonce !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.nonce);
        /* optional bytes hmac = 5; */
        if (message.hmac !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.hmac);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSecret
 */
export const CMsgClientSecret = new CMsgClientSecret$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSentLogs$Type extends MessageType<CMsgClientSentLogs> {
    constructor() {
        super("CMsgClientSentLogs", []);
    }
    create(value?: PartialMessage<CMsgClientSentLogs>): CMsgClientSentLogs {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSentLogs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSentLogs): CMsgClientSentLogs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSentLogs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSentLogs
 */
export const CMsgClientSentLogs = new CMsgClientSentLogs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientServersAvailable$Type extends MessageType<CMsgClientServersAvailable> {
    constructor() {
        super("CMsgClientServersAvailable", [
            { no: 1, name: "server_types_available", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientServersAvailable_Server_Types_Available },
            { no: 2, name: "server_type_for_auth_services", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientServersAvailable>): CMsgClientServersAvailable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverTypesAvailable = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientServersAvailable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientServersAvailable): CMsgClientServersAvailable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientServersAvailable_Server_Types_Available server_types_available */ 1:
                    message.serverTypesAvailable.push(CMsgClientServersAvailable_Server_Types_Available.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 server_type_for_auth_services */ 2:
                    message.serverTypeForAuthServices = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientServersAvailable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientServersAvailable_Server_Types_Available server_types_available = 1; */
        for (let i = 0; i < message.serverTypesAvailable.length; i++)
            CMsgClientServersAvailable_Server_Types_Available.internalBinaryWrite(message.serverTypesAvailable[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 server_type_for_auth_services = 2; */
        if (message.serverTypeForAuthServices !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.serverTypeForAuthServices);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientServersAvailable
 */
export const CMsgClientServersAvailable = new CMsgClientServersAvailable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientServersAvailable_Server_Types_Available$Type extends MessageType<CMsgClientServersAvailable_Server_Types_Available> {
    constructor() {
        super("CMsgClientServersAvailable_Server_Types_Available", [
            { no: 1, name: "server", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "changed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientServersAvailable_Server_Types_Available>): CMsgClientServersAvailable_Server_Types_Available {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientServersAvailable_Server_Types_Available>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientServersAvailable_Server_Types_Available): CMsgClientServersAvailable_Server_Types_Available {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 server */ 1:
                    message.server = reader.uint32();
                    break;
                case /* optional bool changed */ 2:
                    message.changed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientServersAvailable_Server_Types_Available, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 server = 1; */
        if (message.server !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.server);
        /* optional bool changed = 2; */
        if (message.changed !== undefined)
            writer.tag(2, WireType.Varint).bool(message.changed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientServersAvailable_Server_Types_Available
 */
export const CMsgClientServersAvailable_Server_Types_Available = new CMsgClientServersAvailable_Server_Types_Available$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientServerTimestampRequest$Type extends MessageType<CMsgClientServerTimestampRequest> {
    constructor() {
        super("CMsgClientServerTimestampRequest", [
            { no: 1, name: "client_request_timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientServerTimestampRequest>): CMsgClientServerTimestampRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientServerTimestampRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientServerTimestampRequest): CMsgClientServerTimestampRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 client_request_timestamp */ 1:
                    message.clientRequestTimestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientServerTimestampRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 client_request_timestamp = 1; */
        if (message.clientRequestTimestamp !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.clientRequestTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientServerTimestampRequest
 */
export const CMsgClientServerTimestampRequest = new CMsgClientServerTimestampRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientServerTimestampResponse$Type extends MessageType<CMsgClientServerTimestampResponse> {
    constructor() {
        super("CMsgClientServerTimestampResponse", [
            { no: 1, name: "client_request_timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "server_timestamp_ms", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientServerTimestampResponse>): CMsgClientServerTimestampResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientServerTimestampResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientServerTimestampResponse): CMsgClientServerTimestampResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 client_request_timestamp */ 1:
                    message.clientRequestTimestamp = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 server_timestamp_ms */ 2:
                    message.serverTimestampMs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientServerTimestampResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 client_request_timestamp = 1; */
        if (message.clientRequestTimestamp !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.clientRequestTimestamp);
        /* optional uint64 server_timestamp_ms = 2; */
        if (message.serverTimestampMs !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.serverTimestampMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientServerTimestampResponse
 */
export const CMsgClientServerTimestampResponse = new CMsgClientServerTimestampResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientServiceCall$Type extends MessageType<CMsgClientServiceCall> {
    constructor() {
        super("CMsgClientServiceCall", [
            { no: 1, name: "sysid_routing", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "call_handle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "module_crc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "module_hash", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "function_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "cub_output_max", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "callparameter", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "ping_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "max_outstanding_calls", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientServiceCall>): CMsgClientServiceCall {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientServiceCall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientServiceCall): CMsgClientServiceCall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes sysid_routing */ 1:
                    message.sysidRouting = reader.bytes();
                    break;
                case /* optional uint32 call_handle */ 2:
                    message.callHandle = reader.uint32();
                    break;
                case /* optional uint32 module_crc */ 3:
                    message.moduleCrc = reader.uint32();
                    break;
                case /* optional bytes module_hash */ 4:
                    message.moduleHash = reader.bytes();
                    break;
                case /* optional uint32 function_id */ 5:
                    message.functionId = reader.uint32();
                    break;
                case /* optional uint32 cub_output_max */ 6:
                    message.cubOutputMax = reader.uint32();
                    break;
                case /* optional uint32 flags */ 7:
                    message.flags = reader.uint32();
                    break;
                case /* optional bytes callparameter */ 8:
                    message.callparameter = reader.bytes();
                    break;
                case /* optional bool ping_only */ 9:
                    message.pingOnly = reader.bool();
                    break;
                case /* optional uint32 max_outstanding_calls */ 10:
                    message.maxOutstandingCalls = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientServiceCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes sysid_routing = 1; */
        if (message.sysidRouting !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.sysidRouting);
        /* optional uint32 call_handle = 2; */
        if (message.callHandle !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.callHandle);
        /* optional uint32 module_crc = 3; */
        if (message.moduleCrc !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.moduleCrc);
        /* optional bytes module_hash = 4; */
        if (message.moduleHash !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.moduleHash);
        /* optional uint32 function_id = 5; */
        if (message.functionId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.functionId);
        /* optional uint32 cub_output_max = 6; */
        if (message.cubOutputMax !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.cubOutputMax);
        /* optional uint32 flags = 7; */
        if (message.flags !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.flags);
        /* optional bytes callparameter = 8; */
        if (message.callparameter !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.callparameter);
        /* optional bool ping_only = 9; */
        if (message.pingOnly !== undefined)
            writer.tag(9, WireType.Varint).bool(message.pingOnly);
        /* optional uint32 max_outstanding_calls = 10; */
        if (message.maxOutstandingCalls !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.maxOutstandingCalls);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientServiceCall
 */
export const CMsgClientServiceCall = new CMsgClientServiceCall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientServiceCallResponse$Type extends MessageType<CMsgClientServiceCallResponse> {
    constructor() {
        super("CMsgClientServiceCallResponse", [
            { no: 1, name: "sysid_routing", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "call_handle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "module_crc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "module_hash", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "ecallresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "result_content", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "os_version_info", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "system_info", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "load_address", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "exception_record", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "portable_os_version_info", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "portable_system_info", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 13, name: "was_converted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "internal_result", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "current_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "last_call_handle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "last_call_module_crc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "last_call_sysid_routing", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 19, name: "last_ecallresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "last_callissue_delta", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "last_callcomplete_delta", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientServiceCallResponse>): CMsgClientServiceCallResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientServiceCallResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientServiceCallResponse): CMsgClientServiceCallResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes sysid_routing */ 1:
                    message.sysidRouting = reader.bytes();
                    break;
                case /* optional uint32 call_handle */ 2:
                    message.callHandle = reader.uint32();
                    break;
                case /* optional uint32 module_crc */ 3:
                    message.moduleCrc = reader.uint32();
                    break;
                case /* optional bytes module_hash */ 4:
                    message.moduleHash = reader.bytes();
                    break;
                case /* optional uint32 ecallresult */ 5:
                    message.ecallresult = reader.uint32();
                    break;
                case /* optional bytes result_content */ 6:
                    message.resultContent = reader.bytes();
                    break;
                case /* optional bytes os_version_info */ 7:
                    message.osVersionInfo = reader.bytes();
                    break;
                case /* optional bytes system_info */ 8:
                    message.systemInfo = reader.bytes();
                    break;
                case /* optional fixed64 load_address */ 9:
                    message.loadAddress = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes exception_record */ 10:
                    message.exceptionRecord = reader.bytes();
                    break;
                case /* optional bytes portable_os_version_info */ 11:
                    message.portableOsVersionInfo = reader.bytes();
                    break;
                case /* optional bytes portable_system_info */ 12:
                    message.portableSystemInfo = reader.bytes();
                    break;
                case /* optional bool was_converted */ 13:
                    message.wasConverted = reader.bool();
                    break;
                case /* optional uint32 internal_result */ 14:
                    message.internalResult = reader.uint32();
                    break;
                case /* optional uint32 current_count */ 15:
                    message.currentCount = reader.uint32();
                    break;
                case /* optional uint32 last_call_handle */ 16:
                    message.lastCallHandle = reader.uint32();
                    break;
                case /* optional uint32 last_call_module_crc */ 17:
                    message.lastCallModuleCrc = reader.uint32();
                    break;
                case /* optional bytes last_call_sysid_routing */ 18:
                    message.lastCallSysidRouting = reader.bytes();
                    break;
                case /* optional uint32 last_ecallresult */ 19:
                    message.lastEcallresult = reader.uint32();
                    break;
                case /* optional uint32 last_callissue_delta */ 20:
                    message.lastCallissueDelta = reader.uint32();
                    break;
                case /* optional uint32 last_callcomplete_delta */ 21:
                    message.lastCallcompleteDelta = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientServiceCallResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes sysid_routing = 1; */
        if (message.sysidRouting !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.sysidRouting);
        /* optional uint32 call_handle = 2; */
        if (message.callHandle !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.callHandle);
        /* optional uint32 module_crc = 3; */
        if (message.moduleCrc !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.moduleCrc);
        /* optional bytes module_hash = 4; */
        if (message.moduleHash !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.moduleHash);
        /* optional uint32 ecallresult = 5; */
        if (message.ecallresult !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.ecallresult);
        /* optional bytes result_content = 6; */
        if (message.resultContent !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.resultContent);
        /* optional bytes os_version_info = 7; */
        if (message.osVersionInfo !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.osVersionInfo);
        /* optional bytes system_info = 8; */
        if (message.systemInfo !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.systemInfo);
        /* optional fixed64 load_address = 9; */
        if (message.loadAddress !== undefined)
            writer.tag(9, WireType.Bit64).fixed64(message.loadAddress);
        /* optional bytes exception_record = 10; */
        if (message.exceptionRecord !== undefined)
            writer.tag(10, WireType.LengthDelimited).bytes(message.exceptionRecord);
        /* optional bytes portable_os_version_info = 11; */
        if (message.portableOsVersionInfo !== undefined)
            writer.tag(11, WireType.LengthDelimited).bytes(message.portableOsVersionInfo);
        /* optional bytes portable_system_info = 12; */
        if (message.portableSystemInfo !== undefined)
            writer.tag(12, WireType.LengthDelimited).bytes(message.portableSystemInfo);
        /* optional bool was_converted = 13; */
        if (message.wasConverted !== undefined)
            writer.tag(13, WireType.Varint).bool(message.wasConverted);
        /* optional uint32 internal_result = 14; */
        if (message.internalResult !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.internalResult);
        /* optional uint32 current_count = 15; */
        if (message.currentCount !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.currentCount);
        /* optional uint32 last_call_handle = 16; */
        if (message.lastCallHandle !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.lastCallHandle);
        /* optional uint32 last_call_module_crc = 17; */
        if (message.lastCallModuleCrc !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.lastCallModuleCrc);
        /* optional bytes last_call_sysid_routing = 18; */
        if (message.lastCallSysidRouting !== undefined)
            writer.tag(18, WireType.LengthDelimited).bytes(message.lastCallSysidRouting);
        /* optional uint32 last_ecallresult = 19; */
        if (message.lastEcallresult !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.lastEcallresult);
        /* optional uint32 last_callissue_delta = 20; */
        if (message.lastCallissueDelta !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.lastCallissueDelta);
        /* optional uint32 last_callcomplete_delta = 21; */
        if (message.lastCallcompleteDelta !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.lastCallcompleteDelta);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientServiceCallResponse
 */
export const CMsgClientServiceCallResponse = new CMsgClientServiceCallResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientServiceMethodLegacy$Type extends MessageType<CMsgClientServiceMethodLegacy> {
    constructor() {
        super("CMsgClientServiceMethodLegacy", [
            { no: 1, name: "method_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "serialized_method", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "is_notification", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientServiceMethodLegacy>): CMsgClientServiceMethodLegacy {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientServiceMethodLegacy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientServiceMethodLegacy): CMsgClientServiceMethodLegacy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string method_name */ 1:
                    message.methodName = reader.string();
                    break;
                case /* optional bytes serialized_method */ 2:
                    message.serializedMethod = reader.bytes();
                    break;
                case /* optional bool is_notification */ 3:
                    message.isNotification = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientServiceMethodLegacy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string method_name = 1; */
        if (message.methodName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.methodName);
        /* optional bytes serialized_method = 2; */
        if (message.serializedMethod !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.serializedMethod);
        /* optional bool is_notification = 3; */
        if (message.isNotification !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isNotification);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientServiceMethodLegacy
 */
export const CMsgClientServiceMethodLegacy = new CMsgClientServiceMethodLegacy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientServiceMethodLegacyResponse$Type extends MessageType<CMsgClientServiceMethodLegacyResponse> {
    constructor() {
        super("CMsgClientServiceMethodLegacyResponse", [
            { no: 1, name: "method_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "serialized_method_response", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientServiceMethodLegacyResponse>): CMsgClientServiceMethodLegacyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientServiceMethodLegacyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientServiceMethodLegacyResponse): CMsgClientServiceMethodLegacyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string method_name */ 1:
                    message.methodName = reader.string();
                    break;
                case /* optional bytes serialized_method_response */ 2:
                    message.serializedMethodResponse = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientServiceMethodLegacyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string method_name = 1; */
        if (message.methodName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.methodName);
        /* optional bytes serialized_method_response = 2; */
        if (message.serializedMethodResponse !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.serializedMethodResponse);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientServiceMethodLegacyResponse
 */
export const CMsgClientServiceMethodLegacyResponse = new CMsgClientServiceMethodLegacyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientServiceModule$Type extends MessageType<CMsgClientServiceModule> {
    constructor() {
        super("CMsgClientServiceModule", [
            { no: 1, name: "module_crc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "module_hash", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "module_content", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientServiceModule>): CMsgClientServiceModule {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientServiceModule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientServiceModule): CMsgClientServiceModule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 module_crc */ 1:
                    message.moduleCrc = reader.uint32();
                    break;
                case /* optional bytes module_hash */ 2:
                    message.moduleHash = reader.bytes();
                    break;
                case /* optional bytes module_content */ 3:
                    message.moduleContent = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientServiceModule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 module_crc = 1; */
        if (message.moduleCrc !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.moduleCrc);
        /* optional bytes module_hash = 2; */
        if (message.moduleHash !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.moduleHash);
        /* optional bytes module_content = 3; */
        if (message.moduleContent !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.moduleContent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientServiceModule
 */
export const CMsgClientServiceModule = new CMsgClientServiceModule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSessionToken$Type extends MessageType<CMsgClientSessionToken> {
    constructor() {
        super("CMsgClientSessionToken", [
            { no: 1, name: "token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSessionToken>): CMsgClientSessionToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSessionToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSessionToken): CMsgClientSessionToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 token */ 1:
                    message.token = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSessionToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 token = 1; */
        if (message.token !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSessionToken
 */
export const CMsgClientSessionToken = new CMsgClientSessionToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSetClientAppUpdateState$Type extends MessageType<CMsgClientSetClientAppUpdateState> {
    constructor() {
        super("CMsgClientSetClientAppUpdateState", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSetClientAppUpdateState>): CMsgClientSetClientAppUpdateState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSetClientAppUpdateState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSetClientAppUpdateState): CMsgClientSetClientAppUpdateState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional bool update */ 2:
                    message.update = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSetClientAppUpdateState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional bool update = 2; */
        if (message.update !== undefined)
            writer.tag(2, WireType.Varint).bool(message.update);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSetClientAppUpdateState
 */
export const CMsgClientSetClientAppUpdateState = new CMsgClientSetClientAppUpdateState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSetClientAppUpdateStateResponse$Type extends MessageType<CMsgClientSetClientAppUpdateStateResponse> {
    constructor() {
        super("CMsgClientSetClientAppUpdateStateResponse", [
            { no: 1, name: "result", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSetClientAppUpdateStateResponse>): CMsgClientSetClientAppUpdateStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSetClientAppUpdateStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSetClientAppUpdateStateResponse): CMsgClientSetClientAppUpdateStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 result */ 1:
                    message.result = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSetClientAppUpdateStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 result = 1; */
        if (message.result !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSetClientAppUpdateStateResponse
 */
export const CMsgClientSetClientAppUpdateStateResponse = new CMsgClientSetClientAppUpdateStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSetPlayerNickname$Type extends MessageType<CMsgClientSetPlayerNickname> {
    constructor() {
        super("CMsgClientSetPlayerNickname", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "nickname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSetPlayerNickname>): CMsgClientSetPlayerNickname {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSetPlayerNickname>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSetPlayerNickname): CMsgClientSetPlayerNickname {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string nickname */ 2:
                    message.nickname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSetPlayerNickname, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional string nickname = 2; */
        if (message.nickname !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.nickname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSetPlayerNickname
 */
export const CMsgClientSetPlayerNickname = new CMsgClientSetPlayerNickname$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSetPlayerNicknameResponse$Type extends MessageType<CMsgClientSetPlayerNicknameResponse> {
    constructor() {
        super("CMsgClientSetPlayerNicknameResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSetPlayerNicknameResponse>): CMsgClientSetPlayerNicknameResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSetPlayerNicknameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSetPlayerNicknameResponse): CMsgClientSetPlayerNicknameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSetPlayerNicknameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSetPlayerNicknameResponse
 */
export const CMsgClientSetPlayerNicknameResponse = new CMsgClientSetPlayerNicknameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSettings$Type extends MessageType<CMsgClientSettings> {
    constructor() {
        super("CMsgClientSettings", [
            { no: 1, name: "no_save_personal_info", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "oobe_test_mode_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "in_client_beta", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_steam_sideloaded", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "preferred_monitor", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "steam_cef_gpu_blocklist_disabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "bigpicture_windowed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "is_external_display", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "steam_os_underscan_level", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "steam_os_underscan_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "min_scale_factor", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "max_scale_factor", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "auto_scale_factor", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 16, name: "small_mode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "skip_steamvr_install_dialog", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "always_show_user_chooser", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "os_version_unsupported", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3000, name: "show_family_sharing_notifications", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3001, name: "show_copy_count_in_library", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4000, name: "overlay_fps_counter_corner", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4001, name: "overlay_fps_counter_high_contrast", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4002, name: "overlay_key", kind: "message", T: () => CMsgHotkey },
            { no: 4003, name: "screenshot_key", kind: "message", T: () => CMsgHotkey },
            { no: 4004, name: "enable_overlay", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4006, name: "enable_screenshot_notification", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4007, name: "enable_screenshot_sound", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4008, name: "save_uncompressed_screenshots", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4009, name: "screenshots_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4010, name: "default_ping_rate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4011, name: "server_ping_rate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4012, name: "steam_networking_share_ip", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4013, name: "web_browser_home", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4014, name: "voice_mic_device_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4015, name: "voice_mic_input_gain", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4016, name: "voice_speaker_output_gain", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4017, name: "voice_push_to_talk_setting", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4018, name: "voice_push_to_talk_key", kind: "message", T: () => CMsgHotkey },
            { no: 4019, name: "overlay_toolbar_list_view", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4020, name: "always_use_gamepadui_overlay", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4021, name: "overlay_tabs", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4022, name: "overlay_scale_interface", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4023, name: "overlay_restore_browser_tabs", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4024, name: "enable_avif_screenshots", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4025, name: "overlay_fps_counter_detail_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4026, name: "overlay_fps_counter_saturation_factor", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4027, name: "overlay_fps_counter_bgopacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4028, name: "overlay_fps_counter_scale_factor", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4029, name: "overlay_fps_counter_key", kind: "message", T: () => CMsgHotkey },
            { no: 4030, name: "overlay_fps_counter_fps_graph", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4031, name: "overlay_fps_counter_cpu_graph", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5000, name: "smooth_scroll_webviews", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5001, name: "enable_gpu_accelerated_webviews", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5003, name: "enable_hardware_video_decoding", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5004, name: "run_at_startup", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5005, name: "enable_dpi_scaling", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5006, name: "enable_marketing_messages", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5007, name: "start_in_big_picture_mode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5008, name: "jumplist_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5009, name: "enable_ui_sounds", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6000, name: "disable_all_toasts", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6001, name: "disable_toasts_in_game", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6002, name: "play_sound_on_toast", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7000, name: "library_display_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7001, name: "library_whats_new_show_only_product_updates", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7002, name: "show_store_content_on_home", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7003, name: "start_page", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7004, name: "library_low_bandwidth_mode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7005, name: "library_low_perf_mode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7006, name: "library_disable_community_content", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7007, name: "library_display_icon_in_game_list", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7008, name: "ready_to_play_includes_streaming", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7009, name: "show_steam_deck_info", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8000, name: "enable_shader_precache", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8001, name: "enable_shader_background_processing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8002, name: "shader_precached_size", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8003, name: "needs_steam_service_repair", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8004, name: "download_peer_content", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8005, name: "download_rate_bits_per_s", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8006, name: "restrict_auto_updates", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8007, name: "restrict_auto_updates_start", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8008, name: "restrict_auto_updates_end", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8009, name: "download_region", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8010, name: "download_while_app_running", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8011, name: "download_throttle_while_streaming", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8012, name: "download_throttle_rate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8013, name: "default_app_update_behavior", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10000, name: "cloud_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10001, name: "show_screenshot_manager", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11000, name: "music_volume", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11001, name: "music_pause_on_app_start", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11002, name: "music_pause_on_voice_chat", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11003, name: "music_download_high_quality", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11004, name: "music_playlist_notification", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12000, name: "broadcast_permissions", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 12001, name: "broadcast_output_width", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12002, name: "broadcast_output_height", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12003, name: "broadcast_bitrate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12004, name: "broadcast_encoding_option", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 12005, name: "broadcast_record_all_video", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12006, name: "broadcast_record_all_audio", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12007, name: "broadcast_record_microphone", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12008, name: "broadcast_show_upload_stats", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12009, name: "broadcast_show_live_reminder", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12010, name: "broadcast_chat_corner", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13000, name: "gamestream_hardware_video_encode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13001, name: "gamestream_enable_video_h265", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14001, name: "steam_input_configurator_error_msg_enable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14002, name: "controller_guide_button_focus_steam", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14003, name: "controller_ps_support", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14004, name: "controller_xbox_support", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14005, name: "controller_xbox_driver", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14006, name: "controller_switch_support", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14007, name: "controller_generic_support", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14008, name: "controller_power_off_timeout", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14009, name: "turn_off_controller_on_exit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14010, name: "controller_combine_nintendo_joycons", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16000, name: "startup_movie_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16001, name: "startup_movie_local_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16002, name: "startup_movie_shuffle", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16003, name: "startup_movie_used_for_resume", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17001, name: "game_notes_enable_spellcheck", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18000, name: "screenshot_items_per_row", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18201, name: "gamerecording_background_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18202, name: "gamerecording_background_max_keep", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18203, name: "gamerecording_background_time_resolution", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18207, name: "gamerecording_background_mk", kind: "message", T: () => CMsgHotkey },
            { no: 18208, name: "gamerecording_background_tg", kind: "message", T: () => CMsgHotkey },
            { no: 18209, name: "gamerecording_background_a_m", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18210, name: "gamerecording_video_bitrate", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18212, name: "gamerecording_background_mode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 18213, name: "gamerecording_background_audio", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 18214, name: "gamerecording_max_fps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18215, name: "gamerecording_hotkey_ic", kind: "message", T: () => CMsgHotkey },
            { no: 18216, name: "gamerecording_ic_seconds", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 18217, name: "gamerecording_export_limit_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 18218, name: "gamerecording_export_limit_size_mb", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18219, name: "gamerecording_export_limit_bitrate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18220, name: "gamerecording_export_limit_width", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18221, name: "gamerecording_export_limit_height", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18222, name: "gamerecording_export_limit_frame_rate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18223, name: "gamerecording_export_directory", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18224, name: "gamerecording_export_codec", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 18225, name: "gamerecording_video_maxheight", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18226, name: "gamerecording_force_mic_mono", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18227, name: "gamerecording_automatic_gain_control", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20000, name: "show_timestamps_in_console", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20001, name: "force_oobe", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20002, name: "override_browser_composer_mode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 20003, name: "cef_remote_debugging_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20004, name: "force_deck_perf_tab", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20005, name: "force_fake_mandatory_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20006, name: "hdr_compat_testing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20007, name: "developer_mode_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20008, name: "show_advanced_update_channels", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21001, name: "gamescope_hdr_visualization", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 21002, name: "gamescope_app_target_framerate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 21003, name: "gamescope_enable_app_target_framerate", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21004, name: "gamescope_disable_framelimit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21005, name: "gamescope_display_refresh_rate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 21006, name: "gamescope_use_game_refresh_rate_in_steam", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21007, name: "gamescope_disable_mura_correction", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21008, name: "gamescope_include_steamui_in_screenshots", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21009, name: "gamescope_allow_tearing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21010, name: "gamescope_composite_debug", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21011, name: "gamescope_force_composite", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21012, name: "gamescope_game_resolution_global", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 21013, name: "gamescope_guide_hotkey", kind: "message", T: () => CMsgHotkey },
            { no: 21014, name: "gamescope_qam_hotkey", kind: "message", T: () => CMsgHotkey },
            { no: 21015, name: "gamescope_hdr_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21016, name: "gamescope_native_external_res_in_steam", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22000, name: "steamos_status_led_brightness", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22001, name: "steamos_tdp_limit_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22002, name: "steamos_tdp_limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22003, name: "steamos_cec_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22004, name: "steamos_cec_wake_on_resume", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22005, name: "steamos_wifi_debug", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22006, name: "steamos_wifi_force_wpa_supplicant", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22007, name: "steamos_magnifier_scale", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22008, name: "steamos_manual_gpu_clock_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22009, name: "steamos_manual_gpu_clock_hz", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22010, name: "steamos_platform_performance_profile", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 22011, name: "steamos_charge_limit_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22012, name: "steamos_charge_limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22013, name: "steamos_charge_limit_devmode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 23001, name: "setting_validation_bool", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 23002, name: "setting_validation_enum", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 23003, name: "setting_validation_int32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 23004, name: "setting_validation_uint32", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23005, name: "setting_validation_uint64", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 23006, name: "setting_validation_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 23007, name: "setting_validation_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 23008, name: "setting_validation_hotkey", kind: "message", T: () => CMsgHotkey },
            { no: 24000, name: "system_bluetooth_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24001, name: "hardware_updater_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 25000, name: "vr_show_perf_graph_in_hmd", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 26000, name: "accessibility_debug_visualizer", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 26001, name: "accessibility_screen_reader_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 26002, name: "accessibility_screen_reader_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 26003, name: "accessibility_screen_reader_pitch", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 26004, name: "accessibility_screen_reader_volume", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 26005, name: "accessibility_high_contrast_mode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 26006, name: "accessibility_reduce_motion", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 26008, name: "accessibility_minimum_font_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26009, name: "accessibility_color_filter_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 26010, name: "accessibility_desktop_ui_scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 140011, name: "controller_enable_chord", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 140012, name: "controller_poll_rate", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSettings>): CMsgClientSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSettings): CMsgClientSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool no_save_personal_info */ 1:
                    message.noSavePersonalInfo = reader.bool();
                    break;
                case /* optional bool oobe_test_mode_enabled */ 2:
                    message.oobeTestModeEnabled = reader.bool();
                    break;
                case /* optional bool in_client_beta */ 3:
                    message.inClientBeta = reader.bool();
                    break;
                case /* optional bool is_steam_sideloaded */ 4:
                    message.isSteamSideloaded = reader.bool();
                    break;
                case /* optional string preferred_monitor */ 5:
                    message.preferredMonitor = reader.string();
                    break;
                case /* optional bool steam_cef_gpu_blocklist_disabled */ 6:
                    message.steamCefGpuBlocklistDisabled = reader.bool();
                    break;
                case /* optional bool bigpicture_windowed */ 7:
                    message.bigpictureWindowed = reader.bool();
                    break;
                case /* optional string display_name */ 8:
                    message.displayName = reader.string();
                    break;
                case /* optional bool is_external_display */ 9:
                    message.isExternalDisplay = reader.bool();
                    break;
                case /* optional float steam_os_underscan_level */ 10:
                    message.steamOsUnderscanLevel = reader.float();
                    break;
                case /* optional bool steam_os_underscan_enabled */ 11:
                    message.steamOsUnderscanEnabled = reader.bool();
                    break;
                case /* optional float min_scale_factor */ 12:
                    message.minScaleFactor = reader.float();
                    break;
                case /* optional float max_scale_factor */ 13:
                    message.maxScaleFactor = reader.float();
                    break;
                case /* optional float auto_scale_factor */ 14:
                    message.autoScaleFactor = reader.float();
                    break;
                case /* optional bool small_mode */ 16:
                    message.smallMode = reader.bool();
                    break;
                case /* optional bool skip_steamvr_install_dialog */ 19:
                    message.skipSteamvrInstallDialog = reader.bool();
                    break;
                case /* optional bool always_show_user_chooser */ 20:
                    message.alwaysShowUserChooser = reader.bool();
                    break;
                case /* optional bool os_version_unsupported */ 21:
                    message.osVersionUnsupported = reader.bool();
                    break;
                case /* optional bool show_family_sharing_notifications */ 3000:
                    message.showFamilySharingNotifications = reader.bool();
                    break;
                case /* optional bool show_copy_count_in_library */ 3001:
                    message.showCopyCountInLibrary = reader.bool();
                    break;
                case /* optional int32 overlay_fps_counter_corner */ 4000:
                    message.overlayFpsCounterCorner = reader.int32();
                    break;
                case /* optional bool overlay_fps_counter_high_contrast */ 4001:
                    message.overlayFpsCounterHighContrast = reader.bool();
                    break;
                case /* optional CMsgHotkey overlay_key */ 4002:
                    message.overlayKey = CMsgHotkey.internalBinaryRead(reader, reader.uint32(), options, message.overlayKey);
                    break;
                case /* optional CMsgHotkey screenshot_key */ 4003:
                    message.screenshotKey = CMsgHotkey.internalBinaryRead(reader, reader.uint32(), options, message.screenshotKey);
                    break;
                case /* optional bool enable_overlay */ 4004:
                    message.enableOverlay = reader.bool();
                    break;
                case /* optional bool enable_screenshot_notification */ 4006:
                    message.enableScreenshotNotification = reader.bool();
                    break;
                case /* optional bool enable_screenshot_sound */ 4007:
                    message.enableScreenshotSound = reader.bool();
                    break;
                case /* optional bool save_uncompressed_screenshots */ 4008:
                    message.saveUncompressedScreenshots = reader.bool();
                    break;
                case /* optional string screenshots_path */ 4009:
                    message.screenshotsPath = reader.string();
                    break;
                case /* optional int32 default_ping_rate */ 4010:
                    message.defaultPingRate = reader.int32();
                    break;
                case /* optional int32 server_ping_rate */ 4011:
                    message.serverPingRate = reader.int32();
                    break;
                case /* optional int32 steam_networking_share_ip */ 4012:
                    message.steamNetworkingShareIp = reader.int32();
                    break;
                case /* optional string web_browser_home */ 4013:
                    message.webBrowserHome = reader.string();
                    break;
                case /* optional string voice_mic_device_name */ 4014:
                    message.voiceMicDeviceName = reader.string();
                    break;
                case /* optional float voice_mic_input_gain */ 4015:
                    message.voiceMicInputGain = reader.float();
                    break;
                case /* optional float voice_speaker_output_gain */ 4016:
                    message.voiceSpeakerOutputGain = reader.float();
                    break;
                case /* optional int32 voice_push_to_talk_setting */ 4017:
                    message.voicePushToTalkSetting = reader.int32();
                    break;
                case /* optional CMsgHotkey voice_push_to_talk_key */ 4018:
                    message.voicePushToTalkKey = CMsgHotkey.internalBinaryRead(reader, reader.uint32(), options, message.voicePushToTalkKey);
                    break;
                case /* optional bool overlay_toolbar_list_view */ 4019:
                    message.overlayToolbarListView = reader.bool();
                    break;
                case /* optional bool always_use_gamepadui_overlay */ 4020:
                    message.alwaysUseGamepaduiOverlay = reader.bool();
                    break;
                case /* optional string overlay_tabs */ 4021:
                    message.overlayTabs = reader.string();
                    break;
                case /* optional bool overlay_scale_interface */ 4022:
                    message.overlayScaleInterface = reader.bool();
                    break;
                case /* optional bool overlay_restore_browser_tabs */ 4023:
                    message.overlayRestoreBrowserTabs = reader.bool();
                    break;
                case /* optional bool enable_avif_screenshots */ 4024:
                    message.enableAvifScreenshots = reader.bool();
                    break;
                case /* optional int32 overlay_fps_counter_detail_level */ 4025:
                    message.overlayFpsCounterDetailLevel = reader.int32();
                    break;
                case /* optional float overlay_fps_counter_saturation_factor */ 4026:
                    message.overlayFpsCounterSaturationFactor = reader.float();
                    break;
                case /* optional float overlay_fps_counter_bgopacity */ 4027:
                    message.overlayFpsCounterBgopacity = reader.float();
                    break;
                case /* optional float overlay_fps_counter_scale_factor */ 4028:
                    message.overlayFpsCounterScaleFactor = reader.float();
                    break;
                case /* optional CMsgHotkey overlay_fps_counter_key */ 4029:
                    message.overlayFpsCounterKey = CMsgHotkey.internalBinaryRead(reader, reader.uint32(), options, message.overlayFpsCounterKey);
                    break;
                case /* optional bool overlay_fps_counter_fps_graph */ 4030:
                    message.overlayFpsCounterFpsGraph = reader.bool();
                    break;
                case /* optional bool overlay_fps_counter_cpu_graph */ 4031:
                    message.overlayFpsCounterCpuGraph = reader.bool();
                    break;
                case /* optional bool smooth_scroll_webviews */ 5000:
                    message.smoothScrollWebviews = reader.bool();
                    break;
                case /* optional bool enable_gpu_accelerated_webviews */ 5001:
                    message.enableGpuAcceleratedWebviews = reader.bool();
                    break;
                case /* optional bool enable_hardware_video_decoding */ 5003:
                    message.enableHardwareVideoDecoding = reader.bool();
                    break;
                case /* optional bool run_at_startup */ 5004:
                    message.runAtStartup = reader.bool();
                    break;
                case /* optional bool enable_dpi_scaling */ 5005:
                    message.enableDpiScaling = reader.bool();
                    break;
                case /* optional bool enable_marketing_messages */ 5006:
                    message.enableMarketingMessages = reader.bool();
                    break;
                case /* optional bool start_in_big_picture_mode */ 5007:
                    message.startInBigPictureMode = reader.bool();
                    break;
                case /* optional uint32 jumplist_flags */ 5008:
                    message.jumplistFlags = reader.uint32();
                    break;
                case /* optional bool enable_ui_sounds */ 5009:
                    message.enableUiSounds = reader.bool();
                    break;
                case /* optional bool disable_all_toasts */ 6000:
                    message.disableAllToasts = reader.bool();
                    break;
                case /* optional bool disable_toasts_in_game */ 6001:
                    message.disableToastsInGame = reader.bool();
                    break;
                case /* optional bool play_sound_on_toast */ 6002:
                    message.playSoundOnToast = reader.bool();
                    break;
                case /* optional int32 library_display_size */ 7000:
                    message.libraryDisplaySize = reader.int32();
                    break;
                case /* optional bool library_whats_new_show_only_product_updates */ 7001:
                    message.libraryWhatsNewShowOnlyProductUpdates = reader.bool();
                    break;
                case /* optional bool show_store_content_on_home */ 7002:
                    message.showStoreContentOnHome = reader.bool();
                    break;
                case /* optional string start_page */ 7003:
                    message.startPage = reader.string();
                    break;
                case /* optional bool library_low_bandwidth_mode */ 7004:
                    message.libraryLowBandwidthMode = reader.bool();
                    break;
                case /* optional bool library_low_perf_mode */ 7005:
                    message.libraryLowPerfMode = reader.bool();
                    break;
                case /* optional bool library_disable_community_content */ 7006:
                    message.libraryDisableCommunityContent = reader.bool();
                    break;
                case /* optional bool library_display_icon_in_game_list */ 7007:
                    message.libraryDisplayIconInGameList = reader.bool();
                    break;
                case /* optional bool ready_to_play_includes_streaming */ 7008:
                    message.readyToPlayIncludesStreaming = reader.bool();
                    break;
                case /* optional bool show_steam_deck_info */ 7009:
                    message.showSteamDeckInfo = reader.bool();
                    break;
                case /* optional bool enable_shader_precache */ 8000:
                    message.enableShaderPrecache = reader.bool();
                    break;
                case /* optional bool enable_shader_background_processing */ 8001:
                    message.enableShaderBackgroundProcessing = reader.bool();
                    break;
                case /* optional uint64 shader_precached_size */ 8002:
                    message.shaderPrecachedSize = reader.uint64().toBigInt();
                    break;
                case /* optional bool needs_steam_service_repair */ 8003:
                    message.needsSteamServiceRepair = reader.bool();
                    break;
                case /* optional int32 download_peer_content */ 8004:
                    message.downloadPeerContent = reader.int32();
                    break;
                case /* optional bool download_rate_bits_per_s */ 8005:
                    message.downloadRateBitsPerS = reader.bool();
                    break;
                case /* optional bool restrict_auto_updates */ 8006:
                    message.restrictAutoUpdates = reader.bool();
                    break;
                case /* optional int32 restrict_auto_updates_start */ 8007:
                    message.restrictAutoUpdatesStart = reader.int32();
                    break;
                case /* optional int32 restrict_auto_updates_end */ 8008:
                    message.restrictAutoUpdatesEnd = reader.int32();
                    break;
                case /* optional int32 download_region */ 8009:
                    message.downloadRegion = reader.int32();
                    break;
                case /* optional bool download_while_app_running */ 8010:
                    message.downloadWhileAppRunning = reader.bool();
                    break;
                case /* optional bool download_throttle_while_streaming */ 8011:
                    message.downloadThrottleWhileStreaming = reader.bool();
                    break;
                case /* optional int32 download_throttle_rate */ 8012:
                    message.downloadThrottleRate = reader.int32();
                    break;
                case /* optional int32 default_app_update_behavior */ 8013:
                    message.defaultAppUpdateBehavior = reader.int32();
                    break;
                case /* optional bool cloud_enabled */ 10000:
                    message.cloudEnabled = reader.bool();
                    break;
                case /* optional bool show_screenshot_manager */ 10001:
                    message.showScreenshotManager = reader.bool();
                    break;
                case /* optional int32 music_volume */ 11000:
                    message.musicVolume = reader.int32();
                    break;
                case /* optional bool music_pause_on_app_start */ 11001:
                    message.musicPauseOnAppStart = reader.bool();
                    break;
                case /* optional bool music_pause_on_voice_chat */ 11002:
                    message.musicPauseOnVoiceChat = reader.bool();
                    break;
                case /* optional bool music_download_high_quality */ 11003:
                    message.musicDownloadHighQuality = reader.bool();
                    break;
                case /* optional bool music_playlist_notification */ 11004:
                    message.musicPlaylistNotification = reader.bool();
                    break;
                case /* optional int32 broadcast_permissions */ 12000:
                    message.broadcastPermissions = reader.int32();
                    break;
                case /* optional int32 broadcast_output_width */ 12001:
                    message.broadcastOutputWidth = reader.int32();
                    break;
                case /* optional int32 broadcast_output_height */ 12002:
                    message.broadcastOutputHeight = reader.int32();
                    break;
                case /* optional int32 broadcast_bitrate */ 12003:
                    message.broadcastBitrate = reader.int32();
                    break;
                case /* optional int32 broadcast_encoding_option */ 12004:
                    message.broadcastEncodingOption = reader.int32();
                    break;
                case /* optional bool broadcast_record_all_video */ 12005:
                    message.broadcastRecordAllVideo = reader.bool();
                    break;
                case /* optional bool broadcast_record_all_audio */ 12006:
                    message.broadcastRecordAllAudio = reader.bool();
                    break;
                case /* optional bool broadcast_record_microphone */ 12007:
                    message.broadcastRecordMicrophone = reader.bool();
                    break;
                case /* optional bool broadcast_show_upload_stats */ 12008:
                    message.broadcastShowUploadStats = reader.bool();
                    break;
                case /* optional bool broadcast_show_live_reminder */ 12009:
                    message.broadcastShowLiveReminder = reader.bool();
                    break;
                case /* optional int32 broadcast_chat_corner */ 12010:
                    message.broadcastChatCorner = reader.int32();
                    break;
                case /* optional bool gamestream_hardware_video_encode */ 13000:
                    message.gamestreamHardwareVideoEncode = reader.bool();
                    break;
                case /* optional bool gamestream_enable_video_h265 */ 13001:
                    message.gamestreamEnableVideoH265 = reader.bool();
                    break;
                case /* optional bool steam_input_configurator_error_msg_enable */ 14001:
                    message.steamInputConfiguratorErrorMsgEnable = reader.bool();
                    break;
                case /* optional bool controller_guide_button_focus_steam */ 14002:
                    message.controllerGuideButtonFocusSteam = reader.bool();
                    break;
                case /* optional int32 controller_ps_support */ 14003:
                    message.controllerPsSupport = reader.int32();
                    break;
                case /* optional bool controller_xbox_support */ 14004:
                    message.controllerXboxSupport = reader.bool();
                    break;
                case /* optional bool controller_xbox_driver */ 14005:
                    message.controllerXboxDriver = reader.bool();
                    break;
                case /* optional bool controller_switch_support */ 14006:
                    message.controllerSwitchSupport = reader.bool();
                    break;
                case /* optional bool controller_generic_support */ 14007:
                    message.controllerGenericSupport = reader.bool();
                    break;
                case /* optional int32 controller_power_off_timeout */ 14008:
                    message.controllerPowerOffTimeout = reader.int32();
                    break;
                case /* optional bool turn_off_controller_on_exit */ 14009:
                    message.turnOffControllerOnExit = reader.bool();
                    break;
                case /* optional bool controller_combine_nintendo_joycons */ 14010:
                    message.controllerCombineNintendoJoycons = reader.bool();
                    break;
                case /* optional uint64 startup_movie_id */ 16000:
                    message.startupMovieId = reader.uint64().toBigInt();
                    break;
                case /* optional string startup_movie_local_path */ 16001:
                    message.startupMovieLocalPath = reader.string();
                    break;
                case /* optional bool startup_movie_shuffle */ 16002:
                    message.startupMovieShuffle = reader.bool();
                    break;
                case /* optional bool startup_movie_used_for_resume */ 16003:
                    message.startupMovieUsedForResume = reader.bool();
                    break;
                case /* optional bool game_notes_enable_spellcheck */ 17001:
                    message.gameNotesEnableSpellcheck = reader.bool();
                    break;
                case /* optional int32 screenshot_items_per_row */ 18000:
                    message.screenshotItemsPerRow = reader.int32();
                    break;
                case /* optional string gamerecording_background_path */ 18201:
                    message.gamerecordingBackgroundPath = reader.string();
                    break;
                case /* optional string gamerecording_background_max_keep */ 18202:
                    message.gamerecordingBackgroundMaxKeep = reader.string();
                    break;
                case /* optional int32 gamerecording_background_time_resolution */ 18203:
                    message.gamerecordingBackgroundTimeResolution = reader.int32();
                    break;
                case /* optional CMsgHotkey gamerecording_background_mk */ 18207:
                    message.gamerecordingBackgroundMk = CMsgHotkey.internalBinaryRead(reader, reader.uint32(), options, message.gamerecordingBackgroundMk);
                    break;
                case /* optional CMsgHotkey gamerecording_background_tg */ 18208:
                    message.gamerecordingBackgroundTg = CMsgHotkey.internalBinaryRead(reader, reader.uint32(), options, message.gamerecordingBackgroundTg);
                    break;
                case /* optional bool gamerecording_background_a_m */ 18209:
                    message.gamerecordingBackgroundAM = reader.bool();
                    break;
                case /* optional string gamerecording_video_bitrate */ 18210:
                    message.gamerecordingVideoBitrate = reader.string();
                    break;
                case /* optional int32 gamerecording_background_mode */ 18212:
                    message.gamerecordingBackgroundMode = reader.int32();
                    break;
                case /* optional int32 gamerecording_background_audio */ 18213:
                    message.gamerecordingBackgroundAudio = reader.int32();
                    break;
                case /* optional int32 gamerecording_max_fps */ 18214:
                    message.gamerecordingMaxFps = reader.int32();
                    break;
                case /* optional CMsgHotkey gamerecording_hotkey_ic */ 18215:
                    message.gamerecordingHotkeyIc = CMsgHotkey.internalBinaryRead(reader, reader.uint32(), options, message.gamerecordingHotkeyIc);
                    break;
                case /* optional float gamerecording_ic_seconds */ 18216:
                    message.gamerecordingIcSeconds = reader.float();
                    break;
                case /* optional int32 gamerecording_export_limit_type */ 18217:
                    message.gamerecordingExportLimitType = reader.int32();
                    break;
                case /* optional int32 gamerecording_export_limit_size_mb */ 18218:
                    message.gamerecordingExportLimitSizeMb = reader.int32();
                    break;
                case /* optional int32 gamerecording_export_limit_bitrate */ 18219:
                    message.gamerecordingExportLimitBitrate = reader.int32();
                    break;
                case /* optional int32 gamerecording_export_limit_width */ 18220:
                    message.gamerecordingExportLimitWidth = reader.int32();
                    break;
                case /* optional int32 gamerecording_export_limit_height */ 18221:
                    message.gamerecordingExportLimitHeight = reader.int32();
                    break;
                case /* optional int32 gamerecording_export_limit_frame_rate */ 18222:
                    message.gamerecordingExportLimitFrameRate = reader.int32();
                    break;
                case /* optional string gamerecording_export_directory */ 18223:
                    message.gamerecordingExportDirectory = reader.string();
                    break;
                case /* optional int32 gamerecording_export_codec */ 18224:
                    message.gamerecordingExportCodec = reader.int32();
                    break;
                case /* optional int32 gamerecording_video_maxheight */ 18225:
                    message.gamerecordingVideoMaxheight = reader.int32();
                    break;
                case /* optional bool gamerecording_force_mic_mono */ 18226:
                    message.gamerecordingForceMicMono = reader.bool();
                    break;
                case /* optional bool gamerecording_automatic_gain_control */ 18227:
                    message.gamerecordingAutomaticGainControl = reader.bool();
                    break;
                case /* optional bool show_timestamps_in_console */ 20000:
                    message.showTimestampsInConsole = reader.bool();
                    break;
                case /* optional bool force_oobe */ 20001:
                    message.forceOobe = reader.bool();
                    break;
                case /* optional int32 override_browser_composer_mode */ 20002:
                    message.overrideBrowserComposerMode = reader.int32();
                    break;
                case /* optional bool cef_remote_debugging_enabled */ 20003:
                    message.cefRemoteDebuggingEnabled = reader.bool();
                    break;
                case /* optional bool force_deck_perf_tab */ 20004:
                    message.forceDeckPerfTab = reader.bool();
                    break;
                case /* optional bool force_fake_mandatory_update */ 20005:
                    message.forceFakeMandatoryUpdate = reader.bool();
                    break;
                case /* optional bool hdr_compat_testing */ 20006:
                    message.hdrCompatTesting = reader.bool();
                    break;
                case /* optional bool developer_mode_enabled */ 20007:
                    message.developerModeEnabled = reader.bool();
                    break;
                case /* optional bool show_advanced_update_channels */ 20008:
                    message.showAdvancedUpdateChannels = reader.bool();
                    break;
                case /* optional int32 gamescope_hdr_visualization */ 21001:
                    message.gamescopeHdrVisualization = reader.int32();
                    break;
                case /* optional int32 gamescope_app_target_framerate */ 21002:
                    message.gamescopeAppTargetFramerate = reader.int32();
                    break;
                case /* optional bool gamescope_enable_app_target_framerate */ 21003:
                    message.gamescopeEnableAppTargetFramerate = reader.bool();
                    break;
                case /* optional bool gamescope_disable_framelimit */ 21004:
                    message.gamescopeDisableFramelimit = reader.bool();
                    break;
                case /* optional int32 gamescope_display_refresh_rate */ 21005:
                    message.gamescopeDisplayRefreshRate = reader.int32();
                    break;
                case /* optional bool gamescope_use_game_refresh_rate_in_steam */ 21006:
                    message.gamescopeUseGameRefreshRateInSteam = reader.bool();
                    break;
                case /* optional bool gamescope_disable_mura_correction */ 21007:
                    message.gamescopeDisableMuraCorrection = reader.bool();
                    break;
                case /* optional bool gamescope_include_steamui_in_screenshots */ 21008:
                    message.gamescopeIncludeSteamuiInScreenshots = reader.bool();
                    break;
                case /* optional bool gamescope_allow_tearing */ 21009:
                    message.gamescopeAllowTearing = reader.bool();
                    break;
                case /* optional bool gamescope_composite_debug */ 21010:
                    message.gamescopeCompositeDebug = reader.bool();
                    break;
                case /* optional bool gamescope_force_composite */ 21011:
                    message.gamescopeForceComposite = reader.bool();
                    break;
                case /* optional string gamescope_game_resolution_global */ 21012:
                    message.gamescopeGameResolutionGlobal = reader.string();
                    break;
                case /* optional CMsgHotkey gamescope_guide_hotkey */ 21013:
                    message.gamescopeGuideHotkey = CMsgHotkey.internalBinaryRead(reader, reader.uint32(), options, message.gamescopeGuideHotkey);
                    break;
                case /* optional CMsgHotkey gamescope_qam_hotkey */ 21014:
                    message.gamescopeQamHotkey = CMsgHotkey.internalBinaryRead(reader, reader.uint32(), options, message.gamescopeQamHotkey);
                    break;
                case /* optional bool gamescope_hdr_enabled */ 21015:
                    message.gamescopeHdrEnabled = reader.bool();
                    break;
                case /* optional bool gamescope_native_external_res_in_steam */ 21016:
                    message.gamescopeNativeExternalResInSteam = reader.bool();
                    break;
                case /* optional int32 steamos_status_led_brightness */ 22000:
                    message.steamosStatusLedBrightness = reader.int32();
                    break;
                case /* optional bool steamos_tdp_limit_enabled */ 22001:
                    message.steamosTdpLimitEnabled = reader.bool();
                    break;
                case /* optional int32 steamos_tdp_limit */ 22002:
                    message.steamosTdpLimit = reader.int32();
                    break;
                case /* optional bool steamos_cec_enabled */ 22003:
                    message.steamosCecEnabled = reader.bool();
                    break;
                case /* optional bool steamos_cec_wake_on_resume */ 22004:
                    message.steamosCecWakeOnResume = reader.bool();
                    break;
                case /* optional bool steamos_wifi_debug */ 22005:
                    message.steamosWifiDebug = reader.bool();
                    break;
                case /* optional bool steamos_wifi_force_wpa_supplicant */ 22006:
                    message.steamosWifiForceWpaSupplicant = reader.bool();
                    break;
                case /* optional int32 steamos_magnifier_scale */ 22007:
                    message.steamosMagnifierScale = reader.int32();
                    break;
                case /* optional bool steamos_manual_gpu_clock_enabled */ 22008:
                    message.steamosManualGpuClockEnabled = reader.bool();
                    break;
                case /* optional int32 steamos_manual_gpu_clock_hz */ 22009:
                    message.steamosManualGpuClockHz = reader.int32();
                    break;
                case /* optional string steamos_platform_performance_profile */ 22010:
                    message.steamosPlatformPerformanceProfile = reader.string();
                    break;
                case /* optional bool steamos_charge_limit_enabled */ 22011:
                    message.steamosChargeLimitEnabled = reader.bool();
                    break;
                case /* optional int32 steamos_charge_limit */ 22012:
                    message.steamosChargeLimit = reader.int32();
                    break;
                case /* optional bool steamos_charge_limit_devmode */ 22013:
                    message.steamosChargeLimitDevmode = reader.bool();
                    break;
                case /* optional bool setting_validation_bool */ 23001:
                    message.settingValidationBool = reader.bool();
                    break;
                case /* optional int32 setting_validation_enum */ 23002:
                    message.settingValidationEnum = reader.int32();
                    break;
                case /* optional int32 setting_validation_int32 */ 23003:
                    message.settingValidationInt32 = reader.int32();
                    break;
                case /* optional uint32 setting_validation_uint32 */ 23004:
                    message.settingValidationUint32 = reader.uint32();
                    break;
                case /* optional uint64 setting_validation_uint64 */ 23005:
                    message.settingValidationUint64 = reader.uint64().toBigInt();
                    break;
                case /* optional float setting_validation_float */ 23006:
                    message.settingValidationFloat = reader.float();
                    break;
                case /* optional string setting_validation_string */ 23007:
                    message.settingValidationString = reader.string();
                    break;
                case /* optional CMsgHotkey setting_validation_hotkey */ 23008:
                    message.settingValidationHotkey = CMsgHotkey.internalBinaryRead(reader, reader.uint32(), options, message.settingValidationHotkey);
                    break;
                case /* optional bool system_bluetooth_enabled */ 24000:
                    message.systemBluetoothEnabled = reader.bool();
                    break;
                case /* optional bool hardware_updater_enabled */ 24001:
                    message.hardwareUpdaterEnabled = reader.bool();
                    break;
                case /* optional bool vr_show_perf_graph_in_hmd */ 25000:
                    message.vrShowPerfGraphInHmd = reader.bool();
                    break;
                case /* optional bool accessibility_debug_visualizer */ 26000:
                    message.accessibilityDebugVisualizer = reader.bool();
                    break;
                case /* optional bool accessibility_screen_reader_enabled */ 26001:
                    message.accessibilityScreenReaderEnabled = reader.bool();
                    break;
                case /* optional float accessibility_screen_reader_rate */ 26002:
                    message.accessibilityScreenReaderRate = reader.float();
                    break;
                case /* optional float accessibility_screen_reader_pitch */ 26003:
                    message.accessibilityScreenReaderPitch = reader.float();
                    break;
                case /* optional float accessibility_screen_reader_volume */ 26004:
                    message.accessibilityScreenReaderVolume = reader.float();
                    break;
                case /* optional bool accessibility_high_contrast_mode */ 26005:
                    message.accessibilityHighContrastMode = reader.bool();
                    break;
                case /* optional bool accessibility_reduce_motion */ 26006:
                    message.accessibilityReduceMotion = reader.bool();
                    break;
                case /* optional uint32 accessibility_minimum_font_size */ 26008:
                    message.accessibilityMinimumFontSize = reader.uint32();
                    break;
                case /* optional string accessibility_color_filter_name */ 26009:
                    message.accessibilityColorFilterName = reader.string();
                    break;
                case /* optional float accessibility_desktop_ui_scale */ 26010:
                    message.accessibilityDesktopUiScale = reader.float();
                    break;
                case /* optional bool controller_enable_chord */ 140011:
                    message.controllerEnableChord = reader.bool();
                    break;
                case /* optional bool controller_poll_rate */ 140012:
                    message.controllerPollRate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool no_save_personal_info = 1; */
        if (message.noSavePersonalInfo !== undefined)
            writer.tag(1, WireType.Varint).bool(message.noSavePersonalInfo);
        /* optional bool oobe_test_mode_enabled = 2; */
        if (message.oobeTestModeEnabled !== undefined)
            writer.tag(2, WireType.Varint).bool(message.oobeTestModeEnabled);
        /* optional bool in_client_beta = 3; */
        if (message.inClientBeta !== undefined)
            writer.tag(3, WireType.Varint).bool(message.inClientBeta);
        /* optional bool is_steam_sideloaded = 4; */
        if (message.isSteamSideloaded !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isSteamSideloaded);
        /* optional string preferred_monitor = 5; */
        if (message.preferredMonitor !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.preferredMonitor);
        /* optional bool steam_cef_gpu_blocklist_disabled = 6; */
        if (message.steamCefGpuBlocklistDisabled !== undefined)
            writer.tag(6, WireType.Varint).bool(message.steamCefGpuBlocklistDisabled);
        /* optional bool bigpicture_windowed = 7; */
        if (message.bigpictureWindowed !== undefined)
            writer.tag(7, WireType.Varint).bool(message.bigpictureWindowed);
        /* optional string display_name = 8; */
        if (message.displayName !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.displayName);
        /* optional bool is_external_display = 9; */
        if (message.isExternalDisplay !== undefined)
            writer.tag(9, WireType.Varint).bool(message.isExternalDisplay);
        /* optional float steam_os_underscan_level = 10; */
        if (message.steamOsUnderscanLevel !== undefined)
            writer.tag(10, WireType.Bit32).float(message.steamOsUnderscanLevel);
        /* optional bool steam_os_underscan_enabled = 11; */
        if (message.steamOsUnderscanEnabled !== undefined)
            writer.tag(11, WireType.Varint).bool(message.steamOsUnderscanEnabled);
        /* optional float min_scale_factor = 12; */
        if (message.minScaleFactor !== undefined)
            writer.tag(12, WireType.Bit32).float(message.minScaleFactor);
        /* optional float max_scale_factor = 13; */
        if (message.maxScaleFactor !== undefined)
            writer.tag(13, WireType.Bit32).float(message.maxScaleFactor);
        /* optional float auto_scale_factor = 14; */
        if (message.autoScaleFactor !== undefined)
            writer.tag(14, WireType.Bit32).float(message.autoScaleFactor);
        /* optional bool small_mode = 16; */
        if (message.smallMode !== undefined)
            writer.tag(16, WireType.Varint).bool(message.smallMode);
        /* optional bool skip_steamvr_install_dialog = 19; */
        if (message.skipSteamvrInstallDialog !== undefined)
            writer.tag(19, WireType.Varint).bool(message.skipSteamvrInstallDialog);
        /* optional bool always_show_user_chooser = 20; */
        if (message.alwaysShowUserChooser !== undefined)
            writer.tag(20, WireType.Varint).bool(message.alwaysShowUserChooser);
        /* optional bool os_version_unsupported = 21; */
        if (message.osVersionUnsupported !== undefined)
            writer.tag(21, WireType.Varint).bool(message.osVersionUnsupported);
        /* optional bool show_family_sharing_notifications = 3000; */
        if (message.showFamilySharingNotifications !== undefined)
            writer.tag(3000, WireType.Varint).bool(message.showFamilySharingNotifications);
        /* optional bool show_copy_count_in_library = 3001; */
        if (message.showCopyCountInLibrary !== undefined)
            writer.tag(3001, WireType.Varint).bool(message.showCopyCountInLibrary);
        /* optional int32 overlay_fps_counter_corner = 4000; */
        if (message.overlayFpsCounterCorner !== undefined)
            writer.tag(4000, WireType.Varint).int32(message.overlayFpsCounterCorner);
        /* optional bool overlay_fps_counter_high_contrast = 4001; */
        if (message.overlayFpsCounterHighContrast !== undefined)
            writer.tag(4001, WireType.Varint).bool(message.overlayFpsCounterHighContrast);
        /* optional CMsgHotkey overlay_key = 4002; */
        if (message.overlayKey)
            CMsgHotkey.internalBinaryWrite(message.overlayKey, writer.tag(4002, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgHotkey screenshot_key = 4003; */
        if (message.screenshotKey)
            CMsgHotkey.internalBinaryWrite(message.screenshotKey, writer.tag(4003, WireType.LengthDelimited).fork(), options).join();
        /* optional bool enable_overlay = 4004; */
        if (message.enableOverlay !== undefined)
            writer.tag(4004, WireType.Varint).bool(message.enableOverlay);
        /* optional bool enable_screenshot_notification = 4006; */
        if (message.enableScreenshotNotification !== undefined)
            writer.tag(4006, WireType.Varint).bool(message.enableScreenshotNotification);
        /* optional bool enable_screenshot_sound = 4007; */
        if (message.enableScreenshotSound !== undefined)
            writer.tag(4007, WireType.Varint).bool(message.enableScreenshotSound);
        /* optional bool save_uncompressed_screenshots = 4008; */
        if (message.saveUncompressedScreenshots !== undefined)
            writer.tag(4008, WireType.Varint).bool(message.saveUncompressedScreenshots);
        /* optional string screenshots_path = 4009; */
        if (message.screenshotsPath !== undefined)
            writer.tag(4009, WireType.LengthDelimited).string(message.screenshotsPath);
        /* optional int32 default_ping_rate = 4010; */
        if (message.defaultPingRate !== undefined)
            writer.tag(4010, WireType.Varint).int32(message.defaultPingRate);
        /* optional int32 server_ping_rate = 4011; */
        if (message.serverPingRate !== undefined)
            writer.tag(4011, WireType.Varint).int32(message.serverPingRate);
        /* optional int32 steam_networking_share_ip = 4012; */
        if (message.steamNetworkingShareIp !== undefined)
            writer.tag(4012, WireType.Varint).int32(message.steamNetworkingShareIp);
        /* optional string web_browser_home = 4013; */
        if (message.webBrowserHome !== undefined)
            writer.tag(4013, WireType.LengthDelimited).string(message.webBrowserHome);
        /* optional string voice_mic_device_name = 4014; */
        if (message.voiceMicDeviceName !== undefined)
            writer.tag(4014, WireType.LengthDelimited).string(message.voiceMicDeviceName);
        /* optional float voice_mic_input_gain = 4015; */
        if (message.voiceMicInputGain !== undefined)
            writer.tag(4015, WireType.Bit32).float(message.voiceMicInputGain);
        /* optional float voice_speaker_output_gain = 4016; */
        if (message.voiceSpeakerOutputGain !== undefined)
            writer.tag(4016, WireType.Bit32).float(message.voiceSpeakerOutputGain);
        /* optional int32 voice_push_to_talk_setting = 4017; */
        if (message.voicePushToTalkSetting !== undefined)
            writer.tag(4017, WireType.Varint).int32(message.voicePushToTalkSetting);
        /* optional CMsgHotkey voice_push_to_talk_key = 4018; */
        if (message.voicePushToTalkKey)
            CMsgHotkey.internalBinaryWrite(message.voicePushToTalkKey, writer.tag(4018, WireType.LengthDelimited).fork(), options).join();
        /* optional bool overlay_toolbar_list_view = 4019; */
        if (message.overlayToolbarListView !== undefined)
            writer.tag(4019, WireType.Varint).bool(message.overlayToolbarListView);
        /* optional bool always_use_gamepadui_overlay = 4020; */
        if (message.alwaysUseGamepaduiOverlay !== undefined)
            writer.tag(4020, WireType.Varint).bool(message.alwaysUseGamepaduiOverlay);
        /* optional string overlay_tabs = 4021; */
        if (message.overlayTabs !== undefined)
            writer.tag(4021, WireType.LengthDelimited).string(message.overlayTabs);
        /* optional bool overlay_scale_interface = 4022; */
        if (message.overlayScaleInterface !== undefined)
            writer.tag(4022, WireType.Varint).bool(message.overlayScaleInterface);
        /* optional bool overlay_restore_browser_tabs = 4023; */
        if (message.overlayRestoreBrowserTabs !== undefined)
            writer.tag(4023, WireType.Varint).bool(message.overlayRestoreBrowserTabs);
        /* optional bool enable_avif_screenshots = 4024; */
        if (message.enableAvifScreenshots !== undefined)
            writer.tag(4024, WireType.Varint).bool(message.enableAvifScreenshots);
        /* optional int32 overlay_fps_counter_detail_level = 4025; */
        if (message.overlayFpsCounterDetailLevel !== undefined)
            writer.tag(4025, WireType.Varint).int32(message.overlayFpsCounterDetailLevel);
        /* optional float overlay_fps_counter_saturation_factor = 4026; */
        if (message.overlayFpsCounterSaturationFactor !== undefined)
            writer.tag(4026, WireType.Bit32).float(message.overlayFpsCounterSaturationFactor);
        /* optional float overlay_fps_counter_bgopacity = 4027; */
        if (message.overlayFpsCounterBgopacity !== undefined)
            writer.tag(4027, WireType.Bit32).float(message.overlayFpsCounterBgopacity);
        /* optional float overlay_fps_counter_scale_factor = 4028; */
        if (message.overlayFpsCounterScaleFactor !== undefined)
            writer.tag(4028, WireType.Bit32).float(message.overlayFpsCounterScaleFactor);
        /* optional CMsgHotkey overlay_fps_counter_key = 4029; */
        if (message.overlayFpsCounterKey)
            CMsgHotkey.internalBinaryWrite(message.overlayFpsCounterKey, writer.tag(4029, WireType.LengthDelimited).fork(), options).join();
        /* optional bool overlay_fps_counter_fps_graph = 4030; */
        if (message.overlayFpsCounterFpsGraph !== undefined)
            writer.tag(4030, WireType.Varint).bool(message.overlayFpsCounterFpsGraph);
        /* optional bool overlay_fps_counter_cpu_graph = 4031; */
        if (message.overlayFpsCounterCpuGraph !== undefined)
            writer.tag(4031, WireType.Varint).bool(message.overlayFpsCounterCpuGraph);
        /* optional bool smooth_scroll_webviews = 5000; */
        if (message.smoothScrollWebviews !== undefined)
            writer.tag(5000, WireType.Varint).bool(message.smoothScrollWebviews);
        /* optional bool enable_gpu_accelerated_webviews = 5001; */
        if (message.enableGpuAcceleratedWebviews !== undefined)
            writer.tag(5001, WireType.Varint).bool(message.enableGpuAcceleratedWebviews);
        /* optional bool enable_hardware_video_decoding = 5003; */
        if (message.enableHardwareVideoDecoding !== undefined)
            writer.tag(5003, WireType.Varint).bool(message.enableHardwareVideoDecoding);
        /* optional bool run_at_startup = 5004; */
        if (message.runAtStartup !== undefined)
            writer.tag(5004, WireType.Varint).bool(message.runAtStartup);
        /* optional bool enable_dpi_scaling = 5005; */
        if (message.enableDpiScaling !== undefined)
            writer.tag(5005, WireType.Varint).bool(message.enableDpiScaling);
        /* optional bool enable_marketing_messages = 5006; */
        if (message.enableMarketingMessages !== undefined)
            writer.tag(5006, WireType.Varint).bool(message.enableMarketingMessages);
        /* optional bool start_in_big_picture_mode = 5007; */
        if (message.startInBigPictureMode !== undefined)
            writer.tag(5007, WireType.Varint).bool(message.startInBigPictureMode);
        /* optional uint32 jumplist_flags = 5008; */
        if (message.jumplistFlags !== undefined)
            writer.tag(5008, WireType.Varint).uint32(message.jumplistFlags);
        /* optional bool enable_ui_sounds = 5009; */
        if (message.enableUiSounds !== undefined)
            writer.tag(5009, WireType.Varint).bool(message.enableUiSounds);
        /* optional bool disable_all_toasts = 6000; */
        if (message.disableAllToasts !== undefined)
            writer.tag(6000, WireType.Varint).bool(message.disableAllToasts);
        /* optional bool disable_toasts_in_game = 6001; */
        if (message.disableToastsInGame !== undefined)
            writer.tag(6001, WireType.Varint).bool(message.disableToastsInGame);
        /* optional bool play_sound_on_toast = 6002; */
        if (message.playSoundOnToast !== undefined)
            writer.tag(6002, WireType.Varint).bool(message.playSoundOnToast);
        /* optional int32 library_display_size = 7000; */
        if (message.libraryDisplaySize !== undefined)
            writer.tag(7000, WireType.Varint).int32(message.libraryDisplaySize);
        /* optional bool library_whats_new_show_only_product_updates = 7001; */
        if (message.libraryWhatsNewShowOnlyProductUpdates !== undefined)
            writer.tag(7001, WireType.Varint).bool(message.libraryWhatsNewShowOnlyProductUpdates);
        /* optional bool show_store_content_on_home = 7002; */
        if (message.showStoreContentOnHome !== undefined)
            writer.tag(7002, WireType.Varint).bool(message.showStoreContentOnHome);
        /* optional string start_page = 7003; */
        if (message.startPage !== undefined)
            writer.tag(7003, WireType.LengthDelimited).string(message.startPage);
        /* optional bool library_low_bandwidth_mode = 7004; */
        if (message.libraryLowBandwidthMode !== undefined)
            writer.tag(7004, WireType.Varint).bool(message.libraryLowBandwidthMode);
        /* optional bool library_low_perf_mode = 7005; */
        if (message.libraryLowPerfMode !== undefined)
            writer.tag(7005, WireType.Varint).bool(message.libraryLowPerfMode);
        /* optional bool library_disable_community_content = 7006; */
        if (message.libraryDisableCommunityContent !== undefined)
            writer.tag(7006, WireType.Varint).bool(message.libraryDisableCommunityContent);
        /* optional bool library_display_icon_in_game_list = 7007; */
        if (message.libraryDisplayIconInGameList !== undefined)
            writer.tag(7007, WireType.Varint).bool(message.libraryDisplayIconInGameList);
        /* optional bool ready_to_play_includes_streaming = 7008; */
        if (message.readyToPlayIncludesStreaming !== undefined)
            writer.tag(7008, WireType.Varint).bool(message.readyToPlayIncludesStreaming);
        /* optional bool show_steam_deck_info = 7009; */
        if (message.showSteamDeckInfo !== undefined)
            writer.tag(7009, WireType.Varint).bool(message.showSteamDeckInfo);
        /* optional bool enable_shader_precache = 8000; */
        if (message.enableShaderPrecache !== undefined)
            writer.tag(8000, WireType.Varint).bool(message.enableShaderPrecache);
        /* optional bool enable_shader_background_processing = 8001; */
        if (message.enableShaderBackgroundProcessing !== undefined)
            writer.tag(8001, WireType.Varint).bool(message.enableShaderBackgroundProcessing);
        /* optional uint64 shader_precached_size = 8002; */
        if (message.shaderPrecachedSize !== undefined)
            writer.tag(8002, WireType.Varint).uint64(message.shaderPrecachedSize);
        /* optional bool needs_steam_service_repair = 8003; */
        if (message.needsSteamServiceRepair !== undefined)
            writer.tag(8003, WireType.Varint).bool(message.needsSteamServiceRepair);
        /* optional int32 download_peer_content = 8004; */
        if (message.downloadPeerContent !== undefined)
            writer.tag(8004, WireType.Varint).int32(message.downloadPeerContent);
        /* optional bool download_rate_bits_per_s = 8005; */
        if (message.downloadRateBitsPerS !== undefined)
            writer.tag(8005, WireType.Varint).bool(message.downloadRateBitsPerS);
        /* optional bool restrict_auto_updates = 8006; */
        if (message.restrictAutoUpdates !== undefined)
            writer.tag(8006, WireType.Varint).bool(message.restrictAutoUpdates);
        /* optional int32 restrict_auto_updates_start = 8007; */
        if (message.restrictAutoUpdatesStart !== undefined)
            writer.tag(8007, WireType.Varint).int32(message.restrictAutoUpdatesStart);
        /* optional int32 restrict_auto_updates_end = 8008; */
        if (message.restrictAutoUpdatesEnd !== undefined)
            writer.tag(8008, WireType.Varint).int32(message.restrictAutoUpdatesEnd);
        /* optional int32 download_region = 8009; */
        if (message.downloadRegion !== undefined)
            writer.tag(8009, WireType.Varint).int32(message.downloadRegion);
        /* optional bool download_while_app_running = 8010; */
        if (message.downloadWhileAppRunning !== undefined)
            writer.tag(8010, WireType.Varint).bool(message.downloadWhileAppRunning);
        /* optional bool download_throttle_while_streaming = 8011; */
        if (message.downloadThrottleWhileStreaming !== undefined)
            writer.tag(8011, WireType.Varint).bool(message.downloadThrottleWhileStreaming);
        /* optional int32 download_throttle_rate = 8012; */
        if (message.downloadThrottleRate !== undefined)
            writer.tag(8012, WireType.Varint).int32(message.downloadThrottleRate);
        /* optional int32 default_app_update_behavior = 8013; */
        if (message.defaultAppUpdateBehavior !== undefined)
            writer.tag(8013, WireType.Varint).int32(message.defaultAppUpdateBehavior);
        /* optional bool cloud_enabled = 10000; */
        if (message.cloudEnabled !== undefined)
            writer.tag(10000, WireType.Varint).bool(message.cloudEnabled);
        /* optional bool show_screenshot_manager = 10001; */
        if (message.showScreenshotManager !== undefined)
            writer.tag(10001, WireType.Varint).bool(message.showScreenshotManager);
        /* optional int32 music_volume = 11000; */
        if (message.musicVolume !== undefined)
            writer.tag(11000, WireType.Varint).int32(message.musicVolume);
        /* optional bool music_pause_on_app_start = 11001; */
        if (message.musicPauseOnAppStart !== undefined)
            writer.tag(11001, WireType.Varint).bool(message.musicPauseOnAppStart);
        /* optional bool music_pause_on_voice_chat = 11002; */
        if (message.musicPauseOnVoiceChat !== undefined)
            writer.tag(11002, WireType.Varint).bool(message.musicPauseOnVoiceChat);
        /* optional bool music_download_high_quality = 11003; */
        if (message.musicDownloadHighQuality !== undefined)
            writer.tag(11003, WireType.Varint).bool(message.musicDownloadHighQuality);
        /* optional bool music_playlist_notification = 11004; */
        if (message.musicPlaylistNotification !== undefined)
            writer.tag(11004, WireType.Varint).bool(message.musicPlaylistNotification);
        /* optional int32 broadcast_permissions = 12000; */
        if (message.broadcastPermissions !== undefined)
            writer.tag(12000, WireType.Varint).int32(message.broadcastPermissions);
        /* optional int32 broadcast_output_width = 12001; */
        if (message.broadcastOutputWidth !== undefined)
            writer.tag(12001, WireType.Varint).int32(message.broadcastOutputWidth);
        /* optional int32 broadcast_output_height = 12002; */
        if (message.broadcastOutputHeight !== undefined)
            writer.tag(12002, WireType.Varint).int32(message.broadcastOutputHeight);
        /* optional int32 broadcast_bitrate = 12003; */
        if (message.broadcastBitrate !== undefined)
            writer.tag(12003, WireType.Varint).int32(message.broadcastBitrate);
        /* optional int32 broadcast_encoding_option = 12004; */
        if (message.broadcastEncodingOption !== undefined)
            writer.tag(12004, WireType.Varint).int32(message.broadcastEncodingOption);
        /* optional bool broadcast_record_all_video = 12005; */
        if (message.broadcastRecordAllVideo !== undefined)
            writer.tag(12005, WireType.Varint).bool(message.broadcastRecordAllVideo);
        /* optional bool broadcast_record_all_audio = 12006; */
        if (message.broadcastRecordAllAudio !== undefined)
            writer.tag(12006, WireType.Varint).bool(message.broadcastRecordAllAudio);
        /* optional bool broadcast_record_microphone = 12007; */
        if (message.broadcastRecordMicrophone !== undefined)
            writer.tag(12007, WireType.Varint).bool(message.broadcastRecordMicrophone);
        /* optional bool broadcast_show_upload_stats = 12008; */
        if (message.broadcastShowUploadStats !== undefined)
            writer.tag(12008, WireType.Varint).bool(message.broadcastShowUploadStats);
        /* optional bool broadcast_show_live_reminder = 12009; */
        if (message.broadcastShowLiveReminder !== undefined)
            writer.tag(12009, WireType.Varint).bool(message.broadcastShowLiveReminder);
        /* optional int32 broadcast_chat_corner = 12010; */
        if (message.broadcastChatCorner !== undefined)
            writer.tag(12010, WireType.Varint).int32(message.broadcastChatCorner);
        /* optional bool gamestream_hardware_video_encode = 13000; */
        if (message.gamestreamHardwareVideoEncode !== undefined)
            writer.tag(13000, WireType.Varint).bool(message.gamestreamHardwareVideoEncode);
        /* optional bool gamestream_enable_video_h265 = 13001; */
        if (message.gamestreamEnableVideoH265 !== undefined)
            writer.tag(13001, WireType.Varint).bool(message.gamestreamEnableVideoH265);
        /* optional bool steam_input_configurator_error_msg_enable = 14001; */
        if (message.steamInputConfiguratorErrorMsgEnable !== undefined)
            writer.tag(14001, WireType.Varint).bool(message.steamInputConfiguratorErrorMsgEnable);
        /* optional bool controller_guide_button_focus_steam = 14002; */
        if (message.controllerGuideButtonFocusSteam !== undefined)
            writer.tag(14002, WireType.Varint).bool(message.controllerGuideButtonFocusSteam);
        /* optional int32 controller_ps_support = 14003; */
        if (message.controllerPsSupport !== undefined)
            writer.tag(14003, WireType.Varint).int32(message.controllerPsSupport);
        /* optional bool controller_xbox_support = 14004; */
        if (message.controllerXboxSupport !== undefined)
            writer.tag(14004, WireType.Varint).bool(message.controllerXboxSupport);
        /* optional bool controller_xbox_driver = 14005; */
        if (message.controllerXboxDriver !== undefined)
            writer.tag(14005, WireType.Varint).bool(message.controllerXboxDriver);
        /* optional bool controller_switch_support = 14006; */
        if (message.controllerSwitchSupport !== undefined)
            writer.tag(14006, WireType.Varint).bool(message.controllerSwitchSupport);
        /* optional bool controller_generic_support = 14007; */
        if (message.controllerGenericSupport !== undefined)
            writer.tag(14007, WireType.Varint).bool(message.controllerGenericSupport);
        /* optional int32 controller_power_off_timeout = 14008; */
        if (message.controllerPowerOffTimeout !== undefined)
            writer.tag(14008, WireType.Varint).int32(message.controllerPowerOffTimeout);
        /* optional bool turn_off_controller_on_exit = 14009; */
        if (message.turnOffControllerOnExit !== undefined)
            writer.tag(14009, WireType.Varint).bool(message.turnOffControllerOnExit);
        /* optional bool controller_combine_nintendo_joycons = 14010; */
        if (message.controllerCombineNintendoJoycons !== undefined)
            writer.tag(14010, WireType.Varint).bool(message.controllerCombineNintendoJoycons);
        /* optional uint64 startup_movie_id = 16000; */
        if (message.startupMovieId !== undefined)
            writer.tag(16000, WireType.Varint).uint64(message.startupMovieId);
        /* optional string startup_movie_local_path = 16001; */
        if (message.startupMovieLocalPath !== undefined)
            writer.tag(16001, WireType.LengthDelimited).string(message.startupMovieLocalPath);
        /* optional bool startup_movie_shuffle = 16002; */
        if (message.startupMovieShuffle !== undefined)
            writer.tag(16002, WireType.Varint).bool(message.startupMovieShuffle);
        /* optional bool startup_movie_used_for_resume = 16003; */
        if (message.startupMovieUsedForResume !== undefined)
            writer.tag(16003, WireType.Varint).bool(message.startupMovieUsedForResume);
        /* optional bool game_notes_enable_spellcheck = 17001; */
        if (message.gameNotesEnableSpellcheck !== undefined)
            writer.tag(17001, WireType.Varint).bool(message.gameNotesEnableSpellcheck);
        /* optional int32 screenshot_items_per_row = 18000; */
        if (message.screenshotItemsPerRow !== undefined)
            writer.tag(18000, WireType.Varint).int32(message.screenshotItemsPerRow);
        /* optional string gamerecording_background_path = 18201; */
        if (message.gamerecordingBackgroundPath !== undefined)
            writer.tag(18201, WireType.LengthDelimited).string(message.gamerecordingBackgroundPath);
        /* optional string gamerecording_background_max_keep = 18202; */
        if (message.gamerecordingBackgroundMaxKeep !== undefined)
            writer.tag(18202, WireType.LengthDelimited).string(message.gamerecordingBackgroundMaxKeep);
        /* optional int32 gamerecording_background_time_resolution = 18203; */
        if (message.gamerecordingBackgroundTimeResolution !== undefined)
            writer.tag(18203, WireType.Varint).int32(message.gamerecordingBackgroundTimeResolution);
        /* optional CMsgHotkey gamerecording_background_mk = 18207; */
        if (message.gamerecordingBackgroundMk)
            CMsgHotkey.internalBinaryWrite(message.gamerecordingBackgroundMk, writer.tag(18207, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgHotkey gamerecording_background_tg = 18208; */
        if (message.gamerecordingBackgroundTg)
            CMsgHotkey.internalBinaryWrite(message.gamerecordingBackgroundTg, writer.tag(18208, WireType.LengthDelimited).fork(), options).join();
        /* optional bool gamerecording_background_a_m = 18209; */
        if (message.gamerecordingBackgroundAM !== undefined)
            writer.tag(18209, WireType.Varint).bool(message.gamerecordingBackgroundAM);
        /* optional string gamerecording_video_bitrate = 18210; */
        if (message.gamerecordingVideoBitrate !== undefined)
            writer.tag(18210, WireType.LengthDelimited).string(message.gamerecordingVideoBitrate);
        /* optional int32 gamerecording_background_mode = 18212; */
        if (message.gamerecordingBackgroundMode !== undefined)
            writer.tag(18212, WireType.Varint).int32(message.gamerecordingBackgroundMode);
        /* optional int32 gamerecording_background_audio = 18213; */
        if (message.gamerecordingBackgroundAudio !== undefined)
            writer.tag(18213, WireType.Varint).int32(message.gamerecordingBackgroundAudio);
        /* optional int32 gamerecording_max_fps = 18214; */
        if (message.gamerecordingMaxFps !== undefined)
            writer.tag(18214, WireType.Varint).int32(message.gamerecordingMaxFps);
        /* optional CMsgHotkey gamerecording_hotkey_ic = 18215; */
        if (message.gamerecordingHotkeyIc)
            CMsgHotkey.internalBinaryWrite(message.gamerecordingHotkeyIc, writer.tag(18215, WireType.LengthDelimited).fork(), options).join();
        /* optional float gamerecording_ic_seconds = 18216; */
        if (message.gamerecordingIcSeconds !== undefined)
            writer.tag(18216, WireType.Bit32).float(message.gamerecordingIcSeconds);
        /* optional int32 gamerecording_export_limit_type = 18217; */
        if (message.gamerecordingExportLimitType !== undefined)
            writer.tag(18217, WireType.Varint).int32(message.gamerecordingExportLimitType);
        /* optional int32 gamerecording_export_limit_size_mb = 18218; */
        if (message.gamerecordingExportLimitSizeMb !== undefined)
            writer.tag(18218, WireType.Varint).int32(message.gamerecordingExportLimitSizeMb);
        /* optional int32 gamerecording_export_limit_bitrate = 18219; */
        if (message.gamerecordingExportLimitBitrate !== undefined)
            writer.tag(18219, WireType.Varint).int32(message.gamerecordingExportLimitBitrate);
        /* optional int32 gamerecording_export_limit_width = 18220; */
        if (message.gamerecordingExportLimitWidth !== undefined)
            writer.tag(18220, WireType.Varint).int32(message.gamerecordingExportLimitWidth);
        /* optional int32 gamerecording_export_limit_height = 18221; */
        if (message.gamerecordingExportLimitHeight !== undefined)
            writer.tag(18221, WireType.Varint).int32(message.gamerecordingExportLimitHeight);
        /* optional int32 gamerecording_export_limit_frame_rate = 18222; */
        if (message.gamerecordingExportLimitFrameRate !== undefined)
            writer.tag(18222, WireType.Varint).int32(message.gamerecordingExportLimitFrameRate);
        /* optional string gamerecording_export_directory = 18223; */
        if (message.gamerecordingExportDirectory !== undefined)
            writer.tag(18223, WireType.LengthDelimited).string(message.gamerecordingExportDirectory);
        /* optional int32 gamerecording_export_codec = 18224; */
        if (message.gamerecordingExportCodec !== undefined)
            writer.tag(18224, WireType.Varint).int32(message.gamerecordingExportCodec);
        /* optional int32 gamerecording_video_maxheight = 18225; */
        if (message.gamerecordingVideoMaxheight !== undefined)
            writer.tag(18225, WireType.Varint).int32(message.gamerecordingVideoMaxheight);
        /* optional bool gamerecording_force_mic_mono = 18226; */
        if (message.gamerecordingForceMicMono !== undefined)
            writer.tag(18226, WireType.Varint).bool(message.gamerecordingForceMicMono);
        /* optional bool gamerecording_automatic_gain_control = 18227; */
        if (message.gamerecordingAutomaticGainControl !== undefined)
            writer.tag(18227, WireType.Varint).bool(message.gamerecordingAutomaticGainControl);
        /* optional bool show_timestamps_in_console = 20000; */
        if (message.showTimestampsInConsole !== undefined)
            writer.tag(20000, WireType.Varint).bool(message.showTimestampsInConsole);
        /* optional bool force_oobe = 20001; */
        if (message.forceOobe !== undefined)
            writer.tag(20001, WireType.Varint).bool(message.forceOobe);
        /* optional int32 override_browser_composer_mode = 20002; */
        if (message.overrideBrowserComposerMode !== undefined)
            writer.tag(20002, WireType.Varint).int32(message.overrideBrowserComposerMode);
        /* optional bool cef_remote_debugging_enabled = 20003; */
        if (message.cefRemoteDebuggingEnabled !== undefined)
            writer.tag(20003, WireType.Varint).bool(message.cefRemoteDebuggingEnabled);
        /* optional bool force_deck_perf_tab = 20004; */
        if (message.forceDeckPerfTab !== undefined)
            writer.tag(20004, WireType.Varint).bool(message.forceDeckPerfTab);
        /* optional bool force_fake_mandatory_update = 20005; */
        if (message.forceFakeMandatoryUpdate !== undefined)
            writer.tag(20005, WireType.Varint).bool(message.forceFakeMandatoryUpdate);
        /* optional bool hdr_compat_testing = 20006; */
        if (message.hdrCompatTesting !== undefined)
            writer.tag(20006, WireType.Varint).bool(message.hdrCompatTesting);
        /* optional bool developer_mode_enabled = 20007; */
        if (message.developerModeEnabled !== undefined)
            writer.tag(20007, WireType.Varint).bool(message.developerModeEnabled);
        /* optional bool show_advanced_update_channels = 20008; */
        if (message.showAdvancedUpdateChannels !== undefined)
            writer.tag(20008, WireType.Varint).bool(message.showAdvancedUpdateChannels);
        /* optional int32 gamescope_hdr_visualization = 21001; */
        if (message.gamescopeHdrVisualization !== undefined)
            writer.tag(21001, WireType.Varint).int32(message.gamescopeHdrVisualization);
        /* optional int32 gamescope_app_target_framerate = 21002; */
        if (message.gamescopeAppTargetFramerate !== undefined)
            writer.tag(21002, WireType.Varint).int32(message.gamescopeAppTargetFramerate);
        /* optional bool gamescope_enable_app_target_framerate = 21003; */
        if (message.gamescopeEnableAppTargetFramerate !== undefined)
            writer.tag(21003, WireType.Varint).bool(message.gamescopeEnableAppTargetFramerate);
        /* optional bool gamescope_disable_framelimit = 21004; */
        if (message.gamescopeDisableFramelimit !== undefined)
            writer.tag(21004, WireType.Varint).bool(message.gamescopeDisableFramelimit);
        /* optional int32 gamescope_display_refresh_rate = 21005; */
        if (message.gamescopeDisplayRefreshRate !== undefined)
            writer.tag(21005, WireType.Varint).int32(message.gamescopeDisplayRefreshRate);
        /* optional bool gamescope_use_game_refresh_rate_in_steam = 21006; */
        if (message.gamescopeUseGameRefreshRateInSteam !== undefined)
            writer.tag(21006, WireType.Varint).bool(message.gamescopeUseGameRefreshRateInSteam);
        /* optional bool gamescope_disable_mura_correction = 21007; */
        if (message.gamescopeDisableMuraCorrection !== undefined)
            writer.tag(21007, WireType.Varint).bool(message.gamescopeDisableMuraCorrection);
        /* optional bool gamescope_include_steamui_in_screenshots = 21008; */
        if (message.gamescopeIncludeSteamuiInScreenshots !== undefined)
            writer.tag(21008, WireType.Varint).bool(message.gamescopeIncludeSteamuiInScreenshots);
        /* optional bool gamescope_allow_tearing = 21009; */
        if (message.gamescopeAllowTearing !== undefined)
            writer.tag(21009, WireType.Varint).bool(message.gamescopeAllowTearing);
        /* optional bool gamescope_composite_debug = 21010; */
        if (message.gamescopeCompositeDebug !== undefined)
            writer.tag(21010, WireType.Varint).bool(message.gamescopeCompositeDebug);
        /* optional bool gamescope_force_composite = 21011; */
        if (message.gamescopeForceComposite !== undefined)
            writer.tag(21011, WireType.Varint).bool(message.gamescopeForceComposite);
        /* optional string gamescope_game_resolution_global = 21012; */
        if (message.gamescopeGameResolutionGlobal !== undefined)
            writer.tag(21012, WireType.LengthDelimited).string(message.gamescopeGameResolutionGlobal);
        /* optional CMsgHotkey gamescope_guide_hotkey = 21013; */
        if (message.gamescopeGuideHotkey)
            CMsgHotkey.internalBinaryWrite(message.gamescopeGuideHotkey, writer.tag(21013, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgHotkey gamescope_qam_hotkey = 21014; */
        if (message.gamescopeQamHotkey)
            CMsgHotkey.internalBinaryWrite(message.gamescopeQamHotkey, writer.tag(21014, WireType.LengthDelimited).fork(), options).join();
        /* optional bool gamescope_hdr_enabled = 21015; */
        if (message.gamescopeHdrEnabled !== undefined)
            writer.tag(21015, WireType.Varint).bool(message.gamescopeHdrEnabled);
        /* optional bool gamescope_native_external_res_in_steam = 21016; */
        if (message.gamescopeNativeExternalResInSteam !== undefined)
            writer.tag(21016, WireType.Varint).bool(message.gamescopeNativeExternalResInSteam);
        /* optional int32 steamos_status_led_brightness = 22000; */
        if (message.steamosStatusLedBrightness !== undefined)
            writer.tag(22000, WireType.Varint).int32(message.steamosStatusLedBrightness);
        /* optional bool steamos_tdp_limit_enabled = 22001; */
        if (message.steamosTdpLimitEnabled !== undefined)
            writer.tag(22001, WireType.Varint).bool(message.steamosTdpLimitEnabled);
        /* optional int32 steamos_tdp_limit = 22002; */
        if (message.steamosTdpLimit !== undefined)
            writer.tag(22002, WireType.Varint).int32(message.steamosTdpLimit);
        /* optional bool steamos_cec_enabled = 22003; */
        if (message.steamosCecEnabled !== undefined)
            writer.tag(22003, WireType.Varint).bool(message.steamosCecEnabled);
        /* optional bool steamos_cec_wake_on_resume = 22004; */
        if (message.steamosCecWakeOnResume !== undefined)
            writer.tag(22004, WireType.Varint).bool(message.steamosCecWakeOnResume);
        /* optional bool steamos_wifi_debug = 22005; */
        if (message.steamosWifiDebug !== undefined)
            writer.tag(22005, WireType.Varint).bool(message.steamosWifiDebug);
        /* optional bool steamos_wifi_force_wpa_supplicant = 22006; */
        if (message.steamosWifiForceWpaSupplicant !== undefined)
            writer.tag(22006, WireType.Varint).bool(message.steamosWifiForceWpaSupplicant);
        /* optional int32 steamos_magnifier_scale = 22007; */
        if (message.steamosMagnifierScale !== undefined)
            writer.tag(22007, WireType.Varint).int32(message.steamosMagnifierScale);
        /* optional bool steamos_manual_gpu_clock_enabled = 22008; */
        if (message.steamosManualGpuClockEnabled !== undefined)
            writer.tag(22008, WireType.Varint).bool(message.steamosManualGpuClockEnabled);
        /* optional int32 steamos_manual_gpu_clock_hz = 22009; */
        if (message.steamosManualGpuClockHz !== undefined)
            writer.tag(22009, WireType.Varint).int32(message.steamosManualGpuClockHz);
        /* optional string steamos_platform_performance_profile = 22010; */
        if (message.steamosPlatformPerformanceProfile !== undefined)
            writer.tag(22010, WireType.LengthDelimited).string(message.steamosPlatformPerformanceProfile);
        /* optional bool steamos_charge_limit_enabled = 22011; */
        if (message.steamosChargeLimitEnabled !== undefined)
            writer.tag(22011, WireType.Varint).bool(message.steamosChargeLimitEnabled);
        /* optional int32 steamos_charge_limit = 22012; */
        if (message.steamosChargeLimit !== undefined)
            writer.tag(22012, WireType.Varint).int32(message.steamosChargeLimit);
        /* optional bool steamos_charge_limit_devmode = 22013; */
        if (message.steamosChargeLimitDevmode !== undefined)
            writer.tag(22013, WireType.Varint).bool(message.steamosChargeLimitDevmode);
        /* optional bool setting_validation_bool = 23001; */
        if (message.settingValidationBool !== undefined)
            writer.tag(23001, WireType.Varint).bool(message.settingValidationBool);
        /* optional int32 setting_validation_enum = 23002; */
        if (message.settingValidationEnum !== undefined)
            writer.tag(23002, WireType.Varint).int32(message.settingValidationEnum);
        /* optional int32 setting_validation_int32 = 23003; */
        if (message.settingValidationInt32 !== undefined)
            writer.tag(23003, WireType.Varint).int32(message.settingValidationInt32);
        /* optional uint32 setting_validation_uint32 = 23004; */
        if (message.settingValidationUint32 !== undefined)
            writer.tag(23004, WireType.Varint).uint32(message.settingValidationUint32);
        /* optional uint64 setting_validation_uint64 = 23005; */
        if (message.settingValidationUint64 !== undefined)
            writer.tag(23005, WireType.Varint).uint64(message.settingValidationUint64);
        /* optional float setting_validation_float = 23006; */
        if (message.settingValidationFloat !== undefined)
            writer.tag(23006, WireType.Bit32).float(message.settingValidationFloat);
        /* optional string setting_validation_string = 23007; */
        if (message.settingValidationString !== undefined)
            writer.tag(23007, WireType.LengthDelimited).string(message.settingValidationString);
        /* optional CMsgHotkey setting_validation_hotkey = 23008; */
        if (message.settingValidationHotkey)
            CMsgHotkey.internalBinaryWrite(message.settingValidationHotkey, writer.tag(23008, WireType.LengthDelimited).fork(), options).join();
        /* optional bool system_bluetooth_enabled = 24000; */
        if (message.systemBluetoothEnabled !== undefined)
            writer.tag(24000, WireType.Varint).bool(message.systemBluetoothEnabled);
        /* optional bool hardware_updater_enabled = 24001; */
        if (message.hardwareUpdaterEnabled !== undefined)
            writer.tag(24001, WireType.Varint).bool(message.hardwareUpdaterEnabled);
        /* optional bool vr_show_perf_graph_in_hmd = 25000; */
        if (message.vrShowPerfGraphInHmd !== undefined)
            writer.tag(25000, WireType.Varint).bool(message.vrShowPerfGraphInHmd);
        /* optional bool accessibility_debug_visualizer = 26000; */
        if (message.accessibilityDebugVisualizer !== undefined)
            writer.tag(26000, WireType.Varint).bool(message.accessibilityDebugVisualizer);
        /* optional bool accessibility_screen_reader_enabled = 26001; */
        if (message.accessibilityScreenReaderEnabled !== undefined)
            writer.tag(26001, WireType.Varint).bool(message.accessibilityScreenReaderEnabled);
        /* optional float accessibility_screen_reader_rate = 26002; */
        if (message.accessibilityScreenReaderRate !== undefined)
            writer.tag(26002, WireType.Bit32).float(message.accessibilityScreenReaderRate);
        /* optional float accessibility_screen_reader_pitch = 26003; */
        if (message.accessibilityScreenReaderPitch !== undefined)
            writer.tag(26003, WireType.Bit32).float(message.accessibilityScreenReaderPitch);
        /* optional float accessibility_screen_reader_volume = 26004; */
        if (message.accessibilityScreenReaderVolume !== undefined)
            writer.tag(26004, WireType.Bit32).float(message.accessibilityScreenReaderVolume);
        /* optional bool accessibility_high_contrast_mode = 26005; */
        if (message.accessibilityHighContrastMode !== undefined)
            writer.tag(26005, WireType.Varint).bool(message.accessibilityHighContrastMode);
        /* optional bool accessibility_reduce_motion = 26006; */
        if (message.accessibilityReduceMotion !== undefined)
            writer.tag(26006, WireType.Varint).bool(message.accessibilityReduceMotion);
        /* optional uint32 accessibility_minimum_font_size = 26008; */
        if (message.accessibilityMinimumFontSize !== undefined)
            writer.tag(26008, WireType.Varint).uint32(message.accessibilityMinimumFontSize);
        /* optional string accessibility_color_filter_name = 26009; */
        if (message.accessibilityColorFilterName !== undefined)
            writer.tag(26009, WireType.LengthDelimited).string(message.accessibilityColorFilterName);
        /* optional float accessibility_desktop_ui_scale = 26010; */
        if (message.accessibilityDesktopUiScale !== undefined)
            writer.tag(26010, WireType.Bit32).float(message.accessibilityDesktopUiScale);
        /* optional bool controller_enable_chord = 140011; */
        if (message.controllerEnableChord !== undefined)
            writer.tag(140011, WireType.Varint).bool(message.controllerEnableChord);
        /* optional bool controller_poll_rate = 140012; */
        if (message.controllerPollRate !== undefined)
            writer.tag(140012, WireType.Varint).bool(message.controllerPollRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSettings
 */
export const CMsgClientSettings = new CMsgClientSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSharedLibraryLockStatus$Type extends MessageType<CMsgClientSharedLibraryLockStatus> {
    constructor() {
        super("CMsgClientSharedLibraryLockStatus", [
            { no: 1, name: "locked_library", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientSharedLibraryLockStatus_LockedLibrary },
            { no: 2, name: "own_library_locked_by", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSharedLibraryLockStatus>): CMsgClientSharedLibraryLockStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lockedLibrary = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSharedLibraryLockStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSharedLibraryLockStatus): CMsgClientSharedLibraryLockStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientSharedLibraryLockStatus_LockedLibrary locked_library */ 1:
                    message.lockedLibrary.push(CMsgClientSharedLibraryLockStatus_LockedLibrary.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 own_library_locked_by */ 2:
                    message.ownLibraryLockedBy = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSharedLibraryLockStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientSharedLibraryLockStatus_LockedLibrary locked_library = 1; */
        for (let i = 0; i < message.lockedLibrary.length; i++)
            CMsgClientSharedLibraryLockStatus_LockedLibrary.internalBinaryWrite(message.lockedLibrary[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 own_library_locked_by = 2; */
        if (message.ownLibraryLockedBy !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.ownLibraryLockedBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSharedLibraryLockStatus
 */
export const CMsgClientSharedLibraryLockStatus = new CMsgClientSharedLibraryLockStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSharedLibraryLockStatus_LockedLibrary$Type extends MessageType<CMsgClientSharedLibraryLockStatus_LockedLibrary> {
    constructor() {
        super("CMsgClientSharedLibraryLockStatus_LockedLibrary", [
            { no: 1, name: "owner_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "locked_by", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSharedLibraryLockStatus_LockedLibrary>): CMsgClientSharedLibraryLockStatus_LockedLibrary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSharedLibraryLockStatus_LockedLibrary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSharedLibraryLockStatus_LockedLibrary): CMsgClientSharedLibraryLockStatus_LockedLibrary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 owner_id */ 1:
                    message.ownerId = reader.uint32();
                    break;
                case /* optional uint32 locked_by */ 2:
                    message.lockedBy = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSharedLibraryLockStatus_LockedLibrary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 owner_id = 1; */
        if (message.ownerId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.ownerId);
        /* optional uint32 locked_by = 2; */
        if (message.lockedBy !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.lockedBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSharedLibraryLockStatus_LockedLibrary
 */
export const CMsgClientSharedLibraryLockStatus_LockedLibrary = new CMsgClientSharedLibraryLockStatus_LockedLibrary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSharedLibraryStopPlaying$Type extends MessageType<CMsgClientSharedLibraryStopPlaying> {
    constructor() {
        super("CMsgClientSharedLibraryStopPlaying", [
            { no: 1, name: "seconds_left", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "stop_apps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientSharedLibraryStopPlaying_StopApp }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSharedLibraryStopPlaying>): CMsgClientSharedLibraryStopPlaying {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stopApps = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSharedLibraryStopPlaying>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSharedLibraryStopPlaying): CMsgClientSharedLibraryStopPlaying {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 seconds_left */ 1:
                    message.secondsLeft = reader.int32();
                    break;
                case /* repeated CMsgClientSharedLibraryStopPlaying_StopApp stop_apps */ 2:
                    message.stopApps.push(CMsgClientSharedLibraryStopPlaying_StopApp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSharedLibraryStopPlaying, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 seconds_left = 1; */
        if (message.secondsLeft !== undefined)
            writer.tag(1, WireType.Varint).int32(message.secondsLeft);
        /* repeated CMsgClientSharedLibraryStopPlaying_StopApp stop_apps = 2; */
        for (let i = 0; i < message.stopApps.length; i++)
            CMsgClientSharedLibraryStopPlaying_StopApp.internalBinaryWrite(message.stopApps[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSharedLibraryStopPlaying
 */
export const CMsgClientSharedLibraryStopPlaying = new CMsgClientSharedLibraryStopPlaying$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientSharedLibraryStopPlaying_StopApp$Type extends MessageType<CMsgClientSharedLibraryStopPlaying_StopApp> {
    constructor() {
        super("CMsgClientSharedLibraryStopPlaying_StopApp", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "owner_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientSharedLibraryStopPlaying_StopApp>): CMsgClientSharedLibraryStopPlaying_StopApp {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientSharedLibraryStopPlaying_StopApp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientSharedLibraryStopPlaying_StopApp): CMsgClientSharedLibraryStopPlaying_StopApp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 owner_id */ 2:
                    message.ownerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientSharedLibraryStopPlaying_StopApp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 owner_id = 2; */
        if (message.ownerId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.ownerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientSharedLibraryStopPlaying_StopApp
 */
export const CMsgClientSharedLibraryStopPlaying_StopApp = new CMsgClientSharedLibraryStopPlaying_StopApp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientStat2$Type extends MessageType<CMsgClientStat2> {
    constructor() {
        super("CMsgClientStat2", [
            { no: 1, name: "stat_detail", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientStat2_StatDetail }
        ]);
    }
    create(value?: PartialMessage<CMsgClientStat2>): CMsgClientStat2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statDetail = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientStat2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientStat2): CMsgClientStat2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientStat2_StatDetail stat_detail */ 1:
                    message.statDetail.push(CMsgClientStat2_StatDetail.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientStat2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientStat2_StatDetail stat_detail = 1; */
        for (let i = 0; i < message.statDetail.length; i++)
            CMsgClientStat2_StatDetail.internalBinaryWrite(message.statDetail[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientStat2
 */
export const CMsgClientStat2 = new CMsgClientStat2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientStat2_StatDetail$Type extends MessageType<CMsgClientStat2_StatDetail> {
    constructor() {
        super("CMsgClientStat2_StatDetail", [
            { no: 1, name: "client_stat", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "ll_value", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "time_of_day", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "depot_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientStat2_StatDetail>): CMsgClientStat2_StatDetail {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientStat2_StatDetail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientStat2_StatDetail): CMsgClientStat2_StatDetail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 client_stat */ 1:
                    message.clientStat = reader.uint32();
                    break;
                case /* optional int64 ll_value */ 2:
                    message.llValue = reader.int64().toBigInt();
                    break;
                case /* optional uint32 time_of_day */ 3:
                    message.timeOfDay = reader.uint32();
                    break;
                case /* optional uint32 cell_id */ 4:
                    message.cellId = reader.uint32();
                    break;
                case /* optional uint32 depot_id */ 5:
                    message.depotId = reader.uint32();
                    break;
                case /* optional uint32 app_id */ 6:
                    message.appId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientStat2_StatDetail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 client_stat = 1; */
        if (message.clientStat !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.clientStat);
        /* optional int64 ll_value = 2; */
        if (message.llValue !== undefined)
            writer.tag(2, WireType.Varint).int64(message.llValue);
        /* optional uint32 time_of_day = 3; */
        if (message.timeOfDay !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.timeOfDay);
        /* optional uint32 cell_id = 4; */
        if (message.cellId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.cellId);
        /* optional uint32 depot_id = 5; */
        if (message.depotId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.depotId);
        /* optional uint32 app_id = 6; */
        if (message.appId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.appId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientStat2_StatDetail
 */
export const CMsgClientStat2_StatDetail = new CMsgClientStat2_StatDetail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientStatsUpdated$Type extends MessageType<CMsgClientStatsUpdated> {
    constructor() {
        super("CMsgClientStatsUpdated", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "crc_stats", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "updated_stats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientStatsUpdated_Updated_Stats }
        ]);
    }
    create(value?: PartialMessage<CMsgClientStatsUpdated>): CMsgClientStatsUpdated {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updatedStats = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientStatsUpdated>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientStatsUpdated): CMsgClientStatsUpdated {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 game_id */ 2:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 crc_stats */ 3:
                    message.crcStats = reader.uint32();
                    break;
                case /* repeated CMsgClientStatsUpdated_Updated_Stats updated_stats */ 4:
                    message.updatedStats.push(CMsgClientStatsUpdated_Updated_Stats.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientStatsUpdated, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional fixed64 game_id = 2; */
        if (message.gameId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.gameId);
        /* optional uint32 crc_stats = 3; */
        if (message.crcStats !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.crcStats);
        /* repeated CMsgClientStatsUpdated_Updated_Stats updated_stats = 4; */
        for (let i = 0; i < message.updatedStats.length; i++)
            CMsgClientStatsUpdated_Updated_Stats.internalBinaryWrite(message.updatedStats[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientStatsUpdated
 */
export const CMsgClientStatsUpdated = new CMsgClientStatsUpdated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientStatsUpdated_Updated_Stats$Type extends MessageType<CMsgClientStatsUpdated_Updated_Stats> {
    constructor() {
        super("CMsgClientStatsUpdated_Updated_Stats", [
            { no: 1, name: "stat_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stat_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientStatsUpdated_Updated_Stats>): CMsgClientStatsUpdated_Updated_Stats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientStatsUpdated_Updated_Stats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientStatsUpdated_Updated_Stats): CMsgClientStatsUpdated_Updated_Stats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 stat_id */ 1:
                    message.statId = reader.uint32();
                    break;
                case /* optional uint32 stat_value */ 2:
                    message.statValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientStatsUpdated_Updated_Stats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 stat_id = 1; */
        if (message.statId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.statId);
        /* optional uint32 stat_value = 2; */
        if (message.statValue !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.statValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientStatsUpdated_Updated_Stats
 */
export const CMsgClientStatsUpdated_Updated_Stats = new CMsgClientStatsUpdated_Updated_Stats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientStoreUserStats$Type extends MessageType<CMsgClientStoreUserStats> {
    constructor() {
        super("CMsgClientStoreUserStats", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "explicit_reset", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "stats_to_store", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientStoreUserStats_Stats_To_Store }
        ]);
    }
    create(value?: PartialMessage<CMsgClientStoreUserStats>): CMsgClientStoreUserStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statsToStore = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientStoreUserStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientStoreUserStats): CMsgClientStoreUserStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 game_id */ 1:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional bool explicit_reset */ 2:
                    message.explicitReset = reader.bool();
                    break;
                case /* repeated CMsgClientStoreUserStats_Stats_To_Store stats_to_store */ 3:
                    message.statsToStore.push(CMsgClientStoreUserStats_Stats_To_Store.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientStoreUserStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameId);
        /* optional bool explicit_reset = 2; */
        if (message.explicitReset !== undefined)
            writer.tag(2, WireType.Varint).bool(message.explicitReset);
        /* repeated CMsgClientStoreUserStats_Stats_To_Store stats_to_store = 3; */
        for (let i = 0; i < message.statsToStore.length; i++)
            CMsgClientStoreUserStats_Stats_To_Store.internalBinaryWrite(message.statsToStore[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientStoreUserStats
 */
export const CMsgClientStoreUserStats = new CMsgClientStoreUserStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientStoreUserStats_Stats_To_Store$Type extends MessageType<CMsgClientStoreUserStats_Stats_To_Store> {
    constructor() {
        super("CMsgClientStoreUserStats_Stats_To_Store", [
            { no: 1, name: "stat_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stat_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientStoreUserStats_Stats_To_Store>): CMsgClientStoreUserStats_Stats_To_Store {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientStoreUserStats_Stats_To_Store>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientStoreUserStats_Stats_To_Store): CMsgClientStoreUserStats_Stats_To_Store {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 stat_id */ 1:
                    message.statId = reader.uint32();
                    break;
                case /* optional uint32 stat_value */ 2:
                    message.statValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientStoreUserStats_Stats_To_Store, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 stat_id = 1; */
        if (message.statId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.statId);
        /* optional uint32 stat_value = 2; */
        if (message.statValue !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.statValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientStoreUserStats_Stats_To_Store
 */
export const CMsgClientStoreUserStats_Stats_To_Store = new CMsgClientStoreUserStats_Stats_To_Store$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientStoreUserStats2$Type extends MessageType<CMsgClientStoreUserStats2> {
    constructor() {
        super("CMsgClientStoreUserStats2", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "settor_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "settee_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "crc_stats", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "explicit_reset", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "stats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientStoreUserStats2_Stats }
        ]);
    }
    create(value?: PartialMessage<CMsgClientStoreUserStats2>): CMsgClientStoreUserStats2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stats = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientStoreUserStats2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientStoreUserStats2): CMsgClientStoreUserStats2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 game_id */ 1:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 settor_steam_id */ 2:
                    message.settorSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 settee_steam_id */ 3:
                    message.setteeSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 crc_stats */ 4:
                    message.crcStats = reader.uint32();
                    break;
                case /* optional bool explicit_reset */ 5:
                    message.explicitReset = reader.bool();
                    break;
                case /* repeated CMsgClientStoreUserStats2_Stats stats */ 6:
                    message.stats.push(CMsgClientStoreUserStats2_Stats.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientStoreUserStats2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameId);
        /* optional fixed64 settor_steam_id = 2; */
        if (message.settorSteamId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.settorSteamId);
        /* optional fixed64 settee_steam_id = 3; */
        if (message.setteeSteamId !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.setteeSteamId);
        /* optional uint32 crc_stats = 4; */
        if (message.crcStats !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.crcStats);
        /* optional bool explicit_reset = 5; */
        if (message.explicitReset !== undefined)
            writer.tag(5, WireType.Varint).bool(message.explicitReset);
        /* repeated CMsgClientStoreUserStats2_Stats stats = 6; */
        for (let i = 0; i < message.stats.length; i++)
            CMsgClientStoreUserStats2_Stats.internalBinaryWrite(message.stats[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientStoreUserStats2
 */
export const CMsgClientStoreUserStats2 = new CMsgClientStoreUserStats2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientStoreUserStats2_Stats$Type extends MessageType<CMsgClientStoreUserStats2_Stats> {
    constructor() {
        super("CMsgClientStoreUserStats2_Stats", [
            { no: 1, name: "stat_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stat_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientStoreUserStats2_Stats>): CMsgClientStoreUserStats2_Stats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientStoreUserStats2_Stats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientStoreUserStats2_Stats): CMsgClientStoreUserStats2_Stats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 stat_id */ 1:
                    message.statId = reader.uint32();
                    break;
                case /* optional uint32 stat_value */ 2:
                    message.statValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientStoreUserStats2_Stats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 stat_id = 1; */
        if (message.statId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.statId);
        /* optional uint32 stat_value = 2; */
        if (message.statValue !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.statValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientStoreUserStats2_Stats
 */
export const CMsgClientStoreUserStats2_Stats = new CMsgClientStoreUserStats2_Stats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientStoreUserStatsResponse$Type extends MessageType<CMsgClientStoreUserStatsResponse> {
    constructor() {
        super("CMsgClientStoreUserStatsResponse", [
            { no: 1, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "crc_stats", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "stats_failed_validation", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientStoreUserStatsResponse_Stats_Failed_Validation },
            { no: 5, name: "stats_out_of_date", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientStoreUserStatsResponse>): CMsgClientStoreUserStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statsFailedValidation = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientStoreUserStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientStoreUserStatsResponse): CMsgClientStoreUserStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 game_id */ 1:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 eresult = 2 [default = 2] */ 2:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 crc_stats */ 3:
                    message.crcStats = reader.uint32();
                    break;
                case /* repeated CMsgClientStoreUserStatsResponse_Stats_Failed_Validation stats_failed_validation */ 4:
                    message.statsFailedValidation.push(CMsgClientStoreUserStatsResponse_Stats_Failed_Validation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool stats_out_of_date */ 5:
                    message.statsOutOfDate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientStoreUserStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 game_id = 1; */
        if (message.gameId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gameId);
        /* optional int32 eresult = 2 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).int32(message.eresult);
        /* optional uint32 crc_stats = 3; */
        if (message.crcStats !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.crcStats);
        /* repeated CMsgClientStoreUserStatsResponse_Stats_Failed_Validation stats_failed_validation = 4; */
        for (let i = 0; i < message.statsFailedValidation.length; i++)
            CMsgClientStoreUserStatsResponse_Stats_Failed_Validation.internalBinaryWrite(message.statsFailedValidation[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional bool stats_out_of_date = 5; */
        if (message.statsOutOfDate !== undefined)
            writer.tag(5, WireType.Varint).bool(message.statsOutOfDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientStoreUserStatsResponse
 */
export const CMsgClientStoreUserStatsResponse = new CMsgClientStoreUserStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientStoreUserStatsResponse_Stats_Failed_Validation$Type extends MessageType<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation> {
    constructor() {
        super("CMsgClientStoreUserStatsResponse_Stats_Failed_Validation", [
            { no: 1, name: "stat_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "reverted_stat_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>): CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientStoreUserStatsResponse_Stats_Failed_Validation): CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 stat_id */ 1:
                    message.statId = reader.uint32();
                    break;
                case /* optional uint32 reverted_stat_value */ 2:
                    message.revertedStatValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientStoreUserStatsResponse_Stats_Failed_Validation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 stat_id = 1; */
        if (message.statId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.statId);
        /* optional uint32 reverted_stat_value = 2; */
        if (message.revertedStatValue !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.revertedStatValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientStoreUserStatsResponse_Stats_Failed_Validation
 */
export const CMsgClientStoreUserStatsResponse_Stats_Failed_Validation = new CMsgClientStoreUserStatsResponse_Stats_Failed_Validation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientTicketAuthComplete$Type extends MessageType<CMsgClientTicketAuthComplete> {
    constructor() {
        super("CMsgClientTicketAuthComplete", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "estate", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "eauth_session_response", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "DEPRECATED_ticket", kind: "scalar", jsonName: "DEPRECATEDTicket", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "ticket_crc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "ticket_sequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "owner_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientTicketAuthComplete>): CMsgClientTicketAuthComplete {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientTicketAuthComplete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientTicketAuthComplete): CMsgClientTicketAuthComplete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 game_id */ 2:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 estate */ 3:
                    message.estate = reader.uint32();
                    break;
                case /* optional uint32 eauth_session_response */ 4:
                    message.eauthSessionResponse = reader.uint32();
                    break;
                case /* optional bytes DEPRECATED_ticket */ 5:
                    message.dEPRECATEDTicket = reader.bytes();
                    break;
                case /* optional uint32 ticket_crc */ 6:
                    message.ticketCrc = reader.uint32();
                    break;
                case /* optional uint32 ticket_sequence */ 7:
                    message.ticketSequence = reader.uint32();
                    break;
                case /* optional fixed64 owner_steam_id */ 8:
                    message.ownerSteamId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientTicketAuthComplete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional fixed64 game_id = 2; */
        if (message.gameId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.gameId);
        /* optional uint32 estate = 3; */
        if (message.estate !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.estate);
        /* optional uint32 eauth_session_response = 4; */
        if (message.eauthSessionResponse !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.eauthSessionResponse);
        /* optional bytes DEPRECATED_ticket = 5; */
        if (message.dEPRECATEDTicket !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.dEPRECATEDTicket);
        /* optional uint32 ticket_crc = 6; */
        if (message.ticketCrc !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.ticketCrc);
        /* optional uint32 ticket_sequence = 7; */
        if (message.ticketSequence !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.ticketSequence);
        /* optional fixed64 owner_steam_id = 8; */
        if (message.ownerSteamId !== undefined)
            writer.tag(8, WireType.Bit64).fixed64(message.ownerSteamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientTicketAuthComplete
 */
export const CMsgClientTicketAuthComplete = new CMsgClientTicketAuthComplete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMAddScreenshot$Type extends MessageType<CMsgClientUCMAddScreenshot> {
    constructor() {
        super("CMsgClientUCMAddScreenshot", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "thumbname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "rtime32_created", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "width", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "height", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "permissions", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "caption", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "shortcut_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "tag", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUCMAddScreenshot_Tag },
            { no: 11, name: "tagged_steamid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "spoiler_tag", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "tagged_publishedfileid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "vr_filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMAddScreenshot>): CMsgClientUCMAddScreenshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tag = [];
        message.taggedSteamid = [];
        message.taggedPublishedfileid = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMAddScreenshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMAddScreenshot): CMsgClientUCMAddScreenshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional string filename */ 2:
                    message.filename = reader.string();
                    break;
                case /* optional string thumbname */ 3:
                    message.thumbname = reader.string();
                    break;
                case /* optional fixed32 rtime32_created */ 4:
                    message.rtime32Created = reader.fixed32();
                    break;
                case /* optional uint32 width */ 5:
                    message.width = reader.uint32();
                    break;
                case /* optional uint32 height */ 6:
                    message.height = reader.uint32();
                    break;
                case /* optional uint32 permissions */ 7:
                    message.permissions = reader.uint32();
                    break;
                case /* optional string caption */ 8:
                    message.caption = reader.string();
                    break;
                case /* optional string shortcut_name */ 9:
                    message.shortcutName = reader.string();
                    break;
                case /* repeated CMsgClientUCMAddScreenshot_Tag tag */ 10:
                    message.tag.push(CMsgClientUCMAddScreenshot_Tag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated fixed64 tagged_steamid */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.taggedSteamid.push(reader.fixed64().toBigInt());
                    else
                        message.taggedSteamid.push(reader.fixed64().toBigInt());
                    break;
                case /* optional bool spoiler_tag */ 12:
                    message.spoilerTag = reader.bool();
                    break;
                case /* repeated uint64 tagged_publishedfileid */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.taggedPublishedfileid.push(reader.uint64().toBigInt());
                    else
                        message.taggedPublishedfileid.push(reader.uint64().toBigInt());
                    break;
                case /* optional string vr_filename */ 14:
                    message.vrFilename = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMAddScreenshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional string filename = 2; */
        if (message.filename !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.filename);
        /* optional string thumbname = 3; */
        if (message.thumbname !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.thumbname);
        /* optional fixed32 rtime32_created = 4; */
        if (message.rtime32Created !== undefined)
            writer.tag(4, WireType.Bit32).fixed32(message.rtime32Created);
        /* optional uint32 width = 5; */
        if (message.width !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.width);
        /* optional uint32 height = 6; */
        if (message.height !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.height);
        /* optional uint32 permissions = 7; */
        if (message.permissions !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.permissions);
        /* optional string caption = 8; */
        if (message.caption !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.caption);
        /* optional string shortcut_name = 9; */
        if (message.shortcutName !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.shortcutName);
        /* repeated CMsgClientUCMAddScreenshot_Tag tag = 10; */
        for (let i = 0; i < message.tag.length; i++)
            CMsgClientUCMAddScreenshot_Tag.internalBinaryWrite(message.tag[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated fixed64 tagged_steamid = 11; */
        for (let i = 0; i < message.taggedSteamid.length; i++)
            writer.tag(11, WireType.Bit64).fixed64(message.taggedSteamid[i]);
        /* optional bool spoiler_tag = 12; */
        if (message.spoilerTag !== undefined)
            writer.tag(12, WireType.Varint).bool(message.spoilerTag);
        /* repeated uint64 tagged_publishedfileid = 13; */
        for (let i = 0; i < message.taggedPublishedfileid.length; i++)
            writer.tag(13, WireType.Varint).uint64(message.taggedPublishedfileid[i]);
        /* optional string vr_filename = 14; */
        if (message.vrFilename !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.vrFilename);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMAddScreenshot
 */
export const CMsgClientUCMAddScreenshot = new CMsgClientUCMAddScreenshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMAddScreenshot_Tag$Type extends MessageType<CMsgClientUCMAddScreenshot_Tag> {
    constructor() {
        super("CMsgClientUCMAddScreenshot_Tag", [
            { no: 1, name: "tag_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tag_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMAddScreenshot_Tag>): CMsgClientUCMAddScreenshot_Tag {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMAddScreenshot_Tag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMAddScreenshot_Tag): CMsgClientUCMAddScreenshot_Tag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string tag_name */ 1:
                    message.tagName = reader.string();
                    break;
                case /* optional string tag_value */ 2:
                    message.tagValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMAddScreenshot_Tag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string tag_name = 1; */
        if (message.tagName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.tagName);
        /* optional string tag_value = 2; */
        if (message.tagValue !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.tagValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMAddScreenshot_Tag
 */
export const CMsgClientUCMAddScreenshot_Tag = new CMsgClientUCMAddScreenshot_Tag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMAddScreenshotResponse$Type extends MessageType<CMsgClientUCMAddScreenshotResponse> {
    constructor() {
        super("CMsgClientUCMAddScreenshotResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "screenshotid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMAddScreenshotResponse>): CMsgClientUCMAddScreenshotResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMAddScreenshotResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMAddScreenshotResponse): CMsgClientUCMAddScreenshotResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional fixed64 screenshotid = 2 [default = 18446744073709551615] */ 2:
                    message.screenshotid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMAddScreenshotResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional fixed64 screenshotid = 2 [default = 18446744073709551615]; */
        if (message.screenshotid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.screenshotid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMAddScreenshotResponse
 */
export const CMsgClientUCMAddScreenshotResponse = new CMsgClientUCMAddScreenshotResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMDeletePublishedFile$Type extends MessageType<CMsgClientUCMDeletePublishedFile> {
    constructor() {
        super("CMsgClientUCMDeletePublishedFile", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMDeletePublishedFile>): CMsgClientUCMDeletePublishedFile {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMDeletePublishedFile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMDeletePublishedFile): CMsgClientUCMDeletePublishedFile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMDeletePublishedFile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMDeletePublishedFile
 */
export const CMsgClientUCMDeletePublishedFile = new CMsgClientUCMDeletePublishedFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMDeletePublishedFileResponse$Type extends MessageType<CMsgClientUCMDeletePublishedFileResponse> {
    constructor() {
        super("CMsgClientUCMDeletePublishedFileResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMDeletePublishedFileResponse>): CMsgClientUCMDeletePublishedFileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMDeletePublishedFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMDeletePublishedFileResponse): CMsgClientUCMDeletePublishedFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMDeletePublishedFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMDeletePublishedFileResponse
 */
export const CMsgClientUCMDeletePublishedFileResponse = new CMsgClientUCMDeletePublishedFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMDeleteScreenshot$Type extends MessageType<CMsgClientUCMDeleteScreenshot> {
    constructor() {
        super("CMsgClientUCMDeleteScreenshot", [
            { no: 1, name: "screenshotid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMDeleteScreenshot>): CMsgClientUCMDeleteScreenshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMDeleteScreenshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMDeleteScreenshot): CMsgClientUCMDeleteScreenshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 screenshotid = 1 [default = 18446744073709551615] */ 1:
                    message.screenshotid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMDeleteScreenshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 screenshotid = 1 [default = 18446744073709551615]; */
        if (message.screenshotid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.screenshotid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMDeleteScreenshot
 */
export const CMsgClientUCMDeleteScreenshot = new CMsgClientUCMDeleteScreenshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMDeleteScreenshotResponse$Type extends MessageType<CMsgClientUCMDeleteScreenshotResponse> {
    constructor() {
        super("CMsgClientUCMDeleteScreenshotResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMDeleteScreenshotResponse>): CMsgClientUCMDeleteScreenshotResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMDeleteScreenshotResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMDeleteScreenshotResponse): CMsgClientUCMDeleteScreenshotResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMDeleteScreenshotResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMDeleteScreenshotResponse
 */
export const CMsgClientUCMDeleteScreenshotResponse = new CMsgClientUCMDeleteScreenshotResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumeratePublishedFilesByUserAction$Type extends MessageType<CMsgClientUCMEnumeratePublishedFilesByUserAction> {
    constructor() {
        super("CMsgClientUCMEnumeratePublishedFilesByUserAction", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "start_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "action", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumeratePublishedFilesByUserAction>): CMsgClientUCMEnumeratePublishedFilesByUserAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumeratePublishedFilesByUserAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumeratePublishedFilesByUserAction): CMsgClientUCMEnumeratePublishedFilesByUserAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 start_index */ 2:
                    message.startIndex = reader.uint32();
                    break;
                case /* optional int32 action */ 3:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumeratePublishedFilesByUserAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 start_index = 2; */
        if (message.startIndex !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.startIndex);
        /* optional int32 action = 3; */
        if (message.action !== undefined)
            writer.tag(3, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumeratePublishedFilesByUserAction
 */
export const CMsgClientUCMEnumeratePublishedFilesByUserAction = new CMsgClientUCMEnumeratePublishedFilesByUserAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumeratePublishedFilesByUserActionResponse$Type extends MessageType<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse> {
    constructor() {
        super("CMsgClientUCMEnumeratePublishedFilesByUserActionResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "published_files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId },
            { no: 3, name: "total_results", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse>): CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishedFiles = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse): CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId published_files */ 2:
                    message.publishedFiles.push(CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 total_results */ 3:
                    message.totalResults = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* repeated CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId published_files = 2; */
        for (let i = 0; i < message.publishedFiles.length; i++)
            CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId.internalBinaryWrite(message.publishedFiles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 total_results = 3; */
        if (message.totalResults !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.totalResults);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumeratePublishedFilesByUserActionResponse
 */
export const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse = new CMsgClientUCMEnumeratePublishedFilesByUserActionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId$Type extends MessageType<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId> {
    constructor() {
        super("CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "rtime_time_stamp", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId>): CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId): CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed32 rtime_time_stamp = 2 [default = 0] */ 2:
                    message.rtimeTimeStamp = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional fixed32 rtime_time_stamp = 2 [default = 0]; */
        if (message.rtimeTimeStamp !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.rtimeTimeStamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId
 */
export const CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId = new CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumerateUserPublishedFiles$Type extends MessageType<CMsgClientUCMEnumerateUserPublishedFiles> {
    constructor() {
        super("CMsgClientUCMEnumerateUserPublishedFiles", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "start_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sort_order", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumerateUserPublishedFiles>): CMsgClientUCMEnumerateUserPublishedFiles {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumerateUserPublishedFiles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumerateUserPublishedFiles): CMsgClientUCMEnumerateUserPublishedFiles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 start_index */ 2:
                    message.startIndex = reader.uint32();
                    break;
                case /* optional uint32 sort_order */ 3:
                    message.sortOrder = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumerateUserPublishedFiles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 start_index = 2; */
        if (message.startIndex !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.startIndex);
        /* optional uint32 sort_order = 3; */
        if (message.sortOrder !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.sortOrder);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumerateUserPublishedFiles
 */
export const CMsgClientUCMEnumerateUserPublishedFiles = new CMsgClientUCMEnumerateUserPublishedFiles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumerateUserPublishedFilesResponse$Type extends MessageType<CMsgClientUCMEnumerateUserPublishedFilesResponse> {
    constructor() {
        super("CMsgClientUCMEnumerateUserPublishedFilesResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "published_files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId },
            { no: 3, name: "total_results", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumerateUserPublishedFilesResponse>): CMsgClientUCMEnumerateUserPublishedFilesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishedFiles = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumerateUserPublishedFilesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumerateUserPublishedFilesResponse): CMsgClientUCMEnumerateUserPublishedFilesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId published_files */ 2:
                    message.publishedFiles.push(CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 total_results */ 3:
                    message.totalResults = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumerateUserPublishedFilesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* repeated CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId published_files = 2; */
        for (let i = 0; i < message.publishedFiles.length; i++)
            CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId.internalBinaryWrite(message.publishedFiles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 total_results = 3; */
        if (message.totalResults !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.totalResults);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumerateUserPublishedFilesResponse
 */
export const CMsgClientUCMEnumerateUserPublishedFilesResponse = new CMsgClientUCMEnumerateUserPublishedFilesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId$Type extends MessageType<CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId> {
    constructor() {
        super("CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId>): CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId): CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId
 */
export const CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId = new CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumerateUserSubscribedFiles$Type extends MessageType<CMsgClientUCMEnumerateUserSubscribedFiles> {
    constructor() {
        super("CMsgClientUCMEnumerateUserSubscribedFiles", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "start_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "list_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "matching_file_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumerateUserSubscribedFiles>): CMsgClientUCMEnumerateUserSubscribedFiles {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumerateUserSubscribedFiles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumerateUserSubscribedFiles): CMsgClientUCMEnumerateUserSubscribedFiles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 start_index */ 2:
                    message.startIndex = reader.uint32();
                    break;
                case /* optional uint32 list_type = 3 [default = 1] */ 3:
                    message.listType = reader.uint32();
                    break;
                case /* optional uint32 matching_file_type = 4 [default = 0] */ 4:
                    message.matchingFileType = reader.uint32();
                    break;
                case /* optional uint32 count = 5 [default = 50] */ 5:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumerateUserSubscribedFiles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 start_index = 2; */
        if (message.startIndex !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.startIndex);
        /* optional uint32 list_type = 3 [default = 1]; */
        if (message.listType !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.listType);
        /* optional uint32 matching_file_type = 4 [default = 0]; */
        if (message.matchingFileType !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.matchingFileType);
        /* optional uint32 count = 5 [default = 50]; */
        if (message.count !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumerateUserSubscribedFiles
 */
export const CMsgClientUCMEnumerateUserSubscribedFiles = new CMsgClientUCMEnumerateUserSubscribedFiles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumerateUserSubscribedFilesResponse$Type extends MessageType<CMsgClientUCMEnumerateUserSubscribedFilesResponse> {
    constructor() {
        super("CMsgClientUCMEnumerateUserSubscribedFilesResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "subscribed_files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId },
            { no: 3, name: "total_results", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumerateUserSubscribedFilesResponse>): CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscribedFiles = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumerateUserSubscribedFilesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumerateUserSubscribedFilesResponse): CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId subscribed_files */ 2:
                    message.subscribedFiles.push(CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 total_results */ 3:
                    message.totalResults = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumerateUserSubscribedFilesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* repeated CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId subscribed_files = 2; */
        for (let i = 0; i < message.subscribedFiles.length; i++)
            CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId.internalBinaryWrite(message.subscribedFiles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 total_results = 3; */
        if (message.totalResults !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.totalResults);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumerateUserSubscribedFilesResponse
 */
export const CMsgClientUCMEnumerateUserSubscribedFilesResponse = new CMsgClientUCMEnumerateUserSubscribedFilesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId$Type extends MessageType<CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId> {
    constructor() {
        super("CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "rtime32_subscribed", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId>): CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId): CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed32 rtime32_subscribed = 2 [default = 0] */ 2:
                    message.rtime32Subscribed = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional fixed32 rtime32_subscribed = 2 [default = 0]; */
        if (message.rtime32Subscribed !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.rtime32Subscribed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId
 */
export const CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId = new CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates$Type extends MessageType<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates> {
    constructor() {
        super("CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "start_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "start_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "desired_revision", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates>): CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates): CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 start_index */ 2:
                    message.startIndex = reader.uint32();
                    break;
                case /* optional fixed32 start_time */ 3:
                    message.startTime = reader.fixed32();
                    break;
                case /* optional uint32 desired_revision = 4 [default = 0] */ 4:
                    message.desiredRevision = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 start_index = 2; */
        if (message.startIndex !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.startIndex);
        /* optional fixed32 start_time = 3; */
        if (message.startTime !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.startTime);
        /* optional uint32 desired_revision = 4 [default = 0]; */
        if (message.desiredRevision !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.desiredRevision);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates
 */
export const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates = new CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse$Type extends MessageType<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse> {
    constructor() {
        super("CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "subscribed_files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId },
            { no: 3, name: "total_results", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse>): CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscribedFiles = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse): CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId subscribed_files */ 2:
                    message.subscribedFiles.push(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 total_results */ 3:
                    message.totalResults = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* repeated CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId subscribed_files = 2; */
        for (let i = 0; i < message.subscribedFiles.length; i++)
            CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId.internalBinaryWrite(message.subscribedFiles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 total_results = 3; */
        if (message.totalResults !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.totalResults);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse
 */
export const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse = new CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId$Type extends MessageType<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId> {
    constructor() {
        super("CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "rtime32_subscribed", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "file_hcontent", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "file_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "rtime32_last_updated", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 7, name: "is_depot_content", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId>): CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId): CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed32 rtime32_subscribed = 2 [default = 0] */ 2:
                    message.rtime32Subscribed = reader.fixed32();
                    break;
                case /* optional uint32 appid */ 3:
                    message.appid = reader.uint32();
                    break;
                case /* optional fixed64 file_hcontent */ 4:
                    message.fileHcontent = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 file_size */ 5:
                    message.fileSize = reader.uint32();
                    break;
                case /* optional fixed32 rtime32_last_updated */ 6:
                    message.rtime32LastUpdated = reader.fixed32();
                    break;
                case /* optional bool is_depot_content */ 7:
                    message.isDepotContent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional fixed32 rtime32_subscribed = 2 [default = 0]; */
        if (message.rtime32Subscribed !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.rtime32Subscribed);
        /* optional uint32 appid = 3; */
        if (message.appid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.appid);
        /* optional fixed64 file_hcontent = 4; */
        if (message.fileHcontent !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.fileHcontent);
        /* optional uint32 file_size = 5; */
        if (message.fileSize !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.fileSize);
        /* optional fixed32 rtime32_last_updated = 6; */
        if (message.rtime32LastUpdated !== undefined)
            writer.tag(6, WireType.Bit32).fixed32(message.rtime32LastUpdated);
        /* optional bool is_depot_content = 7; */
        if (message.isDepotContent !== undefined)
            writer.tag(7, WireType.Varint).bool(message.isDepotContent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId
 */
export const CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId = new CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMGetPublishedFilesForUser$Type extends MessageType<CMsgClientUCMGetPublishedFilesForUser> {
    constructor() {
        super("CMsgClientUCMGetPublishedFilesForUser", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "creator_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "required_tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "excluded_tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "start_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMGetPublishedFilesForUser>): CMsgClientUCMGetPublishedFilesForUser {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requiredTags = [];
        message.excludedTags = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMGetPublishedFilesForUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMGetPublishedFilesForUser): CMsgClientUCMGetPublishedFilesForUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 creator_steam_id */ 2:
                    message.creatorSteamId = reader.fixed64().toBigInt();
                    break;
                case /* repeated string required_tags */ 3:
                    message.requiredTags.push(reader.string());
                    break;
                case /* repeated string excluded_tags */ 4:
                    message.excludedTags.push(reader.string());
                    break;
                case /* optional uint32 start_index */ 5:
                    message.startIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMGetPublishedFilesForUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 creator_steam_id = 2; */
        if (message.creatorSteamId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.creatorSteamId);
        /* repeated string required_tags = 3; */
        for (let i = 0; i < message.requiredTags.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.requiredTags[i]);
        /* repeated string excluded_tags = 4; */
        for (let i = 0; i < message.excludedTags.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.excludedTags[i]);
        /* optional uint32 start_index = 5; */
        if (message.startIndex !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.startIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMGetPublishedFilesForUser
 */
export const CMsgClientUCMGetPublishedFilesForUser = new CMsgClientUCMGetPublishedFilesForUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMGetPublishedFilesForUserResponse$Type extends MessageType<CMsgClientUCMGetPublishedFilesForUserResponse> {
    constructor() {
        super("CMsgClientUCMGetPublishedFilesForUserResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "published_files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId },
            { no: 3, name: "total_results", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMGetPublishedFilesForUserResponse>): CMsgClientUCMGetPublishedFilesForUserResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishedFiles = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMGetPublishedFilesForUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMGetPublishedFilesForUserResponse): CMsgClientUCMGetPublishedFilesForUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId published_files */ 2:
                    message.publishedFiles.push(CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 total_results */ 3:
                    message.totalResults = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMGetPublishedFilesForUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* repeated CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId published_files = 2; */
        for (let i = 0; i < message.publishedFiles.length; i++)
            CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId.internalBinaryWrite(message.publishedFiles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 total_results = 3; */
        if (message.totalResults !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.totalResults);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMGetPublishedFilesForUserResponse
 */
export const CMsgClientUCMGetPublishedFilesForUserResponse = new CMsgClientUCMGetPublishedFilesForUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId$Type extends MessageType<CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId> {
    constructor() {
        super("CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId>): CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId): CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId
 */
export const CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId = new CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMPublishedFileUpdated$Type extends MessageType<CMsgClientUCMPublishedFileUpdated> {
    constructor() {
        super("CMsgClientUCMPublishedFileUpdated", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "time_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hcontent", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "file_size", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "is_depot_content", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "revision", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMPublishedFileUpdated>): CMsgClientUCMPublishedFileUpdated {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMPublishedFileUpdated>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMPublishedFileUpdated): CMsgClientUCMPublishedFileUpdated {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 time_updated */ 3:
                    message.timeUpdated = reader.uint32();
                    break;
                case /* optional fixed64 hcontent */ 4:
                    message.hcontent = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed32 file_size */ 5:
                    message.fileSize = reader.fixed32();
                    break;
                case /* optional bool is_depot_content */ 6:
                    message.isDepotContent = reader.bool();
                    break;
                case /* optional uint32 revision */ 7:
                    message.revision = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMPublishedFileUpdated, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional uint32 time_updated = 3; */
        if (message.timeUpdated !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.timeUpdated);
        /* optional fixed64 hcontent = 4; */
        if (message.hcontent !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.hcontent);
        /* optional fixed32 file_size = 5; */
        if (message.fileSize !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.fileSize);
        /* optional bool is_depot_content = 6; */
        if (message.isDepotContent !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isDepotContent);
        /* optional uint32 revision = 7; */
        if (message.revision !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.revision);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMPublishedFileUpdated
 */
export const CMsgClientUCMPublishedFileUpdated = new CMsgClientUCMPublishedFileUpdated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMPublishFile$Type extends MessageType<CMsgClientUCMPublishFile> {
    constructor() {
        super("CMsgClientUCMPublishFile", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "preview_file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "consumer_app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "workshop_file", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "visibility", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "file_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "video_provider", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "video_account_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "video_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "in_progress", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMPublishFile>): CMsgClientUCMPublishFile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMPublishFile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMPublishFile): CMsgClientUCMPublishFile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional string file_name */ 2:
                    message.fileName = reader.string();
                    break;
                case /* optional string preview_file_name */ 3:
                    message.previewFileName = reader.string();
                    break;
                case /* optional uint32 consumer_app_id */ 4:
                    message.consumerAppId = reader.uint32();
                    break;
                case /* optional string title */ 5:
                    message.title = reader.string();
                    break;
                case /* optional string description */ 6:
                    message.description = reader.string();
                    break;
                case /* repeated string tags */ 8:
                    message.tags.push(reader.string());
                    break;
                case /* optional bool workshop_file */ 9:
                    message.workshopFile = reader.bool();
                    break;
                case /* optional int32 visibility */ 10:
                    message.visibility = reader.int32();
                    break;
                case /* optional uint32 file_type */ 11:
                    message.fileType = reader.uint32();
                    break;
                case /* optional string url */ 12:
                    message.url = reader.string();
                    break;
                case /* optional uint32 video_provider */ 13:
                    message.videoProvider = reader.uint32();
                    break;
                case /* optional string video_account_name */ 14:
                    message.videoAccountName = reader.string();
                    break;
                case /* optional string video_identifier */ 15:
                    message.videoIdentifier = reader.string();
                    break;
                case /* optional bool in_progress */ 16:
                    message.inProgress = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMPublishFile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional string file_name = 2; */
        if (message.fileName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        /* optional string preview_file_name = 3; */
        if (message.previewFileName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.previewFileName);
        /* optional uint32 consumer_app_id = 4; */
        if (message.consumerAppId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.consumerAppId);
        /* optional string title = 5; */
        if (message.title !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.title);
        /* optional string description = 6; */
        if (message.description !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.description);
        /* repeated string tags = 8; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.tags[i]);
        /* optional bool workshop_file = 9; */
        if (message.workshopFile !== undefined)
            writer.tag(9, WireType.Varint).bool(message.workshopFile);
        /* optional int32 visibility = 10; */
        if (message.visibility !== undefined)
            writer.tag(10, WireType.Varint).int32(message.visibility);
        /* optional uint32 file_type = 11; */
        if (message.fileType !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.fileType);
        /* optional string url = 12; */
        if (message.url !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.url);
        /* optional uint32 video_provider = 13; */
        if (message.videoProvider !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.videoProvider);
        /* optional string video_account_name = 14; */
        if (message.videoAccountName !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.videoAccountName);
        /* optional string video_identifier = 15; */
        if (message.videoIdentifier !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.videoIdentifier);
        /* optional bool in_progress = 16; */
        if (message.inProgress !== undefined)
            writer.tag(16, WireType.Varint).bool(message.inProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMPublishFile
 */
export const CMsgClientUCMPublishFile = new CMsgClientUCMPublishFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMPublishFileResponse$Type extends MessageType<CMsgClientUCMPublishFileResponse> {
    constructor() {
        super("CMsgClientUCMPublishFileResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "needs_workshop_legal_agreement_acceptance", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMPublishFileResponse>): CMsgClientUCMPublishFileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMPublishFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMPublishFileResponse): CMsgClientUCMPublishFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional fixed64 published_file_id = 2 [default = 18446744073709551615] */ 2:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional bool needs_workshop_legal_agreement_acceptance = 3 [default = false] */ 3:
                    message.needsWorkshopLegalAgreementAcceptance = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMPublishFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional fixed64 published_file_id = 2 [default = 18446744073709551615]; */
        if (message.publishedFileId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional bool needs_workshop_legal_agreement_acceptance = 3 [default = false]; */
        if (message.needsWorkshopLegalAgreementAcceptance !== undefined)
            writer.tag(3, WireType.Varint).bool(message.needsWorkshopLegalAgreementAcceptance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMPublishFileResponse
 */
export const CMsgClientUCMPublishFileResponse = new CMsgClientUCMPublishFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMSetUserPublishedFileAction$Type extends MessageType<CMsgClientUCMSetUserPublishedFileAction> {
    constructor() {
        super("CMsgClientUCMSetUserPublishedFileAction", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "action", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMSetUserPublishedFileAction>): CMsgClientUCMSetUserPublishedFileAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMSetUserPublishedFileAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMSetUserPublishedFileAction): CMsgClientUCMSetUserPublishedFileAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional int32 action */ 3:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMSetUserPublishedFileAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional int32 action = 3; */
        if (message.action !== undefined)
            writer.tag(3, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMSetUserPublishedFileAction
 */
export const CMsgClientUCMSetUserPublishedFileAction = new CMsgClientUCMSetUserPublishedFileAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMSetUserPublishedFileActionResponse$Type extends MessageType<CMsgClientUCMSetUserPublishedFileActionResponse> {
    constructor() {
        super("CMsgClientUCMSetUserPublishedFileActionResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMSetUserPublishedFileActionResponse>): CMsgClientUCMSetUserPublishedFileActionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMSetUserPublishedFileActionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMSetUserPublishedFileActionResponse): CMsgClientUCMSetUserPublishedFileActionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMSetUserPublishedFileActionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMSetUserPublishedFileActionResponse
 */
export const CMsgClientUCMSetUserPublishedFileActionResponse = new CMsgClientUCMSetUserPublishedFileActionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMUpdatePublishedFile$Type extends MessageType<CMsgClientUCMUpdatePublishedFile> {
    constructor() {
        super("CMsgClientUCMUpdatePublishedFile", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "preview_file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "visibility", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "update_file", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "update_preview_file", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "update_title", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "update_description", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "update_tags", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "update_visibility", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "change_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "update_url", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "update_content_manifest", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "content_manifest", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "metadata", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "update_metadata", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "language", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "removed_kvtags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "kvtags", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUCMUpdatePublishedFile_KeyValueTag },
            { no: 25, name: "previews", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUCMUpdatePublishedFile_AdditionalPreview },
            { no: 26, name: "previews_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 27, name: "clear_in_progress", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "remove_all_kvtags", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMUpdatePublishedFile>): CMsgClientUCMUpdatePublishedFile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = [];
        message.removedKvtags = [];
        message.kvtags = [];
        message.previews = [];
        message.previewsToRemove = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMUpdatePublishedFile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMUpdatePublishedFile): CMsgClientUCMUpdatePublishedFile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional fixed64 published_file_id */ 2:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional string file_name */ 3:
                    message.fileName = reader.string();
                    break;
                case /* optional string preview_file_name */ 4:
                    message.previewFileName = reader.string();
                    break;
                case /* optional string title */ 5:
                    message.title = reader.string();
                    break;
                case /* optional string description */ 6:
                    message.description = reader.string();
                    break;
                case /* repeated string tags */ 7:
                    message.tags.push(reader.string());
                    break;
                case /* optional int32 visibility */ 8:
                    message.visibility = reader.int32();
                    break;
                case /* optional bool update_file */ 9:
                    message.updateFile = reader.bool();
                    break;
                case /* optional bool update_preview_file */ 10:
                    message.updatePreviewFile = reader.bool();
                    break;
                case /* optional bool update_title */ 11:
                    message.updateTitle = reader.bool();
                    break;
                case /* optional bool update_description */ 12:
                    message.updateDescription = reader.bool();
                    break;
                case /* optional bool update_tags */ 13:
                    message.updateTags = reader.bool();
                    break;
                case /* optional bool update_visibility */ 14:
                    message.updateVisibility = reader.bool();
                    break;
                case /* optional string change_description */ 15:
                    message.changeDescription = reader.string();
                    break;
                case /* optional bool update_url */ 16:
                    message.updateUrl = reader.bool();
                    break;
                case /* optional string url */ 17:
                    message.url = reader.string();
                    break;
                case /* optional bool update_content_manifest */ 18:
                    message.updateContentManifest = reader.bool();
                    break;
                case /* optional fixed64 content_manifest */ 19:
                    message.contentManifest = reader.fixed64().toBigInt();
                    break;
                case /* optional string metadata */ 20:
                    message.metadata = reader.string();
                    break;
                case /* optional bool update_metadata */ 21:
                    message.updateMetadata = reader.bool();
                    break;
                case /* optional int32 language = 22 [default = 0] */ 22:
                    message.language = reader.int32();
                    break;
                case /* repeated string removed_kvtags */ 23:
                    message.removedKvtags.push(reader.string());
                    break;
                case /* repeated CMsgClientUCMUpdatePublishedFile_KeyValueTag kvtags */ 24:
                    message.kvtags.push(CMsgClientUCMUpdatePublishedFile_KeyValueTag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgClientUCMUpdatePublishedFile_AdditionalPreview previews */ 25:
                    message.previews.push(CMsgClientUCMUpdatePublishedFile_AdditionalPreview.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 previews_to_remove */ 26:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.previewsToRemove.push(reader.int32());
                    else
                        message.previewsToRemove.push(reader.int32());
                    break;
                case /* optional bool clear_in_progress */ 27:
                    message.clearInProgress = reader.bool();
                    break;
                case /* optional bool remove_all_kvtags */ 28:
                    message.removeAllKvtags = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMUpdatePublishedFile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional fixed64 published_file_id = 2; */
        if (message.publishedFileId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional string file_name = 3; */
        if (message.fileName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.fileName);
        /* optional string preview_file_name = 4; */
        if (message.previewFileName !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.previewFileName);
        /* optional string title = 5; */
        if (message.title !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.title);
        /* optional string description = 6; */
        if (message.description !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.description);
        /* repeated string tags = 7; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.tags[i]);
        /* optional int32 visibility = 8; */
        if (message.visibility !== undefined)
            writer.tag(8, WireType.Varint).int32(message.visibility);
        /* optional bool update_file = 9; */
        if (message.updateFile !== undefined)
            writer.tag(9, WireType.Varint).bool(message.updateFile);
        /* optional bool update_preview_file = 10; */
        if (message.updatePreviewFile !== undefined)
            writer.tag(10, WireType.Varint).bool(message.updatePreviewFile);
        /* optional bool update_title = 11; */
        if (message.updateTitle !== undefined)
            writer.tag(11, WireType.Varint).bool(message.updateTitle);
        /* optional bool update_description = 12; */
        if (message.updateDescription !== undefined)
            writer.tag(12, WireType.Varint).bool(message.updateDescription);
        /* optional bool update_tags = 13; */
        if (message.updateTags !== undefined)
            writer.tag(13, WireType.Varint).bool(message.updateTags);
        /* optional bool update_visibility = 14; */
        if (message.updateVisibility !== undefined)
            writer.tag(14, WireType.Varint).bool(message.updateVisibility);
        /* optional string change_description = 15; */
        if (message.changeDescription !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.changeDescription);
        /* optional bool update_url = 16; */
        if (message.updateUrl !== undefined)
            writer.tag(16, WireType.Varint).bool(message.updateUrl);
        /* optional string url = 17; */
        if (message.url !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.url);
        /* optional bool update_content_manifest = 18; */
        if (message.updateContentManifest !== undefined)
            writer.tag(18, WireType.Varint).bool(message.updateContentManifest);
        /* optional fixed64 content_manifest = 19; */
        if (message.contentManifest !== undefined)
            writer.tag(19, WireType.Bit64).fixed64(message.contentManifest);
        /* optional string metadata = 20; */
        if (message.metadata !== undefined)
            writer.tag(20, WireType.LengthDelimited).string(message.metadata);
        /* optional bool update_metadata = 21; */
        if (message.updateMetadata !== undefined)
            writer.tag(21, WireType.Varint).bool(message.updateMetadata);
        /* optional int32 language = 22 [default = 0]; */
        if (message.language !== undefined)
            writer.tag(22, WireType.Varint).int32(message.language);
        /* repeated string removed_kvtags = 23; */
        for (let i = 0; i < message.removedKvtags.length; i++)
            writer.tag(23, WireType.LengthDelimited).string(message.removedKvtags[i]);
        /* repeated CMsgClientUCMUpdatePublishedFile_KeyValueTag kvtags = 24; */
        for (let i = 0; i < message.kvtags.length; i++)
            CMsgClientUCMUpdatePublishedFile_KeyValueTag.internalBinaryWrite(message.kvtags[i], writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgClientUCMUpdatePublishedFile_AdditionalPreview previews = 25; */
        for (let i = 0; i < message.previews.length; i++)
            CMsgClientUCMUpdatePublishedFile_AdditionalPreview.internalBinaryWrite(message.previews[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 previews_to_remove = 26; */
        for (let i = 0; i < message.previewsToRemove.length; i++)
            writer.tag(26, WireType.Varint).int32(message.previewsToRemove[i]);
        /* optional bool clear_in_progress = 27; */
        if (message.clearInProgress !== undefined)
            writer.tag(27, WireType.Varint).bool(message.clearInProgress);
        /* optional bool remove_all_kvtags = 28; */
        if (message.removeAllKvtags !== undefined)
            writer.tag(28, WireType.Varint).bool(message.removeAllKvtags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMUpdatePublishedFile
 */
export const CMsgClientUCMUpdatePublishedFile = new CMsgClientUCMUpdatePublishedFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMUpdatePublishedFile_AdditionalPreview$Type extends MessageType<CMsgClientUCMUpdatePublishedFile_AdditionalPreview> {
    constructor() {
        super("CMsgClientUCMUpdatePublishedFile_AdditionalPreview", [
            { no: 1, name: "original_file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "internal_file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "videoid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "preview_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "update_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMUpdatePublishedFile_AdditionalPreview>): CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMUpdatePublishedFile_AdditionalPreview>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMUpdatePublishedFile_AdditionalPreview): CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string original_file_name */ 1:
                    message.originalFileName = reader.string();
                    break;
                case /* optional string internal_file_name */ 2:
                    message.internalFileName = reader.string();
                    break;
                case /* optional string videoid */ 3:
                    message.videoid = reader.string();
                    break;
                case /* optional uint32 preview_type */ 4:
                    message.previewType = reader.uint32();
                    break;
                case /* optional int32 update_index = 5 [default = -1] */ 5:
                    message.updateIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMUpdatePublishedFile_AdditionalPreview, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string original_file_name = 1; */
        if (message.originalFileName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.originalFileName);
        /* optional string internal_file_name = 2; */
        if (message.internalFileName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.internalFileName);
        /* optional string videoid = 3; */
        if (message.videoid !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.videoid);
        /* optional uint32 preview_type = 4; */
        if (message.previewType !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.previewType);
        /* optional int32 update_index = 5 [default = -1]; */
        if (message.updateIndex !== undefined)
            writer.tag(5, WireType.Varint).int32(message.updateIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMUpdatePublishedFile_AdditionalPreview
 */
export const CMsgClientUCMUpdatePublishedFile_AdditionalPreview = new CMsgClientUCMUpdatePublishedFile_AdditionalPreview$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMUpdatePublishedFile_KeyValueTag$Type extends MessageType<CMsgClientUCMUpdatePublishedFile_KeyValueTag> {
    constructor() {
        super("CMsgClientUCMUpdatePublishedFile_KeyValueTag", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMUpdatePublishedFile_KeyValueTag>): CMsgClientUCMUpdatePublishedFile_KeyValueTag {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMUpdatePublishedFile_KeyValueTag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMUpdatePublishedFile_KeyValueTag): CMsgClientUCMUpdatePublishedFile_KeyValueTag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string key */ 1:
                    message.key = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMUpdatePublishedFile_KeyValueTag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMUpdatePublishedFile_KeyValueTag
 */
export const CMsgClientUCMUpdatePublishedFile_KeyValueTag = new CMsgClientUCMUpdatePublishedFile_KeyValueTag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUCMUpdatePublishedFileResponse$Type extends MessageType<CMsgClientUCMUpdatePublishedFileResponse> {
    constructor() {
        super("CMsgClientUCMUpdatePublishedFileResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "needs_workshop_legal_agreement_acceptance", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUCMUpdatePublishedFileResponse>): CMsgClientUCMUpdatePublishedFileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUCMUpdatePublishedFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUCMUpdatePublishedFileResponse): CMsgClientUCMUpdatePublishedFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional bool needs_workshop_legal_agreement_acceptance = 2 [default = false] */ 2:
                    message.needsWorkshopLegalAgreementAcceptance = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUCMUpdatePublishedFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional bool needs_workshop_legal_agreement_acceptance = 2 [default = false]; */
        if (message.needsWorkshopLegalAgreementAcceptance !== undefined)
            writer.tag(2, WireType.Varint).bool(message.needsWorkshopLegalAgreementAcceptance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUCMUpdatePublishedFileResponse
 */
export const CMsgClientUCMUpdatePublishedFileResponse = new CMsgClientUCMUpdatePublishedFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUDSP2PSessionEnded$Type extends MessageType<CMsgClientUDSP2PSessionEnded> {
    constructor() {
        super("CMsgClientUDSP2PSessionEnded", [
            { no: 1, name: "steamid_remote", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "session_length_sec", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "session_error", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "nattype", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "bytes_recv", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "bytes_sent", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "bytes_sent_relay", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "bytes_recv_relay", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "time_to_connect_ms", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUDSP2PSessionEnded>): CMsgClientUDSP2PSessionEnded {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUDSP2PSessionEnded>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUDSP2PSessionEnded): CMsgClientUDSP2PSessionEnded {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_remote */ 1:
                    message.steamidRemote = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 appid */ 2:
                    message.appid = reader.int32();
                    break;
                case /* optional int32 session_length_sec */ 3:
                    message.sessionLengthSec = reader.int32();
                    break;
                case /* optional int32 session_error */ 4:
                    message.sessionError = reader.int32();
                    break;
                case /* optional int32 nattype */ 5:
                    message.nattype = reader.int32();
                    break;
                case /* optional int32 bytes_recv */ 6:
                    message.bytesRecv = reader.int32();
                    break;
                case /* optional int32 bytes_sent */ 7:
                    message.bytesSent = reader.int32();
                    break;
                case /* optional int32 bytes_sent_relay */ 8:
                    message.bytesSentRelay = reader.int32();
                    break;
                case /* optional int32 bytes_recv_relay */ 9:
                    message.bytesRecvRelay = reader.int32();
                    break;
                case /* optional int32 time_to_connect_ms */ 10:
                    message.timeToConnectMs = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUDSP2PSessionEnded, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_remote = 1; */
        if (message.steamidRemote !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidRemote);
        /* optional int32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).int32(message.appid);
        /* optional int32 session_length_sec = 3; */
        if (message.sessionLengthSec !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sessionLengthSec);
        /* optional int32 session_error = 4; */
        if (message.sessionError !== undefined)
            writer.tag(4, WireType.Varint).int32(message.sessionError);
        /* optional int32 nattype = 5; */
        if (message.nattype !== undefined)
            writer.tag(5, WireType.Varint).int32(message.nattype);
        /* optional int32 bytes_recv = 6; */
        if (message.bytesRecv !== undefined)
            writer.tag(6, WireType.Varint).int32(message.bytesRecv);
        /* optional int32 bytes_sent = 7; */
        if (message.bytesSent !== undefined)
            writer.tag(7, WireType.Varint).int32(message.bytesSent);
        /* optional int32 bytes_sent_relay = 8; */
        if (message.bytesSentRelay !== undefined)
            writer.tag(8, WireType.Varint).int32(message.bytesSentRelay);
        /* optional int32 bytes_recv_relay = 9; */
        if (message.bytesRecvRelay !== undefined)
            writer.tag(9, WireType.Varint).int32(message.bytesRecvRelay);
        /* optional int32 time_to_connect_ms = 10; */
        if (message.timeToConnectMs !== undefined)
            writer.tag(10, WireType.Varint).int32(message.timeToConnectMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUDSP2PSessionEnded
 */
export const CMsgClientUDSP2PSessionEnded = new CMsgClientUDSP2PSessionEnded$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUDSP2PSessionStarted$Type extends MessageType<CMsgClientUDSP2PSessionStarted> {
    constructor() {
        super("CMsgClientUDSP2PSessionStarted", [
            { no: 1, name: "steamid_remote", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUDSP2PSessionStarted>): CMsgClientUDSP2PSessionStarted {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUDSP2PSessionStarted>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUDSP2PSessionStarted): CMsgClientUDSP2PSessionStarted {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_remote */ 1:
                    message.steamidRemote = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 appid */ 2:
                    message.appid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUDSP2PSessionStarted, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_remote = 1; */
        if (message.steamidRemote !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidRemote);
        /* optional int32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).int32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUDSP2PSessionStarted
 */
export const CMsgClientUDSP2PSessionStarted = new CMsgClientUDSP2PSessionStarted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSDeleteFileRequest$Type extends MessageType<CMsgClientUFSDeleteFileRequest> {
    constructor() {
        super("CMsgClientUFSDeleteFileRequest", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_explicit_delete", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSDeleteFileRequest>): CMsgClientUFSDeleteFileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSDeleteFileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSDeleteFileRequest): CMsgClientUFSDeleteFileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional string file_name */ 2:
                    message.fileName = reader.string();
                    break;
                case /* optional bool is_explicit_delete */ 3:
                    message.isExplicitDelete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSDeleteFileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional string file_name = 2; */
        if (message.fileName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        /* optional bool is_explicit_delete = 3; */
        if (message.isExplicitDelete !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isExplicitDelete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSDeleteFileRequest
 */
export const CMsgClientUFSDeleteFileRequest = new CMsgClientUFSDeleteFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSDeleteFileResponse$Type extends MessageType<CMsgClientUFSDeleteFileResponse> {
    constructor() {
        super("CMsgClientUFSDeleteFileResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSDeleteFileResponse>): CMsgClientUFSDeleteFileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSDeleteFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSDeleteFileResponse): CMsgClientUFSDeleteFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional string file_name */ 2:
                    message.fileName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSDeleteFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional string file_name = 2; */
        if (message.fileName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSDeleteFileResponse
 */
export const CMsgClientUFSDeleteFileResponse = new CMsgClientUFSDeleteFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSDownloadRequest$Type extends MessageType<CMsgClientUFSDownloadRequest> {
    constructor() {
        super("CMsgClientUFSDownloadRequest", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "can_handle_http", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSDownloadRequest>): CMsgClientUFSDownloadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSDownloadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSDownloadRequest): CMsgClientUFSDownloadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional string file_name */ 2:
                    message.fileName = reader.string();
                    break;
                case /* optional bool can_handle_http */ 3:
                    message.canHandleHttp = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSDownloadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional string file_name = 2; */
        if (message.fileName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        /* optional bool can_handle_http = 3; */
        if (message.canHandleHttp !== undefined)
            writer.tag(3, WireType.Varint).bool(message.canHandleHttp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSDownloadRequest
 */
export const CMsgClientUFSDownloadRequest = new CMsgClientUFSDownloadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSDownloadResponse$Type extends MessageType<CMsgClientUFSDownloadResponse> {
    constructor() {
        super("CMsgClientUFSDownloadResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "file_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "raw_file_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "time_stamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "is_explicit_delete", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "use_http", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "http_host", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "http_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "kv_headers", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "use_https", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "encrypted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSDownloadResponse>): CMsgClientUFSDownloadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSDownloadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSDownloadResponse): CMsgClientUFSDownloadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 file_size */ 3:
                    message.fileSize = reader.uint32();
                    break;
                case /* optional uint32 raw_file_size */ 4:
                    message.rawFileSize = reader.uint32();
                    break;
                case /* optional bytes sha_file */ 5:
                    message.shaFile = reader.bytes();
                    break;
                case /* optional uint64 time_stamp */ 6:
                    message.timeStamp = reader.uint64().toBigInt();
                    break;
                case /* optional bool is_explicit_delete */ 7:
                    message.isExplicitDelete = reader.bool();
                    break;
                case /* optional bool use_http */ 8:
                    message.useHttp = reader.bool();
                    break;
                case /* optional string http_host */ 9:
                    message.httpHost = reader.string();
                    break;
                case /* optional string http_url */ 10:
                    message.httpUrl = reader.string();
                    break;
                case /* optional bytes kv_headers */ 11:
                    message.kvHeaders = reader.bytes();
                    break;
                case /* optional bool use_https */ 12:
                    message.useHttps = reader.bool();
                    break;
                case /* optional bool encrypted */ 13:
                    message.encrypted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSDownloadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional uint32 file_size = 3; */
        if (message.fileSize !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.fileSize);
        /* optional uint32 raw_file_size = 4; */
        if (message.rawFileSize !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.rawFileSize);
        /* optional bytes sha_file = 5; */
        if (message.shaFile !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.shaFile);
        /* optional uint64 time_stamp = 6; */
        if (message.timeStamp !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.timeStamp);
        /* optional bool is_explicit_delete = 7; */
        if (message.isExplicitDelete !== undefined)
            writer.tag(7, WireType.Varint).bool(message.isExplicitDelete);
        /* optional bool use_http = 8; */
        if (message.useHttp !== undefined)
            writer.tag(8, WireType.Varint).bool(message.useHttp);
        /* optional string http_host = 9; */
        if (message.httpHost !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.httpHost);
        /* optional string http_url = 10; */
        if (message.httpUrl !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.httpUrl);
        /* optional bytes kv_headers = 11; */
        if (message.kvHeaders !== undefined)
            writer.tag(11, WireType.LengthDelimited).bytes(message.kvHeaders);
        /* optional bool use_https = 12; */
        if (message.useHttps !== undefined)
            writer.tag(12, WireType.Varint).bool(message.useHttps);
        /* optional bool encrypted = 13; */
        if (message.encrypted !== undefined)
            writer.tag(13, WireType.Varint).bool(message.encrypted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSDownloadResponse
 */
export const CMsgClientUFSDownloadResponse = new CMsgClientUFSDownloadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSFileChunk$Type extends MessageType<CMsgClientUFSFileChunk> {
    constructor() {
        super("CMsgClientUFSFileChunk", [
            { no: 1, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "file_start", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSFileChunk>): CMsgClientUFSFileChunk {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSFileChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSFileChunk): CMsgClientUFSFileChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes sha_file */ 1:
                    message.shaFile = reader.bytes();
                    break;
                case /* optional uint32 file_start */ 2:
                    message.fileStart = reader.uint32();
                    break;
                case /* optional bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSFileChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes sha_file = 1; */
        if (message.shaFile !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.shaFile);
        /* optional uint32 file_start = 2; */
        if (message.fileStart !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.fileStart);
        /* optional bytes data = 3; */
        if (message.data !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSFileChunk
 */
export const CMsgClientUFSFileChunk = new CMsgClientUFSFileChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSGetFileListForApp$Type extends MessageType<CMsgClientUFSGetFileListForApp> {
    constructor() {
        super("CMsgClientUFSGetFileListForApp", [
            { no: 1, name: "apps_to_query", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "send_path_prefixes", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSGetFileListForApp>): CMsgClientUFSGetFileListForApp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appsToQuery = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSGetFileListForApp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSGetFileListForApp): CMsgClientUFSGetFileListForApp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 apps_to_query */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.appsToQuery.push(reader.uint32());
                    else
                        message.appsToQuery.push(reader.uint32());
                    break;
                case /* optional bool send_path_prefixes */ 2:
                    message.sendPathPrefixes = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSGetFileListForApp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 apps_to_query = 1; */
        for (let i = 0; i < message.appsToQuery.length; i++)
            writer.tag(1, WireType.Varint).uint32(message.appsToQuery[i]);
        /* optional bool send_path_prefixes = 2; */
        if (message.sendPathPrefixes !== undefined)
            writer.tag(2, WireType.Varint).bool(message.sendPathPrefixes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSGetFileListForApp
 */
export const CMsgClientUFSGetFileListForApp = new CMsgClientUFSGetFileListForApp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSGetFileListForAppResponse$Type extends MessageType<CMsgClientUFSGetFileListForAppResponse> {
    constructor() {
        super("CMsgClientUFSGetFileListForAppResponse", [
            { no: 1, name: "files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUFSGetFileListForAppResponse_File },
            { no: 2, name: "path_prefixes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSGetFileListForAppResponse>): CMsgClientUFSGetFileListForAppResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.files = [];
        message.pathPrefixes = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSGetFileListForAppResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSGetFileListForAppResponse): CMsgClientUFSGetFileListForAppResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientUFSGetFileListForAppResponse_File files */ 1:
                    message.files.push(CMsgClientUFSGetFileListForAppResponse_File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string path_prefixes */ 2:
                    message.pathPrefixes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSGetFileListForAppResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientUFSGetFileListForAppResponse_File files = 1; */
        for (let i = 0; i < message.files.length; i++)
            CMsgClientUFSGetFileListForAppResponse_File.internalBinaryWrite(message.files[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string path_prefixes = 2; */
        for (let i = 0; i < message.pathPrefixes.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.pathPrefixes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSGetFileListForAppResponse
 */
export const CMsgClientUFSGetFileListForAppResponse = new CMsgClientUFSGetFileListForAppResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSGetFileListForAppResponse_File$Type extends MessageType<CMsgClientUFSGetFileListForAppResponse_File> {
    constructor() {
        super("CMsgClientUFSGetFileListForAppResponse_File", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "time_stamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "raw_file_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "is_explicit_delete", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "platforms_to_sync", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "path_prefix_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSGetFileListForAppResponse_File>): CMsgClientUFSGetFileListForAppResponse_File {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSGetFileListForAppResponse_File>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSGetFileListForAppResponse_File): CMsgClientUFSGetFileListForAppResponse_File {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional string file_name */ 2:
                    message.fileName = reader.string();
                    break;
                case /* optional bytes sha_file */ 3:
                    message.shaFile = reader.bytes();
                    break;
                case /* optional uint64 time_stamp */ 4:
                    message.timeStamp = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 raw_file_size */ 5:
                    message.rawFileSize = reader.uint32();
                    break;
                case /* optional bool is_explicit_delete */ 6:
                    message.isExplicitDelete = reader.bool();
                    break;
                case /* optional uint32 platforms_to_sync */ 7:
                    message.platformsToSync = reader.uint32();
                    break;
                case /* optional uint32 path_prefix_index */ 8:
                    message.pathPrefixIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSGetFileListForAppResponse_File, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional string file_name = 2; */
        if (message.fileName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        /* optional bytes sha_file = 3; */
        if (message.shaFile !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.shaFile);
        /* optional uint64 time_stamp = 4; */
        if (message.timeStamp !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.timeStamp);
        /* optional uint32 raw_file_size = 5; */
        if (message.rawFileSize !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.rawFileSize);
        /* optional bool is_explicit_delete = 6; */
        if (message.isExplicitDelete !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isExplicitDelete);
        /* optional uint32 platforms_to_sync = 7; */
        if (message.platformsToSync !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.platformsToSync);
        /* optional uint32 path_prefix_index = 8; */
        if (message.pathPrefixIndex !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.pathPrefixIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSGetFileListForAppResponse_File
 */
export const CMsgClientUFSGetFileListForAppResponse_File = new CMsgClientUFSGetFileListForAppResponse_File$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSGetSingleFileInfo$Type extends MessageType<CMsgClientUFSGetSingleFileInfo> {
    constructor() {
        super("CMsgClientUFSGetSingleFileInfo", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSGetSingleFileInfo>): CMsgClientUFSGetSingleFileInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSGetSingleFileInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSGetSingleFileInfo): CMsgClientUFSGetSingleFileInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional string file_name */ 2:
                    message.fileName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSGetSingleFileInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional string file_name = 2; */
        if (message.fileName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSGetSingleFileInfo
 */
export const CMsgClientUFSGetSingleFileInfo = new CMsgClientUFSGetSingleFileInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSGetSingleFileInfoResponse$Type extends MessageType<CMsgClientUFSGetSingleFileInfoResponse> {
    constructor() {
        super("CMsgClientUFSGetSingleFileInfoResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "time_stamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "raw_file_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "is_explicit_delete", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSGetSingleFileInfoResponse>): CMsgClientUFSGetSingleFileInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSGetSingleFileInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSGetSingleFileInfoResponse): CMsgClientUFSGetSingleFileInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional string file_name */ 3:
                    message.fileName = reader.string();
                    break;
                case /* optional bytes sha_file */ 4:
                    message.shaFile = reader.bytes();
                    break;
                case /* optional uint64 time_stamp */ 5:
                    message.timeStamp = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 raw_file_size */ 6:
                    message.rawFileSize = reader.uint32();
                    break;
                case /* optional bool is_explicit_delete */ 7:
                    message.isExplicitDelete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSGetSingleFileInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional string file_name = 3; */
        if (message.fileName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.fileName);
        /* optional bytes sha_file = 4; */
        if (message.shaFile !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.shaFile);
        /* optional uint64 time_stamp = 5; */
        if (message.timeStamp !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.timeStamp);
        /* optional uint32 raw_file_size = 6; */
        if (message.rawFileSize !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.rawFileSize);
        /* optional bool is_explicit_delete = 7; */
        if (message.isExplicitDelete !== undefined)
            writer.tag(7, WireType.Varint).bool(message.isExplicitDelete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSGetSingleFileInfoResponse
 */
export const CMsgClientUFSGetSingleFileInfoResponse = new CMsgClientUFSGetSingleFileInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSGetUGCDetails$Type extends MessageType<CMsgClientUFSGetUGCDetails> {
    constructor() {
        super("CMsgClientUFSGetUGCDetails", [
            { no: 1, name: "hcontent", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSGetUGCDetails>): CMsgClientUFSGetUGCDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSGetUGCDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSGetUGCDetails): CMsgClientUFSGetUGCDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 hcontent = 1 [default = 18446744073709551615] */ 1:
                    message.hcontent = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSGetUGCDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 hcontent = 1 [default = 18446744073709551615]; */
        if (message.hcontent !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.hcontent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSGetUGCDetails
 */
export const CMsgClientUFSGetUGCDetails = new CMsgClientUFSGetUGCDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSGetUGCDetailsResponse$Type extends MessageType<CMsgClientUFSGetUGCDetailsResponse> {
    constructor() {
        super("CMsgClientUFSGetUGCDetailsResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "steamid_creator", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "file_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "compressed_file_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "rangecheck_host", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "file_encoded_sha1", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSGetUGCDetailsResponse>): CMsgClientUFSGetUGCDetailsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSGetUGCDetailsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSGetUGCDetailsResponse): CMsgClientUFSGetUGCDetailsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional string url */ 2:
                    message.url = reader.string();
                    break;
                case /* optional uint32 app_id */ 3:
                    message.appId = reader.uint32();
                    break;
                case /* optional string filename */ 4:
                    message.filename = reader.string();
                    break;
                case /* optional fixed64 steamid_creator */ 5:
                    message.steamidCreator = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 file_size */ 6:
                    message.fileSize = reader.uint32();
                    break;
                case /* optional uint32 compressed_file_size */ 7:
                    message.compressedFileSize = reader.uint32();
                    break;
                case /* optional string rangecheck_host */ 8:
                    message.rangecheckHost = reader.string();
                    break;
                case /* optional string file_encoded_sha1 */ 9:
                    message.fileEncodedSha1 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSGetUGCDetailsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional string url = 2; */
        if (message.url !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* optional uint32 app_id = 3; */
        if (message.appId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.appId);
        /* optional string filename = 4; */
        if (message.filename !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.filename);
        /* optional fixed64 steamid_creator = 5; */
        if (message.steamidCreator !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.steamidCreator);
        /* optional uint32 file_size = 6; */
        if (message.fileSize !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.fileSize);
        /* optional uint32 compressed_file_size = 7; */
        if (message.compressedFileSize !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.compressedFileSize);
        /* optional string rangecheck_host = 8; */
        if (message.rangecheckHost !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.rangecheckHost);
        /* optional string file_encoded_sha1 = 9; */
        if (message.fileEncodedSha1 !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.fileEncodedSha1);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSGetUGCDetailsResponse
 */
export const CMsgClientUFSGetUGCDetailsResponse = new CMsgClientUFSGetUGCDetailsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSLoginRequest$Type extends MessageType<CMsgClientUFSLoginRequest> {
    constructor() {
        super("CMsgClientUFSLoginRequest", [
            { no: 1, name: "protocol_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "am_session_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "apps", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSLoginRequest>): CMsgClientUFSLoginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apps = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSLoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSLoginRequest): CMsgClientUFSLoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 protocol_version */ 1:
                    message.protocolVersion = reader.uint32();
                    break;
                case /* optional uint64 am_session_token */ 2:
                    message.amSessionToken = reader.uint64().toBigInt();
                    break;
                case /* repeated uint32 apps */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.apps.push(reader.uint32());
                    else
                        message.apps.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSLoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 protocol_version = 1; */
        if (message.protocolVersion !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.protocolVersion);
        /* optional uint64 am_session_token = 2; */
        if (message.amSessionToken !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.amSessionToken);
        /* repeated uint32 apps = 3; */
        for (let i = 0; i < message.apps.length; i++)
            writer.tag(3, WireType.Varint).uint32(message.apps[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSLoginRequest
 */
export const CMsgClientUFSLoginRequest = new CMsgClientUFSLoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSLoginResponse$Type extends MessageType<CMsgClientUFSLoginResponse> {
    constructor() {
        super("CMsgClientUFSLoginResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSLoginResponse>): CMsgClientUFSLoginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSLoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSLoginResponse): CMsgClientUFSLoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSLoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSLoginResponse
 */
export const CMsgClientUFSLoginResponse = new CMsgClientUFSLoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSShareFile$Type extends MessageType<CMsgClientUFSShareFile> {
    constructor() {
        super("CMsgClientUFSShareFile", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSShareFile>): CMsgClientUFSShareFile {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSShareFile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSShareFile): CMsgClientUFSShareFile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional string file_name */ 2:
                    message.fileName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSShareFile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional string file_name = 2; */
        if (message.fileName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSShareFile
 */
export const CMsgClientUFSShareFile = new CMsgClientUFSShareFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSShareFileResponse$Type extends MessageType<CMsgClientUFSShareFileResponse> {
    constructor() {
        super("CMsgClientUFSShareFileResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "hcontent", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSShareFileResponse>): CMsgClientUFSShareFileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSShareFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSShareFileResponse): CMsgClientUFSShareFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional fixed64 hcontent = 2 [default = 18446744073709551615] */ 2:
                    message.hcontent = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSShareFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional fixed64 hcontent = 2 [default = 18446744073709551615]; */
        if (message.hcontent !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.hcontent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSShareFileResponse
 */
export const CMsgClientUFSShareFileResponse = new CMsgClientUFSShareFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSTransferHeartbeat$Type extends MessageType<CMsgClientUFSTransferHeartbeat> {
    constructor() {
        super("CMsgClientUFSTransferHeartbeat", []);
    }
    create(value?: PartialMessage<CMsgClientUFSTransferHeartbeat>): CMsgClientUFSTransferHeartbeat {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSTransferHeartbeat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSTransferHeartbeat): CMsgClientUFSTransferHeartbeat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSTransferHeartbeat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSTransferHeartbeat
 */
export const CMsgClientUFSTransferHeartbeat = new CMsgClientUFSTransferHeartbeat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSUploadCommit$Type extends MessageType<CMsgClientUFSUploadCommit> {
    constructor() {
        super("CMsgClientUFSUploadCommit", [
            { no: 1, name: "files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUFSUploadCommit_File }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSUploadCommit>): CMsgClientUFSUploadCommit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.files = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSUploadCommit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSUploadCommit): CMsgClientUFSUploadCommit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientUFSUploadCommit_File files */ 1:
                    message.files.push(CMsgClientUFSUploadCommit_File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSUploadCommit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientUFSUploadCommit_File files = 1; */
        for (let i = 0; i < message.files.length; i++)
            CMsgClientUFSUploadCommit_File.internalBinaryWrite(message.files[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSUploadCommit
 */
export const CMsgClientUFSUploadCommit = new CMsgClientUFSUploadCommit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSUploadCommit_File$Type extends MessageType<CMsgClientUFSUploadCommit_File> {
    constructor() {
        super("CMsgClientUFSUploadCommit_File", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "cub_file", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSUploadCommit_File>): CMsgClientUFSUploadCommit_File {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSUploadCommit_File>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSUploadCommit_File): CMsgClientUFSUploadCommit_File {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional bytes sha_file */ 3:
                    message.shaFile = reader.bytes();
                    break;
                case /* optional uint32 cub_file */ 4:
                    message.cubFile = reader.uint32();
                    break;
                case /* optional string file_name */ 5:
                    message.fileName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSUploadCommit_File, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional bytes sha_file = 3; */
        if (message.shaFile !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.shaFile);
        /* optional uint32 cub_file = 4; */
        if (message.cubFile !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.cubFile);
        /* optional string file_name = 5; */
        if (message.fileName !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.fileName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSUploadCommit_File
 */
export const CMsgClientUFSUploadCommit_File = new CMsgClientUFSUploadCommit_File$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSUploadCommitResponse$Type extends MessageType<CMsgClientUFSUploadCommitResponse> {
    constructor() {
        super("CMsgClientUFSUploadCommitResponse", [
            { no: 1, name: "files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUFSUploadCommitResponse_File }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSUploadCommitResponse>): CMsgClientUFSUploadCommitResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.files = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSUploadCommitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSUploadCommitResponse): CMsgClientUFSUploadCommitResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientUFSUploadCommitResponse_File files */ 1:
                    message.files.push(CMsgClientUFSUploadCommitResponse_File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSUploadCommitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientUFSUploadCommitResponse_File files = 1; */
        for (let i = 0; i < message.files.length; i++)
            CMsgClientUFSUploadCommitResponse_File.internalBinaryWrite(message.files[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSUploadCommitResponse
 */
export const CMsgClientUFSUploadCommitResponse = new CMsgClientUFSUploadCommitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSUploadCommitResponse_File$Type extends MessageType<CMsgClientUFSUploadCommitResponse_File> {
    constructor() {
        super("CMsgClientUFSUploadCommitResponse_File", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSUploadCommitResponse_File>): CMsgClientUFSUploadCommitResponse_File {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSUploadCommitResponse_File>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSUploadCommitResponse_File): CMsgClientUFSUploadCommitResponse_File {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional bytes sha_file */ 3:
                    message.shaFile = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSUploadCommitResponse_File, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional bytes sha_file = 3; */
        if (message.shaFile !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.shaFile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSUploadCommitResponse_File
 */
export const CMsgClientUFSUploadCommitResponse_File = new CMsgClientUFSUploadCommitResponse_File$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSUploadFileFinished$Type extends MessageType<CMsgClientUFSUploadFileFinished> {
    constructor() {
        super("CMsgClientUFSUploadFileFinished", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSUploadFileFinished>): CMsgClientUFSUploadFileFinished {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSUploadFileFinished>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSUploadFileFinished): CMsgClientUFSUploadFileFinished {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional bytes sha_file */ 2:
                    message.shaFile = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSUploadFileFinished, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional bytes sha_file = 2; */
        if (message.shaFile !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.shaFile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSUploadFileFinished
 */
export const CMsgClientUFSUploadFileFinished = new CMsgClientUFSUploadFileFinished$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSUploadFileRequest$Type extends MessageType<CMsgClientUFSUploadFileRequest> {
    constructor() {
        super("CMsgClientUFSUploadFileRequest", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "file_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "raw_file_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "time_stamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "platforms_to_sync_deprecated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "platforms_to_sync", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "can_encrypt", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSUploadFileRequest>): CMsgClientUFSUploadFileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSUploadFileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSUploadFileRequest): CMsgClientUFSUploadFileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 file_size */ 2:
                    message.fileSize = reader.uint32();
                    break;
                case /* optional uint32 raw_file_size */ 3:
                    message.rawFileSize = reader.uint32();
                    break;
                case /* optional bytes sha_file */ 4:
                    message.shaFile = reader.bytes();
                    break;
                case /* optional uint64 time_stamp */ 5:
                    message.timeStamp = reader.uint64().toBigInt();
                    break;
                case /* optional string file_name */ 6:
                    message.fileName = reader.string();
                    break;
                case /* optional uint32 platforms_to_sync_deprecated */ 7:
                    message.platformsToSyncDeprecated = reader.uint32();
                    break;
                case /* optional uint32 platforms_to_sync = 8 [default = 4294967295] */ 8:
                    message.platformsToSync = reader.uint32();
                    break;
                case /* optional uint32 cell_id */ 9:
                    message.cellId = reader.uint32();
                    break;
                case /* optional bool can_encrypt */ 10:
                    message.canEncrypt = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSUploadFileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 file_size = 2; */
        if (message.fileSize !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.fileSize);
        /* optional uint32 raw_file_size = 3; */
        if (message.rawFileSize !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.rawFileSize);
        /* optional bytes sha_file = 4; */
        if (message.shaFile !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.shaFile);
        /* optional uint64 time_stamp = 5; */
        if (message.timeStamp !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.timeStamp);
        /* optional string file_name = 6; */
        if (message.fileName !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.fileName);
        /* optional uint32 platforms_to_sync_deprecated = 7; */
        if (message.platformsToSyncDeprecated !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.platformsToSyncDeprecated);
        /* optional uint32 platforms_to_sync = 8 [default = 4294967295]; */
        if (message.platformsToSync !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.platformsToSync);
        /* optional uint32 cell_id = 9; */
        if (message.cellId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.cellId);
        /* optional bool can_encrypt = 10; */
        if (message.canEncrypt !== undefined)
            writer.tag(10, WireType.Varint).bool(message.canEncrypt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSUploadFileRequest
 */
export const CMsgClientUFSUploadFileRequest = new CMsgClientUFSUploadFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUFSUploadFileResponse$Type extends MessageType<CMsgClientUFSUploadFileResponse> {
    constructor() {
        super("CMsgClientUFSUploadFileResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "use_http", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "http_host", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "http_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "kv_headers", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "use_https", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "encrypt_file", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUFSUploadFileResponse>): CMsgClientUFSUploadFileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUFSUploadFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUFSUploadFileResponse): CMsgClientUFSUploadFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional bytes sha_file */ 2:
                    message.shaFile = reader.bytes();
                    break;
                case /* optional bool use_http */ 3:
                    message.useHttp = reader.bool();
                    break;
                case /* optional string http_host */ 4:
                    message.httpHost = reader.string();
                    break;
                case /* optional string http_url */ 5:
                    message.httpUrl = reader.string();
                    break;
                case /* optional bytes kv_headers */ 6:
                    message.kvHeaders = reader.bytes();
                    break;
                case /* optional bool use_https */ 7:
                    message.useHttps = reader.bool();
                    break;
                case /* optional bool encrypt_file */ 8:
                    message.encryptFile = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUFSUploadFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional bytes sha_file = 2; */
        if (message.shaFile !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.shaFile);
        /* optional bool use_http = 3; */
        if (message.useHttp !== undefined)
            writer.tag(3, WireType.Varint).bool(message.useHttp);
        /* optional string http_host = 4; */
        if (message.httpHost !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.httpHost);
        /* optional string http_url = 5; */
        if (message.httpUrl !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.httpUrl);
        /* optional bytes kv_headers = 6; */
        if (message.kvHeaders !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.kvHeaders);
        /* optional bool use_https = 7; */
        if (message.useHttps !== undefined)
            writer.tag(7, WireType.Varint).bool(message.useHttps);
        /* optional bool encrypt_file = 8; */
        if (message.encryptFile !== undefined)
            writer.tag(8, WireType.Varint).bool(message.encryptFile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUFSUploadFileResponse
 */
export const CMsgClientUFSUploadFileResponse = new CMsgClientUFSUploadFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUGSGetGlobalStats$Type extends MessageType<CMsgClientUGSGetGlobalStats> {
    constructor() {
        super("CMsgClientUGSGetGlobalStats", [
            { no: 1, name: "gameid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "history_days_requested", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "time_last_requested", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "first_day_cached", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "days_cached", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUGSGetGlobalStats>): CMsgClientUGSGetGlobalStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUGSGetGlobalStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUGSGetGlobalStats): CMsgClientUGSGetGlobalStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 gameid */ 1:
                    message.gameid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 history_days_requested */ 2:
                    message.historyDaysRequested = reader.uint32();
                    break;
                case /* optional fixed32 time_last_requested */ 3:
                    message.timeLastRequested = reader.fixed32();
                    break;
                case /* optional uint32 first_day_cached */ 4:
                    message.firstDayCached = reader.uint32();
                    break;
                case /* optional uint32 days_cached */ 5:
                    message.daysCached = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUGSGetGlobalStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 gameid = 1; */
        if (message.gameid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.gameid);
        /* optional uint32 history_days_requested = 2; */
        if (message.historyDaysRequested !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.historyDaysRequested);
        /* optional fixed32 time_last_requested = 3; */
        if (message.timeLastRequested !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.timeLastRequested);
        /* optional uint32 first_day_cached = 4; */
        if (message.firstDayCached !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.firstDayCached);
        /* optional uint32 days_cached = 5; */
        if (message.daysCached !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.daysCached);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUGSGetGlobalStats
 */
export const CMsgClientUGSGetGlobalStats = new CMsgClientUGSGetGlobalStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUGSGetGlobalStatsResponse$Type extends MessageType<CMsgClientUGSGetGlobalStatsResponse> {
    constructor() {
        super("CMsgClientUGSGetGlobalStatsResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "timestamp", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "day_current", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "days", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUGSGetGlobalStatsResponse_Day }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUGSGetGlobalStatsResponse>): CMsgClientUGSGetGlobalStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.days = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUGSGetGlobalStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUGSGetGlobalStatsResponse): CMsgClientUGSGetGlobalStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional fixed32 timestamp */ 2:
                    message.timestamp = reader.fixed32();
                    break;
                case /* optional int32 day_current */ 3:
                    message.dayCurrent = reader.int32();
                    break;
                case /* repeated CMsgClientUGSGetGlobalStatsResponse_Day days */ 4:
                    message.days.push(CMsgClientUGSGetGlobalStatsResponse_Day.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUGSGetGlobalStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional fixed32 timestamp = 2; */
        if (message.timestamp !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.timestamp);
        /* optional int32 day_current = 3; */
        if (message.dayCurrent !== undefined)
            writer.tag(3, WireType.Varint).int32(message.dayCurrent);
        /* repeated CMsgClientUGSGetGlobalStatsResponse_Day days = 4; */
        for (let i = 0; i < message.days.length; i++)
            CMsgClientUGSGetGlobalStatsResponse_Day.internalBinaryWrite(message.days[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUGSGetGlobalStatsResponse
 */
export const CMsgClientUGSGetGlobalStatsResponse = new CMsgClientUGSGetGlobalStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUGSGetGlobalStatsResponse_Day$Type extends MessageType<CMsgClientUGSGetGlobalStatsResponse_Day> {
    constructor() {
        super("CMsgClientUGSGetGlobalStatsResponse_Day", [
            { no: 1, name: "day_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUGSGetGlobalStatsResponse_Day_Stat }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUGSGetGlobalStatsResponse_Day>): CMsgClientUGSGetGlobalStatsResponse_Day {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stats = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUGSGetGlobalStatsResponse_Day>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUGSGetGlobalStatsResponse_Day): CMsgClientUGSGetGlobalStatsResponse_Day {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 day_id */ 1:
                    message.dayId = reader.uint32();
                    break;
                case /* repeated CMsgClientUGSGetGlobalStatsResponse_Day_Stat stats */ 2:
                    message.stats.push(CMsgClientUGSGetGlobalStatsResponse_Day_Stat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUGSGetGlobalStatsResponse_Day, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 day_id = 1; */
        if (message.dayId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.dayId);
        /* repeated CMsgClientUGSGetGlobalStatsResponse_Day_Stat stats = 2; */
        for (let i = 0; i < message.stats.length; i++)
            CMsgClientUGSGetGlobalStatsResponse_Day_Stat.internalBinaryWrite(message.stats[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUGSGetGlobalStatsResponse_Day
 */
export const CMsgClientUGSGetGlobalStatsResponse_Day = new CMsgClientUGSGetGlobalStatsResponse_Day$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUGSGetGlobalStatsResponse_Day_Stat$Type extends MessageType<CMsgClientUGSGetGlobalStatsResponse_Day_Stat> {
    constructor() {
        super("CMsgClientUGSGetGlobalStatsResponse_Day_Stat", [
            { no: 1, name: "stat_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "data", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUGSGetGlobalStatsResponse_Day_Stat>): CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUGSGetGlobalStatsResponse_Day_Stat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUGSGetGlobalStatsResponse_Day_Stat): CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 stat_id */ 1:
                    message.statId = reader.int32();
                    break;
                case /* optional int64 data */ 2:
                    message.data = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUGSGetGlobalStatsResponse_Day_Stat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 stat_id = 1; */
        if (message.statId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.statId);
        /* optional int64 data = 2; */
        if (message.data !== undefined)
            writer.tag(2, WireType.Varint).int64(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUGSGetGlobalStatsResponse_Day_Stat
 */
export const CMsgClientUGSGetGlobalStatsResponse_Day_Stat = new CMsgClientUGSGetGlobalStatsResponse_Day_Stat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUIMode$Type extends MessageType<CMsgClientUIMode> {
    constructor() {
        super("CMsgClientUIMode", [
            { no: 1, name: "uimode", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "chat_mode", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUIMode>): CMsgClientUIMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUIMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUIMode): CMsgClientUIMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 uimode */ 1:
                    message.uimode = reader.uint32();
                    break;
                case /* optional uint32 chat_mode */ 2:
                    message.chatMode = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUIMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 uimode = 1; */
        if (message.uimode !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.uimode);
        /* optional uint32 chat_mode = 2; */
        if (message.chatMode !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.chatMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUIMode
 */
export const CMsgClientUIMode = new CMsgClientUIMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUninstallClientApp$Type extends MessageType<CMsgClientUninstallClientApp> {
    constructor() {
        super("CMsgClientUninstallClientApp", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUninstallClientApp>): CMsgClientUninstallClientApp {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUninstallClientApp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUninstallClientApp): CMsgClientUninstallClientApp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUninstallClientApp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUninstallClientApp
 */
export const CMsgClientUninstallClientApp = new CMsgClientUninstallClientApp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUninstallClientAppResponse$Type extends MessageType<CMsgClientUninstallClientAppResponse> {
    constructor() {
        super("CMsgClientUninstallClientAppResponse", [
            { no: 1, name: "result", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUninstallClientAppResponse>): CMsgClientUninstallClientAppResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUninstallClientAppResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUninstallClientAppResponse): CMsgClientUninstallClientAppResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 result */ 1:
                    message.result = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUninstallClientAppResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 result = 1; */
        if (message.result !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUninstallClientAppResponse
 */
export const CMsgClientUninstallClientAppResponse = new CMsgClientUninstallClientAppResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUnsignedInstallScript$Type extends MessageType<CMsgClientUnsignedInstallScript> {
    constructor() {
        super("CMsgClientUnsignedInstallScript", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "file_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "signature_broken", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "depot_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "manifest_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "file_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUnsignedInstallScript>): CMsgClientUnsignedInstallScript {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUnsignedInstallScript>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUnsignedInstallScript): CMsgClientUnsignedInstallScript {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional string file_name */ 2:
                    message.fileName = reader.string();
                    break;
                case /* optional uint32 file_size */ 3:
                    message.fileSize = reader.uint32();
                    break;
                case /* optional bool signature_broken */ 4:
                    message.signatureBroken = reader.bool();
                    break;
                case /* optional uint32 depot_id */ 5:
                    message.depotId = reader.uint32();
                    break;
                case /* optional uint64 manifest_id */ 6:
                    message.manifestId = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 file_flags */ 7:
                    message.fileFlags = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUnsignedInstallScript, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional string file_name = 2; */
        if (message.fileName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        /* optional uint32 file_size = 3; */
        if (message.fileSize !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.fileSize);
        /* optional bool signature_broken = 4; */
        if (message.signatureBroken !== undefined)
            writer.tag(4, WireType.Varint).bool(message.signatureBroken);
        /* optional uint32 depot_id = 5; */
        if (message.depotId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.depotId);
        /* optional uint64 manifest_id = 6; */
        if (message.manifestId !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.manifestId);
        /* optional uint32 file_flags = 7; */
        if (message.fileFlags !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.fileFlags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUnsignedInstallScript
 */
export const CMsgClientUnsignedInstallScript = new CMsgClientUnsignedInstallScript$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUpdateAppJobReport$Type extends MessageType<CMsgClientUpdateAppJobReport> {
    constructor() {
        super("CMsgClientUpdateAppJobReport", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "depot_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "app_state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "job_app_error", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "error_details", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "job_duration", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "files_validation_failed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "job_bytes_downloaded", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "job_bytes_staged", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "bytes_comitted", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "start_app_state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "stats_machine_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "branch_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "total_bytes_downloaded", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "total_bytes_staged", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "total_bytes_restored", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "is_borrowed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "is_free_weekend", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "total_bytes_legacy", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "total_bytes_patched", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "total_bytes_saved", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 22, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUpdateAppJobReport>): CMsgClientUpdateAppJobReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.depotIds = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUpdateAppJobReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUpdateAppJobReport): CMsgClientUpdateAppJobReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* repeated uint32 depot_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.depotIds.push(reader.uint32());
                    else
                        message.depotIds.push(reader.uint32());
                    break;
                case /* optional uint32 app_state */ 3:
                    message.appState = reader.uint32();
                    break;
                case /* optional uint32 job_app_error */ 4:
                    message.jobAppError = reader.uint32();
                    break;
                case /* optional string error_details */ 5:
                    message.errorDetails = reader.string();
                    break;
                case /* optional uint32 job_duration */ 6:
                    message.jobDuration = reader.uint32();
                    break;
                case /* optional uint32 files_validation_failed */ 7:
                    message.filesValidationFailed = reader.uint32();
                    break;
                case /* optional uint64 job_bytes_downloaded */ 8:
                    message.jobBytesDownloaded = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 job_bytes_staged */ 9:
                    message.jobBytesStaged = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes_comitted */ 10:
                    message.bytesComitted = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 start_app_state */ 11:
                    message.startAppState = reader.uint32();
                    break;
                case /* optional fixed64 stats_machine_id */ 12:
                    message.statsMachineId = reader.fixed64().toBigInt();
                    break;
                case /* optional string branch_name */ 13:
                    message.branchName = reader.string();
                    break;
                case /* optional uint64 total_bytes_downloaded */ 14:
                    message.totalBytesDownloaded = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 total_bytes_staged */ 15:
                    message.totalBytesStaged = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 total_bytes_restored */ 16:
                    message.totalBytesRestored = reader.uint64().toBigInt();
                    break;
                case /* optional bool is_borrowed */ 17:
                    message.isBorrowed = reader.bool();
                    break;
                case /* optional bool is_free_weekend */ 18:
                    message.isFreeWeekend = reader.bool();
                    break;
                case /* optional uint64 total_bytes_legacy */ 19:
                    message.totalBytesLegacy = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 total_bytes_patched */ 20:
                    message.totalBytesPatched = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 total_bytes_saved */ 21:
                    message.totalBytesSaved = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 cell_id */ 22:
                    message.cellId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUpdateAppJobReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* repeated uint32 depot_ids = 2; */
        for (let i = 0; i < message.depotIds.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.depotIds[i]);
        /* optional uint32 app_state = 3; */
        if (message.appState !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.appState);
        /* optional uint32 job_app_error = 4; */
        if (message.jobAppError !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.jobAppError);
        /* optional string error_details = 5; */
        if (message.errorDetails !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.errorDetails);
        /* optional uint32 job_duration = 6; */
        if (message.jobDuration !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.jobDuration);
        /* optional uint32 files_validation_failed = 7; */
        if (message.filesValidationFailed !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.filesValidationFailed);
        /* optional uint64 job_bytes_downloaded = 8; */
        if (message.jobBytesDownloaded !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.jobBytesDownloaded);
        /* optional uint64 job_bytes_staged = 9; */
        if (message.jobBytesStaged !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.jobBytesStaged);
        /* optional uint64 bytes_comitted = 10; */
        if (message.bytesComitted !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.bytesComitted);
        /* optional uint32 start_app_state = 11; */
        if (message.startAppState !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.startAppState);
        /* optional fixed64 stats_machine_id = 12; */
        if (message.statsMachineId !== undefined)
            writer.tag(12, WireType.Bit64).fixed64(message.statsMachineId);
        /* optional string branch_name = 13; */
        if (message.branchName !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.branchName);
        /* optional uint64 total_bytes_downloaded = 14; */
        if (message.totalBytesDownloaded !== undefined)
            writer.tag(14, WireType.Varint).uint64(message.totalBytesDownloaded);
        /* optional uint64 total_bytes_staged = 15; */
        if (message.totalBytesStaged !== undefined)
            writer.tag(15, WireType.Varint).uint64(message.totalBytesStaged);
        /* optional uint64 total_bytes_restored = 16; */
        if (message.totalBytesRestored !== undefined)
            writer.tag(16, WireType.Varint).uint64(message.totalBytesRestored);
        /* optional bool is_borrowed = 17; */
        if (message.isBorrowed !== undefined)
            writer.tag(17, WireType.Varint).bool(message.isBorrowed);
        /* optional bool is_free_weekend = 18; */
        if (message.isFreeWeekend !== undefined)
            writer.tag(18, WireType.Varint).bool(message.isFreeWeekend);
        /* optional uint64 total_bytes_legacy = 19; */
        if (message.totalBytesLegacy !== undefined)
            writer.tag(19, WireType.Varint).uint64(message.totalBytesLegacy);
        /* optional uint64 total_bytes_patched = 20; */
        if (message.totalBytesPatched !== undefined)
            writer.tag(20, WireType.Varint).uint64(message.totalBytesPatched);
        /* optional uint64 total_bytes_saved = 21; */
        if (message.totalBytesSaved !== undefined)
            writer.tag(21, WireType.Varint).uint64(message.totalBytesSaved);
        /* optional uint32 cell_id = 22; */
        if (message.cellId !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.cellId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUpdateAppJobReport
 */
export const CMsgClientUpdateAppJobReport = new CMsgClientUpdateAppJobReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUpdateMachineAuth$Type extends MessageType<CMsgClientUpdateMachineAuth> {
    constructor() {
        super("CMsgClientUpdateMachineAuth", [
            { no: 1, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "offset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cubtowrite", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "bytes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "otp_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "otp_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "otp_sharedsecret", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "otp_timedrift", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUpdateMachineAuth>): CMsgClientUpdateMachineAuth {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUpdateMachineAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUpdateMachineAuth): CMsgClientUpdateMachineAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string filename */ 1:
                    message.filename = reader.string();
                    break;
                case /* optional uint32 offset */ 2:
                    message.offset = reader.uint32();
                    break;
                case /* optional uint32 cubtowrite */ 3:
                    message.cubtowrite = reader.uint32();
                    break;
                case /* optional bytes bytes */ 4:
                    message.bytes = reader.bytes();
                    break;
                case /* optional uint32 otp_type */ 5:
                    message.otpType = reader.uint32();
                    break;
                case /* optional string otp_identifier */ 6:
                    message.otpIdentifier = reader.string();
                    break;
                case /* optional bytes otp_sharedsecret */ 7:
                    message.otpSharedsecret = reader.bytes();
                    break;
                case /* optional uint32 otp_timedrift */ 8:
                    message.otpTimedrift = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUpdateMachineAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string filename = 1; */
        if (message.filename !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.filename);
        /* optional uint32 offset = 2; */
        if (message.offset !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.offset);
        /* optional uint32 cubtowrite = 3; */
        if (message.cubtowrite !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.cubtowrite);
        /* optional bytes bytes = 4; */
        if (message.bytes !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.bytes);
        /* optional uint32 otp_type = 5; */
        if (message.otpType !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.otpType);
        /* optional string otp_identifier = 6; */
        if (message.otpIdentifier !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.otpIdentifier);
        /* optional bytes otp_sharedsecret = 7; */
        if (message.otpSharedsecret !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.otpSharedsecret);
        /* optional uint32 otp_timedrift = 8; */
        if (message.otpTimedrift !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.otpTimedrift);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUpdateMachineAuth
 */
export const CMsgClientUpdateMachineAuth = new CMsgClientUpdateMachineAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUpdateMachineAuthResponse$Type extends MessageType<CMsgClientUpdateMachineAuthResponse> {
    constructor() {
        super("CMsgClientUpdateMachineAuthResponse", [
            { no: 1, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "filesize", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "sha_file", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "getlasterror", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "offset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "cubwrote", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "otp_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "otp_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "otp_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUpdateMachineAuthResponse>): CMsgClientUpdateMachineAuthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUpdateMachineAuthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUpdateMachineAuthResponse): CMsgClientUpdateMachineAuthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string filename */ 1:
                    message.filename = reader.string();
                    break;
                case /* optional uint32 eresult */ 2:
                    message.eresult = reader.uint32();
                    break;
                case /* optional uint32 filesize */ 3:
                    message.filesize = reader.uint32();
                    break;
                case /* optional bytes sha_file */ 4:
                    message.shaFile = reader.bytes();
                    break;
                case /* optional uint32 getlasterror */ 5:
                    message.getlasterror = reader.uint32();
                    break;
                case /* optional uint32 offset */ 6:
                    message.offset = reader.uint32();
                    break;
                case /* optional uint32 cubwrote */ 7:
                    message.cubwrote = reader.uint32();
                    break;
                case /* optional int32 otp_type */ 8:
                    message.otpType = reader.int32();
                    break;
                case /* optional uint32 otp_value */ 9:
                    message.otpValue = reader.uint32();
                    break;
                case /* optional string otp_identifier */ 10:
                    message.otpIdentifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUpdateMachineAuthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string filename = 1; */
        if (message.filename !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.filename);
        /* optional uint32 eresult = 2; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eresult);
        /* optional uint32 filesize = 3; */
        if (message.filesize !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.filesize);
        /* optional bytes sha_file = 4; */
        if (message.shaFile !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.shaFile);
        /* optional uint32 getlasterror = 5; */
        if (message.getlasterror !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.getlasterror);
        /* optional uint32 offset = 6; */
        if (message.offset !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.offset);
        /* optional uint32 cubwrote = 7; */
        if (message.cubwrote !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.cubwrote);
        /* optional int32 otp_type = 8; */
        if (message.otpType !== undefined)
            writer.tag(8, WireType.Varint).int32(message.otpType);
        /* optional uint32 otp_value = 9; */
        if (message.otpValue !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.otpValue);
        /* optional string otp_identifier = 10; */
        if (message.otpIdentifier !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.otpIdentifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUpdateMachineAuthResponse
 */
export const CMsgClientUpdateMachineAuthResponse = new CMsgClientUpdateMachineAuthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUpdateUserGameInfo$Type extends MessageType<CMsgClientUpdateUserGameInfo> {
    constructor() {
        super("CMsgClientUpdateUserGameInfo", [
            { no: 1, name: "steamid_idgs", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "gameid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "game_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "game_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUpdateUserGameInfo>): CMsgClientUpdateUserGameInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUpdateUserGameInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUpdateUserGameInfo): CMsgClientUpdateUserGameInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_idgs */ 1:
                    message.steamidIdgs = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 gameid */ 2:
                    message.gameid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 game_ip */ 3:
                    message.gameIp = reader.uint32();
                    break;
                case /* optional uint32 game_port */ 4:
                    message.gamePort = reader.uint32();
                    break;
                case /* optional bytes token */ 5:
                    message.token = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUpdateUserGameInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_idgs = 1; */
        if (message.steamidIdgs !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidIdgs);
        /* optional fixed64 gameid = 2; */
        if (message.gameid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.gameid);
        /* optional uint32 game_ip = 3; */
        if (message.gameIp !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.gameIp);
        /* optional uint32 game_port = 4; */
        if (message.gamePort !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.gamePort);
        /* optional bytes token = 5; */
        if (message.token !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUpdateUserGameInfo
 */
export const CMsgClientUpdateUserGameInfo = new CMsgClientUpdateUserGameInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUseLocalDeviceAuthorizations$Type extends MessageType<CMsgClientUseLocalDeviceAuthorizations> {
    constructor() {
        super("CMsgClientUseLocalDeviceAuthorizations", [
            { no: 1, name: "authorization_account_id", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "device_tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUseLocalDeviceAuthorizations_DeviceToken }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUseLocalDeviceAuthorizations>): CMsgClientUseLocalDeviceAuthorizations {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorizationAccountId = [];
        message.deviceTokens = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUseLocalDeviceAuthorizations>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUseLocalDeviceAuthorizations): CMsgClientUseLocalDeviceAuthorizations {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 authorization_account_id */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.authorizationAccountId.push(reader.uint32());
                    else
                        message.authorizationAccountId.push(reader.uint32());
                    break;
                case /* repeated CMsgClientUseLocalDeviceAuthorizations_DeviceToken device_tokens */ 2:
                    message.deviceTokens.push(CMsgClientUseLocalDeviceAuthorizations_DeviceToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUseLocalDeviceAuthorizations, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 authorization_account_id = 1; */
        for (let i = 0; i < message.authorizationAccountId.length; i++)
            writer.tag(1, WireType.Varint).uint32(message.authorizationAccountId[i]);
        /* repeated CMsgClientUseLocalDeviceAuthorizations_DeviceToken device_tokens = 2; */
        for (let i = 0; i < message.deviceTokens.length; i++)
            CMsgClientUseLocalDeviceAuthorizations_DeviceToken.internalBinaryWrite(message.deviceTokens[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUseLocalDeviceAuthorizations
 */
export const CMsgClientUseLocalDeviceAuthorizations = new CMsgClientUseLocalDeviceAuthorizations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUseLocalDeviceAuthorizations_DeviceToken$Type extends MessageType<CMsgClientUseLocalDeviceAuthorizations_DeviceToken> {
    constructor() {
        super("CMsgClientUseLocalDeviceAuthorizations_DeviceToken", [
            { no: 1, name: "owner_account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "token_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUseLocalDeviceAuthorizations_DeviceToken>): CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUseLocalDeviceAuthorizations_DeviceToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUseLocalDeviceAuthorizations_DeviceToken): CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 owner_account_id */ 1:
                    message.ownerAccountId = reader.uint32();
                    break;
                case /* optional uint64 token_id */ 2:
                    message.tokenId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUseLocalDeviceAuthorizations_DeviceToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 owner_account_id = 1; */
        if (message.ownerAccountId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.ownerAccountId);
        /* optional uint64 token_id = 2; */
        if (message.tokenId !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.tokenId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUseLocalDeviceAuthorizations_DeviceToken
 */
export const CMsgClientUseLocalDeviceAuthorizations_DeviceToken = new CMsgClientUseLocalDeviceAuthorizations_DeviceToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUserNotifications$Type extends MessageType<CMsgClientUserNotifications> {
    constructor() {
        super("CMsgClientUserNotifications", [
            { no: 1, name: "notifications", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientUserNotifications_Notification }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUserNotifications>): CMsgClientUserNotifications {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.notifications = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUserNotifications>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUserNotifications): CMsgClientUserNotifications {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgClientUserNotifications_Notification notifications */ 1:
                    message.notifications.push(CMsgClientUserNotifications_Notification.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUserNotifications, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgClientUserNotifications_Notification notifications = 1; */
        for (let i = 0; i < message.notifications.length; i++)
            CMsgClientUserNotifications_Notification.internalBinaryWrite(message.notifications[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUserNotifications
 */
export const CMsgClientUserNotifications = new CMsgClientUserNotifications$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientUserNotifications_Notification$Type extends MessageType<CMsgClientUserNotifications_Notification> {
    constructor() {
        super("CMsgClientUserNotifications_Notification", [
            { no: 1, name: "user_notification_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientUserNotifications_Notification>): CMsgClientUserNotifications_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientUserNotifications_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientUserNotifications_Notification): CMsgClientUserNotifications_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 user_notification_type */ 1:
                    message.userNotificationType = reader.uint32();
                    break;
                case /* optional uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientUserNotifications_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 user_notification_type = 1; */
        if (message.userNotificationType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.userNotificationType);
        /* optional uint32 count = 2; */
        if (message.count !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientUserNotifications_Notification
 */
export const CMsgClientUserNotifications_Notification = new CMsgClientUserNotifications_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientVanityURLChangedNotification$Type extends MessageType<CMsgClientVanityURLChangedNotification> {
    constructor() {
        super("CMsgClientVanityURLChangedNotification", [
            { no: 1, name: "vanity_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientVanityURLChangedNotification>): CMsgClientVanityURLChangedNotification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientVanityURLChangedNotification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientVanityURLChangedNotification): CMsgClientVanityURLChangedNotification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string vanity_url */ 1:
                    message.vanityUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientVanityURLChangedNotification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string vanity_url = 1; */
        if (message.vanityUrl !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.vanityUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientVanityURLChangedNotification
 */
export const CMsgClientVanityURLChangedNotification = new CMsgClientVanityURLChangedNotification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientVoiceCallPreAuthorize$Type extends MessageType<CMsgClientVoiceCallPreAuthorize> {
    constructor() {
        super("CMsgClientVoiceCallPreAuthorize", [
            { no: 1, name: "caller_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "receiver_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "caller_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "hangup", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientVoiceCallPreAuthorize>): CMsgClientVoiceCallPreAuthorize {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientVoiceCallPreAuthorize>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientVoiceCallPreAuthorize): CMsgClientVoiceCallPreAuthorize {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 caller_steamid */ 1:
                    message.callerSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 receiver_steamid */ 2:
                    message.receiverSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 caller_id */ 3:
                    message.callerId = reader.int32();
                    break;
                case /* optional bool hangup */ 4:
                    message.hangup = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientVoiceCallPreAuthorize, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 caller_steamid = 1; */
        if (message.callerSteamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.callerSteamid);
        /* optional fixed64 receiver_steamid = 2; */
        if (message.receiverSteamid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.receiverSteamid);
        /* optional int32 caller_id = 3; */
        if (message.callerId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.callerId);
        /* optional bool hangup = 4; */
        if (message.hangup !== undefined)
            writer.tag(4, WireType.Varint).bool(message.hangup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientVoiceCallPreAuthorize
 */
export const CMsgClientVoiceCallPreAuthorize = new CMsgClientVoiceCallPreAuthorize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientVoiceCallPreAuthorizeResponse$Type extends MessageType<CMsgClientVoiceCallPreAuthorizeResponse> {
    constructor() {
        super("CMsgClientVoiceCallPreAuthorizeResponse", [
            { no: 1, name: "caller_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "receiver_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "caller_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientVoiceCallPreAuthorizeResponse>): CMsgClientVoiceCallPreAuthorizeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientVoiceCallPreAuthorizeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientVoiceCallPreAuthorizeResponse): CMsgClientVoiceCallPreAuthorizeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 caller_steamid */ 1:
                    message.callerSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 receiver_steamid */ 2:
                    message.receiverSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 eresult = 3 [default = 2] */ 3:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 caller_id */ 4:
                    message.callerId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientVoiceCallPreAuthorizeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 caller_steamid = 1; */
        if (message.callerSteamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.callerSteamid);
        /* optional fixed64 receiver_steamid = 2; */
        if (message.receiverSteamid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.receiverSteamid);
        /* optional int32 eresult = 3 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(3, WireType.Varint).int32(message.eresult);
        /* optional int32 caller_id = 4; */
        if (message.callerId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.callerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientVoiceCallPreAuthorizeResponse
 */
export const CMsgClientVoiceCallPreAuthorizeResponse = new CMsgClientVoiceCallPreAuthorizeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWalletInfoUpdate$Type extends MessageType<CMsgClientWalletInfoUpdate> {
    constructor() {
        super("CMsgClientWalletInfoUpdate", [
            { no: 1, name: "has_wallet", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "balance", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "currency", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "balance_delayed", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "balance64", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "balance64_delayed", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientWalletInfoUpdate>): CMsgClientWalletInfoUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientWalletInfoUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientWalletInfoUpdate): CMsgClientWalletInfoUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool has_wallet */ 1:
                    message.hasWallet = reader.bool();
                    break;
                case /* optional int32 balance */ 2:
                    message.balance = reader.int32();
                    break;
                case /* optional int32 currency */ 3:
                    message.currency = reader.int32();
                    break;
                case /* optional int32 balance_delayed */ 4:
                    message.balanceDelayed = reader.int32();
                    break;
                case /* optional int64 balance64 */ 5:
                    message.balance64 = reader.int64().toBigInt();
                    break;
                case /* optional int64 balance64_delayed */ 6:
                    message.balance64Delayed = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientWalletInfoUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool has_wallet = 1; */
        if (message.hasWallet !== undefined)
            writer.tag(1, WireType.Varint).bool(message.hasWallet);
        /* optional int32 balance = 2; */
        if (message.balance !== undefined)
            writer.tag(2, WireType.Varint).int32(message.balance);
        /* optional int32 currency = 3; */
        if (message.currency !== undefined)
            writer.tag(3, WireType.Varint).int32(message.currency);
        /* optional int32 balance_delayed = 4; */
        if (message.balanceDelayed !== undefined)
            writer.tag(4, WireType.Varint).int32(message.balanceDelayed);
        /* optional int64 balance64 = 5; */
        if (message.balance64 !== undefined)
            writer.tag(5, WireType.Varint).int64(message.balance64);
        /* optional int64 balance64_delayed = 6; */
        if (message.balance64Delayed !== undefined)
            writer.tag(6, WireType.Varint).int64(message.balance64Delayed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientWalletInfoUpdate
 */
export const CMsgClientWalletInfoUpdate = new CMsgClientWalletInfoUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWorkshopItemChangesRequest$Type extends MessageType<CMsgClientWorkshopItemChangesRequest> {
    constructor() {
        super("CMsgClientWorkshopItemChangesRequest", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "last_time_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "num_items_needed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientWorkshopItemChangesRequest>): CMsgClientWorkshopItemChangesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientWorkshopItemChangesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientWorkshopItemChangesRequest): CMsgClientWorkshopItemChangesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 last_time_updated */ 2:
                    message.lastTimeUpdated = reader.uint32();
                    break;
                case /* optional uint32 num_items_needed */ 3:
                    message.numItemsNeeded = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientWorkshopItemChangesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 last_time_updated = 2; */
        if (message.lastTimeUpdated !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.lastTimeUpdated);
        /* optional uint32 num_items_needed = 3; */
        if (message.numItemsNeeded !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.numItemsNeeded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientWorkshopItemChangesRequest
 */
export const CMsgClientWorkshopItemChangesRequest = new CMsgClientWorkshopItemChangesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWorkshopItemChangesResponse$Type extends MessageType<CMsgClientWorkshopItemChangesResponse> {
    constructor() {
        super("CMsgClientWorkshopItemChangesResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "update_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "workshop_items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo }
        ]);
    }
    create(value?: PartialMessage<CMsgClientWorkshopItemChangesResponse>): CMsgClientWorkshopItemChangesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workshopItems = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientWorkshopItemChangesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientWorkshopItemChangesResponse): CMsgClientWorkshopItemChangesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 update_time */ 2:
                    message.updateTime = reader.uint32();
                    break;
                case /* repeated CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo workshop_items */ 5:
                    message.workshopItems.push(CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientWorkshopItemChangesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional uint32 update_time = 2; */
        if (message.updateTime !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.updateTime);
        /* repeated CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo workshop_items = 5; */
        for (let i = 0; i < message.workshopItems.length; i++)
            CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo.internalBinaryWrite(message.workshopItems[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientWorkshopItemChangesResponse
 */
export const CMsgClientWorkshopItemChangesResponse = new CMsgClientWorkshopItemChangesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo$Type extends MessageType<CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo> {
    constructor() {
        super("CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "time_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "manifest_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo>): CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo): CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 time_updated */ 2:
                    message.timeUpdated = reader.uint32();
                    break;
                case /* optional fixed64 manifest_id */ 3:
                    message.manifestId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional uint32 time_updated = 2; */
        if (message.timeUpdated !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.timeUpdated);
        /* optional fixed64 manifest_id = 3; */
        if (message.manifestId !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.manifestId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo
 */
export const CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo = new CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWorkshopItemInfoRequest$Type extends MessageType<CMsgClientWorkshopItemInfoRequest> {
    constructor() {
        super("CMsgClientWorkshopItemInfoRequest", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "last_time_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "workshop_items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientWorkshopItemInfoRequest_WorkshopItem }
        ]);
    }
    create(value?: PartialMessage<CMsgClientWorkshopItemInfoRequest>): CMsgClientWorkshopItemInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workshopItems = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientWorkshopItemInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientWorkshopItemInfoRequest): CMsgClientWorkshopItemInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 last_time_updated */ 2:
                    message.lastTimeUpdated = reader.uint32();
                    break;
                case /* repeated CMsgClientWorkshopItemInfoRequest_WorkshopItem workshop_items */ 3:
                    message.workshopItems.push(CMsgClientWorkshopItemInfoRequest_WorkshopItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientWorkshopItemInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 last_time_updated = 2; */
        if (message.lastTimeUpdated !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.lastTimeUpdated);
        /* repeated CMsgClientWorkshopItemInfoRequest_WorkshopItem workshop_items = 3; */
        for (let i = 0; i < message.workshopItems.length; i++)
            CMsgClientWorkshopItemInfoRequest_WorkshopItem.internalBinaryWrite(message.workshopItems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientWorkshopItemInfoRequest
 */
export const CMsgClientWorkshopItemInfoRequest = new CMsgClientWorkshopItemInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWorkshopItemInfoRequest_WorkshopItem$Type extends MessageType<CMsgClientWorkshopItemInfoRequest_WorkshopItem> {
    constructor() {
        super("CMsgClientWorkshopItemInfoRequest_WorkshopItem", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "time_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientWorkshopItemInfoRequest_WorkshopItem>): CMsgClientWorkshopItemInfoRequest_WorkshopItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientWorkshopItemInfoRequest_WorkshopItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientWorkshopItemInfoRequest_WorkshopItem): CMsgClientWorkshopItemInfoRequest_WorkshopItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 time_updated */ 2:
                    message.timeUpdated = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientWorkshopItemInfoRequest_WorkshopItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional uint32 time_updated = 2; */
        if (message.timeUpdated !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.timeUpdated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientWorkshopItemInfoRequest_WorkshopItem
 */
export const CMsgClientWorkshopItemInfoRequest_WorkshopItem = new CMsgClientWorkshopItemInfoRequest_WorkshopItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWorkshopItemInfoResponse$Type extends MessageType<CMsgClientWorkshopItemInfoResponse> {
    constructor() {
        super("CMsgClientWorkshopItemInfoResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "update_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "workshop_items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo },
            { no: 4, name: "private_items", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientWorkshopItemInfoResponse>): CMsgClientWorkshopItemInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workshopItems = [];
        message.privateItems = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientWorkshopItemInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientWorkshopItemInfoResponse): CMsgClientWorkshopItemInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional uint32 update_time */ 2:
                    message.updateTime = reader.uint32();
                    break;
                case /* repeated CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo workshop_items */ 3:
                    message.workshopItems.push(CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated fixed64 private_items */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.privateItems.push(reader.fixed64().toBigInt());
                    else
                        message.privateItems.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientWorkshopItemInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional uint32 update_time = 2; */
        if (message.updateTime !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.updateTime);
        /* repeated CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo workshop_items = 3; */
        for (let i = 0; i < message.workshopItems.length; i++)
            CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo.internalBinaryWrite(message.workshopItems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated fixed64 private_items = 4; */
        for (let i = 0; i < message.privateItems.length; i++)
            writer.tag(4, WireType.Bit64).fixed64(message.privateItems[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientWorkshopItemInfoResponse
 */
export const CMsgClientWorkshopItemInfoResponse = new CMsgClientWorkshopItemInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo$Type extends MessageType<CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo> {
    constructor() {
        super("CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "time_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "manifest_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "is_legacy", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo>): CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo): CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 time_updated */ 2:
                    message.timeUpdated = reader.uint32();
                    break;
                case /* optional fixed64 manifest_id */ 3:
                    message.manifestId = reader.fixed64().toBigInt();
                    break;
                case /* optional bool is_legacy */ 4:
                    message.isLegacy = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional uint32 time_updated = 2; */
        if (message.timeUpdated !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.timeUpdated);
        /* optional fixed64 manifest_id = 3; */
        if (message.manifestId !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.manifestId);
        /* optional bool is_legacy = 4; */
        if (message.isLegacy !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isLegacy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo
 */
export const CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo = new CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCloudPendingRemoteOperations$Type extends MessageType<CMsgCloudPendingRemoteOperations> {
    constructor() {
        super("CMsgCloudPendingRemoteOperations", [
            { no: 1, name: "operations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CCloud_PendingRemoteOperation }
        ]);
    }
    create(value?: PartialMessage<CMsgCloudPendingRemoteOperations>): CMsgCloudPendingRemoteOperations {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operations = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgCloudPendingRemoteOperations>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCloudPendingRemoteOperations): CMsgCloudPendingRemoteOperations {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CCloud_PendingRemoteOperation operations */ 1:
                    message.operations.push(CCloud_PendingRemoteOperation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCloudPendingRemoteOperations, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CCloud_PendingRemoteOperation operations = 1; */
        for (let i = 0; i < message.operations.length; i++)
            CCloud_PendingRemoteOperation.internalBinaryWrite(message.operations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCloudPendingRemoteOperations
 */
export const CMsgCloudPendingRemoteOperations = new CMsgCloudPendingRemoteOperations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerActionSetMiscSettings$Type extends MessageType<CMsgControllerActionSetMiscSettings> {
    constructor() {
        super("CMsgControllerActionSetMiscSettings", [
            { no: 1, name: "cursor_visible_action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cursor_hidden_action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerActionSetMiscSettings>): CMsgControllerActionSetMiscSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerActionSetMiscSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerActionSetMiscSettings): CMsgControllerActionSetMiscSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string cursor_visible_action_set_key */ 1:
                    message.cursorVisibleActionSetKey = reader.string();
                    break;
                case /* optional string cursor_hidden_action_set_key */ 2:
                    message.cursorHiddenActionSetKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerActionSetMiscSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string cursor_visible_action_set_key = 1; */
        if (message.cursorVisibleActionSetKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.cursorVisibleActionSetKey);
        /* optional string cursor_hidden_action_set_key = 2; */
        if (message.cursorHiddenActionSetKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.cursorHiddenActionSetKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerActionSetMiscSettings
 */
export const CMsgControllerActionSetMiscSettings = new CMsgControllerActionSetMiscSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerConfiguration$Type extends MessageType<CMsgControllerConfiguration> {
    constructor() {
        super("CMsgControllerConfiguration", [
            { no: 1, name: "binding_handle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "creator", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "controller_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "capability_bits", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "controller_style", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "sets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGameActionSet },
            { no: 9, name: "modes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgControllerMode },
            { no: 10, name: "error_msg", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "action_block_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "misc_action_set_settings", kind: "message", T: () => CMsgControllerActionSetMiscSettings },
            { no: 13, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerConfiguration>): CMsgControllerConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sets = [];
        message.modes = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerConfiguration): CMsgControllerConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 binding_handle */ 1:
                    message.bindingHandle = reader.uint32();
                    break;
                case /* optional string display_name */ 2:
                    message.displayName = reader.string();
                    break;
                case /* optional string description */ 3:
                    message.description = reader.string();
                    break;
                case /* optional string creator */ 4:
                    message.creator = reader.string();
                    break;
                case /* optional int32 controller_type */ 5:
                    message.controllerType = reader.int32();
                    break;
                case /* optional string capability_bits */ 6:
                    message.capabilityBits = reader.string();
                    break;
                case /* optional int32 controller_style */ 7:
                    message.controllerStyle = reader.int32();
                    break;
                case /* repeated CMsgGameActionSet sets */ 8:
                    message.sets.push(CMsgGameActionSet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgControllerMode modes */ 9:
                    message.modes.push(CMsgControllerMode.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string error_msg */ 10:
                    message.errorMsg = reader.string();
                    break;
                case /* optional string action_block_path */ 11:
                    message.actionBlockPath = reader.string();
                    break;
                case /* optional CMsgControllerActionSetMiscSettings misc_action_set_settings */ 12:
                    message.miscActionSetSettings = CMsgControllerActionSetMiscSettings.internalBinaryRead(reader, reader.uint32(), options, message.miscActionSetSettings);
                    break;
                case /* optional string url */ 13:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 binding_handle = 1; */
        if (message.bindingHandle !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.bindingHandle);
        /* optional string display_name = 2; */
        if (message.displayName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.displayName);
        /* optional string description = 3; */
        if (message.description !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* optional string creator = 4; */
        if (message.creator !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.creator);
        /* optional int32 controller_type = 5; */
        if (message.controllerType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.controllerType);
        /* optional string capability_bits = 6; */
        if (message.capabilityBits !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.capabilityBits);
        /* optional int32 controller_style = 7; */
        if (message.controllerStyle !== undefined)
            writer.tag(7, WireType.Varint).int32(message.controllerStyle);
        /* repeated CMsgGameActionSet sets = 8; */
        for (let i = 0; i < message.sets.length; i++)
            CMsgGameActionSet.internalBinaryWrite(message.sets[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgControllerMode modes = 9; */
        for (let i = 0; i < message.modes.length; i++)
            CMsgControllerMode.internalBinaryWrite(message.modes[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional string error_msg = 10; */
        if (message.errorMsg !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.errorMsg);
        /* optional string action_block_path = 11; */
        if (message.actionBlockPath !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.actionBlockPath);
        /* optional CMsgControllerActionSetMiscSettings misc_action_set_settings = 12; */
        if (message.miscActionSetSettings)
            CMsgControllerActionSetMiscSettings.internalBinaryWrite(message.miscActionSetSettings, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional string url = 13; */
        if (message.url !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerConfiguration
 */
export const CMsgControllerConfiguration = new CMsgControllerConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInput$Type extends MessageType<CMsgControllerInput> {
    constructor() {
        super("CMsgControllerInput", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "activators", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgControllerInputActivator },
            { no: 3, name: "disabled_activators", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgControllerInputActivator },
            { no: 4, name: "inherited_from_parentset", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInput>): CMsgControllerInput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activators = [];
        message.disabledActivators = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInput): CMsgControllerInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 key */ 1:
                    message.key = reader.int32();
                    break;
                case /* repeated CMsgControllerInputActivator activators */ 2:
                    message.activators.push(CMsgControllerInputActivator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgControllerInputActivator disabled_activators */ 3:
                    message.disabledActivators.push(CMsgControllerInputActivator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool inherited_from_parentset */ 4:
                    message.inheritedFromParentset = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.Varint).int32(message.key);
        /* repeated CMsgControllerInputActivator activators = 2; */
        for (let i = 0; i < message.activators.length; i++)
            CMsgControllerInputActivator.internalBinaryWrite(message.activators[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgControllerInputActivator disabled_activators = 3; */
        for (let i = 0; i < message.disabledActivators.length; i++)
            CMsgControllerInputActivator.internalBinaryWrite(message.disabledActivators[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional bool inherited_from_parentset = 4; */
        if (message.inheritedFromParentset !== undefined)
            writer.tag(4, WireType.Varint).bool(message.inheritedFromParentset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInput
 */
export const CMsgControllerInput = new CMsgControllerInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputActivator$Type extends MessageType<CMsgControllerInputActivator> {
    constructor() {
        super("CMsgControllerInputActivator", [
            { no: 1, name: "activation", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "bindings", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgControllerInputBinding },
            { no: 3, name: "settings", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgControllerSetting }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputActivator>): CMsgControllerInputActivator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bindings = [];
        message.settings = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputActivator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputActivator): CMsgControllerInputActivator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 activation */ 1:
                    message.activation = reader.int32();
                    break;
                case /* repeated CMsgControllerInputBinding bindings */ 2:
                    message.bindings.push(CMsgControllerInputBinding.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgControllerSetting settings */ 3:
                    message.settings.push(CMsgControllerSetting.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputActivator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 activation = 1; */
        if (message.activation !== undefined)
            writer.tag(1, WireType.Varint).int32(message.activation);
        /* repeated CMsgControllerInputBinding bindings = 2; */
        for (let i = 0; i < message.bindings.length; i++)
            CMsgControllerInputBinding.internalBinaryWrite(message.bindings[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgControllerSetting settings = 3; */
        for (let i = 0; i < message.settings.length; i++)
            CMsgControllerSetting.internalBinaryWrite(message.settings[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputActivator
 */
export const CMsgControllerInputActivator = new CMsgControllerInputActivator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputBinding$Type extends MessageType<CMsgControllerInputBinding> {
    constructor() {
        super("CMsgControllerInputBinding", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "key_binding_data", kind: "message", T: () => CMsgControllerInputBinding_KeyBindingData },
            { no: 3, name: "keyboard_key", kind: "message", T: () => CMsgControllerInputKeyBinding },
            { no: 4, name: "mouse_button", kind: "message", T: () => CMsgControllerInputMouseButtonBinding },
            { no: 5, name: "gamepad_button", kind: "message", T: () => CMsgControllerInputGamepadButtonBinding },
            { no: 6, name: "mouse_wheel", kind: "message", T: () => CMsgControllerInputMouseWheelBinding },
            { no: 7, name: "mode_shift", kind: "message", T: () => CMsgControllerInputModeShiftBinding },
            { no: 8, name: "game_action", kind: "message", T: () => CMsgControllerInputGameActionBinding },
            { no: 9, name: "controller_action", kind: "message", T: () => CMsgControllerInputControllerActionBinding }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputBinding>): CMsgControllerInputBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputBinding): CMsgControllerInputBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional CMsgControllerInputBinding_KeyBindingData key_binding_data */ 2:
                    message.keyBindingData = CMsgControllerInputBinding_KeyBindingData.internalBinaryRead(reader, reader.uint32(), options, message.keyBindingData);
                    break;
                case /* optional CMsgControllerInputKeyBinding keyboard_key */ 3:
                    message.keyboardKey = CMsgControllerInputKeyBinding.internalBinaryRead(reader, reader.uint32(), options, message.keyboardKey);
                    break;
                case /* optional CMsgControllerInputMouseButtonBinding mouse_button */ 4:
                    message.mouseButton = CMsgControllerInputMouseButtonBinding.internalBinaryRead(reader, reader.uint32(), options, message.mouseButton);
                    break;
                case /* optional CMsgControllerInputGamepadButtonBinding gamepad_button */ 5:
                    message.gamepadButton = CMsgControllerInputGamepadButtonBinding.internalBinaryRead(reader, reader.uint32(), options, message.gamepadButton);
                    break;
                case /* optional CMsgControllerInputMouseWheelBinding mouse_wheel */ 6:
                    message.mouseWheel = CMsgControllerInputMouseWheelBinding.internalBinaryRead(reader, reader.uint32(), options, message.mouseWheel);
                    break;
                case /* optional CMsgControllerInputModeShiftBinding mode_shift */ 7:
                    message.modeShift = CMsgControllerInputModeShiftBinding.internalBinaryRead(reader, reader.uint32(), options, message.modeShift);
                    break;
                case /* optional CMsgControllerInputGameActionBinding game_action */ 8:
                    message.gameAction = CMsgControllerInputGameActionBinding.internalBinaryRead(reader, reader.uint32(), options, message.gameAction);
                    break;
                case /* optional CMsgControllerInputControllerActionBinding controller_action */ 9:
                    message.controllerAction = CMsgControllerInputControllerActionBinding.internalBinaryRead(reader, reader.uint32(), options, message.controllerAction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional CMsgControllerInputBinding_KeyBindingData key_binding_data = 2; */
        if (message.keyBindingData)
            CMsgControllerInputBinding_KeyBindingData.internalBinaryWrite(message.keyBindingData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputKeyBinding keyboard_key = 3; */
        if (message.keyboardKey)
            CMsgControllerInputKeyBinding.internalBinaryWrite(message.keyboardKey, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputMouseButtonBinding mouse_button = 4; */
        if (message.mouseButton)
            CMsgControllerInputMouseButtonBinding.internalBinaryWrite(message.mouseButton, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputGamepadButtonBinding gamepad_button = 5; */
        if (message.gamepadButton)
            CMsgControllerInputGamepadButtonBinding.internalBinaryWrite(message.gamepadButton, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputMouseWheelBinding mouse_wheel = 6; */
        if (message.mouseWheel)
            CMsgControllerInputMouseWheelBinding.internalBinaryWrite(message.mouseWheel, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputModeShiftBinding mode_shift = 7; */
        if (message.modeShift)
            CMsgControllerInputModeShiftBinding.internalBinaryWrite(message.modeShift, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputGameActionBinding game_action = 8; */
        if (message.gameAction)
            CMsgControllerInputGameActionBinding.internalBinaryWrite(message.gameAction, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputControllerActionBinding controller_action = 9; */
        if (message.controllerAction)
            CMsgControllerInputControllerActionBinding.internalBinaryWrite(message.controllerAction, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputBinding
 */
export const CMsgControllerInputBinding = new CMsgControllerInputBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputBinding_IconBindingData$Type extends MessageType<CMsgControllerInputBinding_IconBindingData> {
    constructor() {
        super("CMsgControllerInputBinding_IconBindingData", [
            { no: 1, name: "icon_filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "color_foreground", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "color_background", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "icon_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputBinding_IconBindingData>): CMsgControllerInputBinding_IconBindingData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputBinding_IconBindingData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputBinding_IconBindingData): CMsgControllerInputBinding_IconBindingData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string icon_filename */ 1:
                    message.iconFilename = reader.string();
                    break;
                case /* optional string color_foreground */ 2:
                    message.colorForeground = reader.string();
                    break;
                case /* optional string color_background */ 3:
                    message.colorBackground = reader.string();
                    break;
                case /* optional string icon_url */ 4:
                    message.iconUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputBinding_IconBindingData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string icon_filename = 1; */
        if (message.iconFilename !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.iconFilename);
        /* optional string color_foreground = 2; */
        if (message.colorForeground !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.colorForeground);
        /* optional string color_background = 3; */
        if (message.colorBackground !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.colorBackground);
        /* optional string icon_url = 4; */
        if (message.iconUrl !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.iconUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputBinding_IconBindingData
 */
export const CMsgControllerInputBinding_IconBindingData = new CMsgControllerInputBinding_IconBindingData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputBinding_KeyBindingData$Type extends MessageType<CMsgControllerInputBinding_KeyBindingData> {
    constructor() {
        super("CMsgControllerInputBinding_KeyBindingData", [
            { no: 1, name: "keys_bound_utf8", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "friendly_name_utf8", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "icon_data", kind: "message", T: () => CMsgControllerInputBinding_IconBindingData }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputBinding_KeyBindingData>): CMsgControllerInputBinding_KeyBindingData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputBinding_KeyBindingData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputBinding_KeyBindingData): CMsgControllerInputBinding_KeyBindingData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string keys_bound_utf8 */ 1:
                    message.keysBoundUtf8 = reader.string();
                    break;
                case /* optional string friendly_name_utf8 */ 2:
                    message.friendlyNameUtf8 = reader.string();
                    break;
                case /* optional CMsgControllerInputBinding_IconBindingData icon_data */ 3:
                    message.iconData = CMsgControllerInputBinding_IconBindingData.internalBinaryRead(reader, reader.uint32(), options, message.iconData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputBinding_KeyBindingData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string keys_bound_utf8 = 1; */
        if (message.keysBoundUtf8 !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.keysBoundUtf8);
        /* optional string friendly_name_utf8 = 2; */
        if (message.friendlyNameUtf8 !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.friendlyNameUtf8);
        /* optional CMsgControllerInputBinding_IconBindingData icon_data = 3; */
        if (message.iconData)
            CMsgControllerInputBinding_IconBindingData.internalBinaryWrite(message.iconData, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputBinding_KeyBindingData
 */
export const CMsgControllerInputBinding_KeyBindingData = new CMsgControllerInputBinding_KeyBindingData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputControllerActionBinding$Type extends MessageType<CMsgControllerInputControllerActionBinding> {
    constructor() {
        super("CMsgControllerInputControllerActionBinding", [
            { no: 1, name: "action", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "mouse", kind: "message", T: () => CMsgControllerInputControllerActionMouseBinding },
            { no: 3, name: "camera_horizon_reset", kind: "message", T: () => CMsgControllerInputControllerActionCameraHorizonReset },
            { no: 4, name: "dots_per_360_calibration_spin", kind: "message", T: () => CMsgControllerInputControllerActionDotsPer360CalibrationSpin },
            { no: 5, name: "turn_to_face_direction", kind: "message", T: () => CMsgControllerInputControllerActionTurnToFaceDirection },
            { no: 6, name: "action_set", kind: "message", T: () => CMsgControllerInputControllerActionGameActionSetBinding },
            { no: 7, name: "led_color", kind: "message", T: () => CMsgControllerInputControllerActionLEDColorBinding },
            { no: 8, name: "change_player_number", kind: "message", T: () => CMsgControllerInputControllerActionChangePlayerNumberBinding }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputControllerActionBinding>): CMsgControllerInputControllerActionBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputControllerActionBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputControllerActionBinding): CMsgControllerInputControllerActionBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 action */ 1:
                    message.action = reader.int32();
                    break;
                case /* optional CMsgControllerInputControllerActionMouseBinding mouse */ 2:
                    message.mouse = CMsgControllerInputControllerActionMouseBinding.internalBinaryRead(reader, reader.uint32(), options, message.mouse);
                    break;
                case /* optional CMsgControllerInputControllerActionCameraHorizonReset camera_horizon_reset */ 3:
                    message.cameraHorizonReset = CMsgControllerInputControllerActionCameraHorizonReset.internalBinaryRead(reader, reader.uint32(), options, message.cameraHorizonReset);
                    break;
                case /* optional CMsgControllerInputControllerActionDotsPer360CalibrationSpin dots_per_360_calibration_spin */ 4:
                    message.dotsPer360CalibrationSpin = CMsgControllerInputControllerActionDotsPer360CalibrationSpin.internalBinaryRead(reader, reader.uint32(), options, message.dotsPer360CalibrationSpin);
                    break;
                case /* optional CMsgControllerInputControllerActionTurnToFaceDirection turn_to_face_direction */ 5:
                    message.turnToFaceDirection = CMsgControllerInputControllerActionTurnToFaceDirection.internalBinaryRead(reader, reader.uint32(), options, message.turnToFaceDirection);
                    break;
                case /* optional CMsgControllerInputControllerActionGameActionSetBinding action_set */ 6:
                    message.actionSet = CMsgControllerInputControllerActionGameActionSetBinding.internalBinaryRead(reader, reader.uint32(), options, message.actionSet);
                    break;
                case /* optional CMsgControllerInputControllerActionLEDColorBinding led_color */ 7:
                    message.ledColor = CMsgControllerInputControllerActionLEDColorBinding.internalBinaryRead(reader, reader.uint32(), options, message.ledColor);
                    break;
                case /* optional CMsgControllerInputControllerActionChangePlayerNumberBinding change_player_number */ 8:
                    message.changePlayerNumber = CMsgControllerInputControllerActionChangePlayerNumberBinding.internalBinaryRead(reader, reader.uint32(), options, message.changePlayerNumber);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputControllerActionBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 action = 1; */
        if (message.action !== undefined)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* optional CMsgControllerInputControllerActionMouseBinding mouse = 2; */
        if (message.mouse)
            CMsgControllerInputControllerActionMouseBinding.internalBinaryWrite(message.mouse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputControllerActionCameraHorizonReset camera_horizon_reset = 3; */
        if (message.cameraHorizonReset)
            CMsgControllerInputControllerActionCameraHorizonReset.internalBinaryWrite(message.cameraHorizonReset, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputControllerActionDotsPer360CalibrationSpin dots_per_360_calibration_spin = 4; */
        if (message.dotsPer360CalibrationSpin)
            CMsgControllerInputControllerActionDotsPer360CalibrationSpin.internalBinaryWrite(message.dotsPer360CalibrationSpin, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputControllerActionTurnToFaceDirection turn_to_face_direction = 5; */
        if (message.turnToFaceDirection)
            CMsgControllerInputControllerActionTurnToFaceDirection.internalBinaryWrite(message.turnToFaceDirection, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputControllerActionGameActionSetBinding action_set = 6; */
        if (message.actionSet)
            CMsgControllerInputControllerActionGameActionSetBinding.internalBinaryWrite(message.actionSet, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputControllerActionLEDColorBinding led_color = 7; */
        if (message.ledColor)
            CMsgControllerInputControllerActionLEDColorBinding.internalBinaryWrite(message.ledColor, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerInputControllerActionChangePlayerNumberBinding change_player_number = 8; */
        if (message.changePlayerNumber)
            CMsgControllerInputControllerActionChangePlayerNumberBinding.internalBinaryWrite(message.changePlayerNumber, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputControllerActionBinding
 */
export const CMsgControllerInputControllerActionBinding = new CMsgControllerInputControllerActionBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputControllerActionCameraHorizonReset$Type extends MessageType<CMsgControllerInputControllerActionCameraHorizonReset> {
    constructor() {
        super("CMsgControllerInputControllerActionCameraHorizonReset", [
            { no: 1, name: "camera_dip_angle", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "delay_duration", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "camera_horizon_reset_angle", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputControllerActionCameraHorizonReset>): CMsgControllerInputControllerActionCameraHorizonReset {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputControllerActionCameraHorizonReset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputControllerActionCameraHorizonReset): CMsgControllerInputControllerActionCameraHorizonReset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 camera_dip_angle */ 1:
                    message.cameraDipAngle = reader.int32();
                    break;
                case /* optional int32 delay_duration */ 2:
                    message.delayDuration = reader.int32();
                    break;
                case /* optional int32 camera_horizon_reset_angle */ 3:
                    message.cameraHorizonResetAngle = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputControllerActionCameraHorizonReset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 camera_dip_angle = 1; */
        if (message.cameraDipAngle !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cameraDipAngle);
        /* optional int32 delay_duration = 2; */
        if (message.delayDuration !== undefined)
            writer.tag(2, WireType.Varint).int32(message.delayDuration);
        /* optional int32 camera_horizon_reset_angle = 3; */
        if (message.cameraHorizonResetAngle !== undefined)
            writer.tag(3, WireType.Varint).int32(message.cameraHorizonResetAngle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputControllerActionCameraHorizonReset
 */
export const CMsgControllerInputControllerActionCameraHorizonReset = new CMsgControllerInputControllerActionCameraHorizonReset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputControllerActionChangePlayerNumberBinding$Type extends MessageType<CMsgControllerInputControllerActionChangePlayerNumberBinding> {
    constructor() {
        super("CMsgControllerInputControllerActionChangePlayerNumberBinding", [
            { no: 1, name: "player_number", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputControllerActionChangePlayerNumberBinding>): CMsgControllerInputControllerActionChangePlayerNumberBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputControllerActionChangePlayerNumberBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputControllerActionChangePlayerNumberBinding): CMsgControllerInputControllerActionChangePlayerNumberBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 player_number */ 1:
                    message.playerNumber = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputControllerActionChangePlayerNumberBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 player_number = 1; */
        if (message.playerNumber !== undefined)
            writer.tag(1, WireType.Varint).int32(message.playerNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputControllerActionChangePlayerNumberBinding
 */
export const CMsgControllerInputControllerActionChangePlayerNumberBinding = new CMsgControllerInputControllerActionChangePlayerNumberBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputControllerActionDotsPer360CalibrationSpin$Type extends MessageType<CMsgControllerInputControllerActionDotsPer360CalibrationSpin> {
    constructor() {
        super("CMsgControllerInputControllerActionDotsPer360CalibrationSpin", [
            { no: 1, name: "spin_by_amount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "spin_duration", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputControllerActionDotsPer360CalibrationSpin>): CMsgControllerInputControllerActionDotsPer360CalibrationSpin {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputControllerActionDotsPer360CalibrationSpin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputControllerActionDotsPer360CalibrationSpin): CMsgControllerInputControllerActionDotsPer360CalibrationSpin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 spin_by_amount */ 1:
                    message.spinByAmount = reader.int32();
                    break;
                case /* optional int32 spin_duration */ 2:
                    message.spinDuration = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputControllerActionDotsPer360CalibrationSpin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 spin_by_amount = 1; */
        if (message.spinByAmount !== undefined)
            writer.tag(1, WireType.Varint).int32(message.spinByAmount);
        /* optional int32 spin_duration = 2; */
        if (message.spinDuration !== undefined)
            writer.tag(2, WireType.Varint).int32(message.spinDuration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputControllerActionDotsPer360CalibrationSpin
 */
export const CMsgControllerInputControllerActionDotsPer360CalibrationSpin = new CMsgControllerInputControllerActionDotsPer360CalibrationSpin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputControllerActionGameActionSetBinding$Type extends MessageType<CMsgControllerInputControllerActionGameActionSetBinding> {
    constructor() {
        super("CMsgControllerInputControllerActionGameActionSetBinding", [
            { no: 1, name: "preset_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "display", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "beep", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputControllerActionGameActionSetBinding>): CMsgControllerInputControllerActionGameActionSetBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputControllerActionGameActionSetBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputControllerActionGameActionSetBinding): CMsgControllerInputControllerActionGameActionSetBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 preset_type */ 1:
                    message.presetType = reader.int32();
                    break;
                case /* optional string action_set_key */ 2:
                    message.actionSetKey = reader.string();
                    break;
                case /* optional bool display */ 3:
                    message.display = reader.bool();
                    break;
                case /* optional bool beep */ 4:
                    message.beep = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputControllerActionGameActionSetBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 preset_type = 1; */
        if (message.presetType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.presetType);
        /* optional string action_set_key = 2; */
        if (message.actionSetKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionSetKey);
        /* optional bool display = 3; */
        if (message.display !== undefined)
            writer.tag(3, WireType.Varint).bool(message.display);
        /* optional bool beep = 4; */
        if (message.beep !== undefined)
            writer.tag(4, WireType.Varint).bool(message.beep);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputControllerActionGameActionSetBinding
 */
export const CMsgControllerInputControllerActionGameActionSetBinding = new CMsgControllerInputControllerActionGameActionSetBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputControllerActionLEDColorBinding$Type extends MessageType<CMsgControllerInputControllerActionLEDColorBinding> {
    constructor() {
        super("CMsgControllerInputControllerActionLEDColorBinding", [
            { no: 1, name: "setting", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "brightness", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "saturation", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "color_r", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "color_g", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "color_b", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputControllerActionLEDColorBinding>): CMsgControllerInputControllerActionLEDColorBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputControllerActionLEDColorBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputControllerActionLEDColorBinding): CMsgControllerInputControllerActionLEDColorBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 setting */ 1:
                    message.setting = reader.int32();
                    break;
                case /* optional int32 brightness */ 2:
                    message.brightness = reader.int32();
                    break;
                case /* optional int32 saturation */ 3:
                    message.saturation = reader.int32();
                    break;
                case /* optional int32 color_r */ 4:
                    message.colorR = reader.int32();
                    break;
                case /* optional int32 color_g */ 5:
                    message.colorG = reader.int32();
                    break;
                case /* optional int32 color_b */ 6:
                    message.colorB = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputControllerActionLEDColorBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 setting = 1; */
        if (message.setting !== undefined)
            writer.tag(1, WireType.Varint).int32(message.setting);
        /* optional int32 brightness = 2; */
        if (message.brightness !== undefined)
            writer.tag(2, WireType.Varint).int32(message.brightness);
        /* optional int32 saturation = 3; */
        if (message.saturation !== undefined)
            writer.tag(3, WireType.Varint).int32(message.saturation);
        /* optional int32 color_r = 4; */
        if (message.colorR !== undefined)
            writer.tag(4, WireType.Varint).int32(message.colorR);
        /* optional int32 color_g = 5; */
        if (message.colorG !== undefined)
            writer.tag(5, WireType.Varint).int32(message.colorG);
        /* optional int32 color_b = 6; */
        if (message.colorB !== undefined)
            writer.tag(6, WireType.Varint).int32(message.colorB);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputControllerActionLEDColorBinding
 */
export const CMsgControllerInputControllerActionLEDColorBinding = new CMsgControllerInputControllerActionLEDColorBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputControllerActionMouseBinding$Type extends MessageType<CMsgControllerInputControllerActionMouseBinding> {
    constructor() {
        super("CMsgControllerInputControllerActionMouseBinding", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "restore", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputControllerActionMouseBinding>): CMsgControllerInputControllerActionMouseBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputControllerActionMouseBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputControllerActionMouseBinding): CMsgControllerInputControllerActionMouseBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint32 x */ 1:
                    message.x = reader.sint32();
                    break;
                case /* optional sint32 y */ 2:
                    message.y = reader.sint32();
                    break;
                case /* optional bool restore */ 3:
                    message.restore = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputControllerActionMouseBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sint32 x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Varint).sint32(message.x);
        /* optional sint32 y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Varint).sint32(message.y);
        /* optional bool restore = 3; */
        if (message.restore !== undefined)
            writer.tag(3, WireType.Varint).bool(message.restore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputControllerActionMouseBinding
 */
export const CMsgControllerInputControllerActionMouseBinding = new CMsgControllerInputControllerActionMouseBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputControllerActionTurnToFaceDirection$Type extends MessageType<CMsgControllerInputControllerActionTurnToFaceDirection> {
    constructor() {
        super("CMsgControllerInputControllerActionTurnToFaceDirection", [
            { no: 1, name: "source_of_direction", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "turn_duration", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "use_last_direction_if_deadzoned", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputControllerActionTurnToFaceDirection>): CMsgControllerInputControllerActionTurnToFaceDirection {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputControllerActionTurnToFaceDirection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputControllerActionTurnToFaceDirection): CMsgControllerInputControllerActionTurnToFaceDirection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 source_of_direction */ 1:
                    message.sourceOfDirection = reader.int32();
                    break;
                case /* optional int32 turn_duration */ 2:
                    message.turnDuration = reader.int32();
                    break;
                case /* optional bool use_last_direction_if_deadzoned */ 3:
                    message.useLastDirectionIfDeadzoned = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputControllerActionTurnToFaceDirection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 source_of_direction = 1; */
        if (message.sourceOfDirection !== undefined)
            writer.tag(1, WireType.Varint).int32(message.sourceOfDirection);
        /* optional int32 turn_duration = 2; */
        if (message.turnDuration !== undefined)
            writer.tag(2, WireType.Varint).int32(message.turnDuration);
        /* optional bool use_last_direction_if_deadzoned = 3; */
        if (message.useLastDirectionIfDeadzoned !== undefined)
            writer.tag(3, WireType.Varint).bool(message.useLastDirectionIfDeadzoned);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputControllerActionTurnToFaceDirection
 */
export const CMsgControllerInputControllerActionTurnToFaceDirection = new CMsgControllerInputControllerActionTurnToFaceDirection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputGameActionBinding$Type extends MessageType<CMsgControllerInputGameActionBinding> {
    constructor() {
        super("CMsgControllerInputGameActionBinding", [
            { no: 1, name: "action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputGameActionBinding>): CMsgControllerInputGameActionBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputGameActionBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputGameActionBinding): CMsgControllerInputGameActionBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string action_set_key */ 1:
                    message.actionSetKey = reader.string();
                    break;
                case /* optional string action_key */ 2:
                    message.actionKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputGameActionBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string action_set_key = 1; */
        if (message.actionSetKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.actionSetKey);
        /* optional string action_key = 2; */
        if (message.actionKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputGameActionBinding
 */
export const CMsgControllerInputGameActionBinding = new CMsgControllerInputGameActionBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputGamepadButtonBinding$Type extends MessageType<CMsgControllerInputGamepadButtonBinding> {
    constructor() {
        super("CMsgControllerInputGamepadButtonBinding", [
            { no: 1, name: "button", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputGamepadButtonBinding>): CMsgControllerInputGamepadButtonBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputGamepadButtonBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputGamepadButtonBinding): CMsgControllerInputGamepadButtonBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 button */ 1:
                    message.button = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputGamepadButtonBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 button = 1; */
        if (message.button !== undefined)
            writer.tag(1, WireType.Varint).int32(message.button);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputGamepadButtonBinding
 */
export const CMsgControllerInputGamepadButtonBinding = new CMsgControllerInputGamepadButtonBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputKeyBinding$Type extends MessageType<CMsgControllerInputKeyBinding> {
    constructor() {
        super("CMsgControllerInputKeyBinding", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputKeyBinding>): CMsgControllerInputKeyBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputKeyBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputKeyBinding): CMsgControllerInputKeyBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 key */ 1:
                    message.key = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputKeyBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.Varint).int32(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputKeyBinding
 */
export const CMsgControllerInputKeyBinding = new CMsgControllerInputKeyBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputModeShiftBinding$Type extends MessageType<CMsgControllerInputModeShiftBinding> {
    constructor() {
        super("CMsgControllerInputModeShiftBinding", [
            { no: 1, name: "source", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputModeShiftBinding>): CMsgControllerInputModeShiftBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputModeShiftBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputModeShiftBinding): CMsgControllerInputModeShiftBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 source */ 1:
                    message.source = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputModeShiftBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 source = 1; */
        if (message.source !== undefined)
            writer.tag(1, WireType.Varint).int32(message.source);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputModeShiftBinding
 */
export const CMsgControllerInputModeShiftBinding = new CMsgControllerInputModeShiftBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputMouseButtonBinding$Type extends MessageType<CMsgControllerInputMouseButtonBinding> {
    constructor() {
        super("CMsgControllerInputMouseButtonBinding", [
            { no: 1, name: "button", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputMouseButtonBinding>): CMsgControllerInputMouseButtonBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputMouseButtonBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputMouseButtonBinding): CMsgControllerInputMouseButtonBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 button */ 1:
                    message.button = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputMouseButtonBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 button = 1; */
        if (message.button !== undefined)
            writer.tag(1, WireType.Varint).int32(message.button);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputMouseButtonBinding
 */
export const CMsgControllerInputMouseButtonBinding = new CMsgControllerInputMouseButtonBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerInputMouseWheelBinding$Type extends MessageType<CMsgControllerInputMouseWheelBinding> {
    constructor() {
        super("CMsgControllerInputMouseWheelBinding", [
            { no: 1, name: "button", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerInputMouseWheelBinding>): CMsgControllerInputMouseWheelBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerInputMouseWheelBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerInputMouseWheelBinding): CMsgControllerInputMouseWheelBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 button */ 1:
                    message.button = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerInputMouseWheelBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 button = 1; */
        if (message.button !== undefined)
            writer.tag(1, WireType.Varint).int32(message.button);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerInputMouseWheelBinding
 */
export const CMsgControllerInputMouseWheelBinding = new CMsgControllerInputMouseWheelBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerMode$Type extends MessageType<CMsgControllerMode> {
    constructor() {
        super("CMsgControllerMode", [
            { no: 1, name: "mode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "modeid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "inputs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgControllerInput },
            { no: 5, name: "settings", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgControllerSetting },
            { no: 6, name: "friendlyname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "source", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 8, name: "virtual_menu_info", kind: "message", T: () => CMsgControllerVirtualMenuPreviewInfo },
            { no: 9, name: "mode_shift", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "reference_modeid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "mode_shift_buttons", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerMode>): CMsgControllerMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inputs = [];
        message.settings = [];
        message.modeShiftButtons = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerMode): CMsgControllerMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mode */ 1:
                    message.mode = reader.int32();
                    break;
                case /* optional uint32 modeid */ 2:
                    message.modeid = reader.uint32();
                    break;
                case /* optional string description */ 3:
                    message.description = reader.string();
                    break;
                case /* repeated CMsgControllerInput inputs */ 4:
                    message.inputs.push(CMsgControllerInput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgControllerSetting settings */ 5:
                    message.settings.push(CMsgControllerSetting.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string friendlyname */ 6:
                    message.friendlyname = reader.string();
                    break;
                case /* optional int32 source */ 7:
                    message.source = reader.int32();
                    break;
                case /* optional CMsgControllerVirtualMenuPreviewInfo virtual_menu_info */ 8:
                    message.virtualMenuInfo = CMsgControllerVirtualMenuPreviewInfo.internalBinaryRead(reader, reader.uint32(), options, message.virtualMenuInfo);
                    break;
                case /* optional bool mode_shift */ 9:
                    message.modeShift = reader.bool();
                    break;
                case /* optional uint32 reference_modeid */ 10:
                    message.referenceModeid = reader.uint32();
                    break;
                case /* repeated int32 mode_shift_buttons */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.modeShiftButtons.push(reader.int32());
                    else
                        message.modeShiftButtons.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mode = 1; */
        if (message.mode !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mode);
        /* optional uint32 modeid = 2; */
        if (message.modeid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.modeid);
        /* optional string description = 3; */
        if (message.description !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* repeated CMsgControllerInput inputs = 4; */
        for (let i = 0; i < message.inputs.length; i++)
            CMsgControllerInput.internalBinaryWrite(message.inputs[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgControllerSetting settings = 5; */
        for (let i = 0; i < message.settings.length; i++)
            CMsgControllerSetting.internalBinaryWrite(message.settings[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional string friendlyname = 6; */
        if (message.friendlyname !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.friendlyname);
        /* optional int32 source = 7; */
        if (message.source !== undefined)
            writer.tag(7, WireType.Varint).int32(message.source);
        /* optional CMsgControllerVirtualMenuPreviewInfo virtual_menu_info = 8; */
        if (message.virtualMenuInfo)
            CMsgControllerVirtualMenuPreviewInfo.internalBinaryWrite(message.virtualMenuInfo, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional bool mode_shift = 9; */
        if (message.modeShift !== undefined)
            writer.tag(9, WireType.Varint).bool(message.modeShift);
        /* optional uint32 reference_modeid = 10; */
        if (message.referenceModeid !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.referenceModeid);
        /* repeated int32 mode_shift_buttons = 11; */
        for (let i = 0; i < message.modeShiftButtons.length; i++)
            writer.tag(11, WireType.Varint).int32(message.modeShiftButtons[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerMode
 */
export const CMsgControllerMode = new CMsgControllerMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerSetting$Type extends MessageType<CMsgControllerSetting> {
    constructor() {
        super("CMsgControllerSetting", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "int_value", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "int_min", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "int_max", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "int_default", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "parentset_setting", kind: "message", T: () => CMsgControllerSetting },
            { no: 7, name: "long_value", kind: "scalar", opt: true, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerSetting>): CMsgControllerSetting {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerSetting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerSetting): CMsgControllerSetting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 key */ 1:
                    message.key = reader.int32();
                    break;
                case /* optional sint32 int_value */ 2:
                    message.intValue = reader.sint32();
                    break;
                case /* optional sint32 int_min */ 3:
                    message.intMin = reader.sint32();
                    break;
                case /* optional sint32 int_max */ 4:
                    message.intMax = reader.sint32();
                    break;
                case /* optional sint32 int_default */ 5:
                    message.intDefault = reader.sint32();
                    break;
                case /* optional CMsgControllerSetting parentset_setting */ 6:
                    message.parentsetSetting = CMsgControllerSetting.internalBinaryRead(reader, reader.uint32(), options, message.parentsetSetting);
                    break;
                case /* optional sint64 long_value */ 7:
                    message.longValue = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerSetting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.Varint).int32(message.key);
        /* optional sint32 int_value = 2; */
        if (message.intValue !== undefined)
            writer.tag(2, WireType.Varint).sint32(message.intValue);
        /* optional sint32 int_min = 3; */
        if (message.intMin !== undefined)
            writer.tag(3, WireType.Varint).sint32(message.intMin);
        /* optional sint32 int_max = 4; */
        if (message.intMax !== undefined)
            writer.tag(4, WireType.Varint).sint32(message.intMax);
        /* optional sint32 int_default = 5; */
        if (message.intDefault !== undefined)
            writer.tag(5, WireType.Varint).sint32(message.intDefault);
        /* optional CMsgControllerSetting parentset_setting = 6; */
        if (message.parentsetSetting)
            CMsgControllerSetting.internalBinaryWrite(message.parentsetSetting, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional sint64 long_value = 7; */
        if (message.longValue !== undefined)
            writer.tag(7, WireType.Varint).sint64(message.longValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerSetting
 */
export const CMsgControllerSetting = new CMsgControllerSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerSourceGroup$Type extends MessageType<CMsgControllerSourceGroup> {
    constructor() {
        super("CMsgControllerSourceGroup", [
            { no: 1, name: "mode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "game_action", kind: "message", T: () => CMsgControllerInputGameActionBinding },
            { no: 3, name: "inputs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgControllerInput },
            { no: 4, name: "settings", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgControllerSetting },
            { no: 5, name: "modeid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "mode_shift", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "mode_shift_source_group", kind: "message", T: () => CMsgControllerSourceGroup }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerSourceGroup>): CMsgControllerSourceGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inputs = [];
        message.settings = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerSourceGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerSourceGroup): CMsgControllerSourceGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mode */ 1:
                    message.mode = reader.int32();
                    break;
                case /* optional CMsgControllerInputGameActionBinding game_action */ 2:
                    message.gameAction = CMsgControllerInputGameActionBinding.internalBinaryRead(reader, reader.uint32(), options, message.gameAction);
                    break;
                case /* repeated CMsgControllerInput inputs */ 3:
                    message.inputs.push(CMsgControllerInput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgControllerSetting settings */ 4:
                    message.settings.push(CMsgControllerSetting.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 modeid */ 5:
                    message.modeid = reader.uint32();
                    break;
                case /* optional bool mode_shift */ 6:
                    message.modeShift = reader.bool();
                    break;
                case /* optional CMsgControllerSourceGroup mode_shift_source_group */ 7:
                    message.modeShiftSourceGroup = CMsgControllerSourceGroup.internalBinaryRead(reader, reader.uint32(), options, message.modeShiftSourceGroup);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerSourceGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mode = 1; */
        if (message.mode !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mode);
        /* optional CMsgControllerInputGameActionBinding game_action = 2; */
        if (message.gameAction)
            CMsgControllerInputGameActionBinding.internalBinaryWrite(message.gameAction, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgControllerInput inputs = 3; */
        for (let i = 0; i < message.inputs.length; i++)
            CMsgControllerInput.internalBinaryWrite(message.inputs[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgControllerSetting settings = 4; */
        for (let i = 0; i < message.settings.length; i++)
            CMsgControllerSetting.internalBinaryWrite(message.settings[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 modeid = 5; */
        if (message.modeid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.modeid);
        /* optional bool mode_shift = 6; */
        if (message.modeShift !== undefined)
            writer.tag(6, WireType.Varint).bool(message.modeShift);
        /* optional CMsgControllerSourceGroup mode_shift_source_group = 7; */
        if (message.modeShiftSourceGroup)
            CMsgControllerSourceGroup.internalBinaryWrite(message.modeShiftSourceGroup, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerSourceGroup
 */
export const CMsgControllerSourceGroup = new CMsgControllerSourceGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerSources$Type extends MessageType<CMsgControllerSources> {
    constructor() {
        super("CMsgControllerSources", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "active_group", kind: "message", T: () => CMsgControllerSourceGroup }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerSources>): CMsgControllerSources {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerSources>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerSources): CMsgControllerSources {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 key */ 1:
                    message.key = reader.int32();
                    break;
                case /* optional CMsgControllerSourceGroup active_group */ 2:
                    message.activeGroup = CMsgControllerSourceGroup.internalBinaryRead(reader, reader.uint32(), options, message.activeGroup);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerSources, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.Varint).int32(message.key);
        /* optional CMsgControllerSourceGroup active_group = 2; */
        if (message.activeGroup)
            CMsgControllerSourceGroup.internalBinaryWrite(message.activeGroup, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerSources
 */
export const CMsgControllerSources = new CMsgControllerSources$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgControllerVirtualMenuPreviewInfo$Type extends MessageType<CMsgControllerVirtualMenuPreviewInfo> {
    constructor() {
        super("CMsgControllerVirtualMenuPreviewInfo", [
            { no: 1, name: "source", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "x_pos", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "y_pos", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "show_labels", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "menu_style", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "force_on", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CVirtualMenuKey }
        ]);
    }
    create(value?: PartialMessage<CMsgControllerVirtualMenuPreviewInfo>): CMsgControllerVirtualMenuPreviewInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgControllerVirtualMenuPreviewInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgControllerVirtualMenuPreviewInfo): CMsgControllerVirtualMenuPreviewInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 source */ 1:
                    message.source = reader.int32();
                    break;
                case /* optional float x_pos */ 2:
                    message.xPos = reader.float();
                    break;
                case /* optional float y_pos */ 3:
                    message.yPos = reader.float();
                    break;
                case /* optional float opacity */ 4:
                    message.opacity = reader.float();
                    break;
                case /* optional float scale */ 5:
                    message.scale = reader.float();
                    break;
                case /* optional bool show_labels */ 6:
                    message.showLabels = reader.bool();
                    break;
                case /* optional uint32 menu_style */ 7:
                    message.menuStyle = reader.uint32();
                    break;
                case /* optional bool force_on */ 8:
                    message.forceOn = reader.bool();
                    break;
                case /* repeated CVirtualMenuKey keys */ 9:
                    message.keys.push(CVirtualMenuKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgControllerVirtualMenuPreviewInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 source = 1; */
        if (message.source !== undefined)
            writer.tag(1, WireType.Varint).int32(message.source);
        /* optional float x_pos = 2; */
        if (message.xPos !== undefined)
            writer.tag(2, WireType.Bit32).float(message.xPos);
        /* optional float y_pos = 3; */
        if (message.yPos !== undefined)
            writer.tag(3, WireType.Bit32).float(message.yPos);
        /* optional float opacity = 4; */
        if (message.opacity !== undefined)
            writer.tag(4, WireType.Bit32).float(message.opacity);
        /* optional float scale = 5; */
        if (message.scale !== undefined)
            writer.tag(5, WireType.Bit32).float(message.scale);
        /* optional bool show_labels = 6; */
        if (message.showLabels !== undefined)
            writer.tag(6, WireType.Varint).bool(message.showLabels);
        /* optional uint32 menu_style = 7; */
        if (message.menuStyle !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.menuStyle);
        /* optional bool force_on = 8; */
        if (message.forceOn !== undefined)
            writer.tag(8, WireType.Varint).bool(message.forceOn);
        /* repeated CVirtualMenuKey keys = 9; */
        for (let i = 0; i < message.keys.length; i++)
            CVirtualMenuKey.internalBinaryWrite(message.keys[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgControllerVirtualMenuPreviewInfo
 */
export const CMsgControllerVirtualMenuPreviewInfo = new CMsgControllerVirtualMenuPreviewInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCREGetUserPublishedItemVoteDetails$Type extends MessageType<CMsgCREGetUserPublishedItemVoteDetails> {
    constructor() {
        super("CMsgCREGetUserPublishedItemVoteDetails", [
            { no: 1, name: "published_file_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId }
        ]);
    }
    create(value?: PartialMessage<CMsgCREGetUserPublishedItemVoteDetails>): CMsgCREGetUserPublishedItemVoteDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishedFileIds = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgCREGetUserPublishedItemVoteDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCREGetUserPublishedItemVoteDetails): CMsgCREGetUserPublishedItemVoteDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId published_file_ids */ 1:
                    message.publishedFileIds.push(CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCREGetUserPublishedItemVoteDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId published_file_ids = 1; */
        for (let i = 0; i < message.publishedFileIds.length; i++)
            CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId.internalBinaryWrite(message.publishedFileIds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCREGetUserPublishedItemVoteDetails
 */
export const CMsgCREGetUserPublishedItemVoteDetails = new CMsgCREGetUserPublishedItemVoteDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId$Type extends MessageType<CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId> {
    constructor() {
        super("CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId>): CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId): CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId
 */
export const CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId = new CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCREGetUserPublishedItemVoteDetailsResponse$Type extends MessageType<CMsgCREGetUserPublishedItemVoteDetailsResponse> {
    constructor() {
        super("CMsgCREGetUserPublishedItemVoteDetailsResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "user_item_vote_details", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail }
        ]);
    }
    create(value?: PartialMessage<CMsgCREGetUserPublishedItemVoteDetailsResponse>): CMsgCREGetUserPublishedItemVoteDetailsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userItemVoteDetails = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgCREGetUserPublishedItemVoteDetailsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCREGetUserPublishedItemVoteDetailsResponse): CMsgCREGetUserPublishedItemVoteDetailsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail user_item_vote_details */ 2:
                    message.userItemVoteDetails.push(CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCREGetUserPublishedItemVoteDetailsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* repeated CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail user_item_vote_details = 2; */
        for (let i = 0; i < message.userItemVoteDetails.length; i++)
            CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail.internalBinaryWrite(message.userItemVoteDetails[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCREGetUserPublishedItemVoteDetailsResponse
 */
export const CMsgCREGetUserPublishedItemVoteDetailsResponse = new CMsgCREGetUserPublishedItemVoteDetailsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail$Type extends MessageType<CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail> {
    constructor() {
        super("CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "vote", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail>): CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail): CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 vote = 2 [default = 0] */ 2:
                    message.vote = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional int32 vote = 2 [default = 0]; */
        if (message.vote !== undefined)
            writer.tag(2, WireType.Varint).int32(message.vote);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail
 */
export const CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail = new CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCREItemVoteSummary$Type extends MessageType<CMsgCREItemVoteSummary> {
    constructor() {
        super("CMsgCREItemVoteSummary", [
            { no: 1, name: "published_file_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgCREItemVoteSummary_PublishedFileId }
        ]);
    }
    create(value?: PartialMessage<CMsgCREItemVoteSummary>): CMsgCREItemVoteSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishedFileIds = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgCREItemVoteSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCREItemVoteSummary): CMsgCREItemVoteSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgCREItemVoteSummary_PublishedFileId published_file_ids */ 1:
                    message.publishedFileIds.push(CMsgCREItemVoteSummary_PublishedFileId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCREItemVoteSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgCREItemVoteSummary_PublishedFileId published_file_ids = 1; */
        for (let i = 0; i < message.publishedFileIds.length; i++)
            CMsgCREItemVoteSummary_PublishedFileId.internalBinaryWrite(message.publishedFileIds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCREItemVoteSummary
 */
export const CMsgCREItemVoteSummary = new CMsgCREItemVoteSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCREItemVoteSummary_PublishedFileId$Type extends MessageType<CMsgCREItemVoteSummary_PublishedFileId> {
    constructor() {
        super("CMsgCREItemVoteSummary_PublishedFileId", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgCREItemVoteSummary_PublishedFileId>): CMsgCREItemVoteSummary_PublishedFileId {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgCREItemVoteSummary_PublishedFileId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCREItemVoteSummary_PublishedFileId): CMsgCREItemVoteSummary_PublishedFileId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCREItemVoteSummary_PublishedFileId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCREItemVoteSummary_PublishedFileId
 */
export const CMsgCREItemVoteSummary_PublishedFileId = new CMsgCREItemVoteSummary_PublishedFileId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCREItemVoteSummaryResponse$Type extends MessageType<CMsgCREItemVoteSummaryResponse> {
    constructor() {
        super("CMsgCREItemVoteSummaryResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "item_vote_summaries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgCREItemVoteSummaryResponse_ItemVoteSummary }
        ]);
    }
    create(value?: PartialMessage<CMsgCREItemVoteSummaryResponse>): CMsgCREItemVoteSummaryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.itemVoteSummaries = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgCREItemVoteSummaryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCREItemVoteSummaryResponse): CMsgCREItemVoteSummaryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgCREItemVoteSummaryResponse_ItemVoteSummary item_vote_summaries */ 2:
                    message.itemVoteSummaries.push(CMsgCREItemVoteSummaryResponse_ItemVoteSummary.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCREItemVoteSummaryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* repeated CMsgCREItemVoteSummaryResponse_ItemVoteSummary item_vote_summaries = 2; */
        for (let i = 0; i < message.itemVoteSummaries.length; i++)
            CMsgCREItemVoteSummaryResponse_ItemVoteSummary.internalBinaryWrite(message.itemVoteSummaries[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCREItemVoteSummaryResponse
 */
export const CMsgCREItemVoteSummaryResponse = new CMsgCREItemVoteSummaryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCREItemVoteSummaryResponse_ItemVoteSummary$Type extends MessageType<CMsgCREItemVoteSummaryResponse_ItemVoteSummary> {
    constructor() {
        super("CMsgCREItemVoteSummaryResponse_ItemVoteSummary", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "votes_for", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "votes_against", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "reports", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgCREItemVoteSummaryResponse_ItemVoteSummary>): CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgCREItemVoteSummaryResponse_ItemVoteSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCREItemVoteSummaryResponse_ItemVoteSummary): CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 votes_for */ 2:
                    message.votesFor = reader.int32();
                    break;
                case /* optional int32 votes_against */ 3:
                    message.votesAgainst = reader.int32();
                    break;
                case /* optional int32 reports */ 4:
                    message.reports = reader.int32();
                    break;
                case /* optional float score */ 5:
                    message.score = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCREItemVoteSummaryResponse_ItemVoteSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional int32 votes_for = 2; */
        if (message.votesFor !== undefined)
            writer.tag(2, WireType.Varint).int32(message.votesFor);
        /* optional int32 votes_against = 3; */
        if (message.votesAgainst !== undefined)
            writer.tag(3, WireType.Varint).int32(message.votesAgainst);
        /* optional int32 reports = 4; */
        if (message.reports !== undefined)
            writer.tag(4, WireType.Varint).int32(message.reports);
        /* optional float score = 5; */
        if (message.score !== undefined)
            writer.tag(5, WireType.Bit32).float(message.score);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCREItemVoteSummaryResponse_ItemVoteSummary
 */
export const CMsgCREItemVoteSummaryResponse_ItemVoteSummary = new CMsgCREItemVoteSummaryResponse_ItemVoteSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCREUpdateUserPublishedItemVote$Type extends MessageType<CMsgCREUpdateUserPublishedItemVote> {
    constructor() {
        super("CMsgCREUpdateUserPublishedItemVote", [
            { no: 1, name: "published_file_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "vote_up", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgCREUpdateUserPublishedItemVote>): CMsgCREUpdateUserPublishedItemVote {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgCREUpdateUserPublishedItemVote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCREUpdateUserPublishedItemVote): CMsgCREUpdateUserPublishedItemVote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 published_file_id */ 1:
                    message.publishedFileId = reader.fixed64().toBigInt();
                    break;
                case /* optional bool vote_up */ 2:
                    message.voteUp = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCREUpdateUserPublishedItemVote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 published_file_id = 1; */
        if (message.publishedFileId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedFileId);
        /* optional bool vote_up = 2; */
        if (message.voteUp !== undefined)
            writer.tag(2, WireType.Varint).bool(message.voteUp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCREUpdateUserPublishedItemVote
 */
export const CMsgCREUpdateUserPublishedItemVote = new CMsgCREUpdateUserPublishedItemVote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCREUpdateUserPublishedItemVoteResponse$Type extends MessageType<CMsgCREUpdateUserPublishedItemVoteResponse> {
    constructor() {
        super("CMsgCREUpdateUserPublishedItemVoteResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgCREUpdateUserPublishedItemVoteResponse>): CMsgCREUpdateUserPublishedItemVoteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgCREUpdateUserPublishedItemVoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgCREUpdateUserPublishedItemVoteResponse): CMsgCREUpdateUserPublishedItemVoteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgCREUpdateUserPublishedItemVoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgCREUpdateUserPublishedItemVoteResponse
 */
export const CMsgCREUpdateUserPublishedItemVoteResponse = new CMsgCREUpdateUserPublishedItemVoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDownloadRateStatistics$Type extends MessageType<CMsgDownloadRateStatistics> {
    constructor() {
        super("CMsgDownloadRateStatistics", [
            { no: 1, name: "cell_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgDownloadRateStatistics_StatsInfo },
            { no: 3, name: "throttling_kbps", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "steam_realm", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgDownloadRateStatistics>): CMsgDownloadRateStatistics {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stats = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgDownloadRateStatistics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDownloadRateStatistics): CMsgDownloadRateStatistics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 cell_id */ 1:
                    message.cellId = reader.uint32();
                    break;
                case /* repeated CMsgDownloadRateStatistics_StatsInfo stats */ 2:
                    message.stats.push(CMsgDownloadRateStatistics_StatsInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 throttling_kbps */ 3:
                    message.throttlingKbps = reader.uint32();
                    break;
                case /* optional uint32 steam_realm */ 4:
                    message.steamRealm = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDownloadRateStatistics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 cell_id = 1; */
        if (message.cellId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cellId);
        /* repeated CMsgDownloadRateStatistics_StatsInfo stats = 2; */
        for (let i = 0; i < message.stats.length; i++)
            CMsgDownloadRateStatistics_StatsInfo.internalBinaryWrite(message.stats[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 throttling_kbps = 3; */
        if (message.throttlingKbps !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.throttlingKbps);
        /* optional uint32 steam_realm = 4; */
        if (message.steamRealm !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.steamRealm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDownloadRateStatistics
 */
export const CMsgDownloadRateStatistics = new CMsgDownloadRateStatistics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDownloadRateStatistics_StatsInfo$Type extends MessageType<CMsgDownloadRateStatistics_StatsInfo> {
    constructor() {
        super("CMsgDownloadRateStatistics_StatsInfo", [
            { no: 1, name: "source_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "source_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "host_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "microseconds", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "used_ipv6", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "proxied", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgDownloadRateStatistics_StatsInfo>): CMsgDownloadRateStatistics_StatsInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgDownloadRateStatistics_StatsInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDownloadRateStatistics_StatsInfo): CMsgDownloadRateStatistics_StatsInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 source_type */ 1:
                    message.sourceType = reader.uint32();
                    break;
                case /* optional uint32 source_id */ 2:
                    message.sourceId = reader.uint32();
                    break;
                case /* optional uint32 seconds */ 3:
                    message.seconds = reader.uint32();
                    break;
                case /* optional uint64 bytes */ 4:
                    message.bytes = reader.uint64().toBigInt();
                    break;
                case /* optional string host_name */ 5:
                    message.hostName = reader.string();
                    break;
                case /* optional uint64 microseconds */ 6:
                    message.microseconds = reader.uint64().toBigInt();
                    break;
                case /* optional bool used_ipv6 */ 7:
                    message.usedIpv6 = reader.bool();
                    break;
                case /* optional bool proxied */ 8:
                    message.proxied = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDownloadRateStatistics_StatsInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 source_type = 1; */
        if (message.sourceType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.sourceType);
        /* optional uint32 source_id = 2; */
        if (message.sourceId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.sourceId);
        /* optional uint32 seconds = 3; */
        if (message.seconds !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.seconds);
        /* optional uint64 bytes = 4; */
        if (message.bytes !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.bytes);
        /* optional string host_name = 5; */
        if (message.hostName !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.hostName);
        /* optional uint64 microseconds = 6; */
        if (message.microseconds !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.microseconds);
        /* optional bool used_ipv6 = 7; */
        if (message.usedIpv6 !== undefined)
            writer.tag(7, WireType.Varint).bool(message.usedIpv6);
        /* optional bool proxied = 8; */
        if (message.proxied !== undefined)
            writer.tag(8, WireType.Varint).bool(message.proxied);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDownloadRateStatistics_StatsInfo
 */
export const CMsgDownloadRateStatistics_StatsInfo = new CMsgDownloadRateStatistics_StatsInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDPGetNumberOfCurrentPlayers$Type extends MessageType<CMsgDPGetNumberOfCurrentPlayers> {
    constructor() {
        super("CMsgDPGetNumberOfCurrentPlayers", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgDPGetNumberOfCurrentPlayers>): CMsgDPGetNumberOfCurrentPlayers {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgDPGetNumberOfCurrentPlayers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDPGetNumberOfCurrentPlayers): CMsgDPGetNumberOfCurrentPlayers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDPGetNumberOfCurrentPlayers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDPGetNumberOfCurrentPlayers
 */
export const CMsgDPGetNumberOfCurrentPlayers = new CMsgDPGetNumberOfCurrentPlayers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDPGetNumberOfCurrentPlayersResponse$Type extends MessageType<CMsgDPGetNumberOfCurrentPlayersResponse> {
    constructor() {
        super("CMsgDPGetNumberOfCurrentPlayersResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "player_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgDPGetNumberOfCurrentPlayersResponse>): CMsgDPGetNumberOfCurrentPlayersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgDPGetNumberOfCurrentPlayersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDPGetNumberOfCurrentPlayersResponse): CMsgDPGetNumberOfCurrentPlayersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 player_count */ 2:
                    message.playerCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDPGetNumberOfCurrentPlayersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 player_count = 2; */
        if (message.playerCount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.playerCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDPGetNumberOfCurrentPlayersResponse
 */
export const CMsgDPGetNumberOfCurrentPlayersResponse = new CMsgDPGetNumberOfCurrentPlayersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDRMDownloadRequestWithCrashData$Type extends MessageType<CMsgDRMDownloadRequestWithCrashData> {
    constructor() {
        super("CMsgDRMDownloadRequestWithCrashData", [
            { no: 1, name: "download_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "download_types_known", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "guid_drm", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "guid_split", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "guid_merge", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "module_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "module_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "crash_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgDRMDownloadRequestWithCrashData>): CMsgDRMDownloadRequestWithCrashData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgDRMDownloadRequestWithCrashData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDRMDownloadRequestWithCrashData): CMsgDRMDownloadRequestWithCrashData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 download_flags */ 1:
                    message.downloadFlags = reader.uint32();
                    break;
                case /* optional uint32 download_types_known */ 2:
                    message.downloadTypesKnown = reader.uint32();
                    break;
                case /* optional bytes guid_drm */ 3:
                    message.guidDrm = reader.bytes();
                    break;
                case /* optional bytes guid_split */ 4:
                    message.guidSplit = reader.bytes();
                    break;
                case /* optional bytes guid_merge */ 5:
                    message.guidMerge = reader.bytes();
                    break;
                case /* optional string module_name */ 6:
                    message.moduleName = reader.string();
                    break;
                case /* optional string module_path */ 7:
                    message.modulePath = reader.string();
                    break;
                case /* optional bytes crash_data */ 8:
                    message.crashData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDRMDownloadRequestWithCrashData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 download_flags = 1; */
        if (message.downloadFlags !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.downloadFlags);
        /* optional uint32 download_types_known = 2; */
        if (message.downloadTypesKnown !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.downloadTypesKnown);
        /* optional bytes guid_drm = 3; */
        if (message.guidDrm !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.guidDrm);
        /* optional bytes guid_split = 4; */
        if (message.guidSplit !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.guidSplit);
        /* optional bytes guid_merge = 5; */
        if (message.guidMerge !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.guidMerge);
        /* optional string module_name = 6; */
        if (message.moduleName !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.moduleName);
        /* optional string module_path = 7; */
        if (message.modulePath !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.modulePath);
        /* optional bytes crash_data = 8; */
        if (message.crashData !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.crashData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDRMDownloadRequestWithCrashData
 */
export const CMsgDRMDownloadRequestWithCrashData = new CMsgDRMDownloadRequestWithCrashData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDRMDownloadResponse$Type extends MessageType<CMsgDRMDownloadResponse> {
    constructor() {
        super("CMsgDRMDownloadResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "blob_download_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "merge_guid", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "download_file_dfs_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "download_file_dfs_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "download_file_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "module_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgDRMDownloadResponse>): CMsgDRMDownloadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgDRMDownloadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDRMDownloadResponse): CMsgDRMDownloadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.uint32();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 blob_download_type */ 3:
                    message.blobDownloadType = reader.uint32();
                    break;
                case /* optional bytes merge_guid */ 4:
                    message.mergeGuid = reader.bytes();
                    break;
                case /* optional uint32 download_file_dfs_ip */ 5:
                    message.downloadFileDfsIp = reader.uint32();
                    break;
                case /* optional uint32 download_file_dfs_port */ 6:
                    message.downloadFileDfsPort = reader.uint32();
                    break;
                case /* optional string download_file_url */ 7:
                    message.downloadFileUrl = reader.string();
                    break;
                case /* optional string module_path */ 8:
                    message.modulePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDRMDownloadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional uint32 blob_download_type = 3; */
        if (message.blobDownloadType !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.blobDownloadType);
        /* optional bytes merge_guid = 4; */
        if (message.mergeGuid !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.mergeGuid);
        /* optional uint32 download_file_dfs_ip = 5; */
        if (message.downloadFileDfsIp !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.downloadFileDfsIp);
        /* optional uint32 download_file_dfs_port = 6; */
        if (message.downloadFileDfsPort !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.downloadFileDfsPort);
        /* optional string download_file_url = 7; */
        if (message.downloadFileUrl !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.downloadFileUrl);
        /* optional string module_path = 8; */
        if (message.modulePath !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.modulePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDRMDownloadResponse
 */
export const CMsgDRMDownloadResponse = new CMsgDRMDownloadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDRMFinalResult$Type extends MessageType<CMsgDRMFinalResult> {
    constructor() {
        super("CMsgDRMFinalResult", [
            { no: 1, name: "eResult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "blob_download_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "error_detail", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "merge_guid", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "download_file_dfs_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "download_file_dfs_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "download_file_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgDRMFinalResult>): CMsgDRMFinalResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgDRMFinalResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDRMFinalResult): CMsgDRMFinalResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eResult = 1 [default = 2] */ 1:
                    message.eResult = reader.uint32();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 blob_download_type */ 3:
                    message.blobDownloadType = reader.uint32();
                    break;
                case /* optional uint32 error_detail */ 4:
                    message.errorDetail = reader.uint32();
                    break;
                case /* optional bytes merge_guid */ 5:
                    message.mergeGuid = reader.bytes();
                    break;
                case /* optional uint32 download_file_dfs_ip */ 6:
                    message.downloadFileDfsIp = reader.uint32();
                    break;
                case /* optional uint32 download_file_dfs_port */ 7:
                    message.downloadFileDfsPort = reader.uint32();
                    break;
                case /* optional string download_file_url */ 8:
                    message.downloadFileUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDRMFinalResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eResult = 1 [default = 2]; */
        if (message.eResult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eResult);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional uint32 blob_download_type = 3; */
        if (message.blobDownloadType !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.blobDownloadType);
        /* optional uint32 error_detail = 4; */
        if (message.errorDetail !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.errorDetail);
        /* optional bytes merge_guid = 5; */
        if (message.mergeGuid !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.mergeGuid);
        /* optional uint32 download_file_dfs_ip = 6; */
        if (message.downloadFileDfsIp !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.downloadFileDfsIp);
        /* optional uint32 download_file_dfs_port = 7; */
        if (message.downloadFileDfsPort !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.downloadFileDfsPort);
        /* optional string download_file_url = 8; */
        if (message.downloadFileUrl !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.downloadFileUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDRMFinalResult
 */
export const CMsgDRMFinalResult = new CMsgDRMFinalResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgFSEnumerateFollowingList$Type extends MessageType<CMsgFSEnumerateFollowingList> {
    constructor() {
        super("CMsgFSEnumerateFollowingList", [
            { no: 1, name: "start_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgFSEnumerateFollowingList>): CMsgFSEnumerateFollowingList {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgFSEnumerateFollowingList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgFSEnumerateFollowingList): CMsgFSEnumerateFollowingList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 start_index */ 1:
                    message.startIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgFSEnumerateFollowingList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 start_index = 1; */
        if (message.startIndex !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.startIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgFSEnumerateFollowingList
 */
export const CMsgFSEnumerateFollowingList = new CMsgFSEnumerateFollowingList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgFSEnumerateFollowingListResponse$Type extends MessageType<CMsgFSEnumerateFollowingListResponse> {
    constructor() {
        super("CMsgFSEnumerateFollowingListResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "total_results", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "steam_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgFSEnumerateFollowingListResponse>): CMsgFSEnumerateFollowingListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamIds = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgFSEnumerateFollowingListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgFSEnumerateFollowingListResponse): CMsgFSEnumerateFollowingListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 total_results */ 2:
                    message.totalResults = reader.int32();
                    break;
                case /* repeated fixed64 steam_ids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamIds.push(reader.fixed64().toBigInt());
                    else
                        message.steamIds.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgFSEnumerateFollowingListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 total_results = 2; */
        if (message.totalResults !== undefined)
            writer.tag(2, WireType.Varint).int32(message.totalResults);
        /* repeated fixed64 steam_ids = 3; */
        for (let i = 0; i < message.steamIds.length; i++)
            writer.tag(3, WireType.Bit64).fixed64(message.steamIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgFSEnumerateFollowingListResponse
 */
export const CMsgFSEnumerateFollowingListResponse = new CMsgFSEnumerateFollowingListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgFSGetFollowerCount$Type extends MessageType<CMsgFSGetFollowerCount> {
    constructor() {
        super("CMsgFSGetFollowerCount", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgFSGetFollowerCount>): CMsgFSGetFollowerCount {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgFSGetFollowerCount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgFSGetFollowerCount): CMsgFSGetFollowerCount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgFSGetFollowerCount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgFSGetFollowerCount
 */
export const CMsgFSGetFollowerCount = new CMsgFSGetFollowerCount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgFSGetFollowerCountResponse$Type extends MessageType<CMsgFSGetFollowerCountResponse> {
    constructor() {
        super("CMsgFSGetFollowerCountResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgFSGetFollowerCountResponse>): CMsgFSGetFollowerCountResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgFSGetFollowerCountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgFSGetFollowerCountResponse): CMsgFSGetFollowerCountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 count = 2 [default = 0] */ 2:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgFSGetFollowerCountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 count = 2 [default = 0]; */
        if (message.count !== undefined)
            writer.tag(2, WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgFSGetFollowerCountResponse
 */
export const CMsgFSGetFollowerCountResponse = new CMsgFSGetFollowerCountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgFSGetIsFollowing$Type extends MessageType<CMsgFSGetIsFollowing> {
    constructor() {
        super("CMsgFSGetIsFollowing", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgFSGetIsFollowing>): CMsgFSGetIsFollowing {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgFSGetIsFollowing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgFSGetIsFollowing): CMsgFSGetIsFollowing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgFSGetIsFollowing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgFSGetIsFollowing
 */
export const CMsgFSGetIsFollowing = new CMsgFSGetIsFollowing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgFSGetIsFollowingResponse$Type extends MessageType<CMsgFSGetIsFollowingResponse> {
    constructor() {
        super("CMsgFSGetIsFollowingResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "is_following", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgFSGetIsFollowingResponse>): CMsgFSGetIsFollowingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgFSGetIsFollowingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgFSGetIsFollowingResponse): CMsgFSGetIsFollowingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult = 1 [default = 2] */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional bool is_following = 2 [default = false] */ 2:
                    message.isFollowing = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgFSGetIsFollowingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional bool is_following = 2 [default = false]; */
        if (message.isFollowing !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isFollowing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgFSGetIsFollowingResponse
 */
export const CMsgFSGetIsFollowingResponse = new CMsgFSGetIsFollowingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGameAction$Type extends MessageType<CMsgGameAction> {
    constructor() {
        super("CMsgGameAction", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgGameAction>): CMsgGameAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.modes = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGameAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGameAction): CMsgGameAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string key */ 1:
                    message.key = reader.string();
                    break;
                case /* optional string display_name */ 2:
                    message.displayName = reader.string();
                    break;
                case /* repeated int32 modes */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.modes.push(reader.int32());
                    else
                        message.modes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGameAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* optional string display_name = 2; */
        if (message.displayName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.displayName);
        /* repeated int32 modes = 3; */
        for (let i = 0; i < message.modes.length; i++)
            writer.tag(3, WireType.Varint).int32(message.modes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGameAction
 */
export const CMsgGameAction = new CMsgGameAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGameActionBindingType$Type extends MessageType<CMsgGameActionBindingType> {
    constructor() {
        super("CMsgGameActionBindingType", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "actions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGameAction }
        ]);
    }
    create(value?: PartialMessage<CMsgGameActionBindingType>): CMsgGameActionBindingType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actions = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGameActionBindingType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGameActionBindingType): CMsgGameActionBindingType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 key */ 1:
                    message.key = reader.int32();
                    break;
                case /* repeated CMsgGameAction actions */ 2:
                    message.actions.push(CMsgGameAction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGameActionBindingType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.Varint).int32(message.key);
        /* repeated CMsgGameAction actions = 2; */
        for (let i = 0; i < message.actions.length; i++)
            CMsgGameAction.internalBinaryWrite(message.actions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGameActionBindingType
 */
export const CMsgGameActionBindingType = new CMsgGameActionBindingType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGameActionSet$Type extends MessageType<CMsgGameActionSet> {
    constructor() {
        super("CMsgGameActionSet", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "legacy_set", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "layers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGameActionSet },
            { no: 5, name: "action_binding_types", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGameActionBindingType },
            { no: 6, name: "source_bindings", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgControllerSources }
        ]);
    }
    create(value?: PartialMessage<CMsgGameActionSet>): CMsgGameActionSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.layers = [];
        message.actionBindingTypes = [];
        message.sourceBindings = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGameActionSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGameActionSet): CMsgGameActionSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string key */ 1:
                    message.key = reader.string();
                    break;
                case /* optional string display_name */ 2:
                    message.displayName = reader.string();
                    break;
                case /* optional bool legacy_set */ 3:
                    message.legacySet = reader.bool();
                    break;
                case /* repeated CMsgGameActionSet layers */ 4:
                    message.layers.push(CMsgGameActionSet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgGameActionBindingType action_binding_types */ 5:
                    message.actionBindingTypes.push(CMsgGameActionBindingType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgControllerSources source_bindings */ 6:
                    message.sourceBindings.push(CMsgControllerSources.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGameActionSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* optional string display_name = 2; */
        if (message.displayName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.displayName);
        /* optional bool legacy_set = 3; */
        if (message.legacySet !== undefined)
            writer.tag(3, WireType.Varint).bool(message.legacySet);
        /* repeated CMsgGameActionSet layers = 4; */
        for (let i = 0; i < message.layers.length; i++)
            CMsgGameActionSet.internalBinaryWrite(message.layers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgGameActionBindingType action_binding_types = 5; */
        for (let i = 0; i < message.actionBindingTypes.length; i++)
            CMsgGameActionBindingType.internalBinaryWrite(message.actionBindingTypes[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgControllerSources source_bindings = 6; */
        for (let i = 0; i < message.sourceBindings.length; i++)
            CMsgControllerSources.internalBinaryWrite(message.sourceBindings[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGameActionSet
 */
export const CMsgGameActionSet = new CMsgGameActionSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGameServerData$Type extends MessageType<CMsgGameServerData> {
    constructor() {
        super("CMsgGameServerData", [
            { no: 1, name: "steam_id_gs", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "deprecated_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "query_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "game_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "sourcetv_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "gamedir", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "product", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "region", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGameServerData_Player },
            { no: 12, name: "max_players", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "bot_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "password", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "secure", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "dedicated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "os", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "game_data", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "game_data_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "game_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "map", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "game_ip_address", kind: "message", T: () => CMsgIPAddress }
        ]);
    }
    create(value?: PartialMessage<CMsgGameServerData>): CMsgGameServerData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.players = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGameServerData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGameServerData): CMsgGameServerData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_gs */ 1:
                    message.steamIdGs = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 deprecated_ip */ 2:
                    message.deprecatedIp = reader.uint32();
                    break;
                case /* optional uint32 query_port */ 3:
                    message.queryPort = reader.uint32();
                    break;
                case /* optional uint32 game_port */ 4:
                    message.gamePort = reader.uint32();
                    break;
                case /* optional uint32 sourcetv_port */ 5:
                    message.sourcetvPort = reader.uint32();
                    break;
                case /* optional uint32 app_id */ 6:
                    message.appId = reader.uint32();
                    break;
                case /* optional string gamedir */ 7:
                    message.gamedir = reader.string();
                    break;
                case /* optional string version */ 8:
                    message.version = reader.string();
                    break;
                case /* optional string product */ 9:
                    message.product = reader.string();
                    break;
                case /* optional string region */ 10:
                    message.region = reader.string();
                    break;
                case /* repeated CMsgGameServerData_Player players */ 11:
                    message.players.push(CMsgGameServerData_Player.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 max_players */ 12:
                    message.maxPlayers = reader.uint32();
                    break;
                case /* optional uint32 bot_count */ 13:
                    message.botCount = reader.uint32();
                    break;
                case /* optional bool password */ 14:
                    message.password = reader.bool();
                    break;
                case /* optional bool secure */ 15:
                    message.secure = reader.bool();
                    break;
                case /* optional bool dedicated */ 16:
                    message.dedicated = reader.bool();
                    break;
                case /* optional string os */ 17:
                    message.os = reader.string();
                    break;
                case /* optional string game_data */ 18:
                    message.gameData = reader.string();
                    break;
                case /* optional uint32 game_data_version */ 19:
                    message.gameDataVersion = reader.uint32();
                    break;
                case /* optional string game_type */ 20:
                    message.gameType = reader.string();
                    break;
                case /* optional string map */ 21:
                    message.map = reader.string();
                    break;
                case /* optional string name */ 22:
                    message.name = reader.string();
                    break;
                case /* optional CMsgIPAddress game_ip_address */ 23:
                    message.gameIpAddress = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.gameIpAddress);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGameServerData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_gs = 1; */
        if (message.steamIdGs !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdGs);
        /* optional uint32 deprecated_ip = 2; */
        if (message.deprecatedIp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.deprecatedIp);
        /* optional uint32 query_port = 3; */
        if (message.queryPort !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.queryPort);
        /* optional uint32 game_port = 4; */
        if (message.gamePort !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.gamePort);
        /* optional uint32 sourcetv_port = 5; */
        if (message.sourcetvPort !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.sourcetvPort);
        /* optional uint32 app_id = 6; */
        if (message.appId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.appId);
        /* optional string gamedir = 7; */
        if (message.gamedir !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.gamedir);
        /* optional string version = 8; */
        if (message.version !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.version);
        /* optional string product = 9; */
        if (message.product !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.product);
        /* optional string region = 10; */
        if (message.region !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.region);
        /* repeated CMsgGameServerData_Player players = 11; */
        for (let i = 0; i < message.players.length; i++)
            CMsgGameServerData_Player.internalBinaryWrite(message.players[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 max_players = 12; */
        if (message.maxPlayers !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.maxPlayers);
        /* optional uint32 bot_count = 13; */
        if (message.botCount !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.botCount);
        /* optional bool password = 14; */
        if (message.password !== undefined)
            writer.tag(14, WireType.Varint).bool(message.password);
        /* optional bool secure = 15; */
        if (message.secure !== undefined)
            writer.tag(15, WireType.Varint).bool(message.secure);
        /* optional bool dedicated = 16; */
        if (message.dedicated !== undefined)
            writer.tag(16, WireType.Varint).bool(message.dedicated);
        /* optional string os = 17; */
        if (message.os !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.os);
        /* optional string game_data = 18; */
        if (message.gameData !== undefined)
            writer.tag(18, WireType.LengthDelimited).string(message.gameData);
        /* optional uint32 game_data_version = 19; */
        if (message.gameDataVersion !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.gameDataVersion);
        /* optional string game_type = 20; */
        if (message.gameType !== undefined)
            writer.tag(20, WireType.LengthDelimited).string(message.gameType);
        /* optional string map = 21; */
        if (message.map !== undefined)
            writer.tag(21, WireType.LengthDelimited).string(message.map);
        /* optional string name = 22; */
        if (message.name !== undefined)
            writer.tag(22, WireType.LengthDelimited).string(message.name);
        /* optional CMsgIPAddress game_ip_address = 23; */
        if (message.gameIpAddress)
            CMsgIPAddress.internalBinaryWrite(message.gameIpAddress, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGameServerData
 */
export const CMsgGameServerData = new CMsgGameServerData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGameServerData_Player$Type extends MessageType<CMsgGameServerData_Player> {
    constructor() {
        super("CMsgGameServerData_Player", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGameServerData_Player>): CMsgGameServerData_Player {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGameServerData_Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGameServerData_Player): CMsgGameServerData_Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGameServerData_Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGameServerData_Player
 */
export const CMsgGameServerData_Player = new CMsgGameServerData_Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGameServerOutOfDate$Type extends MessageType<CMsgGameServerOutOfDate> {
    constructor() {
        super("CMsgGameServerOutOfDate", [
            { no: 1, name: "steam_id_gs", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "reject", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGameServerOutOfDate>): CMsgGameServerOutOfDate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGameServerOutOfDate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGameServerOutOfDate): CMsgGameServerOutOfDate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_gs */ 1:
                    message.steamIdGs = reader.fixed64().toBigInt();
                    break;
                case /* optional bool reject */ 2:
                    message.reject = reader.bool();
                    break;
                case /* optional string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGameServerOutOfDate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_gs = 1; */
        if (message.steamIdGs !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdGs);
        /* optional bool reject = 2; */
        if (message.reject !== undefined)
            writer.tag(2, WireType.Varint).bool(message.reject);
        /* optional string message = 3; */
        if (message.message !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGameServerOutOfDate
 */
export const CMsgGameServerOutOfDate = new CMsgGameServerOutOfDate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGameServerPingSample$Type extends MessageType<CMsgGameServerPingSample> {
    constructor() {
        super("CMsgGameServerPingSample", [
            { no: 1, name: "my_ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "gs_app_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "gs_samples", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGameServerPingSample_Sample }
        ]);
    }
    create(value?: PartialMessage<CMsgGameServerPingSample>): CMsgGameServerPingSample {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gsSamples = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGameServerPingSample>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGameServerPingSample): CMsgGameServerPingSample {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 my_ip */ 1:
                    message.myIp = reader.fixed32();
                    break;
                case /* optional int32 gs_app_id */ 2:
                    message.gsAppId = reader.int32();
                    break;
                case /* repeated CMsgGameServerPingSample_Sample gs_samples */ 3:
                    message.gsSamples.push(CMsgGameServerPingSample_Sample.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGameServerPingSample, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 my_ip = 1; */
        if (message.myIp !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.myIp);
        /* optional int32 gs_app_id = 2; */
        if (message.gsAppId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.gsAppId);
        /* repeated CMsgGameServerPingSample_Sample gs_samples = 3; */
        for (let i = 0; i < message.gsSamples.length; i++)
            CMsgGameServerPingSample_Sample.internalBinaryWrite(message.gsSamples[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGameServerPingSample
 */
export const CMsgGameServerPingSample = new CMsgGameServerPingSample$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGameServerPingSample_Sample$Type extends MessageType<CMsgGameServerPingSample_Sample> {
    constructor() {
        super("CMsgGameServerPingSample_Sample", [
            { no: 1, name: "ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "avg_ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "stddev_ping_ms_x10", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGameServerPingSample_Sample>): CMsgGameServerPingSample_Sample {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGameServerPingSample_Sample>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGameServerPingSample_Sample): CMsgGameServerPingSample_Sample {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 ip */ 1:
                    message.ip = reader.fixed32();
                    break;
                case /* optional uint32 avg_ping_ms */ 2:
                    message.avgPingMs = reader.uint32();
                    break;
                case /* optional uint32 stddev_ping_ms_x10 */ 3:
                    message.stddevPingMsX10 = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGameServerPingSample_Sample, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 ip = 1; */
        if (message.ip !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.ip);
        /* optional uint32 avg_ping_ms = 2; */
        if (message.avgPingMs !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.avgPingMs);
        /* optional uint32 stddev_ping_ms_x10 = 3; */
        if (message.stddevPingMsX10 !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.stddevPingMsX10);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGameServerPingSample_Sample
 */
export const CMsgGameServerPingSample_Sample = new CMsgGameServerPingSample_Sample$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGameServerRemove$Type extends MessageType<CMsgGameServerRemove> {
    constructor() {
        super("CMsgGameServerRemove", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "deprecated_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "query_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "ip", kind: "message", T: () => CMsgIPAddress }
        ]);
    }
    create(value?: PartialMessage<CMsgGameServerRemove>): CMsgGameServerRemove {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGameServerRemove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGameServerRemove): CMsgGameServerRemove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 deprecated_ip */ 2:
                    message.deprecatedIp = reader.uint32();
                    break;
                case /* optional uint32 query_port */ 3:
                    message.queryPort = reader.uint32();
                    break;
                case /* optional CMsgIPAddress ip */ 4:
                    message.ip = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.ip);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGameServerRemove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional uint32 deprecated_ip = 2; */
        if (message.deprecatedIp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.deprecatedIp);
        /* optional uint32 query_port = 3; */
        if (message.queryPort !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.queryPort);
        /* optional CMsgIPAddress ip = 4; */
        if (message.ip)
            CMsgIPAddress.internalBinaryWrite(message.ip, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGameServerRemove
 */
export const CMsgGameServerRemove = new CMsgGameServerRemove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCClient$Type extends MessageType<CMsgGCClient> {
    constructor() {
        super("CMsgGCClient", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "msgtype", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "payload", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "gcname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCClient>): CMsgGCClient {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCClient>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCClient): CMsgGCClient {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 msgtype */ 2:
                    message.msgtype = reader.uint32();
                    break;
                case /* optional bytes payload */ 3:
                    message.payload = reader.bytes();
                    break;
                case /* optional fixed64 steamid */ 4:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string gcname */ 5:
                    message.gcname = reader.string();
                    break;
                case /* optional uint32 ip */ 6:
                    message.ip = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCClient, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 msgtype = 2; */
        if (message.msgtype !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.msgtype);
        /* optional bytes payload = 3; */
        if (message.payload !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.payload);
        /* optional fixed64 steamid = 4; */
        if (message.steamid !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.steamid);
        /* optional string gcname = 5; */
        if (message.gcname !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.gcname);
        /* optional uint32 ip = 6; */
        if (message.ip !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.ip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCClient
 */
export const CMsgGCClient = new CMsgGCClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCRoutingProtoBufHeader$Type extends MessageType<CMsgGCRoutingProtoBufHeader> {
    constructor() {
        super("CMsgGCRoutingProtoBufHeader", [
            { no: 1, name: "dst_gcid_queue", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "dst_gc_dir_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCRoutingProtoBufHeader>): CMsgGCRoutingProtoBufHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCRoutingProtoBufHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCRoutingProtoBufHeader): CMsgGCRoutingProtoBufHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 dst_gcid_queue */ 1:
                    message.dstGcidQueue = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 dst_gc_dir_index */ 2:
                    message.dstGcDirIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCRoutingProtoBufHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 dst_gcid_queue = 1; */
        if (message.dstGcidQueue !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.dstGcidQueue);
        /* optional uint32 dst_gc_dir_index = 2; */
        if (message.dstGcDirIndex !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.dstGcDirIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCRoutingProtoBufHeader
 */
export const CMsgGCRoutingProtoBufHeader = new CMsgGCRoutingProtoBufHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGenerateSystemReportReply$Type extends MessageType<CMsgGenerateSystemReportReply> {
    constructor() {
        super("CMsgGenerateSystemReportReply", [
            { no: 1, name: "report_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGenerateSystemReportReply>): CMsgGenerateSystemReportReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGenerateSystemReportReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGenerateSystemReportReply): CMsgGenerateSystemReportReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string report_id */ 1:
                    message.reportId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGenerateSystemReportReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string report_id = 1; */
        if (message.reportId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.reportId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGenerateSystemReportReply
 */
export const CMsgGenerateSystemReportReply = new CMsgGenerateSystemReportReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGMSClientServerQueryResponse$Type extends MessageType<CMsgGMSClientServerQueryResponse> {
    constructor() {
        super("CMsgGMSClientServerQueryResponse", [
            { no: 1, name: "servers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGMSClientServerQueryResponse_Server },
            { no: 2, name: "error", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGMSClientServerQueryResponse>): CMsgGMSClientServerQueryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.servers = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGMSClientServerQueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGMSClientServerQueryResponse): CMsgGMSClientServerQueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGMSClientServerQueryResponse_Server servers */ 1:
                    message.servers.push(CMsgGMSClientServerQueryResponse_Server.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGMSClientServerQueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGMSClientServerQueryResponse_Server servers = 1; */
        for (let i = 0; i < message.servers.length; i++)
            CMsgGMSClientServerQueryResponse_Server.internalBinaryWrite(message.servers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string error = 2; */
        if (message.error !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGMSClientServerQueryResponse
 */
export const CMsgGMSClientServerQueryResponse = new CMsgGMSClientServerQueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGMSClientServerQueryResponse_Server$Type extends MessageType<CMsgGMSClientServerQueryResponse_Server> {
    constructor() {
        super("CMsgGMSClientServerQueryResponse_Server", [
            { no: 1, name: "deprecated_server_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "server_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "auth_players", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "server_ip", kind: "message", T: () => CMsgIPAddress }
        ]);
    }
    create(value?: PartialMessage<CMsgGMSClientServerQueryResponse_Server>): CMsgGMSClientServerQueryResponse_Server {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGMSClientServerQueryResponse_Server>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGMSClientServerQueryResponse_Server): CMsgGMSClientServerQueryResponse_Server {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 deprecated_server_ip */ 1:
                    message.deprecatedServerIp = reader.uint32();
                    break;
                case /* optional uint32 server_port */ 2:
                    message.serverPort = reader.uint32();
                    break;
                case /* optional uint32 auth_players */ 3:
                    message.authPlayers = reader.uint32();
                    break;
                case /* optional CMsgIPAddress server_ip */ 4:
                    message.serverIp = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.serverIp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGMSClientServerQueryResponse_Server, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 deprecated_server_ip = 1; */
        if (message.deprecatedServerIp !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.deprecatedServerIp);
        /* optional uint32 server_port = 2; */
        if (message.serverPort !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.serverPort);
        /* optional uint32 auth_players = 3; */
        if (message.authPlayers !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.authPlayers);
        /* optional CMsgIPAddress server_ip = 4; */
        if (message.serverIp)
            CMsgIPAddress.internalBinaryWrite(message.serverIp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGMSClientServerQueryResponse_Server
 */
export const CMsgGMSClientServerQueryResponse_Server = new CMsgGMSClientServerQueryResponse_Server$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSApprove$Type extends MessageType<CMsgGSApprove> {
    constructor() {
        super("CMsgGSApprove", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "owner_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGSApprove>): CMsgGSApprove {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSApprove>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSApprove): CMsgGSApprove {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 owner_steam_id */ 2:
                    message.ownerSteamId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSApprove, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional fixed64 owner_steam_id = 2; */
        if (message.ownerSteamId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.ownerSteamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSApprove
 */
export const CMsgGSApprove = new CMsgGSApprove$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSAssociateWithClan$Type extends MessageType<CMsgGSAssociateWithClan> {
    constructor() {
        super("CMsgGSAssociateWithClan", [
            { no: 1, name: "steam_id_clan", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGSAssociateWithClan>): CMsgGSAssociateWithClan {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSAssociateWithClan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSAssociateWithClan): CMsgGSAssociateWithClan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_clan */ 1:
                    message.steamIdClan = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSAssociateWithClan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_clan = 1; */
        if (message.steamIdClan !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdClan);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSAssociateWithClan
 */
export const CMsgGSAssociateWithClan = new CMsgGSAssociateWithClan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSAssociateWithClanResponse$Type extends MessageType<CMsgGSAssociateWithClanResponse> {
    constructor() {
        super("CMsgGSAssociateWithClanResponse", [
            { no: 1, name: "steam_id_clan", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGSAssociateWithClanResponse>): CMsgGSAssociateWithClanResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSAssociateWithClanResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSAssociateWithClanResponse): CMsgGSAssociateWithClanResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_clan */ 1:
                    message.steamIdClan = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 eresult = 2 [default = 2] */ 2:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSAssociateWithClanResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_clan = 1; */
        if (message.steamIdClan !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdClan);
        /* optional uint32 eresult = 2 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSAssociateWithClanResponse
 */
export const CMsgGSAssociateWithClanResponse = new CMsgGSAssociateWithClanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSComputeNewPlayerCompatibility$Type extends MessageType<CMsgGSComputeNewPlayerCompatibility> {
    constructor() {
        super("CMsgGSComputeNewPlayerCompatibility", [
            { no: 1, name: "steam_id_candidate", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGSComputeNewPlayerCompatibility>): CMsgGSComputeNewPlayerCompatibility {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSComputeNewPlayerCompatibility>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSComputeNewPlayerCompatibility): CMsgGSComputeNewPlayerCompatibility {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_candidate */ 1:
                    message.steamIdCandidate = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSComputeNewPlayerCompatibility, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_candidate = 1; */
        if (message.steamIdCandidate !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdCandidate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSComputeNewPlayerCompatibility
 */
export const CMsgGSComputeNewPlayerCompatibility = new CMsgGSComputeNewPlayerCompatibility$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSComputeNewPlayerCompatibilityResponse$Type extends MessageType<CMsgGSComputeNewPlayerCompatibilityResponse> {
    constructor() {
        super("CMsgGSComputeNewPlayerCompatibilityResponse", [
            { no: 1, name: "steam_id_candidate", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "is_clan_member", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "ct_dont_like_you", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "ct_you_dont_like", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "ct_clanmembers_dont_like_you", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGSComputeNewPlayerCompatibilityResponse>): CMsgGSComputeNewPlayerCompatibilityResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSComputeNewPlayerCompatibilityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSComputeNewPlayerCompatibilityResponse): CMsgGSComputeNewPlayerCompatibilityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id_candidate */ 1:
                    message.steamIdCandidate = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 eresult = 2 [default = 2] */ 2:
                    message.eresult = reader.uint32();
                    break;
                case /* optional bool is_clan_member */ 3:
                    message.isClanMember = reader.bool();
                    break;
                case /* optional int32 ct_dont_like_you */ 4:
                    message.ctDontLikeYou = reader.int32();
                    break;
                case /* optional int32 ct_you_dont_like */ 5:
                    message.ctYouDontLike = reader.int32();
                    break;
                case /* optional int32 ct_clanmembers_dont_like_you */ 6:
                    message.ctClanmembersDontLikeYou = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSComputeNewPlayerCompatibilityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id_candidate = 1; */
        if (message.steamIdCandidate !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamIdCandidate);
        /* optional uint32 eresult = 2 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eresult);
        /* optional bool is_clan_member = 3; */
        if (message.isClanMember !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isClanMember);
        /* optional int32 ct_dont_like_you = 4; */
        if (message.ctDontLikeYou !== undefined)
            writer.tag(4, WireType.Varint).int32(message.ctDontLikeYou);
        /* optional int32 ct_you_dont_like = 5; */
        if (message.ctYouDontLike !== undefined)
            writer.tag(5, WireType.Varint).int32(message.ctYouDontLike);
        /* optional int32 ct_clanmembers_dont_like_you = 6; */
        if (message.ctClanmembersDontLikeYou !== undefined)
            writer.tag(6, WireType.Varint).int32(message.ctClanmembersDontLikeYou);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSComputeNewPlayerCompatibilityResponse
 */
export const CMsgGSComputeNewPlayerCompatibilityResponse = new CMsgGSComputeNewPlayerCompatibilityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSDeny$Type extends MessageType<CMsgGSDeny> {
    constructor() {
        super("CMsgGSDeny", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "edeny_reason", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "deny_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGSDeny>): CMsgGSDeny {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSDeny>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSDeny): CMsgGSDeny {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 edeny_reason */ 2:
                    message.edenyReason = reader.int32();
                    break;
                case /* optional string deny_string */ 3:
                    message.denyString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSDeny, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional int32 edeny_reason = 2; */
        if (message.edenyReason !== undefined)
            writer.tag(2, WireType.Varint).int32(message.edenyReason);
        /* optional string deny_string = 3; */
        if (message.denyString !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.denyString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSDeny
 */
export const CMsgGSDeny = new CMsgGSDeny$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSDisconnectNotice$Type extends MessageType<CMsgGSDisconnectNotice> {
    constructor() {
        super("CMsgGSDisconnectNotice", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGSDisconnectNotice>): CMsgGSDisconnectNotice {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSDisconnectNotice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSDisconnectNotice): CMsgGSDisconnectNotice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSDisconnectNotice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSDisconnectNotice
 */
export const CMsgGSDisconnectNotice = new CMsgGSDisconnectNotice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSKick$Type extends MessageType<CMsgGSKick> {
    constructor() {
        super("CMsgGSKick", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "edeny_reason", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGSKick>): CMsgGSKick {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSKick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSKick): CMsgGSKick {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 edeny_reason */ 2:
                    message.edenyReason = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSKick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional int32 edeny_reason = 2; */
        if (message.edenyReason !== undefined)
            writer.tag(2, WireType.Varint).int32(message.edenyReason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSKick
 */
export const CMsgGSKick = new CMsgGSKick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSPlayerList$Type extends MessageType<CMsgGSPlayerList> {
    constructor() {
        super("CMsgGSPlayerList", [
            { no: 1, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGSPlayerList_Player }
        ]);
    }
    create(value?: PartialMessage<CMsgGSPlayerList>): CMsgGSPlayerList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.players = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGSPlayerList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSPlayerList): CMsgGSPlayerList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGSPlayerList_Player players */ 1:
                    message.players.push(CMsgGSPlayerList_Player.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSPlayerList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGSPlayerList_Player players = 1; */
        for (let i = 0; i < message.players.length; i++)
            CMsgGSPlayerList_Player.internalBinaryWrite(message.players[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSPlayerList
 */
export const CMsgGSPlayerList = new CMsgGSPlayerList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSPlayerList_Player$Type extends MessageType<CMsgGSPlayerList_Player> {
    constructor() {
        super("CMsgGSPlayerList_Player", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "deprecated_public_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "public_ip", kind: "message", T: () => CMsgIPAddress }
        ]);
    }
    create(value?: PartialMessage<CMsgGSPlayerList_Player>): CMsgGSPlayerList_Player {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSPlayerList_Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSPlayerList_Player): CMsgGSPlayerList_Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 steam_id */ 1:
                    message.steamId = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 deprecated_public_ip */ 2:
                    message.deprecatedPublicIp = reader.uint32();
                    break;
                case /* optional bytes token */ 3:
                    message.token = reader.bytes();
                    break;
                case /* optional CMsgIPAddress public_ip */ 4:
                    message.publicIp = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.publicIp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSPlayerList_Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        /* optional uint32 deprecated_public_ip = 2; */
        if (message.deprecatedPublicIp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.deprecatedPublicIp);
        /* optional bytes token = 3; */
        if (message.token !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token);
        /* optional CMsgIPAddress public_ip = 4; */
        if (message.publicIp)
            CMsgIPAddress.internalBinaryWrite(message.publicIp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSPlayerList_Player
 */
export const CMsgGSPlayerList_Player = new CMsgGSPlayerList_Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSServerType$Type extends MessageType<CMsgGSServerType> {
    constructor() {
        super("CMsgGSServerType", [
            { no: 1, name: "app_id_served", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "deprecated_game_ip_address", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "game_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "game_dir", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "game_version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "game_query_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGSServerType>): CMsgGSServerType {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSServerType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSServerType): CMsgGSServerType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id_served */ 1:
                    message.appIdServed = reader.uint32();
                    break;
                case /* optional uint32 flags */ 2:
                    message.flags = reader.uint32();
                    break;
                case /* optional uint32 deprecated_game_ip_address */ 3:
                    message.deprecatedGameIpAddress = reader.uint32();
                    break;
                case /* optional uint32 game_port */ 4:
                    message.gamePort = reader.uint32();
                    break;
                case /* optional string game_dir */ 5:
                    message.gameDir = reader.string();
                    break;
                case /* optional string game_version */ 6:
                    message.gameVersion = reader.string();
                    break;
                case /* optional uint32 game_query_port */ 7:
                    message.gameQueryPort = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSServerType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id_served = 1; */
        if (message.appIdServed !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appIdServed);
        /* optional uint32 flags = 2; */
        if (message.flags !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.flags);
        /* optional uint32 deprecated_game_ip_address = 3; */
        if (message.deprecatedGameIpAddress !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.deprecatedGameIpAddress);
        /* optional uint32 game_port = 4; */
        if (message.gamePort !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.gamePort);
        /* optional string game_dir = 5; */
        if (message.gameDir !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.gameDir);
        /* optional string game_version = 6; */
        if (message.gameVersion !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.gameVersion);
        /* optional uint32 game_query_port = 7; */
        if (message.gameQueryPort !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.gameQueryPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSServerType
 */
export const CMsgGSServerType = new CMsgGSServerType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSStatusReply$Type extends MessageType<CMsgGSStatusReply> {
    constructor() {
        super("CMsgGSStatusReply", [
            { no: 1, name: "is_secure", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGSStatusReply>): CMsgGSStatusReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSStatusReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSStatusReply): CMsgGSStatusReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_secure */ 1:
                    message.isSecure = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSStatusReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_secure = 1; */
        if (message.isSecure !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isSecure);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSStatusReply
 */
export const CMsgGSStatusReply = new CMsgGSStatusReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGSUserPlaying$Type extends MessageType<CMsgGSUserPlaying> {
    constructor() {
        super("CMsgGSUserPlaying", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "deprecated_public_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "public_ip", kind: "message", T: () => CMsgIPAddress }
        ]);
    }
    create(value?: PartialMessage<CMsgGSUserPlaying>): CMsgGSUserPlaying {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGSUserPlaying>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGSUserPlaying): CMsgGSUserPlaying {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 deprecated_public_ip */ 2:
                    message.deprecatedPublicIp = reader.uint32();
                    break;
                case /* optional bytes token */ 3:
                    message.token = reader.bytes();
                    break;
                case /* optional CMsgIPAddress public_ip */ 4:
                    message.publicIp = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.publicIp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGSUserPlaying, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional uint32 deprecated_public_ip = 2; */
        if (message.deprecatedPublicIp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.deprecatedPublicIp);
        /* optional bytes token = 3; */
        if (message.token !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token);
        /* optional CMsgIPAddress public_ip = 4; */
        if (message.publicIp)
            CMsgIPAddress.internalBinaryWrite(message.publicIp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGSUserPlaying
 */
export const CMsgGSUserPlaying = new CMsgGSUserPlaying$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHotkey$Type extends MessageType<CMsgHotkey> {
    constructor() {
        super("CMsgHotkey", [
            { no: 1, name: "key_code", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "alt_key", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "shift_key", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "ctrl_key", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "meta_key", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHotkey>): CMsgHotkey {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgHotkey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHotkey): CMsgHotkey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 key_code */ 1:
                    message.keyCode = reader.uint32();
                    break;
                case /* optional bool alt_key */ 2:
                    message.altKey = reader.bool();
                    break;
                case /* optional bool shift_key */ 3:
                    message.shiftKey = reader.bool();
                    break;
                case /* optional bool ctrl_key */ 4:
                    message.ctrlKey = reader.bool();
                    break;
                case /* optional bool meta_key */ 5:
                    message.metaKey = reader.bool();
                    break;
                case /* optional string display_name */ 6:
                    message.displayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHotkey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 key_code = 1; */
        if (message.keyCode !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.keyCode);
        /* optional bool alt_key = 2; */
        if (message.altKey !== undefined)
            writer.tag(2, WireType.Varint).bool(message.altKey);
        /* optional bool shift_key = 3; */
        if (message.shiftKey !== undefined)
            writer.tag(3, WireType.Varint).bool(message.shiftKey);
        /* optional bool ctrl_key = 4; */
        if (message.ctrlKey !== undefined)
            writer.tag(4, WireType.Varint).bool(message.ctrlKey);
        /* optional bool meta_key = 5; */
        if (message.metaKey !== undefined)
            writer.tag(5, WireType.Varint).bool(message.metaKey);
        /* optional string display_name = 6; */
        if (message.displayName !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.displayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHotkey
 */
export const CMsgHotkey = new CMsgHotkey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgIPAddress$Type extends MessageType<CMsgIPAddress> {
    constructor() {
        super("CMsgIPAddress", [
            { no: 1, name: "v4", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "v6", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgIPAddress>): CMsgIPAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgIPAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgIPAddress): CMsgIPAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 v4 */ 1:
                    message.v4 = reader.fixed32();
                    break;
                case /* optional bytes v6 */ 2:
                    message.v6 = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgIPAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 v4 = 1; */
        if (message.v4 !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.v4);
        /* optional bytes v6 = 2; */
        if (message.v6 !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.v6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgIPAddress
 */
export const CMsgIPAddress = new CMsgIPAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgIPAddressBucket$Type extends MessageType<CMsgIPAddressBucket> {
    constructor() {
        super("CMsgIPAddressBucket", [
            { no: 1, name: "original_ip_address", kind: "message", T: () => CMsgIPAddress },
            { no: 2, name: "bucket", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgIPAddressBucket>): CMsgIPAddressBucket {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgIPAddressBucket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgIPAddressBucket): CMsgIPAddressBucket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgIPAddress original_ip_address */ 1:
                    message.originalIpAddress = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.originalIpAddress);
                    break;
                case /* optional fixed64 bucket */ 2:
                    message.bucket = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgIPAddressBucket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgIPAddress original_ip_address = 1; */
        if (message.originalIpAddress)
            CMsgIPAddress.internalBinaryWrite(message.originalIpAddress, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 bucket = 2; */
        if (message.bucket !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.bucket);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgIPAddressBucket
 */
export const CMsgIPAddressBucket = new CMsgIPAddressBucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMobileChatFriendMessage$Type extends MessageType<CMsgMobileChatFriendMessage> {
    constructor() {
        super("CMsgMobileChatFriendMessage", [
            { no: 1, name: "steamid_friend", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "local_echo", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "chat_entry_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "current_message_timestamp", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "current_message_ordinal", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 7, name: "previous_message_timestamp", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 8, name: "previous_message_ordinal", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 9, name: "client_message_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgMobileChatFriendMessage>): CMsgMobileChatFriendMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgMobileChatFriendMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgMobileChatFriendMessage): CMsgMobileChatFriendMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_friend */ 1:
                    message.steamidFriend = reader.fixed64().toBigInt();
                    break;
                case /* optional bool local_echo */ 2:
                    message.localEcho = reader.bool();
                    break;
                case /* optional int32 chat_entry_type */ 3:
                    message.chatEntryType = reader.int32();
                    break;
                case /* optional string message */ 4:
                    message.message = reader.string();
                    break;
                case /* optional fixed32 current_message_timestamp */ 5:
                    message.currentMessageTimestamp = reader.fixed32();
                    break;
                case /* optional fixed32 current_message_ordinal */ 6:
                    message.currentMessageOrdinal = reader.fixed32();
                    break;
                case /* optional fixed32 previous_message_timestamp */ 7:
                    message.previousMessageTimestamp = reader.fixed32();
                    break;
                case /* optional fixed32 previous_message_ordinal */ 8:
                    message.previousMessageOrdinal = reader.fixed32();
                    break;
                case /* optional string client_message_id */ 9:
                    message.clientMessageId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgMobileChatFriendMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_friend = 1; */
        if (message.steamidFriend !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidFriend);
        /* optional bool local_echo = 2; */
        if (message.localEcho !== undefined)
            writer.tag(2, WireType.Varint).bool(message.localEcho);
        /* optional int32 chat_entry_type = 3; */
        if (message.chatEntryType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.chatEntryType);
        /* optional string message = 4; */
        if (message.message !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.message);
        /* optional fixed32 current_message_timestamp = 5; */
        if (message.currentMessageTimestamp !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.currentMessageTimestamp);
        /* optional fixed32 current_message_ordinal = 6; */
        if (message.currentMessageOrdinal !== undefined)
            writer.tag(6, WireType.Bit32).fixed32(message.currentMessageOrdinal);
        /* optional fixed32 previous_message_timestamp = 7; */
        if (message.previousMessageTimestamp !== undefined)
            writer.tag(7, WireType.Bit32).fixed32(message.previousMessageTimestamp);
        /* optional fixed32 previous_message_ordinal = 8; */
        if (message.previousMessageOrdinal !== undefined)
            writer.tag(8, WireType.Bit32).fixed32(message.previousMessageOrdinal);
        /* optional string client_message_id = 9; */
        if (message.clientMessageId !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.clientMessageId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgMobileChatFriendMessage
 */
export const CMsgMobileChatFriendMessage = new CMsgMobileChatFriendMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMonitorInfo$Type extends MessageType<CMsgMonitorInfo> {
    constructor() {
        super("CMsgMonitorInfo", [
            { no: 1, name: "selected_display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "monitors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgMonitorInfo_MonitorInfo }
        ]);
    }
    create(value?: PartialMessage<CMsgMonitorInfo>): CMsgMonitorInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.monitors = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgMonitorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgMonitorInfo): CMsgMonitorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string selected_display_name */ 1:
                    message.selectedDisplayName = reader.string();
                    break;
                case /* repeated CMsgMonitorInfo_MonitorInfo monitors */ 2:
                    message.monitors.push(CMsgMonitorInfo_MonitorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgMonitorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string selected_display_name = 1; */
        if (message.selectedDisplayName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.selectedDisplayName);
        /* repeated CMsgMonitorInfo_MonitorInfo monitors = 2; */
        for (let i = 0; i < message.monitors.length; i++)
            CMsgMonitorInfo_MonitorInfo.internalBinaryWrite(message.monitors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgMonitorInfo
 */
export const CMsgMonitorInfo = new CMsgMonitorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMonitorInfo_MonitorInfo$Type extends MessageType<CMsgMonitorInfo_MonitorInfo> {
    constructor() {
        super("CMsgMonitorInfo_MonitorInfo", [
            { no: 1, name: "monitor_device_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "monitor_display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgMonitorInfo_MonitorInfo>): CMsgMonitorInfo_MonitorInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgMonitorInfo_MonitorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgMonitorInfo_MonitorInfo): CMsgMonitorInfo_MonitorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string monitor_device_name */ 1:
                    message.monitorDeviceName = reader.string();
                    break;
                case /* optional string monitor_display_name */ 2:
                    message.monitorDisplayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgMonitorInfo_MonitorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string monitor_device_name = 1; */
        if (message.monitorDeviceName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.monitorDeviceName);
        /* optional string monitor_display_name = 2; */
        if (message.monitorDisplayName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.monitorDisplayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgMonitorInfo_MonitorInfo
 */
export const CMsgMonitorInfo_MonitorInfo = new CMsgMonitorInfo_MonitorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMulti$Type extends MessageType<CMsgMulti> {
    constructor() {
        super("CMsgMulti", [
            { no: 1, name: "size_unzipped", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message_body", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgMulti>): CMsgMulti {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgMulti>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgMulti): CMsgMulti {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 size_unzipped */ 1:
                    message.sizeUnzipped = reader.uint32();
                    break;
                case /* optional bytes message_body */ 2:
                    message.messageBody = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgMulti, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 size_unzipped = 1; */
        if (message.sizeUnzipped !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.sizeUnzipped);
        /* optional bytes message_body = 2; */
        if (message.messageBody !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.messageBody);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgMulti
 */
export const CMsgMulti = new CMsgMulti$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDeviceConnect$Type extends MessageType<CMsgNetworkDeviceConnect> {
    constructor() {
        super("CMsgNetworkDeviceConnect", [
            { no: 1, name: "device_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "ap_known", kind: "message", T: () => CMsgNetworkDeviceConnect_KnownAP },
            { no: 3, name: "ap_custom", kind: "message", T: () => CMsgNetworkDeviceConnect_CustomAP },
            { no: 4, name: "credentials", kind: "message", T: () => CMsgNetworkDeviceConnect_Credentials },
            { no: 5, name: "ip4", kind: "message", T: () => CMsgNetworkDeviceIP4Config },
            { no: 6, name: "ip6", kind: "message", T: () => CMsgNetworkDeviceIP6Config }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDeviceConnect>): CMsgNetworkDeviceConnect {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDeviceConnect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDeviceConnect): CMsgNetworkDeviceConnect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 device_id = 1 [default = 0] */ 1:
                    message.deviceId = reader.uint32();
                    break;
                case /* optional CMsgNetworkDeviceConnect_KnownAP ap_known */ 2:
                    message.apKnown = CMsgNetworkDeviceConnect_KnownAP.internalBinaryRead(reader, reader.uint32(), options, message.apKnown);
                    break;
                case /* optional CMsgNetworkDeviceConnect_CustomAP ap_custom */ 3:
                    message.apCustom = CMsgNetworkDeviceConnect_CustomAP.internalBinaryRead(reader, reader.uint32(), options, message.apCustom);
                    break;
                case /* optional CMsgNetworkDeviceConnect_Credentials credentials */ 4:
                    message.credentials = CMsgNetworkDeviceConnect_Credentials.internalBinaryRead(reader, reader.uint32(), options, message.credentials);
                    break;
                case /* optional CMsgNetworkDeviceIP4Config ip4 */ 5:
                    message.ip4 = CMsgNetworkDeviceIP4Config.internalBinaryRead(reader, reader.uint32(), options, message.ip4);
                    break;
                case /* optional CMsgNetworkDeviceIP6Config ip6 */ 6:
                    message.ip6 = CMsgNetworkDeviceIP6Config.internalBinaryRead(reader, reader.uint32(), options, message.ip6);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDeviceConnect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 device_id = 1 [default = 0]; */
        if (message.deviceId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.deviceId);
        /* optional CMsgNetworkDeviceConnect_KnownAP ap_known = 2; */
        if (message.apKnown)
            CMsgNetworkDeviceConnect_KnownAP.internalBinaryWrite(message.apKnown, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgNetworkDeviceConnect_CustomAP ap_custom = 3; */
        if (message.apCustom)
            CMsgNetworkDeviceConnect_CustomAP.internalBinaryWrite(message.apCustom, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgNetworkDeviceConnect_Credentials credentials = 4; */
        if (message.credentials)
            CMsgNetworkDeviceConnect_Credentials.internalBinaryWrite(message.credentials, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgNetworkDeviceIP4Config ip4 = 5; */
        if (message.ip4)
            CMsgNetworkDeviceIP4Config.internalBinaryWrite(message.ip4, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgNetworkDeviceIP6Config ip6 = 6; */
        if (message.ip6)
            CMsgNetworkDeviceIP6Config.internalBinaryWrite(message.ip6, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDeviceConnect
 */
export const CMsgNetworkDeviceConnect = new CMsgNetworkDeviceConnect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDeviceConnect_Credentials$Type extends MessageType<CMsgNetworkDeviceConnect_Credentials> {
    constructor() {
        super("CMsgNetworkDeviceConnect_Credentials", [
            { no: 1, name: "username", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDeviceConnect_Credentials>): CMsgNetworkDeviceConnect_Credentials {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDeviceConnect_Credentials>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDeviceConnect_Credentials): CMsgNetworkDeviceConnect_Credentials {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string username */ 1:
                    message.username = reader.string();
                    break;
                case /* optional string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDeviceConnect_Credentials, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string username = 1; */
        if (message.username !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* optional string password = 2; */
        if (message.password !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDeviceConnect_Credentials
 */
export const CMsgNetworkDeviceConnect_Credentials = new CMsgNetworkDeviceConnect_Credentials$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDeviceConnect_CustomAP$Type extends MessageType<CMsgNetworkDeviceConnect_CustomAP> {
    constructor() {
        super("CMsgNetworkDeviceConnect_CustomAP", [
            { no: 1, name: "ssid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "esecurity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDeviceConnect_CustomAP>): CMsgNetworkDeviceConnect_CustomAP {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDeviceConnect_CustomAP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDeviceConnect_CustomAP): CMsgNetworkDeviceConnect_CustomAP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string ssid */ 1:
                    message.ssid = reader.string();
                    break;
                case /* optional int32 esecurity */ 2:
                    message.esecurity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDeviceConnect_CustomAP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string ssid = 1; */
        if (message.ssid !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.ssid);
        /* optional int32 esecurity = 2; */
        if (message.esecurity !== undefined)
            writer.tag(2, WireType.Varint).int32(message.esecurity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDeviceConnect_CustomAP
 */
export const CMsgNetworkDeviceConnect_CustomAP = new CMsgNetworkDeviceConnect_CustomAP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDeviceConnect_KnownAP$Type extends MessageType<CMsgNetworkDeviceConnect_KnownAP> {
    constructor() {
        super("CMsgNetworkDeviceConnect_KnownAP", [
            { no: 1, name: "ap_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDeviceConnect_KnownAP>): CMsgNetworkDeviceConnect_KnownAP {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDeviceConnect_KnownAP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDeviceConnect_KnownAP): CMsgNetworkDeviceConnect_KnownAP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 ap_id */ 1:
                    message.apId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDeviceConnect_KnownAP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 ap_id = 1; */
        if (message.apId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.apId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDeviceConnect_KnownAP
 */
export const CMsgNetworkDeviceConnect_KnownAP = new CMsgNetworkDeviceConnect_KnownAP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDeviceIP4Address$Type extends MessageType<CMsgNetworkDeviceIP4Address> {
    constructor() {
        super("CMsgNetworkDeviceIP4Address", [
            { no: 1, name: "ip", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "netmask", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDeviceIP4Address>): CMsgNetworkDeviceIP4Address {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDeviceIP4Address>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDeviceIP4Address): CMsgNetworkDeviceIP4Address {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 ip = 1 [default = 0] */ 1:
                    message.ip = reader.int32();
                    break;
                case /* optional int32 netmask */ 2:
                    message.netmask = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDeviceIP4Address, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 ip = 1 [default = 0]; */
        if (message.ip !== undefined)
            writer.tag(1, WireType.Varint).int32(message.ip);
        /* optional int32 netmask = 2; */
        if (message.netmask !== undefined)
            writer.tag(2, WireType.Varint).int32(message.netmask);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDeviceIP4Address
 */
export const CMsgNetworkDeviceIP4Address = new CMsgNetworkDeviceIP4Address$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDeviceIP4Config$Type extends MessageType<CMsgNetworkDeviceIP4Config> {
    constructor() {
        super("CMsgNetworkDeviceIP4Config", [
            { no: 1, name: "addresses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgNetworkDeviceIP4Address },
            { no: 2, name: "dns_ip", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "gateway_ip", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "is_dhcp_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_default_route", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDeviceIP4Config>): CMsgNetworkDeviceIP4Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addresses = [];
        message.dnsIp = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDeviceIP4Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDeviceIP4Config): CMsgNetworkDeviceIP4Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgNetworkDeviceIP4Address addresses */ 1:
                    message.addresses.push(CMsgNetworkDeviceIP4Address.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 dns_ip */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dnsIp.push(reader.int32());
                    else
                        message.dnsIp.push(reader.int32());
                    break;
                case /* optional int32 gateway_ip */ 3:
                    message.gatewayIp = reader.int32();
                    break;
                case /* optional bool is_dhcp_enabled */ 4:
                    message.isDhcpEnabled = reader.bool();
                    break;
                case /* optional bool is_default_route */ 5:
                    message.isDefaultRoute = reader.bool();
                    break;
                case /* optional bool is_enabled = 6 [default = false] */ 6:
                    message.isEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDeviceIP4Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgNetworkDeviceIP4Address addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            CMsgNetworkDeviceIP4Address.internalBinaryWrite(message.addresses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 dns_ip = 2; */
        for (let i = 0; i < message.dnsIp.length; i++)
            writer.tag(2, WireType.Varint).int32(message.dnsIp[i]);
        /* optional int32 gateway_ip = 3; */
        if (message.gatewayIp !== undefined)
            writer.tag(3, WireType.Varint).int32(message.gatewayIp);
        /* optional bool is_dhcp_enabled = 4; */
        if (message.isDhcpEnabled !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isDhcpEnabled);
        /* optional bool is_default_route = 5; */
        if (message.isDefaultRoute !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isDefaultRoute);
        /* optional bool is_enabled = 6 [default = false]; */
        if (message.isEnabled !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDeviceIP4Config
 */
export const CMsgNetworkDeviceIP4Config = new CMsgNetworkDeviceIP4Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDeviceIP6Address$Type extends MessageType<CMsgNetworkDeviceIP6Address> {
    constructor() {
        super("CMsgNetworkDeviceIP6Address", [
            { no: 1, name: "ip", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDeviceIP6Address>): CMsgNetworkDeviceIP6Address {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDeviceIP6Address>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDeviceIP6Address): CMsgNetworkDeviceIP6Address {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string ip = 1 [default = ""] */ 1:
                    message.ip = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDeviceIP6Address, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string ip = 1 [default = ""]; */
        if (message.ip !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.ip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDeviceIP6Address
 */
export const CMsgNetworkDeviceIP6Address = new CMsgNetworkDeviceIP6Address$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDeviceIP6Config$Type extends MessageType<CMsgNetworkDeviceIP6Config> {
    constructor() {
        super("CMsgNetworkDeviceIP6Config", [
            { no: 1, name: "addresses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgNetworkDeviceIP6Address },
            { no: 2, name: "dns_ip", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "gateway_ip", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_dhcp_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_default_route", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDeviceIP6Config>): CMsgNetworkDeviceIP6Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addresses = [];
        message.dnsIp = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDeviceIP6Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDeviceIP6Config): CMsgNetworkDeviceIP6Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgNetworkDeviceIP6Address addresses */ 1:
                    message.addresses.push(CMsgNetworkDeviceIP6Address.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string dns_ip */ 2:
                    message.dnsIp.push(reader.string());
                    break;
                case /* optional string gateway_ip */ 3:
                    message.gatewayIp = reader.string();
                    break;
                case /* optional bool is_dhcp_enabled */ 4:
                    message.isDhcpEnabled = reader.bool();
                    break;
                case /* optional bool is_default_route */ 5:
                    message.isDefaultRoute = reader.bool();
                    break;
                case /* optional bool is_enabled = 6 [default = false] */ 6:
                    message.isEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDeviceIP6Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgNetworkDeviceIP6Address addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            CMsgNetworkDeviceIP6Address.internalBinaryWrite(message.addresses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string dns_ip = 2; */
        for (let i = 0; i < message.dnsIp.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.dnsIp[i]);
        /* optional string gateway_ip = 3; */
        if (message.gatewayIp !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.gatewayIp);
        /* optional bool is_dhcp_enabled = 4; */
        if (message.isDhcpEnabled !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isDhcpEnabled);
        /* optional bool is_default_route = 5; */
        if (message.isDefaultRoute !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isDefaultRoute);
        /* optional bool is_enabled = 6 [default = false]; */
        if (message.isEnabled !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDeviceIP6Config
 */
export const CMsgNetworkDeviceIP6Config = new CMsgNetworkDeviceIP6Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDevicesData$Type extends MessageType<CMsgNetworkDevicesData> {
    constructor() {
        super("CMsgNetworkDevicesData", [
            { no: 1, name: "devices", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgNetworkDevicesData_Device },
            { no: 2, name: "is_wifi_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_wifi_scanning_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDevicesData>): CMsgNetworkDevicesData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.devices = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDevicesData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDevicesData): CMsgNetworkDevicesData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgNetworkDevicesData_Device devices */ 1:
                    message.devices.push(CMsgNetworkDevicesData_Device.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_wifi_enabled */ 2:
                    message.isWifiEnabled = reader.bool();
                    break;
                case /* optional bool is_wifi_scanning_enabled */ 3:
                    message.isWifiScanningEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDevicesData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgNetworkDevicesData_Device devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            CMsgNetworkDevicesData_Device.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_wifi_enabled = 2; */
        if (message.isWifiEnabled !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isWifiEnabled);
        /* optional bool is_wifi_scanning_enabled = 3; */
        if (message.isWifiScanningEnabled !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isWifiScanningEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDevicesData
 */
export const CMsgNetworkDevicesData = new CMsgNetworkDevicesData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDevicesData_Device$Type extends MessageType<CMsgNetworkDevicesData_Device> {
    constructor() {
        super("CMsgNetworkDevicesData_Device", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "etype", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "estate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "mac", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "vendor", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "product", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "ip4", kind: "message", T: () => CMsgNetworkDeviceIP4Config },
            { no: 8, name: "ip6", kind: "message", T: () => CMsgNetworkDeviceIP6Config },
            { no: 9, name: "wired", kind: "message", T: () => CMsgNetworkDevicesData_Device_Wired },
            { no: 10, name: "wireless", kind: "message", T: () => CMsgNetworkDevicesData_Device_Wireless }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDevicesData_Device>): CMsgNetworkDevicesData_Device {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDevicesData_Device>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDevicesData_Device): CMsgNetworkDevicesData_Device {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 id = 1 [default = 0] */ 1:
                    message.id = reader.uint32();
                    break;
                case /* optional int32 etype */ 2:
                    message.etype = reader.int32();
                    break;
                case /* optional int32 estate */ 3:
                    message.estate = reader.int32();
                    break;
                case /* optional string mac */ 4:
                    message.mac = reader.string();
                    break;
                case /* optional string vendor */ 5:
                    message.vendor = reader.string();
                    break;
                case /* optional string product */ 6:
                    message.product = reader.string();
                    break;
                case /* optional CMsgNetworkDeviceIP4Config ip4 */ 7:
                    message.ip4 = CMsgNetworkDeviceIP4Config.internalBinaryRead(reader, reader.uint32(), options, message.ip4);
                    break;
                case /* optional CMsgNetworkDeviceIP6Config ip6 */ 8:
                    message.ip6 = CMsgNetworkDeviceIP6Config.internalBinaryRead(reader, reader.uint32(), options, message.ip6);
                    break;
                case /* optional CMsgNetworkDevicesData_Device_Wired wired */ 9:
                    message.wired = CMsgNetworkDevicesData_Device_Wired.internalBinaryRead(reader, reader.uint32(), options, message.wired);
                    break;
                case /* optional CMsgNetworkDevicesData_Device_Wireless wireless */ 10:
                    message.wireless = CMsgNetworkDevicesData_Device_Wireless.internalBinaryRead(reader, reader.uint32(), options, message.wireless);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDevicesData_Device, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 id = 1 [default = 0]; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* optional int32 etype = 2; */
        if (message.etype !== undefined)
            writer.tag(2, WireType.Varint).int32(message.etype);
        /* optional int32 estate = 3; */
        if (message.estate !== undefined)
            writer.tag(3, WireType.Varint).int32(message.estate);
        /* optional string mac = 4; */
        if (message.mac !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.mac);
        /* optional string vendor = 5; */
        if (message.vendor !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.vendor);
        /* optional string product = 6; */
        if (message.product !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.product);
        /* optional CMsgNetworkDeviceIP4Config ip4 = 7; */
        if (message.ip4)
            CMsgNetworkDeviceIP4Config.internalBinaryWrite(message.ip4, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgNetworkDeviceIP6Config ip6 = 8; */
        if (message.ip6)
            CMsgNetworkDeviceIP6Config.internalBinaryWrite(message.ip6, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgNetworkDevicesData_Device_Wired wired = 9; */
        if (message.wired)
            CMsgNetworkDevicesData_Device_Wired.internalBinaryWrite(message.wired, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgNetworkDevicesData_Device_Wireless wireless = 10; */
        if (message.wireless)
            CMsgNetworkDevicesData_Device_Wireless.internalBinaryWrite(message.wireless, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDevicesData_Device
 */
export const CMsgNetworkDevicesData_Device = new CMsgNetworkDevicesData_Device$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDevicesData_Device_Wired$Type extends MessageType<CMsgNetworkDevicesData_Device_Wired> {
    constructor() {
        super("CMsgNetworkDevicesData_Device_Wired", [
            { no: 1, name: "is_cable_present", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "speed_mbit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "friendly_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDevicesData_Device_Wired>): CMsgNetworkDevicesData_Device_Wired {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDevicesData_Device_Wired>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDevicesData_Device_Wired): CMsgNetworkDevicesData_Device_Wired {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_cable_present = 1 [default = false] */ 1:
                    message.isCablePresent = reader.bool();
                    break;
                case /* optional uint32 speed_mbit */ 2:
                    message.speedMbit = reader.uint32();
                    break;
                case /* optional string friendly_name */ 3:
                    message.friendlyName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDevicesData_Device_Wired, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_cable_present = 1 [default = false]; */
        if (message.isCablePresent !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isCablePresent);
        /* optional uint32 speed_mbit = 2; */
        if (message.speedMbit !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.speedMbit);
        /* optional string friendly_name = 3; */
        if (message.friendlyName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.friendlyName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDevicesData_Device_Wired
 */
export const CMsgNetworkDevicesData_Device_Wired = new CMsgNetworkDevicesData_Device_Wired$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDevicesData_Device_Wireless$Type extends MessageType<CMsgNetworkDevicesData_Device_Wireless> {
    constructor() {
        super("CMsgNetworkDevicesData_Device_Wireless", [
            { no: 1, name: "aps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgNetworkDevicesData_Device_Wireless_AP },
            { no: 2, name: "esecurity_supported", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDevicesData_Device_Wireless>): CMsgNetworkDevicesData_Device_Wireless {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aps = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDevicesData_Device_Wireless>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDevicesData_Device_Wireless): CMsgNetworkDevicesData_Device_Wireless {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgNetworkDevicesData_Device_Wireless_AP aps */ 1:
                    message.aps.push(CMsgNetworkDevicesData_Device_Wireless_AP.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 esecurity_supported */ 2:
                    message.esecuritySupported = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDevicesData_Device_Wireless, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgNetworkDevicesData_Device_Wireless_AP aps = 1; */
        for (let i = 0; i < message.aps.length; i++)
            CMsgNetworkDevicesData_Device_Wireless_AP.internalBinaryWrite(message.aps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 esecurity_supported = 2; */
        if (message.esecuritySupported !== undefined)
            writer.tag(2, WireType.Varint).int32(message.esecuritySupported);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDevicesData_Device_Wireless
 */
export const CMsgNetworkDevicesData_Device_Wireless = new CMsgNetworkDevicesData_Device_Wireless$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNetworkDevicesData_Device_Wireless_AP$Type extends MessageType<CMsgNetworkDevicesData_Device_Wireless_AP> {
    constructor() {
        super("CMsgNetworkDevicesData_Device_Wireless_AP", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "estrength", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "ssid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_autoconnect", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "esecurity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "user_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "password", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "strength_raw", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNetworkDevicesData_Device_Wireless_AP>): CMsgNetworkDevicesData_Device_Wireless_AP {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNetworkDevicesData_Device_Wireless_AP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNetworkDevicesData_Device_Wireless_AP): CMsgNetworkDevicesData_Device_Wireless_AP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 id = 1 [default = 0] */ 1:
                    message.id = reader.uint32();
                    break;
                case /* optional int32 estrength */ 2:
                    message.estrength = reader.int32();
                    break;
                case /* optional string ssid */ 3:
                    message.ssid = reader.string();
                    break;
                case /* optional bool is_active */ 4:
                    message.isActive = reader.bool();
                    break;
                case /* optional bool is_autoconnect */ 5:
                    message.isAutoconnect = reader.bool();
                    break;
                case /* optional int32 esecurity */ 6:
                    message.esecurity = reader.int32();
                    break;
                case /* optional string user_name */ 7:
                    message.userName = reader.string();
                    break;
                case /* optional string password */ 8:
                    message.password = reader.string();
                    break;
                case /* optional int32 strength_raw */ 9:
                    message.strengthRaw = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNetworkDevicesData_Device_Wireless_AP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 id = 1 [default = 0]; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* optional int32 estrength = 2; */
        if (message.estrength !== undefined)
            writer.tag(2, WireType.Varint).int32(message.estrength);
        /* optional string ssid = 3; */
        if (message.ssid !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.ssid);
        /* optional bool is_active = 4; */
        if (message.isActive !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isActive);
        /* optional bool is_autoconnect = 5; */
        if (message.isAutoconnect !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isAutoconnect);
        /* optional int32 esecurity = 6; */
        if (message.esecurity !== undefined)
            writer.tag(6, WireType.Varint).int32(message.esecurity);
        /* optional string user_name = 7; */
        if (message.userName !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.userName);
        /* optional string password = 8; */
        if (message.password !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.password);
        /* optional int32 strength_raw = 9; */
        if (message.strengthRaw !== undefined)
            writer.tag(9, WireType.Varint).int32(message.strengthRaw);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNetworkDevicesData_Device_Wireless_AP
 */
export const CMsgNetworkDevicesData_Device_Wireless_AP = new CMsgNetworkDevicesData_Device_Wireless_AP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPersonaChangeResponse$Type extends MessageType<CMsgPersonaChangeResponse> {
    constructor() {
        super("CMsgPersonaChangeResponse", [
            { no: 1, name: "result", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "player_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgPersonaChangeResponse>): CMsgPersonaChangeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgPersonaChangeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgPersonaChangeResponse): CMsgPersonaChangeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 result */ 1:
                    message.result = reader.uint32();
                    break;
                case /* optional string player_name */ 2:
                    message.playerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgPersonaChangeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 result = 1; */
        if (message.result !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.result);
        /* optional string player_name = 2; */
        if (message.playerName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.playerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgPersonaChangeResponse
 */
export const CMsgPersonaChangeResponse = new CMsgPersonaChangeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgProtoBufHeader$Type extends MessageType<CMsgProtoBufHeader> {
    constructor() {
        super("CMsgProtoBufHeader", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "client_sessionid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "routing_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "jobid_source", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "jobid_target", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "target_job_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "auth_account_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "transport_error", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "messageid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "publisher_group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "sysid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "trace_tag", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 22, name: "token_source", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "admin_spoofing_user", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "seq_num", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 25, name: "webapi_key_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "is_from_external_source", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "forward_to_sysid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 28, name: "cm_sysid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 29, name: "ip_v6", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 30, name: "wg_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 31, name: "launcher_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 32, name: "realm", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 33, name: "timeout_ms", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 34, name: "debug_source", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "debug_source_string_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 36, name: "token_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 37, name: "routing_gc", kind: "message", T: () => CMsgGCRoutingProtoBufHeader },
            { no: 38, name: "session_disposition", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 39, name: "wg_token__field_39", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 40, name: "webui_auth_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "exclude_client_sessionids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 43, name: "admin_request_spoofing_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 44, name: "is_valveds", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 45, name: "trace_tag__field_45", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgProtoBufHeader>): CMsgProtoBufHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forwardToSysid = [];
        message.excludeClientSessionids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgProtoBufHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgProtoBufHeader): CMsgProtoBufHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 client_sessionid */ 2:
                    message.clientSessionid = reader.int32();
                    break;
                case /* optional uint32 routing_appid */ 3:
                    message.routingAppid = reader.uint32();
                    break;
                case /* optional fixed64 jobid_source = 10 [default = 18446744073709551615] */ 10:
                    message.jobidSource = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 jobid_target = 11 [default = 18446744073709551615] */ 11:
                    message.jobidTarget = reader.fixed64().toBigInt();
                    break;
                case /* optional string target_job_name */ 12:
                    message.targetJobName = reader.string();
                    break;
                case /* optional int32 eresult = 13 [default = 2] */ 13:
                    message.eresult = reader.int32();
                    break;
                case /* optional string error_message */ 14:
                    message.errorMessage = reader.string();
                    break;
                case /* optional uint32 ip */ 15:
                    message.ip = reader.uint32();
                    break;
                case /* optional uint32 auth_account_flags */ 16:
                    message.authAccountFlags = reader.uint32();
                    break;
                case /* optional int32 transport_error = 17 [default = 1] */ 17:
                    message.transportError = reader.int32();
                    break;
                case /* optional uint64 messageid = 18 [default = 18446744073709551615] */ 18:
                    message.messageid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 publisher_group_id */ 19:
                    message.publisherGroupId = reader.uint32();
                    break;
                case /* optional uint32 sysid */ 20:
                    message.sysid = reader.uint32();
                    break;
                case /* optional uint64 trace_tag */ 21:
                    message.traceTag = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 token_source */ 22:
                    message.tokenSource = reader.uint32();
                    break;
                case /* optional bool admin_spoofing_user */ 23:
                    message.adminSpoofingUser = reader.bool();
                    break;
                case /* optional int32 seq_num */ 24:
                    message.seqNum = reader.int32();
                    break;
                case /* optional uint32 webapi_key_id */ 25:
                    message.webapiKeyId = reader.uint32();
                    break;
                case /* optional bool is_from_external_source */ 26:
                    message.isFromExternalSource = reader.bool();
                    break;
                case /* repeated uint32 forward_to_sysid */ 27:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.forwardToSysid.push(reader.uint32());
                    else
                        message.forwardToSysid.push(reader.uint32());
                    break;
                case /* optional uint32 cm_sysid */ 28:
                    message.cmSysid = reader.uint32();
                    break;
                case /* optional bytes ip_v6 */ 29:
                    message.ipV6 = reader.bytes();
                    break;
                case /* optional string wg_token */ 30:
                    message.wgToken = reader.string();
                    break;
                case /* optional uint32 launcher_type = 31 [default = 0] */ 31:
                    message.launcherType = reader.uint32();
                    break;
                case /* optional uint32 realm = 32 [default = 0] */ 32:
                    message.realm = reader.uint32();
                    break;
                case /* optional int32 timeout_ms = 33 [default = -1] */ 33:
                    message.timeoutMs = reader.int32();
                    break;
                case /* optional string debug_source */ 34:
                    message.debugSource = reader.string();
                    break;
                case /* optional uint32 debug_source_string_index */ 35:
                    message.debugSourceStringIndex = reader.uint32();
                    break;
                case /* optional uint64 token_id */ 36:
                    message.tokenId = reader.uint64().toBigInt();
                    break;
                case /* optional CMsgGCRoutingProtoBufHeader routing_gc */ 37:
                    message.routingGc = CMsgGCRoutingProtoBufHeader.internalBinaryRead(reader, reader.uint32(), options, message.routingGc);
                    break;
                case /* optional int32 session_disposition = 38 [default = 0] */ 38:
                    message.sessionDisposition = reader.int32();
                    break;
                case /* optional string wg_token__field_39 */ 39:
                    message.wgTokenField39 = reader.string();
                    break;
                case /* optional string webui_auth_key */ 40:
                    message.webuiAuthKey = reader.string();
                    break;
                case /* repeated int32 exclude_client_sessionids */ 41:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.excludeClientSessionids.push(reader.int32());
                    else
                        message.excludeClientSessionids.push(reader.int32());
                    break;
                case /* optional fixed64 admin_request_spoofing_steamid */ 43:
                    message.adminRequestSpoofingSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional bool is_valveds */ 44:
                    message.isValveds = reader.bool();
                    break;
                case /* optional fixed64 trace_tag__field_45 */ 45:
                    message.traceTagField45 = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgProtoBufHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional int32 client_sessionid = 2; */
        if (message.clientSessionid !== undefined)
            writer.tag(2, WireType.Varint).int32(message.clientSessionid);
        /* optional uint32 routing_appid = 3; */
        if (message.routingAppid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.routingAppid);
        /* optional fixed64 jobid_source = 10 [default = 18446744073709551615]; */
        if (message.jobidSource !== undefined)
            writer.tag(10, WireType.Bit64).fixed64(message.jobidSource);
        /* optional fixed64 jobid_target = 11 [default = 18446744073709551615]; */
        if (message.jobidTarget !== undefined)
            writer.tag(11, WireType.Bit64).fixed64(message.jobidTarget);
        /* optional string target_job_name = 12; */
        if (message.targetJobName !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.targetJobName);
        /* optional int32 eresult = 13 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(13, WireType.Varint).int32(message.eresult);
        /* optional string error_message = 14; */
        if (message.errorMessage !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.errorMessage);
        /* optional uint32 ip = 15; */
        if (message.ip !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.ip);
        /* optional uint32 auth_account_flags = 16; */
        if (message.authAccountFlags !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.authAccountFlags);
        /* optional int32 transport_error = 17 [default = 1]; */
        if (message.transportError !== undefined)
            writer.tag(17, WireType.Varint).int32(message.transportError);
        /* optional uint64 messageid = 18 [default = 18446744073709551615]; */
        if (message.messageid !== undefined)
            writer.tag(18, WireType.Varint).uint64(message.messageid);
        /* optional uint32 publisher_group_id = 19; */
        if (message.publisherGroupId !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.publisherGroupId);
        /* optional uint32 sysid = 20; */
        if (message.sysid !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.sysid);
        /* optional uint64 trace_tag = 21; */
        if (message.traceTag !== undefined)
            writer.tag(21, WireType.Varint).uint64(message.traceTag);
        /* optional uint32 token_source = 22; */
        if (message.tokenSource !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.tokenSource);
        /* optional bool admin_spoofing_user = 23; */
        if (message.adminSpoofingUser !== undefined)
            writer.tag(23, WireType.Varint).bool(message.adminSpoofingUser);
        /* optional int32 seq_num = 24; */
        if (message.seqNum !== undefined)
            writer.tag(24, WireType.Varint).int32(message.seqNum);
        /* optional uint32 webapi_key_id = 25; */
        if (message.webapiKeyId !== undefined)
            writer.tag(25, WireType.Varint).uint32(message.webapiKeyId);
        /* optional bool is_from_external_source = 26; */
        if (message.isFromExternalSource !== undefined)
            writer.tag(26, WireType.Varint).bool(message.isFromExternalSource);
        /* repeated uint32 forward_to_sysid = 27; */
        for (let i = 0; i < message.forwardToSysid.length; i++)
            writer.tag(27, WireType.Varint).uint32(message.forwardToSysid[i]);
        /* optional uint32 cm_sysid = 28; */
        if (message.cmSysid !== undefined)
            writer.tag(28, WireType.Varint).uint32(message.cmSysid);
        /* optional bytes ip_v6 = 29; */
        if (message.ipV6 !== undefined)
            writer.tag(29, WireType.LengthDelimited).bytes(message.ipV6);
        /* optional string wg_token = 30; */
        if (message.wgToken !== undefined)
            writer.tag(30, WireType.LengthDelimited).string(message.wgToken);
        /* optional uint32 launcher_type = 31 [default = 0]; */
        if (message.launcherType !== undefined)
            writer.tag(31, WireType.Varint).uint32(message.launcherType);
        /* optional uint32 realm = 32 [default = 0]; */
        if (message.realm !== undefined)
            writer.tag(32, WireType.Varint).uint32(message.realm);
        /* optional int32 timeout_ms = 33 [default = -1]; */
        if (message.timeoutMs !== undefined)
            writer.tag(33, WireType.Varint).int32(message.timeoutMs);
        /* optional string debug_source = 34; */
        if (message.debugSource !== undefined)
            writer.tag(34, WireType.LengthDelimited).string(message.debugSource);
        /* optional uint32 debug_source_string_index = 35; */
        if (message.debugSourceStringIndex !== undefined)
            writer.tag(35, WireType.Varint).uint32(message.debugSourceStringIndex);
        /* optional uint64 token_id = 36; */
        if (message.tokenId !== undefined)
            writer.tag(36, WireType.Varint).uint64(message.tokenId);
        /* optional CMsgGCRoutingProtoBufHeader routing_gc = 37; */
        if (message.routingGc)
            CMsgGCRoutingProtoBufHeader.internalBinaryWrite(message.routingGc, writer.tag(37, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 session_disposition = 38 [default = 0]; */
        if (message.sessionDisposition !== undefined)
            writer.tag(38, WireType.Varint).int32(message.sessionDisposition);
        /* optional string wg_token__field_39 = 39; */
        if (message.wgTokenField39 !== undefined)
            writer.tag(39, WireType.LengthDelimited).string(message.wgTokenField39);
        /* optional string webui_auth_key = 40; */
        if (message.webuiAuthKey !== undefined)
            writer.tag(40, WireType.LengthDelimited).string(message.webuiAuthKey);
        /* repeated int32 exclude_client_sessionids = 41; */
        for (let i = 0; i < message.excludeClientSessionids.length; i++)
            writer.tag(41, WireType.Varint).int32(message.excludeClientSessionids[i]);
        /* optional fixed64 admin_request_spoofing_steamid = 43; */
        if (message.adminRequestSpoofingSteamid !== undefined)
            writer.tag(43, WireType.Bit64).fixed64(message.adminRequestSpoofingSteamid);
        /* optional bool is_valveds = 44; */
        if (message.isValveds !== undefined)
            writer.tag(44, WireType.Varint).bool(message.isValveds);
        /* optional fixed64 trace_tag__field_45 = 45; */
        if (message.traceTagField45 !== undefined)
            writer.tag(45, WireType.Bit64).fixed64(message.traceTagField45);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgProtoBufHeader
 */
export const CMsgProtoBufHeader = new CMsgProtoBufHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgProtobufWrapped$Type extends MessageType<CMsgProtobufWrapped> {
    constructor() {
        super("CMsgProtobufWrapped", [
            { no: 1, name: "message_body", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgProtobufWrapped>): CMsgProtobufWrapped {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgProtobufWrapped>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgProtobufWrapped): CMsgProtobufWrapped {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes message_body */ 1:
                    message.messageBody = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgProtobufWrapped, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes message_body = 1; */
        if (message.messageBody !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.messageBody);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgProtobufWrapped
 */
export const CMsgProtobufWrapped = new CMsgProtobufWrapped$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSelectOSBranchParams$Type extends MessageType<CMsgSelectOSBranchParams> {
    constructor() {
        super("CMsgSelectOSBranchParams", [
            { no: 1, name: "branch", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "custom_branch", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSelectOSBranchParams>): CMsgSelectOSBranchParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSelectOSBranchParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSelectOSBranchParams): CMsgSelectOSBranchParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 branch */ 1:
                    message.branch = reader.int32();
                    break;
                case /* optional string custom_branch */ 2:
                    message.customBranch = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSelectOSBranchParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 branch = 1; */
        if (message.branch !== undefined)
            writer.tag(1, WireType.Varint).int32(message.branch);
        /* optional string custom_branch = 2; */
        if (message.customBranch !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.customBranch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSelectOSBranchParams
 */
export const CMsgSelectOSBranchParams = new CMsgSelectOSBranchParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSetControllerActionSet$Type extends MessageType<CMsgSetControllerActionSet> {
    constructor() {
        super("CMsgSetControllerActionSet", [
            { no: 1, name: "action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action_set_layer_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "action_set_to_copy_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSetControllerActionSet>): CMsgSetControllerActionSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSetControllerActionSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSetControllerActionSet): CMsgSetControllerActionSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string action_set_key */ 1:
                    message.actionSetKey = reader.string();
                    break;
                case /* optional string action_set_layer_key */ 2:
                    message.actionSetLayerKey = reader.string();
                    break;
                case /* optional string new_display_name */ 3:
                    message.newDisplayName = reader.string();
                    break;
                case /* optional string action_set_to_copy_key */ 4:
                    message.actionSetToCopyKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSetControllerActionSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string action_set_key = 1; */
        if (message.actionSetKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.actionSetKey);
        /* optional string action_set_layer_key = 2; */
        if (message.actionSetLayerKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionSetLayerKey);
        /* optional string new_display_name = 3; */
        if (message.newDisplayName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.newDisplayName);
        /* optional string action_set_to_copy_key = 4; */
        if (message.actionSetToCopyKey !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.actionSetToCopyKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSetControllerActionSet
 */
export const CMsgSetControllerActionSet = new CMsgSetControllerActionSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSetControllerInputActivator$Type extends MessageType<CMsgSetControllerInputActivator> {
    constructor() {
        super("CMsgSetControllerInputActivator", [
            { no: 1, name: "action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action_set_layer_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "source_binding_key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "mode_shift", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "input_key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 6, name: "activator_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "new_activation", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 8, name: "new_setting", kind: "message", T: () => CMsgControllerSetting },
            { no: 9, name: "modeid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSetControllerInputActivator>): CMsgSetControllerInputActivator {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSetControllerInputActivator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSetControllerInputActivator): CMsgSetControllerInputActivator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string action_set_key */ 1:
                    message.actionSetKey = reader.string();
                    break;
                case /* optional string action_set_layer_key */ 2:
                    message.actionSetLayerKey = reader.string();
                    break;
                case /* optional int32 source_binding_key */ 3:
                    message.sourceBindingKey = reader.int32();
                    break;
                case /* optional bool mode_shift */ 4:
                    message.modeShift = reader.bool();
                    break;
                case /* optional int32 input_key */ 5:
                    message.inputKey = reader.int32();
                    break;
                case /* optional int32 activator_index */ 6:
                    message.activatorIndex = reader.int32();
                    break;
                case /* optional int32 new_activation */ 7:
                    message.newActivation = reader.int32();
                    break;
                case /* optional CMsgControllerSetting new_setting */ 8:
                    message.newSetting = CMsgControllerSetting.internalBinaryRead(reader, reader.uint32(), options, message.newSetting);
                    break;
                case /* optional int32 modeid */ 9:
                    message.modeid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSetControllerInputActivator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string action_set_key = 1; */
        if (message.actionSetKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.actionSetKey);
        /* optional string action_set_layer_key = 2; */
        if (message.actionSetLayerKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionSetLayerKey);
        /* optional int32 source_binding_key = 3; */
        if (message.sourceBindingKey !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sourceBindingKey);
        /* optional bool mode_shift = 4; */
        if (message.modeShift !== undefined)
            writer.tag(4, WireType.Varint).bool(message.modeShift);
        /* optional int32 input_key = 5; */
        if (message.inputKey !== undefined)
            writer.tag(5, WireType.Varint).int32(message.inputKey);
        /* optional int32 activator_index = 6; */
        if (message.activatorIndex !== undefined)
            writer.tag(6, WireType.Varint).int32(message.activatorIndex);
        /* optional int32 new_activation = 7; */
        if (message.newActivation !== undefined)
            writer.tag(7, WireType.Varint).int32(message.newActivation);
        /* optional CMsgControllerSetting new_setting = 8; */
        if (message.newSetting)
            CMsgControllerSetting.internalBinaryWrite(message.newSetting, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 modeid = 9; */
        if (message.modeid !== undefined)
            writer.tag(9, WireType.Varint).int32(message.modeid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSetControllerInputActivator
 */
export const CMsgSetControllerInputActivator = new CMsgSetControllerInputActivator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSetControllerInputActivatorEnabled$Type extends MessageType<CMsgSetControllerInputActivatorEnabled> {
    constructor() {
        super("CMsgSetControllerInputActivatorEnabled", [
            { no: 1, name: "action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action_set_layer_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "source_binding_key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "mode_shift", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "input_key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 6, name: "activator_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "modeid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSetControllerInputActivatorEnabled>): CMsgSetControllerInputActivatorEnabled {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSetControllerInputActivatorEnabled>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSetControllerInputActivatorEnabled): CMsgSetControllerInputActivatorEnabled {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string action_set_key */ 1:
                    message.actionSetKey = reader.string();
                    break;
                case /* optional string action_set_layer_key */ 2:
                    message.actionSetLayerKey = reader.string();
                    break;
                case /* optional int32 source_binding_key */ 3:
                    message.sourceBindingKey = reader.int32();
                    break;
                case /* optional bool mode_shift */ 4:
                    message.modeShift = reader.bool();
                    break;
                case /* optional int32 input_key */ 5:
                    message.inputKey = reader.int32();
                    break;
                case /* optional int32 activator_index */ 6:
                    message.activatorIndex = reader.int32();
                    break;
                case /* optional bool enabled */ 7:
                    message.enabled = reader.bool();
                    break;
                case /* optional int32 modeid */ 8:
                    message.modeid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSetControllerInputActivatorEnabled, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string action_set_key = 1; */
        if (message.actionSetKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.actionSetKey);
        /* optional string action_set_layer_key = 2; */
        if (message.actionSetLayerKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionSetLayerKey);
        /* optional int32 source_binding_key = 3; */
        if (message.sourceBindingKey !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sourceBindingKey);
        /* optional bool mode_shift = 4; */
        if (message.modeShift !== undefined)
            writer.tag(4, WireType.Varint).bool(message.modeShift);
        /* optional int32 input_key = 5; */
        if (message.inputKey !== undefined)
            writer.tag(5, WireType.Varint).int32(message.inputKey);
        /* optional int32 activator_index = 6; */
        if (message.activatorIndex !== undefined)
            writer.tag(6, WireType.Varint).int32(message.activatorIndex);
        /* optional bool enabled = 7; */
        if (message.enabled !== undefined)
            writer.tag(7, WireType.Varint).bool(message.enabled);
        /* optional int32 modeid = 8; */
        if (message.modeid !== undefined)
            writer.tag(8, WireType.Varint).int32(message.modeid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSetControllerInputActivatorEnabled
 */
export const CMsgSetControllerInputActivatorEnabled = new CMsgSetControllerInputActivatorEnabled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSetControllerInputBinding$Type extends MessageType<CMsgSetControllerInputBinding> {
    constructor() {
        super("CMsgSetControllerInputBinding", [
            { no: 1, name: "action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action_set_layer_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "source_binding_key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "mode_shift", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "input_key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 6, name: "activator_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "binding_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "new_binding", kind: "message", T: () => CMsgControllerInputBinding },
            { no: 9, name: "source_mode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 10, name: "modeid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSetControllerInputBinding>): CMsgSetControllerInputBinding {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSetControllerInputBinding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSetControllerInputBinding): CMsgSetControllerInputBinding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string action_set_key */ 1:
                    message.actionSetKey = reader.string();
                    break;
                case /* optional string action_set_layer_key */ 2:
                    message.actionSetLayerKey = reader.string();
                    break;
                case /* optional int32 source_binding_key */ 3:
                    message.sourceBindingKey = reader.int32();
                    break;
                case /* optional bool mode_shift */ 4:
                    message.modeShift = reader.bool();
                    break;
                case /* optional int32 input_key */ 5:
                    message.inputKey = reader.int32();
                    break;
                case /* optional int32 activator_index */ 6:
                    message.activatorIndex = reader.int32();
                    break;
                case /* optional int32 binding_index */ 7:
                    message.bindingIndex = reader.int32();
                    break;
                case /* optional CMsgControllerInputBinding new_binding */ 8:
                    message.newBinding = CMsgControllerInputBinding.internalBinaryRead(reader, reader.uint32(), options, message.newBinding);
                    break;
                case /* optional int32 source_mode */ 9:
                    message.sourceMode = reader.int32();
                    break;
                case /* optional int32 modeid */ 10:
                    message.modeid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSetControllerInputBinding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string action_set_key = 1; */
        if (message.actionSetKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.actionSetKey);
        /* optional string action_set_layer_key = 2; */
        if (message.actionSetLayerKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionSetLayerKey);
        /* optional int32 source_binding_key = 3; */
        if (message.sourceBindingKey !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sourceBindingKey);
        /* optional bool mode_shift = 4; */
        if (message.modeShift !== undefined)
            writer.tag(4, WireType.Varint).bool(message.modeShift);
        /* optional int32 input_key = 5; */
        if (message.inputKey !== undefined)
            writer.tag(5, WireType.Varint).int32(message.inputKey);
        /* optional int32 activator_index = 6; */
        if (message.activatorIndex !== undefined)
            writer.tag(6, WireType.Varint).int32(message.activatorIndex);
        /* optional int32 binding_index = 7; */
        if (message.bindingIndex !== undefined)
            writer.tag(7, WireType.Varint).int32(message.bindingIndex);
        /* optional CMsgControllerInputBinding new_binding = 8; */
        if (message.newBinding)
            CMsgControllerInputBinding.internalBinaryWrite(message.newBinding, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 source_mode = 9; */
        if (message.sourceMode !== undefined)
            writer.tag(9, WireType.Varint).int32(message.sourceMode);
        /* optional int32 modeid = 10; */
        if (message.modeid !== undefined)
            writer.tag(10, WireType.Varint).int32(message.modeid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSetControllerInputBinding
 */
export const CMsgSetControllerInputBinding = new CMsgSetControllerInputBinding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSetControllerSourceMode$Type extends MessageType<CMsgSetControllerSourceMode> {
    constructor() {
        super("CMsgSetControllerSourceMode", [
            { no: 1, name: "action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action_set_layer_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "source_binding_key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "mode_shift", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "new_mode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 6, name: "new_game_action", kind: "message", T: () => CMsgControllerInputGameActionBinding },
            { no: 7, name: "new_setting", kind: "message", T: () => CMsgControllerSetting },
            { no: 8, name: "new_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "modeid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "change_mode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "new_virtual_menu", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "enable_virtual_menu_support", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSetControllerSourceMode>): CMsgSetControllerSourceMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSetControllerSourceMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSetControllerSourceMode): CMsgSetControllerSourceMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string action_set_key */ 1:
                    message.actionSetKey = reader.string();
                    break;
                case /* optional string action_set_layer_key */ 2:
                    message.actionSetLayerKey = reader.string();
                    break;
                case /* optional int32 source_binding_key */ 3:
                    message.sourceBindingKey = reader.int32();
                    break;
                case /* optional bool mode_shift */ 4:
                    message.modeShift = reader.bool();
                    break;
                case /* optional int32 new_mode */ 5:
                    message.newMode = reader.int32();
                    break;
                case /* optional CMsgControllerInputGameActionBinding new_game_action */ 6:
                    message.newGameAction = CMsgControllerInputGameActionBinding.internalBinaryRead(reader, reader.uint32(), options, message.newGameAction);
                    break;
                case /* optional CMsgControllerSetting new_setting */ 7:
                    message.newSetting = CMsgControllerSetting.internalBinaryRead(reader, reader.uint32(), options, message.newSetting);
                    break;
                case /* optional string new_name */ 8:
                    message.newName = reader.string();
                    break;
                case /* optional uint32 modeid */ 9:
                    message.modeid = reader.uint32();
                    break;
                case /* optional bool change_mode */ 10:
                    message.changeMode = reader.bool();
                    break;
                case /* optional bool new_virtual_menu */ 11:
                    message.newVirtualMenu = reader.bool();
                    break;
                case /* optional bool enable_virtual_menu_support */ 12:
                    message.enableVirtualMenuSupport = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSetControllerSourceMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string action_set_key = 1; */
        if (message.actionSetKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.actionSetKey);
        /* optional string action_set_layer_key = 2; */
        if (message.actionSetLayerKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionSetLayerKey);
        /* optional int32 source_binding_key = 3; */
        if (message.sourceBindingKey !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sourceBindingKey);
        /* optional bool mode_shift = 4; */
        if (message.modeShift !== undefined)
            writer.tag(4, WireType.Varint).bool(message.modeShift);
        /* optional int32 new_mode = 5; */
        if (message.newMode !== undefined)
            writer.tag(5, WireType.Varint).int32(message.newMode);
        /* optional CMsgControllerInputGameActionBinding new_game_action = 6; */
        if (message.newGameAction)
            CMsgControllerInputGameActionBinding.internalBinaryWrite(message.newGameAction, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgControllerSetting new_setting = 7; */
        if (message.newSetting)
            CMsgControllerSetting.internalBinaryWrite(message.newSetting, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional string new_name = 8; */
        if (message.newName !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.newName);
        /* optional uint32 modeid = 9; */
        if (message.modeid !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.modeid);
        /* optional bool change_mode = 10; */
        if (message.changeMode !== undefined)
            writer.tag(10, WireType.Varint).bool(message.changeMode);
        /* optional bool new_virtual_menu = 11; */
        if (message.newVirtualMenu !== undefined)
            writer.tag(11, WireType.Varint).bool(message.newVirtualMenu);
        /* optional bool enable_virtual_menu_support = 12; */
        if (message.enableVirtualMenuSupport !== undefined)
            writer.tag(12, WireType.Varint).bool(message.enableVirtualMenuSupport);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSetControllerSourceMode
 */
export const CMsgSetControllerSourceMode = new CMsgSetControllerSourceMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSetModeShiftButton$Type extends MessageType<CMsgSetModeShiftButton> {
    constructor() {
        super("CMsgSetModeShiftButton", [
            { no: 1, name: "action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action_set_layer_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "modeid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "source", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 5, name: "mode_shift_buttons_digital_io", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgSetModeShiftButton>): CMsgSetModeShiftButton {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.modeShiftButtonsDigitalIo = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSetModeShiftButton>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSetModeShiftButton): CMsgSetModeShiftButton {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string action_set_key */ 1:
                    message.actionSetKey = reader.string();
                    break;
                case /* optional string action_set_layer_key */ 2:
                    message.actionSetLayerKey = reader.string();
                    break;
                case /* optional int32 modeid */ 3:
                    message.modeid = reader.int32();
                    break;
                case /* optional int32 source */ 4:
                    message.source = reader.int32();
                    break;
                case /* repeated int32 mode_shift_buttons_digital_io */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.modeShiftButtonsDigitalIo.push(reader.int32());
                    else
                        message.modeShiftButtonsDigitalIo.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSetModeShiftButton, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string action_set_key = 1; */
        if (message.actionSetKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.actionSetKey);
        /* optional string action_set_layer_key = 2; */
        if (message.actionSetLayerKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionSetLayerKey);
        /* optional int32 modeid = 3; */
        if (message.modeid !== undefined)
            writer.tag(3, WireType.Varint).int32(message.modeid);
        /* optional int32 source = 4; */
        if (message.source !== undefined)
            writer.tag(4, WireType.Varint).int32(message.source);
        /* repeated int32 mode_shift_buttons_digital_io = 5; */
        for (let i = 0; i < message.modeShiftButtonsDigitalIo.length; i++)
            writer.tag(5, WireType.Varint).int32(message.modeShiftButtonsDigitalIo[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSetModeShiftButton
 */
export const CMsgSetModeShiftButton = new CMsgSetModeShiftButton$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectionQuality$Type extends MessageType<CMsgSteamDatagramConnectionQuality> {
    constructor() {
        super("CMsgSteamDatagramConnectionQuality", [
            { no: 1, name: "instantaneous", kind: "message", T: () => CMsgSteamDatagramLinkInstantaneousStats },
            { no: 2, name: "lifetime", kind: "message", T: () => CMsgSteamDatagramLinkLifetimeStats }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectionQuality>): CMsgSteamDatagramConnectionQuality {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectionQuality>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectionQuality): CMsgSteamDatagramConnectionQuality {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramLinkInstantaneousStats instantaneous */ 1:
                    message.instantaneous = CMsgSteamDatagramLinkInstantaneousStats.internalBinaryRead(reader, reader.uint32(), options, message.instantaneous);
                    break;
                case /* optional CMsgSteamDatagramLinkLifetimeStats lifetime */ 2:
                    message.lifetime = CMsgSteamDatagramLinkLifetimeStats.internalBinaryRead(reader, reader.uint32(), options, message.lifetime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectionQuality, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramLinkInstantaneousStats instantaneous = 1; */
        if (message.instantaneous)
            CMsgSteamDatagramLinkInstantaneousStats.internalBinaryWrite(message.instantaneous, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramLinkLifetimeStats lifetime = 2; */
        if (message.lifetime)
            CMsgSteamDatagramLinkLifetimeStats.internalBinaryWrite(message.lifetime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectionQuality
 */
export const CMsgSteamDatagramConnectionQuality = new CMsgSteamDatagramConnectionQuality$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramLinkInstantaneousStats$Type extends MessageType<CMsgSteamDatagramLinkInstantaneousStats> {
    constructor() {
        super("CMsgSteamDatagramLinkInstantaneousStats", [
            { no: 1, name: "out_packets_per_sec_x10", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "out_bytes_per_sec", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "in_packets_per_sec_x10", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "in_bytes_per_sec", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "packets_dropped_pct", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "packets_weird_sequence_pct", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "peak_jitter_usec", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramLinkInstantaneousStats>): CMsgSteamDatagramLinkInstantaneousStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramLinkInstantaneousStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramLinkInstantaneousStats): CMsgSteamDatagramLinkInstantaneousStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 out_packets_per_sec_x10 */ 1:
                    message.outPacketsPerSecX10 = reader.uint32();
                    break;
                case /* optional uint32 out_bytes_per_sec */ 2:
                    message.outBytesPerSec = reader.uint32();
                    break;
                case /* optional uint32 in_packets_per_sec_x10 */ 3:
                    message.inPacketsPerSecX10 = reader.uint32();
                    break;
                case /* optional uint32 in_bytes_per_sec */ 4:
                    message.inBytesPerSec = reader.uint32();
                    break;
                case /* optional uint32 ping_ms */ 5:
                    message.pingMs = reader.uint32();
                    break;
                case /* optional uint32 packets_dropped_pct */ 6:
                    message.packetsDroppedPct = reader.uint32();
                    break;
                case /* optional uint32 packets_weird_sequence_pct */ 7:
                    message.packetsWeirdSequencePct = reader.uint32();
                    break;
                case /* optional uint32 peak_jitter_usec */ 8:
                    message.peakJitterUsec = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramLinkInstantaneousStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 out_packets_per_sec_x10 = 1; */
        if (message.outPacketsPerSecX10 !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.outPacketsPerSecX10);
        /* optional uint32 out_bytes_per_sec = 2; */
        if (message.outBytesPerSec !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.outBytesPerSec);
        /* optional uint32 in_packets_per_sec_x10 = 3; */
        if (message.inPacketsPerSecX10 !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.inPacketsPerSecX10);
        /* optional uint32 in_bytes_per_sec = 4; */
        if (message.inBytesPerSec !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.inBytesPerSec);
        /* optional uint32 ping_ms = 5; */
        if (message.pingMs !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.pingMs);
        /* optional uint32 packets_dropped_pct = 6; */
        if (message.packetsDroppedPct !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.packetsDroppedPct);
        /* optional uint32 packets_weird_sequence_pct = 7; */
        if (message.packetsWeirdSequencePct !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.packetsWeirdSequencePct);
        /* optional uint32 peak_jitter_usec = 8; */
        if (message.peakJitterUsec !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.peakJitterUsec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramLinkInstantaneousStats
 */
export const CMsgSteamDatagramLinkInstantaneousStats = new CMsgSteamDatagramLinkInstantaneousStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramLinkLifetimeStats$Type extends MessageType<CMsgSteamDatagramLinkLifetimeStats> {
    constructor() {
        super("CMsgSteamDatagramLinkLifetimeStats", [
            { no: 2, name: "connected_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "packets_sent", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "kb_sent", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "packets_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "kb_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "packets_recv_sequenced", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "packets_recv_dropped", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "packets_recv_out_of_order", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "packets_recv_duplicate", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "packets_recv_lurch", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "multipath_packets_recv_sequenced", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "multipath_packets_recv_later", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "multipath_send_enabled", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "packets_recv_out_of_order_corrected", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "quality_histogram_100", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "quality_histogram_99", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "quality_histogram_97", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 24, name: "quality_histogram_95", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "quality_histogram_90", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "quality_histogram_75", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 27, name: "quality_histogram_50", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 28, name: "quality_histogram_1", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 29, name: "quality_histogram_dead", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 30, name: "quality_ntile_2nd", kind: "scalar", jsonName: "qualityNtile2nd", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 31, name: "quality_ntile_5th", kind: "scalar", jsonName: "qualityNtile5th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 32, name: "quality_ntile_25th", kind: "scalar", jsonName: "qualityNtile25th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 33, name: "quality_ntile_50th", kind: "scalar", jsonName: "qualityNtile50th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 41, name: "ping_histogram_25", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 42, name: "ping_histogram_50", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 43, name: "ping_histogram_75", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 44, name: "ping_histogram_100", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 45, name: "ping_histogram_125", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 46, name: "ping_histogram_150", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 47, name: "ping_histogram_200", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 48, name: "ping_histogram_300", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 49, name: "ping_histogram_max", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 50, name: "ping_ntile_5th", kind: "scalar", jsonName: "pingNtile5th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 51, name: "ping_ntile_50th", kind: "scalar", jsonName: "pingNtile50th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 52, name: "ping_ntile_75th", kind: "scalar", jsonName: "pingNtile75th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 53, name: "ping_ntile_95th", kind: "scalar", jsonName: "pingNtile95th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 54, name: "ping_ntile_98th", kind: "scalar", jsonName: "pingNtile98th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 61, name: "jitter_histogram_negligible", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 62, name: "jitter_histogram_1", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 63, name: "jitter_histogram_2", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 64, name: "jitter_histogram_5", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 65, name: "jitter_histogram_10", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 66, name: "jitter_histogram_20", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramLinkLifetimeStats>): CMsgSteamDatagramLinkLifetimeStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.multipathPacketsRecvSequenced = [];
        message.multipathPacketsRecvLater = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramLinkLifetimeStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramLinkLifetimeStats): CMsgSteamDatagramLinkLifetimeStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 connected_seconds */ 2:
                    message.connectedSeconds = reader.uint32();
                    break;
                case /* optional uint64 packets_sent */ 3:
                    message.packetsSent = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 kb_sent */ 4:
                    message.kbSent = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv */ 5:
                    message.packetsRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 kb_recv */ 6:
                    message.kbRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_sequenced */ 7:
                    message.packetsRecvSequenced = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_dropped */ 8:
                    message.packetsRecvDropped = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_out_of_order */ 9:
                    message.packetsRecvOutOfOrder = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_duplicate */ 10:
                    message.packetsRecvDuplicate = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_lurch */ 11:
                    message.packetsRecvLurch = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 multipath_packets_recv_sequenced */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.multipathPacketsRecvSequenced.push(reader.uint64().toBigInt());
                    else
                        message.multipathPacketsRecvSequenced.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint64 multipath_packets_recv_later */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.multipathPacketsRecvLater.push(reader.uint64().toBigInt());
                    else
                        message.multipathPacketsRecvLater.push(reader.uint64().toBigInt());
                    break;
                case /* optional uint32 multipath_send_enabled */ 14:
                    message.multipathSendEnabled = reader.uint32();
                    break;
                case /* optional uint64 packets_recv_out_of_order_corrected */ 15:
                    message.packetsRecvOutOfOrderCorrected = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 quality_histogram_100 */ 21:
                    message.qualityHistogram100 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_99 */ 22:
                    message.qualityHistogram99 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_97 */ 23:
                    message.qualityHistogram97 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_95 */ 24:
                    message.qualityHistogram95 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_90 */ 25:
                    message.qualityHistogram90 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_75 */ 26:
                    message.qualityHistogram75 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_50 */ 27:
                    message.qualityHistogram50 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_1 */ 28:
                    message.qualityHistogram1 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_dead */ 29:
                    message.qualityHistogramDead = reader.uint32();
                    break;
                case /* optional uint32 quality_ntile_2nd */ 30:
                    message.qualityNtile2Nd = reader.uint32();
                    break;
                case /* optional uint32 quality_ntile_5th */ 31:
                    message.qualityNtile5Th = reader.uint32();
                    break;
                case /* optional uint32 quality_ntile_25th */ 32:
                    message.qualityNtile25Th = reader.uint32();
                    break;
                case /* optional uint32 quality_ntile_50th */ 33:
                    message.qualityNtile50Th = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_25 */ 41:
                    message.pingHistogram25 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_50 */ 42:
                    message.pingHistogram50 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_75 */ 43:
                    message.pingHistogram75 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_100 */ 44:
                    message.pingHistogram100 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_125 */ 45:
                    message.pingHistogram125 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_150 */ 46:
                    message.pingHistogram150 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_200 */ 47:
                    message.pingHistogram200 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_300 */ 48:
                    message.pingHistogram300 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_max */ 49:
                    message.pingHistogramMax = reader.uint32();
                    break;
                case /* optional uint32 ping_ntile_5th */ 50:
                    message.pingNtile5Th = reader.uint32();
                    break;
                case /* optional uint32 ping_ntile_50th */ 51:
                    message.pingNtile50Th = reader.uint32();
                    break;
                case /* optional uint32 ping_ntile_75th */ 52:
                    message.pingNtile75Th = reader.uint32();
                    break;
                case /* optional uint32 ping_ntile_95th */ 53:
                    message.pingNtile95Th = reader.uint32();
                    break;
                case /* optional uint32 ping_ntile_98th */ 54:
                    message.pingNtile98Th = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_negligible */ 61:
                    message.jitterHistogramNegligible = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_1 */ 62:
                    message.jitterHistogram1 = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_2 */ 63:
                    message.jitterHistogram2 = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_5 */ 64:
                    message.jitterHistogram5 = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_10 */ 65:
                    message.jitterHistogram10 = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_20 */ 66:
                    message.jitterHistogram20 = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramLinkLifetimeStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 connected_seconds = 2; */
        if (message.connectedSeconds !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.connectedSeconds);
        /* optional uint64 packets_sent = 3; */
        if (message.packetsSent !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.packetsSent);
        /* optional uint64 kb_sent = 4; */
        if (message.kbSent !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.kbSent);
        /* optional uint64 packets_recv = 5; */
        if (message.packetsRecv !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.packetsRecv);
        /* optional uint64 kb_recv = 6; */
        if (message.kbRecv !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.kbRecv);
        /* optional uint64 packets_recv_sequenced = 7; */
        if (message.packetsRecvSequenced !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.packetsRecvSequenced);
        /* optional uint64 packets_recv_dropped = 8; */
        if (message.packetsRecvDropped !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.packetsRecvDropped);
        /* optional uint64 packets_recv_out_of_order = 9; */
        if (message.packetsRecvOutOfOrder !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.packetsRecvOutOfOrder);
        /* optional uint64 packets_recv_duplicate = 10; */
        if (message.packetsRecvDuplicate !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.packetsRecvDuplicate);
        /* optional uint64 packets_recv_lurch = 11; */
        if (message.packetsRecvLurch !== undefined)
            writer.tag(11, WireType.Varint).uint64(message.packetsRecvLurch);
        /* repeated uint64 multipath_packets_recv_sequenced = 12; */
        for (let i = 0; i < message.multipathPacketsRecvSequenced.length; i++)
            writer.tag(12, WireType.Varint).uint64(message.multipathPacketsRecvSequenced[i]);
        /* repeated uint64 multipath_packets_recv_later = 13; */
        for (let i = 0; i < message.multipathPacketsRecvLater.length; i++)
            writer.tag(13, WireType.Varint).uint64(message.multipathPacketsRecvLater[i]);
        /* optional uint32 multipath_send_enabled = 14; */
        if (message.multipathSendEnabled !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.multipathSendEnabled);
        /* optional uint64 packets_recv_out_of_order_corrected = 15; */
        if (message.packetsRecvOutOfOrderCorrected !== undefined)
            writer.tag(15, WireType.Varint).uint64(message.packetsRecvOutOfOrderCorrected);
        /* optional uint32 quality_histogram_100 = 21; */
        if (message.qualityHistogram100 !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.qualityHistogram100);
        /* optional uint32 quality_histogram_99 = 22; */
        if (message.qualityHistogram99 !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.qualityHistogram99);
        /* optional uint32 quality_histogram_97 = 23; */
        if (message.qualityHistogram97 !== undefined)
            writer.tag(23, WireType.Varint).uint32(message.qualityHistogram97);
        /* optional uint32 quality_histogram_95 = 24; */
        if (message.qualityHistogram95 !== undefined)
            writer.tag(24, WireType.Varint).uint32(message.qualityHistogram95);
        /* optional uint32 quality_histogram_90 = 25; */
        if (message.qualityHistogram90 !== undefined)
            writer.tag(25, WireType.Varint).uint32(message.qualityHistogram90);
        /* optional uint32 quality_histogram_75 = 26; */
        if (message.qualityHistogram75 !== undefined)
            writer.tag(26, WireType.Varint).uint32(message.qualityHistogram75);
        /* optional uint32 quality_histogram_50 = 27; */
        if (message.qualityHistogram50 !== undefined)
            writer.tag(27, WireType.Varint).uint32(message.qualityHistogram50);
        /* optional uint32 quality_histogram_1 = 28; */
        if (message.qualityHistogram1 !== undefined)
            writer.tag(28, WireType.Varint).uint32(message.qualityHistogram1);
        /* optional uint32 quality_histogram_dead = 29; */
        if (message.qualityHistogramDead !== undefined)
            writer.tag(29, WireType.Varint).uint32(message.qualityHistogramDead);
        /* optional uint32 quality_ntile_2nd = 30; */
        if (message.qualityNtile2Nd !== undefined)
            writer.tag(30, WireType.Varint).uint32(message.qualityNtile2Nd);
        /* optional uint32 quality_ntile_5th = 31; */
        if (message.qualityNtile5Th !== undefined)
            writer.tag(31, WireType.Varint).uint32(message.qualityNtile5Th);
        /* optional uint32 quality_ntile_25th = 32; */
        if (message.qualityNtile25Th !== undefined)
            writer.tag(32, WireType.Varint).uint32(message.qualityNtile25Th);
        /* optional uint32 quality_ntile_50th = 33; */
        if (message.qualityNtile50Th !== undefined)
            writer.tag(33, WireType.Varint).uint32(message.qualityNtile50Th);
        /* optional uint32 ping_histogram_25 = 41; */
        if (message.pingHistogram25 !== undefined)
            writer.tag(41, WireType.Varint).uint32(message.pingHistogram25);
        /* optional uint32 ping_histogram_50 = 42; */
        if (message.pingHistogram50 !== undefined)
            writer.tag(42, WireType.Varint).uint32(message.pingHistogram50);
        /* optional uint32 ping_histogram_75 = 43; */
        if (message.pingHistogram75 !== undefined)
            writer.tag(43, WireType.Varint).uint32(message.pingHistogram75);
        /* optional uint32 ping_histogram_100 = 44; */
        if (message.pingHistogram100 !== undefined)
            writer.tag(44, WireType.Varint).uint32(message.pingHistogram100);
        /* optional uint32 ping_histogram_125 = 45; */
        if (message.pingHistogram125 !== undefined)
            writer.tag(45, WireType.Varint).uint32(message.pingHistogram125);
        /* optional uint32 ping_histogram_150 = 46; */
        if (message.pingHistogram150 !== undefined)
            writer.tag(46, WireType.Varint).uint32(message.pingHistogram150);
        /* optional uint32 ping_histogram_200 = 47; */
        if (message.pingHistogram200 !== undefined)
            writer.tag(47, WireType.Varint).uint32(message.pingHistogram200);
        /* optional uint32 ping_histogram_300 = 48; */
        if (message.pingHistogram300 !== undefined)
            writer.tag(48, WireType.Varint).uint32(message.pingHistogram300);
        /* optional uint32 ping_histogram_max = 49; */
        if (message.pingHistogramMax !== undefined)
            writer.tag(49, WireType.Varint).uint32(message.pingHistogramMax);
        /* optional uint32 ping_ntile_5th = 50; */
        if (message.pingNtile5Th !== undefined)
            writer.tag(50, WireType.Varint).uint32(message.pingNtile5Th);
        /* optional uint32 ping_ntile_50th = 51; */
        if (message.pingNtile50Th !== undefined)
            writer.tag(51, WireType.Varint).uint32(message.pingNtile50Th);
        /* optional uint32 ping_ntile_75th = 52; */
        if (message.pingNtile75Th !== undefined)
            writer.tag(52, WireType.Varint).uint32(message.pingNtile75Th);
        /* optional uint32 ping_ntile_95th = 53; */
        if (message.pingNtile95Th !== undefined)
            writer.tag(53, WireType.Varint).uint32(message.pingNtile95Th);
        /* optional uint32 ping_ntile_98th = 54; */
        if (message.pingNtile98Th !== undefined)
            writer.tag(54, WireType.Varint).uint32(message.pingNtile98Th);
        /* optional uint32 jitter_histogram_negligible = 61; */
        if (message.jitterHistogramNegligible !== undefined)
            writer.tag(61, WireType.Varint).uint32(message.jitterHistogramNegligible);
        /* optional uint32 jitter_histogram_1 = 62; */
        if (message.jitterHistogram1 !== undefined)
            writer.tag(62, WireType.Varint).uint32(message.jitterHistogram1);
        /* optional uint32 jitter_histogram_2 = 63; */
        if (message.jitterHistogram2 !== undefined)
            writer.tag(63, WireType.Varint).uint32(message.jitterHistogram2);
        /* optional uint32 jitter_histogram_5 = 64; */
        if (message.jitterHistogram5 !== undefined)
            writer.tag(64, WireType.Varint).uint32(message.jitterHistogram5);
        /* optional uint32 jitter_histogram_10 = 65; */
        if (message.jitterHistogram10 !== undefined)
            writer.tag(65, WireType.Varint).uint32(message.jitterHistogram10);
        /* optional uint32 jitter_histogram_20 = 66; */
        if (message.jitterHistogram20 !== undefined)
            writer.tag(66, WireType.Varint).uint32(message.jitterHistogram20);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramLinkLifetimeStats
 */
export const CMsgSteamDatagramLinkLifetimeStats = new CMsgSteamDatagramLinkLifetimeStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramP2PRoutingSummary$Type extends MessageType<CMsgSteamDatagramP2PRoutingSummary> {
    constructor() {
        super("CMsgSteamDatagramP2PRoutingSummary", [
            { no: 2, name: "ice", kind: "message", T: () => CMsgSteamNetworkingICESessionSummary },
            { no: 3, name: "sdr", kind: "message", T: () => CMsgSteamNetworkingP2PSDRRoutingSummary }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramP2PRoutingSummary>): CMsgSteamDatagramP2PRoutingSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramP2PRoutingSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramP2PRoutingSummary): CMsgSteamDatagramP2PRoutingSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamNetworkingICESessionSummary ice */ 2:
                    message.ice = CMsgSteamNetworkingICESessionSummary.internalBinaryRead(reader, reader.uint32(), options, message.ice);
                    break;
                case /* optional CMsgSteamNetworkingP2PSDRRoutingSummary sdr */ 3:
                    message.sdr = CMsgSteamNetworkingP2PSDRRoutingSummary.internalBinaryRead(reader, reader.uint32(), options, message.sdr);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramP2PRoutingSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamNetworkingICESessionSummary ice = 2; */
        if (message.ice)
            CMsgSteamNetworkingICESessionSummary.internalBinaryWrite(message.ice, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamNetworkingP2PSDRRoutingSummary sdr = 3; */
        if (message.sdr)
            CMsgSteamNetworkingP2PSDRRoutingSummary.internalBinaryWrite(message.sdr, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramP2PRoutingSummary
 */
export const CMsgSteamDatagramP2PRoutingSummary = new CMsgSteamDatagramP2PRoutingSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingICESessionSummary$Type extends MessageType<CMsgSteamNetworkingICESessionSummary> {
    constructor() {
        super("CMsgSteamNetworkingICESessionSummary", [
            { no: 1, name: "local_candidate_types", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "remote_candidate_types", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "initial_route_kind", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "initial_ping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "negotiation_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "initial_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "failure_reason_code", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "selected_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "user_settings", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "ice_enable_var", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "local_candidate_types_allowed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "best_route_kind", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "best_ping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "best_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "best_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingICESessionSummary>): CMsgSteamNetworkingICESessionSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingICESessionSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingICESessionSummary): CMsgSteamNetworkingICESessionSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 local_candidate_types */ 1:
                    message.localCandidateTypes = reader.uint32();
                    break;
                case /* optional uint32 remote_candidate_types */ 2:
                    message.remoteCandidateTypes = reader.uint32();
                    break;
                case /* optional uint32 initial_route_kind */ 3:
                    message.initialRouteKind = reader.uint32();
                    break;
                case /* optional uint32 initial_ping */ 4:
                    message.initialPing = reader.uint32();
                    break;
                case /* optional uint32 negotiation_ms */ 5:
                    message.negotiationMs = reader.uint32();
                    break;
                case /* optional uint32 initial_score */ 6:
                    message.initialScore = reader.uint32();
                    break;
                case /* optional uint32 failure_reason_code */ 7:
                    message.failureReasonCode = reader.uint32();
                    break;
                case /* optional uint32 selected_seconds */ 12:
                    message.selectedSeconds = reader.uint32();
                    break;
                case /* optional uint32 user_settings */ 13:
                    message.userSettings = reader.uint32();
                    break;
                case /* optional uint32 ice_enable_var */ 14:
                    message.iceEnableVar = reader.uint32();
                    break;
                case /* optional uint32 local_candidate_types_allowed */ 15:
                    message.localCandidateTypesAllowed = reader.uint32();
                    break;
                case /* optional uint32 best_route_kind */ 16:
                    message.bestRouteKind = reader.uint32();
                    break;
                case /* optional uint32 best_ping */ 17:
                    message.bestPing = reader.uint32();
                    break;
                case /* optional uint32 best_score */ 18:
                    message.bestScore = reader.uint32();
                    break;
                case /* optional uint32 best_time */ 19:
                    message.bestTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingICESessionSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 local_candidate_types = 1; */
        if (message.localCandidateTypes !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.localCandidateTypes);
        /* optional uint32 remote_candidate_types = 2; */
        if (message.remoteCandidateTypes !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.remoteCandidateTypes);
        /* optional uint32 initial_route_kind = 3; */
        if (message.initialRouteKind !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.initialRouteKind);
        /* optional uint32 initial_ping = 4; */
        if (message.initialPing !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.initialPing);
        /* optional uint32 negotiation_ms = 5; */
        if (message.negotiationMs !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.negotiationMs);
        /* optional uint32 initial_score = 6; */
        if (message.initialScore !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.initialScore);
        /* optional uint32 failure_reason_code = 7; */
        if (message.failureReasonCode !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.failureReasonCode);
        /* optional uint32 selected_seconds = 12; */
        if (message.selectedSeconds !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.selectedSeconds);
        /* optional uint32 user_settings = 13; */
        if (message.userSettings !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.userSettings);
        /* optional uint32 ice_enable_var = 14; */
        if (message.iceEnableVar !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.iceEnableVar);
        /* optional uint32 local_candidate_types_allowed = 15; */
        if (message.localCandidateTypesAllowed !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.localCandidateTypesAllowed);
        /* optional uint32 best_route_kind = 16; */
        if (message.bestRouteKind !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.bestRouteKind);
        /* optional uint32 best_ping = 17; */
        if (message.bestPing !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.bestPing);
        /* optional uint32 best_score = 18; */
        if (message.bestScore !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.bestScore);
        /* optional uint32 best_time = 19; */
        if (message.bestTime !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.bestTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingICESessionSummary
 */
export const CMsgSteamNetworkingICESessionSummary = new CMsgSteamNetworkingICESessionSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PSDRRoutingSummary$Type extends MessageType<CMsgSteamNetworkingP2PSDRRoutingSummary> {
    constructor() {
        super("CMsgSteamNetworkingP2PSDRRoutingSummary", [
            { no: 1, name: "initial_ping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "initial_ping_front_local", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "initial_ping_front_remote", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "initial_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "initial_pop_local", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "initial_pop_remote", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 7, name: "negotiation_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "selected_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "best_ping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "best_ping_front_local", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "best_ping_front_remote", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "best_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "best_pop_local", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 16, name: "best_pop_remote", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 17, name: "best_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingP2PSDRRoutingSummary>): CMsgSteamNetworkingP2PSDRRoutingSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingP2PSDRRoutingSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingP2PSDRRoutingSummary): CMsgSteamNetworkingP2PSDRRoutingSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 initial_ping */ 1:
                    message.initialPing = reader.uint32();
                    break;
                case /* optional uint32 initial_ping_front_local */ 2:
                    message.initialPingFrontLocal = reader.uint32();
                    break;
                case /* optional uint32 initial_ping_front_remote */ 3:
                    message.initialPingFrontRemote = reader.uint32();
                    break;
                case /* optional uint32 initial_score */ 4:
                    message.initialScore = reader.uint32();
                    break;
                case /* optional fixed32 initial_pop_local */ 5:
                    message.initialPopLocal = reader.fixed32();
                    break;
                case /* optional fixed32 initial_pop_remote */ 6:
                    message.initialPopRemote = reader.fixed32();
                    break;
                case /* optional uint32 negotiation_ms */ 7:
                    message.negotiationMs = reader.uint32();
                    break;
                case /* optional uint32 selected_seconds */ 8:
                    message.selectedSeconds = reader.uint32();
                    break;
                case /* optional uint32 best_ping */ 11:
                    message.bestPing = reader.uint32();
                    break;
                case /* optional uint32 best_ping_front_local */ 12:
                    message.bestPingFrontLocal = reader.uint32();
                    break;
                case /* optional uint32 best_ping_front_remote */ 13:
                    message.bestPingFrontRemote = reader.uint32();
                    break;
                case /* optional uint32 best_score */ 14:
                    message.bestScore = reader.uint32();
                    break;
                case /* optional fixed32 best_pop_local */ 15:
                    message.bestPopLocal = reader.fixed32();
                    break;
                case /* optional fixed32 best_pop_remote */ 16:
                    message.bestPopRemote = reader.fixed32();
                    break;
                case /* optional uint32 best_time */ 17:
                    message.bestTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingP2PSDRRoutingSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 initial_ping = 1; */
        if (message.initialPing !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.initialPing);
        /* optional uint32 initial_ping_front_local = 2; */
        if (message.initialPingFrontLocal !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.initialPingFrontLocal);
        /* optional uint32 initial_ping_front_remote = 3; */
        if (message.initialPingFrontRemote !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.initialPingFrontRemote);
        /* optional uint32 initial_score = 4; */
        if (message.initialScore !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.initialScore);
        /* optional fixed32 initial_pop_local = 5; */
        if (message.initialPopLocal !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.initialPopLocal);
        /* optional fixed32 initial_pop_remote = 6; */
        if (message.initialPopRemote !== undefined)
            writer.tag(6, WireType.Bit32).fixed32(message.initialPopRemote);
        /* optional uint32 negotiation_ms = 7; */
        if (message.negotiationMs !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.negotiationMs);
        /* optional uint32 selected_seconds = 8; */
        if (message.selectedSeconds !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.selectedSeconds);
        /* optional uint32 best_ping = 11; */
        if (message.bestPing !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.bestPing);
        /* optional uint32 best_ping_front_local = 12; */
        if (message.bestPingFrontLocal !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.bestPingFrontLocal);
        /* optional uint32 best_ping_front_remote = 13; */
        if (message.bestPingFrontRemote !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.bestPingFrontRemote);
        /* optional uint32 best_score = 14; */
        if (message.bestScore !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.bestScore);
        /* optional fixed32 best_pop_local = 15; */
        if (message.bestPopLocal !== undefined)
            writer.tag(15, WireType.Bit32).fixed32(message.bestPopLocal);
        /* optional fixed32 best_pop_remote = 16; */
        if (message.bestPopRemote !== undefined)
            writer.tag(16, WireType.Bit32).fixed32(message.bestPopRemote);
        /* optional uint32 best_time = 17; */
        if (message.bestTime !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.bestTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PSDRRoutingSummary
 */
export const CMsgSteamNetworkingP2PSDRRoutingSummary = new CMsgSteamNetworkingP2PSDRRoutingSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSwapControllerSourceModes$Type extends MessageType<CMsgSwapControllerSourceModes> {
    constructor() {
        super("CMsgSwapControllerSourceModes", [
            { no: 1, name: "action_set_key_a", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action_set_layer_key_a", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "source_a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "action_set_key_b", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "action_set_layer_key_b", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "source_b", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgSwapControllerSourceModes>): CMsgSwapControllerSourceModes {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSwapControllerSourceModes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSwapControllerSourceModes): CMsgSwapControllerSourceModes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string action_set_key_a */ 1:
                    message.actionSetKeyA = reader.string();
                    break;
                case /* optional string action_set_layer_key_a */ 2:
                    message.actionSetLayerKeyA = reader.string();
                    break;
                case /* optional int32 source_a */ 3:
                    message.sourceA = reader.int32();
                    break;
                case /* optional string action_set_key_b */ 4:
                    message.actionSetKeyB = reader.string();
                    break;
                case /* optional string action_set_layer_key_b */ 5:
                    message.actionSetLayerKeyB = reader.string();
                    break;
                case /* optional int32 source_b */ 6:
                    message.sourceB = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSwapControllerSourceModes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string action_set_key_a = 1; */
        if (message.actionSetKeyA !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.actionSetKeyA);
        /* optional string action_set_layer_key_a = 2; */
        if (message.actionSetLayerKeyA !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionSetLayerKeyA);
        /* optional int32 source_a = 3; */
        if (message.sourceA !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sourceA);
        /* optional string action_set_key_b = 4; */
        if (message.actionSetKeyB !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.actionSetKeyB);
        /* optional string action_set_layer_key_b = 5; */
        if (message.actionSetLayerKeyB !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.actionSetLayerKeyB);
        /* optional int32 source_b = 6; */
        if (message.sourceB !== undefined)
            writer.tag(6, WireType.Varint).int32(message.sourceB);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSwapControllerSourceModes
 */
export const CMsgSwapControllerSourceModes = new CMsgSwapControllerSourceModes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSwapModeInputBindings$Type extends MessageType<CMsgSwapModeInputBindings> {
    constructor() {
        super("CMsgSwapModeInputBindings", [
            { no: 1, name: "action_set_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action_set_layer_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "source_binding_key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "mode_shift", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "modeid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "swaps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSwapModeInputBindings_CModeInputSwap }
        ]);
    }
    create(value?: PartialMessage<CMsgSwapModeInputBindings>): CMsgSwapModeInputBindings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.swaps = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSwapModeInputBindings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSwapModeInputBindings): CMsgSwapModeInputBindings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string action_set_key */ 1:
                    message.actionSetKey = reader.string();
                    break;
                case /* optional string action_set_layer_key */ 2:
                    message.actionSetLayerKey = reader.string();
                    break;
                case /* optional int32 source_binding_key */ 3:
                    message.sourceBindingKey = reader.int32();
                    break;
                case /* optional bool mode_shift */ 4:
                    message.modeShift = reader.bool();
                    break;
                case /* optional int32 modeid */ 5:
                    message.modeid = reader.int32();
                    break;
                case /* repeated CMsgSwapModeInputBindings_CModeInputSwap swaps */ 6:
                    message.swaps.push(CMsgSwapModeInputBindings_CModeInputSwap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSwapModeInputBindings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string action_set_key = 1; */
        if (message.actionSetKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.actionSetKey);
        /* optional string action_set_layer_key = 2; */
        if (message.actionSetLayerKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.actionSetLayerKey);
        /* optional int32 source_binding_key = 3; */
        if (message.sourceBindingKey !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sourceBindingKey);
        /* optional bool mode_shift = 4; */
        if (message.modeShift !== undefined)
            writer.tag(4, WireType.Varint).bool(message.modeShift);
        /* optional int32 modeid = 5; */
        if (message.modeid !== undefined)
            writer.tag(5, WireType.Varint).int32(message.modeid);
        /* repeated CMsgSwapModeInputBindings_CModeInputSwap swaps = 6; */
        for (let i = 0; i < message.swaps.length; i++)
            CMsgSwapModeInputBindings_CModeInputSwap.internalBinaryWrite(message.swaps[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSwapModeInputBindings
 */
export const CMsgSwapModeInputBindings = new CMsgSwapModeInputBindings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSwapModeInputBindings_CModeInputSwap$Type extends MessageType<CMsgSwapModeInputBindings_CModeInputSwap> {
    constructor() {
        super("CMsgSwapModeInputBindings_CModeInputSwap", [
            { no: 1, name: "old_key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "new_key", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgSwapModeInputBindings_CModeInputSwap>): CMsgSwapModeInputBindings_CModeInputSwap {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSwapModeInputBindings_CModeInputSwap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSwapModeInputBindings_CModeInputSwap): CMsgSwapModeInputBindings_CModeInputSwap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 old_key */ 1:
                    message.oldKey = reader.int32();
                    break;
                case /* optional int32 new_key */ 2:
                    message.newKey = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSwapModeInputBindings_CModeInputSwap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 old_key = 1; */
        if (message.oldKey !== undefined)
            writer.tag(1, WireType.Varint).int32(message.oldKey);
        /* optional int32 new_key = 2; */
        if (message.newKey !== undefined)
            writer.tag(2, WireType.Varint).int32(message.newKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSwapModeInputBindings_CModeInputSwap
 */
export const CMsgSwapModeInputBindings_CModeInputSwap = new CMsgSwapModeInputBindings_CModeInputSwap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemAudioManagerDevice$Type extends MessageType<CMsgSystemAudioManagerDevice> {
    constructor() {
        super("CMsgSystemAudioManagerDevice", [
            { no: 1, name: "base", kind: "message", T: () => CMsgSystemAudioManagerObject },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "nick", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "api", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemAudioManagerDevice>): CMsgSystemAudioManagerDevice {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemAudioManagerDevice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemAudioManagerDevice): CMsgSystemAudioManagerDevice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSystemAudioManagerObject base */ 1:
                    message.base = CMsgSystemAudioManagerObject.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string nick */ 3:
                    message.nick = reader.string();
                    break;
                case /* optional string description */ 4:
                    message.description = reader.string();
                    break;
                case /* optional string api */ 5:
                    message.api = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemAudioManagerDevice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSystemAudioManagerObject base = 1; */
        if (message.base)
            CMsgSystemAudioManagerObject.internalBinaryWrite(message.base, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string nick = 3; */
        if (message.nick !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.nick);
        /* optional string description = 4; */
        if (message.description !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* optional string api = 5; */
        if (message.api !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.api);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemAudioManagerDevice
 */
export const CMsgSystemAudioManagerDevice = new CMsgSystemAudioManagerDevice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemAudioManagerLink$Type extends MessageType<CMsgSystemAudioManagerLink> {
    constructor() {
        super("CMsgSystemAudioManagerLink", [
            { no: 1, name: "base", kind: "message", T: () => CMsgSystemAudioManagerObject },
            { no: 2, name: "output_node_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "output_port_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "input_node_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "input_port_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemAudioManagerLink>): CMsgSystemAudioManagerLink {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemAudioManagerLink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemAudioManagerLink): CMsgSystemAudioManagerLink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSystemAudioManagerObject base */ 1:
                    message.base = CMsgSystemAudioManagerObject.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                case /* optional uint32 output_node_id */ 2:
                    message.outputNodeId = reader.uint32();
                    break;
                case /* optional uint32 output_port_id */ 3:
                    message.outputPortId = reader.uint32();
                    break;
                case /* optional uint32 input_node_id */ 4:
                    message.inputNodeId = reader.uint32();
                    break;
                case /* optional uint32 input_port_id */ 5:
                    message.inputPortId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemAudioManagerLink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSystemAudioManagerObject base = 1; */
        if (message.base)
            CMsgSystemAudioManagerObject.internalBinaryWrite(message.base, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 output_node_id = 2; */
        if (message.outputNodeId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.outputNodeId);
        /* optional uint32 output_port_id = 3; */
        if (message.outputPortId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.outputPortId);
        /* optional uint32 input_node_id = 4; */
        if (message.inputNodeId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.inputNodeId);
        /* optional uint32 input_port_id = 5; */
        if (message.inputPortId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.inputPortId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemAudioManagerLink
 */
export const CMsgSystemAudioManagerLink = new CMsgSystemAudioManagerLink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemAudioManagerNode$Type extends MessageType<CMsgSystemAudioManagerNode> {
    constructor() {
        super("CMsgSystemAudioManagerNode", [
            { no: 1, name: "base", kind: "message", T: () => CMsgSystemAudioManagerObject },
            { no: 2, name: "device_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "nick", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "edirection", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 7, name: "volume", kind: "message", T: () => CMsgSystemAudioVolume }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemAudioManagerNode>): CMsgSystemAudioManagerNode {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemAudioManagerNode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemAudioManagerNode): CMsgSystemAudioManagerNode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSystemAudioManagerObject base */ 1:
                    message.base = CMsgSystemAudioManagerObject.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                case /* optional uint32 device_id */ 2:
                    message.deviceId = reader.uint32();
                    break;
                case /* optional string name */ 3:
                    message.name = reader.string();
                    break;
                case /* optional string nick */ 4:
                    message.nick = reader.string();
                    break;
                case /* optional string description */ 5:
                    message.description = reader.string();
                    break;
                case /* optional int32 edirection */ 6:
                    message.edirection = reader.int32();
                    break;
                case /* optional CMsgSystemAudioVolume volume */ 7:
                    message.volume = CMsgSystemAudioVolume.internalBinaryRead(reader, reader.uint32(), options, message.volume);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemAudioManagerNode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSystemAudioManagerObject base = 1; */
        if (message.base)
            CMsgSystemAudioManagerObject.internalBinaryWrite(message.base, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 device_id = 2; */
        if (message.deviceId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.deviceId);
        /* optional string name = 3; */
        if (message.name !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* optional string nick = 4; */
        if (message.nick !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.nick);
        /* optional string description = 5; */
        if (message.description !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        /* optional int32 edirection = 6; */
        if (message.edirection !== undefined)
            writer.tag(6, WireType.Varint).int32(message.edirection);
        /* optional CMsgSystemAudioVolume volume = 7; */
        if (message.volume)
            CMsgSystemAudioVolume.internalBinaryWrite(message.volume, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemAudioManagerNode
 */
export const CMsgSystemAudioManagerNode = new CMsgSystemAudioManagerNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemAudioManagerObject$Type extends MessageType<CMsgSystemAudioManagerObject> {
    constructor() {
        super("CMsgSystemAudioManagerObject", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "rtime_last_update", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemAudioManagerObject>): CMsgSystemAudioManagerObject {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemAudioManagerObject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemAudioManagerObject): CMsgSystemAudioManagerObject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* optional fixed32 rtime_last_update */ 2:
                    message.rtimeLastUpdate = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemAudioManagerObject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* optional fixed32 rtime_last_update = 2; */
        if (message.rtimeLastUpdate !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.rtimeLastUpdate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemAudioManagerObject
 */
export const CMsgSystemAudioManagerObject = new CMsgSystemAudioManagerObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemAudioManagerPort$Type extends MessageType<CMsgSystemAudioManagerPort> {
    constructor() {
        super("CMsgSystemAudioManagerPort", [
            { no: 1, name: "base", kind: "message", T: () => CMsgSystemAudioManagerObject },
            { no: 3, name: "node_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "alias", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "etype", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 7, name: "edirection", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 8, name: "is_physical", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "is_terminal", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "is_control", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "is_monitor", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemAudioManagerPort>): CMsgSystemAudioManagerPort {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemAudioManagerPort>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemAudioManagerPort): CMsgSystemAudioManagerPort {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSystemAudioManagerObject base */ 1:
                    message.base = CMsgSystemAudioManagerObject.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                case /* optional uint32 node_id */ 3:
                    message.nodeId = reader.uint32();
                    break;
                case /* optional string name */ 4:
                    message.name = reader.string();
                    break;
                case /* optional string alias */ 5:
                    message.alias = reader.string();
                    break;
                case /* optional int32 etype */ 6:
                    message.etype = reader.int32();
                    break;
                case /* optional int32 edirection */ 7:
                    message.edirection = reader.int32();
                    break;
                case /* optional bool is_physical */ 8:
                    message.isPhysical = reader.bool();
                    break;
                case /* optional bool is_terminal */ 9:
                    message.isTerminal = reader.bool();
                    break;
                case /* optional bool is_control */ 10:
                    message.isControl = reader.bool();
                    break;
                case /* optional bool is_monitor */ 11:
                    message.isMonitor = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemAudioManagerPort, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSystemAudioManagerObject base = 1; */
        if (message.base)
            CMsgSystemAudioManagerObject.internalBinaryWrite(message.base, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 node_id = 3; */
        if (message.nodeId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.nodeId);
        /* optional string name = 4; */
        if (message.name !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* optional string alias = 5; */
        if (message.alias !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.alias);
        /* optional int32 etype = 6; */
        if (message.etype !== undefined)
            writer.tag(6, WireType.Varint).int32(message.etype);
        /* optional int32 edirection = 7; */
        if (message.edirection !== undefined)
            writer.tag(7, WireType.Varint).int32(message.edirection);
        /* optional bool is_physical = 8; */
        if (message.isPhysical !== undefined)
            writer.tag(8, WireType.Varint).bool(message.isPhysical);
        /* optional bool is_terminal = 9; */
        if (message.isTerminal !== undefined)
            writer.tag(9, WireType.Varint).bool(message.isTerminal);
        /* optional bool is_control = 10; */
        if (message.isControl !== undefined)
            writer.tag(10, WireType.Varint).bool(message.isControl);
        /* optional bool is_monitor = 11; */
        if (message.isMonitor !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isMonitor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemAudioManagerPort
 */
export const CMsgSystemAudioManagerPort = new CMsgSystemAudioManagerPort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemAudioManagerState$Type extends MessageType<CMsgSystemAudioManagerState> {
    constructor() {
        super("CMsgSystemAudioManagerState", [
            { no: 1, name: "rtime_filter", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "counter", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "hw", kind: "message", T: () => CMsgSystemAudioManagerStateHW }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemAudioManagerState>): CMsgSystemAudioManagerState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemAudioManagerState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemAudioManagerState): CMsgSystemAudioManagerState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 rtime_filter */ 1:
                    message.rtimeFilter = reader.fixed32();
                    break;
                case /* optional int32 counter */ 2:
                    message.counter = reader.int32();
                    break;
                case /* optional CMsgSystemAudioManagerStateHW hw */ 3:
                    message.hw = CMsgSystemAudioManagerStateHW.internalBinaryRead(reader, reader.uint32(), options, message.hw);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemAudioManagerState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 rtime_filter = 1; */
        if (message.rtimeFilter !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.rtimeFilter);
        /* optional int32 counter = 2; */
        if (message.counter !== undefined)
            writer.tag(2, WireType.Varint).int32(message.counter);
        /* optional CMsgSystemAudioManagerStateHW hw = 3; */
        if (message.hw)
            CMsgSystemAudioManagerStateHW.internalBinaryWrite(message.hw, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemAudioManagerState
 */
export const CMsgSystemAudioManagerState = new CMsgSystemAudioManagerState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemAudioManagerStateHW$Type extends MessageType<CMsgSystemAudioManagerStateHW> {
    constructor() {
        super("CMsgSystemAudioManagerStateHW", [
            { no: 1, name: "devices", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemAudioManagerDevice },
            { no: 2, name: "nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemAudioManagerNode },
            { no: 3, name: "ports", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemAudioManagerPort },
            { no: 4, name: "links", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemAudioManagerLink }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemAudioManagerStateHW>): CMsgSystemAudioManagerStateHW {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.devices = [];
        message.nodes = [];
        message.ports = [];
        message.links = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemAudioManagerStateHW>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemAudioManagerStateHW): CMsgSystemAudioManagerStateHW {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSystemAudioManagerDevice devices */ 1:
                    message.devices.push(CMsgSystemAudioManagerDevice.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSystemAudioManagerNode nodes */ 2:
                    message.nodes.push(CMsgSystemAudioManagerNode.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSystemAudioManagerPort ports */ 3:
                    message.ports.push(CMsgSystemAudioManagerPort.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSystemAudioManagerLink links */ 4:
                    message.links.push(CMsgSystemAudioManagerLink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemAudioManagerStateHW, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSystemAudioManagerDevice devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            CMsgSystemAudioManagerDevice.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSystemAudioManagerNode nodes = 2; */
        for (let i = 0; i < message.nodes.length; i++)
            CMsgSystemAudioManagerNode.internalBinaryWrite(message.nodes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSystemAudioManagerPort ports = 3; */
        for (let i = 0; i < message.ports.length; i++)
            CMsgSystemAudioManagerPort.internalBinaryWrite(message.ports[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSystemAudioManagerLink links = 4; */
        for (let i = 0; i < message.links.length; i++)
            CMsgSystemAudioManagerLink.internalBinaryWrite(message.links[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemAudioManagerStateHW
 */
export const CMsgSystemAudioManagerStateHW = new CMsgSystemAudioManagerStateHW$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemAudioManagerUpdateSomething$Type extends MessageType<CMsgSystemAudioManagerUpdateSomething> {
    constructor() {
        super("CMsgSystemAudioManagerUpdateSomething", [
            { no: 1, name: "counter", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemAudioManagerUpdateSomething>): CMsgSystemAudioManagerUpdateSomething {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemAudioManagerUpdateSomething>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemAudioManagerUpdateSomething): CMsgSystemAudioManagerUpdateSomething {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 counter */ 1:
                    message.counter = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemAudioManagerUpdateSomething, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 counter = 1; */
        if (message.counter !== undefined)
            writer.tag(1, WireType.Varint).int32(message.counter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemAudioManagerUpdateSomething
 */
export const CMsgSystemAudioManagerUpdateSomething = new CMsgSystemAudioManagerUpdateSomething$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemAudioVolume$Type extends MessageType<CMsgSystemAudioVolume> {
    constructor() {
        super("CMsgSystemAudioVolume", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemAudioVolume_ChannelEntry },
            { no: 2, name: "is_muted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemAudioVolume>): CMsgSystemAudioVolume {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemAudioVolume>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemAudioVolume): CMsgSystemAudioVolume {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSystemAudioVolume_ChannelEntry entries */ 1:
                    message.entries.push(CMsgSystemAudioVolume_ChannelEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_muted */ 2:
                    message.isMuted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemAudioVolume, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSystemAudioVolume_ChannelEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CMsgSystemAudioVolume_ChannelEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_muted = 2; */
        if (message.isMuted !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isMuted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemAudioVolume
 */
export const CMsgSystemAudioVolume = new CMsgSystemAudioVolume$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemAudioVolume_ChannelEntry$Type extends MessageType<CMsgSystemAudioVolume_ChannelEntry> {
    constructor() {
        super("CMsgSystemAudioVolume_ChannelEntry", [
            { no: 1, name: "echannel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "volume", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemAudioVolume_ChannelEntry>): CMsgSystemAudioVolume_ChannelEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemAudioVolume_ChannelEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemAudioVolume_ChannelEntry): CMsgSystemAudioVolume_ChannelEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 echannel */ 1:
                    message.echannel = reader.int32();
                    break;
                case /* optional float volume */ 2:
                    message.volume = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemAudioVolume_ChannelEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 echannel = 1; */
        if (message.echannel !== undefined)
            writer.tag(1, WireType.Varint).int32(message.echannel);
        /* optional float volume = 2; */
        if (message.volume !== undefined)
            writer.tag(2, WireType.Bit32).float(message.volume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemAudioVolume_ChannelEntry
 */
export const CMsgSystemAudioVolume_ChannelEntry = new CMsgSystemAudioVolume_ChannelEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemDisplay$Type extends MessageType<CMsgSystemDisplay> {
    constructor() {
        super("CMsgSystemDisplay", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_primary", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_internal", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "has_mode_override", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "width_mm", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "height_mm", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "current_mode_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "modes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemDisplayMode },
            { no: 12, name: "refresh_rate_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "refresh_rate_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "is_vrr_capable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "is_vrr_output_active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "is_hdr_capable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "is_hdr_output_active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "supported_refresh_rates", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemDisplay>): CMsgSystemDisplay {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.modes = [];
        message.supportedRefreshRates = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemDisplay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemDisplay): CMsgSystemDisplay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string description */ 3:
                    message.description = reader.string();
                    break;
                case /* optional bool is_primary */ 4:
                    message.isPrimary = reader.bool();
                    break;
                case /* optional bool is_enabled */ 5:
                    message.isEnabled = reader.bool();
                    break;
                case /* optional bool is_internal */ 6:
                    message.isInternal = reader.bool();
                    break;
                case /* optional bool has_mode_override */ 7:
                    message.hasModeOverride = reader.bool();
                    break;
                case /* optional int32 width_mm */ 8:
                    message.widthMm = reader.int32();
                    break;
                case /* optional int32 height_mm */ 9:
                    message.heightMm = reader.int32();
                    break;
                case /* optional int32 current_mode_id */ 10:
                    message.currentModeId = reader.int32();
                    break;
                case /* repeated CMsgSystemDisplayMode modes */ 11:
                    message.modes.push(CMsgSystemDisplayMode.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 refresh_rate_min */ 12:
                    message.refreshRateMin = reader.int32();
                    break;
                case /* optional int32 refresh_rate_max */ 13:
                    message.refreshRateMax = reader.int32();
                    break;
                case /* optional bool is_vrr_capable */ 14:
                    message.isVrrCapable = reader.bool();
                    break;
                case /* optional bool is_vrr_output_active */ 15:
                    message.isVrrOutputActive = reader.bool();
                    break;
                case /* optional bool is_hdr_capable */ 16:
                    message.isHdrCapable = reader.bool();
                    break;
                case /* optional bool is_hdr_output_active */ 17:
                    message.isHdrOutputActive = reader.bool();
                    break;
                case /* repeated int32 supported_refresh_rates */ 18:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedRefreshRates.push(reader.int32());
                    else
                        message.supportedRefreshRates.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemDisplay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string description = 3; */
        if (message.description !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* optional bool is_primary = 4; */
        if (message.isPrimary !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isPrimary);
        /* optional bool is_enabled = 5; */
        if (message.isEnabled !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isEnabled);
        /* optional bool is_internal = 6; */
        if (message.isInternal !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isInternal);
        /* optional bool has_mode_override = 7; */
        if (message.hasModeOverride !== undefined)
            writer.tag(7, WireType.Varint).bool(message.hasModeOverride);
        /* optional int32 width_mm = 8; */
        if (message.widthMm !== undefined)
            writer.tag(8, WireType.Varint).int32(message.widthMm);
        /* optional int32 height_mm = 9; */
        if (message.heightMm !== undefined)
            writer.tag(9, WireType.Varint).int32(message.heightMm);
        /* optional int32 current_mode_id = 10; */
        if (message.currentModeId !== undefined)
            writer.tag(10, WireType.Varint).int32(message.currentModeId);
        /* repeated CMsgSystemDisplayMode modes = 11; */
        for (let i = 0; i < message.modes.length; i++)
            CMsgSystemDisplayMode.internalBinaryWrite(message.modes[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 refresh_rate_min = 12; */
        if (message.refreshRateMin !== undefined)
            writer.tag(12, WireType.Varint).int32(message.refreshRateMin);
        /* optional int32 refresh_rate_max = 13; */
        if (message.refreshRateMax !== undefined)
            writer.tag(13, WireType.Varint).int32(message.refreshRateMax);
        /* optional bool is_vrr_capable = 14; */
        if (message.isVrrCapable !== undefined)
            writer.tag(14, WireType.Varint).bool(message.isVrrCapable);
        /* optional bool is_vrr_output_active = 15; */
        if (message.isVrrOutputActive !== undefined)
            writer.tag(15, WireType.Varint).bool(message.isVrrOutputActive);
        /* optional bool is_hdr_capable = 16; */
        if (message.isHdrCapable !== undefined)
            writer.tag(16, WireType.Varint).bool(message.isHdrCapable);
        /* optional bool is_hdr_output_active = 17; */
        if (message.isHdrOutputActive !== undefined)
            writer.tag(17, WireType.Varint).bool(message.isHdrOutputActive);
        /* repeated int32 supported_refresh_rates = 18; */
        for (let i = 0; i < message.supportedRefreshRates.length; i++)
            writer.tag(18, WireType.Varint).int32(message.supportedRefreshRates[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemDisplay
 */
export const CMsgSystemDisplay = new CMsgSystemDisplay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemDisplayManagerSetMode$Type extends MessageType<CMsgSystemDisplayManagerSetMode> {
    constructor() {
        super("CMsgSystemDisplayManagerSetMode", [
            { no: 1, name: "display_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "mode_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemDisplayManagerSetMode>): CMsgSystemDisplayManagerSetMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemDisplayManagerSetMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemDisplayManagerSetMode): CMsgSystemDisplayManagerSetMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 display_id */ 1:
                    message.displayId = reader.int32();
                    break;
                case /* optional int32 mode_id */ 2:
                    message.modeId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemDisplayManagerSetMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 display_id = 1; */
        if (message.displayId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.displayId);
        /* optional int32 mode_id = 2; */
        if (message.modeId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.modeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemDisplayManagerSetMode
 */
export const CMsgSystemDisplayManagerSetMode = new CMsgSystemDisplayManagerSetMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemDisplayManagerState$Type extends MessageType<CMsgSystemDisplayManagerState> {
    constructor() {
        super("CMsgSystemDisplayManagerState", [
            { no: 1, name: "displays", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemDisplay },
            { no: 2, name: "is_mode_switching_supported", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "compatibility_mode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemDisplayManagerState>): CMsgSystemDisplayManagerState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.displays = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemDisplayManagerState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemDisplayManagerState): CMsgSystemDisplayManagerState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSystemDisplay displays */ 1:
                    message.displays.push(CMsgSystemDisplay.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_mode_switching_supported */ 2:
                    message.isModeSwitchingSupported = reader.bool();
                    break;
                case /* optional int32 compatibility_mode */ 3:
                    message.compatibilityMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemDisplayManagerState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSystemDisplay displays = 1; */
        for (let i = 0; i < message.displays.length; i++)
            CMsgSystemDisplay.internalBinaryWrite(message.displays[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_mode_switching_supported = 2; */
        if (message.isModeSwitchingSupported !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isModeSwitchingSupported);
        /* optional int32 compatibility_mode = 3; */
        if (message.compatibilityMode !== undefined)
            writer.tag(3, WireType.Varint).int32(message.compatibilityMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemDisplayManagerState
 */
export const CMsgSystemDisplayManagerState = new CMsgSystemDisplayManagerState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemDisplayMode$Type extends MessageType<CMsgSystemDisplayMode> {
    constructor() {
        super("CMsgSystemDisplayMode", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "width", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "height", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "refresh_hz", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemDisplayMode>): CMsgSystemDisplayMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemDisplayMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemDisplayMode): CMsgSystemDisplayMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional int32 width */ 2:
                    message.width = reader.int32();
                    break;
                case /* optional int32 height */ 3:
                    message.height = reader.int32();
                    break;
                case /* optional int32 refresh_hz */ 4:
                    message.refreshHz = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemDisplayMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional int32 width = 2; */
        if (message.width !== undefined)
            writer.tag(2, WireType.Varint).int32(message.width);
        /* optional int32 height = 3; */
        if (message.height !== undefined)
            writer.tag(3, WireType.Varint).int32(message.height);
        /* optional int32 refresh_hz = 4; */
        if (message.refreshHz !== undefined)
            writer.tag(4, WireType.Varint).int32(message.refreshHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemDisplayMode
 */
export const CMsgSystemDisplayMode = new CMsgSystemDisplayMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemDockState$Type extends MessageType<CMsgSystemDockState> {
    constructor() {
        super("CMsgSystemDockState", [
            { no: 1, name: "update_state", kind: "message", T: () => CMsgSystemDockUpdateState }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemDockState>): CMsgSystemDockState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemDockState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemDockState): CMsgSystemDockState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSystemDockUpdateState update_state */ 1:
                    message.updateState = CMsgSystemDockUpdateState.internalBinaryRead(reader, reader.uint32(), options, message.updateState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemDockState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSystemDockUpdateState update_state = 1; */
        if (message.updateState)
            CMsgSystemDockUpdateState.internalBinaryWrite(message.updateState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemDockState
 */
export const CMsgSystemDockState = new CMsgSystemDockState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemDockUpdateFirmware$Type extends MessageType<CMsgSystemDockUpdateFirmware> {
    constructor() {
        super("CMsgSystemDockUpdateFirmware", [
            { no: 1, name: "check_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemDockUpdateFirmware>): CMsgSystemDockUpdateFirmware {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemDockUpdateFirmware>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemDockUpdateFirmware): CMsgSystemDockUpdateFirmware {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool check_only */ 1:
                    message.checkOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemDockUpdateFirmware, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool check_only = 1; */
        if (message.checkOnly !== undefined)
            writer.tag(1, WireType.Varint).bool(message.checkOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemDockUpdateFirmware
 */
export const CMsgSystemDockUpdateFirmware = new CMsgSystemDockUpdateFirmware$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemDockUpdateState$Type extends MessageType<CMsgSystemDockUpdateState> {
    constructor() {
        super("CMsgSystemDockUpdateState", [
            { no: 1, name: "state", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "rtime_last_checked", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "version_current", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version_available", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "stage_progress", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "rtime_estimated_completion", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 7, name: "old_fw_workaround", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemDockUpdateState>): CMsgSystemDockUpdateState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemDockUpdateState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemDockUpdateState): CMsgSystemDockUpdateState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 state */ 1:
                    message.state = reader.int32();
                    break;
                case /* optional fixed32 rtime_last_checked */ 2:
                    message.rtimeLastChecked = reader.fixed32();
                    break;
                case /* optional string version_current */ 3:
                    message.versionCurrent = reader.string();
                    break;
                case /* optional string version_available */ 4:
                    message.versionAvailable = reader.string();
                    break;
                case /* optional float stage_progress */ 5:
                    message.stageProgress = reader.float();
                    break;
                case /* optional fixed32 rtime_estimated_completion */ 6:
                    message.rtimeEstimatedCompletion = reader.fixed32();
                    break;
                case /* optional int32 old_fw_workaround */ 7:
                    message.oldFwWorkaround = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemDockUpdateState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 state = 1; */
        if (message.state !== undefined)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* optional fixed32 rtime_last_checked = 2; */
        if (message.rtimeLastChecked !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.rtimeLastChecked);
        /* optional string version_current = 3; */
        if (message.versionCurrent !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.versionCurrent);
        /* optional string version_available = 4; */
        if (message.versionAvailable !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.versionAvailable);
        /* optional float stage_progress = 5; */
        if (message.stageProgress !== undefined)
            writer.tag(5, WireType.Bit32).float(message.stageProgress);
        /* optional fixed32 rtime_estimated_completion = 6; */
        if (message.rtimeEstimatedCompletion !== undefined)
            writer.tag(6, WireType.Bit32).fixed32(message.rtimeEstimatedCompletion);
        /* optional int32 old_fw_workaround = 7; */
        if (message.oldFwWorkaround !== undefined)
            writer.tag(7, WireType.Varint).int32(message.oldFwWorkaround);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemDockUpdateState
 */
export const CMsgSystemDockUpdateState = new CMsgSystemDockUpdateState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemManagerSettings$Type extends MessageType<CMsgSystemManagerSettings> {
    constructor() {
        super("CMsgSystemManagerSettings", [
            { no: 1, name: "idle_backlight_dim_battery_seconds", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "idle_backlight_dim_ac_seconds", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "idle_suspend_battery_seconds", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "idle_suspend_ac_seconds", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "idle_suspend_supressed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_adaptive_brightness_available", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "display_adaptive_brightness_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "display_nightmode_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "display_nightmode_tintstrength", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "display_nightmode_maxhue", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "display_nightmode_maxsat", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "display_nightmode_uiexp", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "display_nightmode_blend", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 16, name: "display_nightmode_reset", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "display_nightmode_schedule_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "display_nightmode_schedule_starttime", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 19, name: "display_nightmode_schedule_endtime", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "display_diagnostics_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "als_lux_primary", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 22, name: "als_lux_median", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 23, name: "display_backlight_raw", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 24, name: "display_brightness_adaptivemin", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 25, name: "display_brightness_adaptivemax", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 26, name: "is_wifi_powersave_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "is_fan_control_available", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "fan_control_mode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 29, name: "is_display_brightness_available", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 31, name: "is_display_colormanagement_available", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 32, name: "display_colorgamut", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 33, name: "als_lux_alternate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 34, name: "is_display_colortemp_available", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 35, name: "display_colortemp", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 36, name: "display_colortemp_default", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 37, name: "display_colortemp_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 38, name: "display_colorgamut_labelset", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 39, name: "display_brightness_overdrive_hdr_split", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemManagerSettings>): CMsgSystemManagerSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemManagerSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemManagerSettings): CMsgSystemManagerSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float idle_backlight_dim_battery_seconds */ 1:
                    message.idleBacklightDimBatterySeconds = reader.float();
                    break;
                case /* optional float idle_backlight_dim_ac_seconds */ 2:
                    message.idleBacklightDimAcSeconds = reader.float();
                    break;
                case /* optional float idle_suspend_battery_seconds */ 3:
                    message.idleSuspendBatterySeconds = reader.float();
                    break;
                case /* optional float idle_suspend_ac_seconds */ 4:
                    message.idleSuspendAcSeconds = reader.float();
                    break;
                case /* optional bool idle_suspend_supressed */ 5:
                    message.idleSuspendSupressed = reader.bool();
                    break;
                case /* optional bool is_adaptive_brightness_available */ 6:
                    message.isAdaptiveBrightnessAvailable = reader.bool();
                    break;
                case /* optional bool display_adaptive_brightness_enabled */ 7:
                    message.displayAdaptiveBrightnessEnabled = reader.bool();
                    break;
                case /* optional bool display_nightmode_enabled */ 10:
                    message.displayNightmodeEnabled = reader.bool();
                    break;
                case /* optional float display_nightmode_tintstrength */ 11:
                    message.displayNightmodeTintstrength = reader.float();
                    break;
                case /* optional float display_nightmode_maxhue */ 12:
                    message.displayNightmodeMaxhue = reader.float();
                    break;
                case /* optional float display_nightmode_maxsat */ 13:
                    message.displayNightmodeMaxsat = reader.float();
                    break;
                case /* optional float display_nightmode_uiexp */ 14:
                    message.displayNightmodeUiexp = reader.float();
                    break;
                case /* optional float display_nightmode_blend */ 15:
                    message.displayNightmodeBlend = reader.float();
                    break;
                case /* optional bool display_nightmode_reset */ 16:
                    message.displayNightmodeReset = reader.bool();
                    break;
                case /* optional bool display_nightmode_schedule_enabled */ 17:
                    message.displayNightmodeScheduleEnabled = reader.bool();
                    break;
                case /* optional float display_nightmode_schedule_starttime */ 18:
                    message.displayNightmodeScheduleStarttime = reader.float();
                    break;
                case /* optional float display_nightmode_schedule_endtime */ 19:
                    message.displayNightmodeScheduleEndtime = reader.float();
                    break;
                case /* optional bool display_diagnostics_enabled */ 20:
                    message.displayDiagnosticsEnabled = reader.bool();
                    break;
                case /* optional float als_lux_primary */ 21:
                    message.alsLuxPrimary = reader.float();
                    break;
                case /* optional float als_lux_median */ 22:
                    message.alsLuxMedian = reader.float();
                    break;
                case /* optional float display_backlight_raw */ 23:
                    message.displayBacklightRaw = reader.float();
                    break;
                case /* optional float display_brightness_adaptivemin */ 24:
                    message.displayBrightnessAdaptivemin = reader.float();
                    break;
                case /* optional float display_brightness_adaptivemax */ 25:
                    message.displayBrightnessAdaptivemax = reader.float();
                    break;
                case /* optional bool is_wifi_powersave_enabled */ 26:
                    message.isWifiPowersaveEnabled = reader.bool();
                    break;
                case /* optional bool is_fan_control_available */ 27:
                    message.isFanControlAvailable = reader.bool();
                    break;
                case /* optional int32 fan_control_mode */ 28:
                    message.fanControlMode = reader.int32();
                    break;
                case /* optional bool is_display_brightness_available */ 29:
                    message.isDisplayBrightnessAvailable = reader.bool();
                    break;
                case /* optional bool is_display_colormanagement_available */ 31:
                    message.isDisplayColormanagementAvailable = reader.bool();
                    break;
                case /* optional float display_colorgamut */ 32:
                    message.displayColorgamut = reader.float();
                    break;
                case /* optional float als_lux_alternate */ 33:
                    message.alsLuxAlternate = reader.float();
                    break;
                case /* optional bool is_display_colortemp_available */ 34:
                    message.isDisplayColortempAvailable = reader.bool();
                    break;
                case /* optional float display_colortemp */ 35:
                    message.displayColortemp = reader.float();
                    break;
                case /* optional float display_colortemp_default */ 36:
                    message.displayColortempDefault = reader.float();
                    break;
                case /* optional bool display_colortemp_enabled */ 37:
                    message.displayColortempEnabled = reader.bool();
                    break;
                case /* optional int32 display_colorgamut_labelset */ 38:
                    message.displayColorgamutLabelset = reader.int32();
                    break;
                case /* optional float display_brightness_overdrive_hdr_split */ 39:
                    message.displayBrightnessOverdriveHdrSplit = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemManagerSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float idle_backlight_dim_battery_seconds = 1; */
        if (message.idleBacklightDimBatterySeconds !== undefined)
            writer.tag(1, WireType.Bit32).float(message.idleBacklightDimBatterySeconds);
        /* optional float idle_backlight_dim_ac_seconds = 2; */
        if (message.idleBacklightDimAcSeconds !== undefined)
            writer.tag(2, WireType.Bit32).float(message.idleBacklightDimAcSeconds);
        /* optional float idle_suspend_battery_seconds = 3; */
        if (message.idleSuspendBatterySeconds !== undefined)
            writer.tag(3, WireType.Bit32).float(message.idleSuspendBatterySeconds);
        /* optional float idle_suspend_ac_seconds = 4; */
        if (message.idleSuspendAcSeconds !== undefined)
            writer.tag(4, WireType.Bit32).float(message.idleSuspendAcSeconds);
        /* optional bool idle_suspend_supressed = 5; */
        if (message.idleSuspendSupressed !== undefined)
            writer.tag(5, WireType.Varint).bool(message.idleSuspendSupressed);
        /* optional bool is_adaptive_brightness_available = 6; */
        if (message.isAdaptiveBrightnessAvailable !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isAdaptiveBrightnessAvailable);
        /* optional bool display_adaptive_brightness_enabled = 7; */
        if (message.displayAdaptiveBrightnessEnabled !== undefined)
            writer.tag(7, WireType.Varint).bool(message.displayAdaptiveBrightnessEnabled);
        /* optional bool display_nightmode_enabled = 10; */
        if (message.displayNightmodeEnabled !== undefined)
            writer.tag(10, WireType.Varint).bool(message.displayNightmodeEnabled);
        /* optional float display_nightmode_tintstrength = 11; */
        if (message.displayNightmodeTintstrength !== undefined)
            writer.tag(11, WireType.Bit32).float(message.displayNightmodeTintstrength);
        /* optional float display_nightmode_maxhue = 12; */
        if (message.displayNightmodeMaxhue !== undefined)
            writer.tag(12, WireType.Bit32).float(message.displayNightmodeMaxhue);
        /* optional float display_nightmode_maxsat = 13; */
        if (message.displayNightmodeMaxsat !== undefined)
            writer.tag(13, WireType.Bit32).float(message.displayNightmodeMaxsat);
        /* optional float display_nightmode_uiexp = 14; */
        if (message.displayNightmodeUiexp !== undefined)
            writer.tag(14, WireType.Bit32).float(message.displayNightmodeUiexp);
        /* optional float display_nightmode_blend = 15; */
        if (message.displayNightmodeBlend !== undefined)
            writer.tag(15, WireType.Bit32).float(message.displayNightmodeBlend);
        /* optional bool display_nightmode_reset = 16; */
        if (message.displayNightmodeReset !== undefined)
            writer.tag(16, WireType.Varint).bool(message.displayNightmodeReset);
        /* optional bool display_nightmode_schedule_enabled = 17; */
        if (message.displayNightmodeScheduleEnabled !== undefined)
            writer.tag(17, WireType.Varint).bool(message.displayNightmodeScheduleEnabled);
        /* optional float display_nightmode_schedule_starttime = 18; */
        if (message.displayNightmodeScheduleStarttime !== undefined)
            writer.tag(18, WireType.Bit32).float(message.displayNightmodeScheduleStarttime);
        /* optional float display_nightmode_schedule_endtime = 19; */
        if (message.displayNightmodeScheduleEndtime !== undefined)
            writer.tag(19, WireType.Bit32).float(message.displayNightmodeScheduleEndtime);
        /* optional bool display_diagnostics_enabled = 20; */
        if (message.displayDiagnosticsEnabled !== undefined)
            writer.tag(20, WireType.Varint).bool(message.displayDiagnosticsEnabled);
        /* optional float als_lux_primary = 21; */
        if (message.alsLuxPrimary !== undefined)
            writer.tag(21, WireType.Bit32).float(message.alsLuxPrimary);
        /* optional float als_lux_median = 22; */
        if (message.alsLuxMedian !== undefined)
            writer.tag(22, WireType.Bit32).float(message.alsLuxMedian);
        /* optional float display_backlight_raw = 23; */
        if (message.displayBacklightRaw !== undefined)
            writer.tag(23, WireType.Bit32).float(message.displayBacklightRaw);
        /* optional float display_brightness_adaptivemin = 24; */
        if (message.displayBrightnessAdaptivemin !== undefined)
            writer.tag(24, WireType.Bit32).float(message.displayBrightnessAdaptivemin);
        /* optional float display_brightness_adaptivemax = 25; */
        if (message.displayBrightnessAdaptivemax !== undefined)
            writer.tag(25, WireType.Bit32).float(message.displayBrightnessAdaptivemax);
        /* optional bool is_wifi_powersave_enabled = 26; */
        if (message.isWifiPowersaveEnabled !== undefined)
            writer.tag(26, WireType.Varint).bool(message.isWifiPowersaveEnabled);
        /* optional bool is_fan_control_available = 27; */
        if (message.isFanControlAvailable !== undefined)
            writer.tag(27, WireType.Varint).bool(message.isFanControlAvailable);
        /* optional int32 fan_control_mode = 28; */
        if (message.fanControlMode !== undefined)
            writer.tag(28, WireType.Varint).int32(message.fanControlMode);
        /* optional bool is_display_brightness_available = 29; */
        if (message.isDisplayBrightnessAvailable !== undefined)
            writer.tag(29, WireType.Varint).bool(message.isDisplayBrightnessAvailable);
        /* optional bool is_display_colormanagement_available = 31; */
        if (message.isDisplayColormanagementAvailable !== undefined)
            writer.tag(31, WireType.Varint).bool(message.isDisplayColormanagementAvailable);
        /* optional float display_colorgamut = 32; */
        if (message.displayColorgamut !== undefined)
            writer.tag(32, WireType.Bit32).float(message.displayColorgamut);
        /* optional float als_lux_alternate = 33; */
        if (message.alsLuxAlternate !== undefined)
            writer.tag(33, WireType.Bit32).float(message.alsLuxAlternate);
        /* optional bool is_display_colortemp_available = 34; */
        if (message.isDisplayColortempAvailable !== undefined)
            writer.tag(34, WireType.Varint).bool(message.isDisplayColortempAvailable);
        /* optional float display_colortemp = 35; */
        if (message.displayColortemp !== undefined)
            writer.tag(35, WireType.Bit32).float(message.displayColortemp);
        /* optional float display_colortemp_default = 36; */
        if (message.displayColortempDefault !== undefined)
            writer.tag(36, WireType.Bit32).float(message.displayColortempDefault);
        /* optional bool display_colortemp_enabled = 37; */
        if (message.displayColortempEnabled !== undefined)
            writer.tag(37, WireType.Varint).bool(message.displayColortempEnabled);
        /* optional int32 display_colorgamut_labelset = 38; */
        if (message.displayColorgamutLabelset !== undefined)
            writer.tag(38, WireType.Varint).int32(message.displayColorgamutLabelset);
        /* optional float display_brightness_overdrive_hdr_split = 39; */
        if (message.displayBrightnessOverdriveHdrSplit !== undefined)
            writer.tag(39, WireType.Bit32).float(message.displayBrightnessOverdriveHdrSplit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemManagerSettings
 */
export const CMsgSystemManagerSettings = new CMsgSystemManagerSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemPerfDiagnosticEntry$Type extends MessageType<CMsgSystemPerfDiagnosticEntry> {
    constructor() {
        super("CMsgSystemPerfDiagnosticEntry", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemPerfDiagnosticEntry>): CMsgSystemPerfDiagnosticEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemPerfDiagnosticEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemPerfDiagnosticEntry): CMsgSystemPerfDiagnosticEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemPerfDiagnosticEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemPerfDiagnosticEntry
 */
export const CMsgSystemPerfDiagnosticEntry = new CMsgSystemPerfDiagnosticEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemPerfDiagnosticInfo$Type extends MessageType<CMsgSystemPerfDiagnosticInfo> {
    constructor() {
        super("CMsgSystemPerfDiagnosticInfo", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemPerfDiagnosticEntry },
            { no: 2, name: "interfaces", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemPerfNetworkInterface },
            { no: 3, name: "battery_temp_c", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemPerfDiagnosticInfo>): CMsgSystemPerfDiagnosticInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        message.interfaces = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemPerfDiagnosticInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemPerfDiagnosticInfo): CMsgSystemPerfDiagnosticInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSystemPerfDiagnosticEntry entries */ 1:
                    message.entries.push(CMsgSystemPerfDiagnosticEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSystemPerfNetworkInterface interfaces */ 2:
                    message.interfaces.push(CMsgSystemPerfNetworkInterface.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional float battery_temp_c */ 3:
                    message.batteryTempC = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemPerfDiagnosticInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSystemPerfDiagnosticEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CMsgSystemPerfDiagnosticEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSystemPerfNetworkInterface interfaces = 2; */
        for (let i = 0; i < message.interfaces.length; i++)
            CMsgSystemPerfNetworkInterface.internalBinaryWrite(message.interfaces[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional float battery_temp_c = 3; */
        if (message.batteryTempC !== undefined)
            writer.tag(3, WireType.Bit32).float(message.batteryTempC);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemPerfDiagnosticInfo
 */
export const CMsgSystemPerfDiagnosticInfo = new CMsgSystemPerfDiagnosticInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemPerfLimits$Type extends MessageType<CMsgSystemPerfLimits> {
    constructor() {
        super("CMsgSystemPerfLimits", [
            { no: 1, name: "cpu_governor_manual_min_mhz", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "cpu_governor_manual_max_mhz", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "fsr_sharpness_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "fsr_sharpness_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "gpu_performance_manual_min_mhz", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "gpu_performance_manual_max_mhz", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "perf_overlay_is_standalone", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "is_dynamic_vrs_available", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "is_manual_display_refresh_rate_available", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "gpu_performance_levels_available", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 11, name: "display_refresh_manual_hz_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "display_refresh_manual_hz_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "fps_limit_options", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "tdp_limit_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "tdp_limit_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "display_external_refresh_manual_hz_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "display_external_refresh_manual_hz_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "fps_limit_options_external", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "is_vrr_supported", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "is_dynamic_refresh_rate_in_steam_supported", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "split_scaling_filters_available", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 27, name: "split_scaling_scalers_available", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 30, name: "disable_refresh_rate_management", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemPerfLimits>): CMsgSystemPerfLimits {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gpuPerformanceLevelsAvailable = [];
        message.fpsLimitOptions = [];
        message.fpsLimitOptionsExternal = [];
        message.splitScalingFiltersAvailable = [];
        message.splitScalingScalersAvailable = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemPerfLimits>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemPerfLimits): CMsgSystemPerfLimits {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 cpu_governor_manual_min_mhz */ 1:
                    message.cpuGovernorManualMinMhz = reader.int32();
                    break;
                case /* optional int32 cpu_governor_manual_max_mhz */ 2:
                    message.cpuGovernorManualMaxMhz = reader.int32();
                    break;
                case /* optional int32 fsr_sharpness_min */ 3:
                    message.fsrSharpnessMin = reader.int32();
                    break;
                case /* optional int32 fsr_sharpness_max */ 4:
                    message.fsrSharpnessMax = reader.int32();
                    break;
                case /* optional int32 gpu_performance_manual_min_mhz */ 5:
                    message.gpuPerformanceManualMinMhz = reader.int32();
                    break;
                case /* optional int32 gpu_performance_manual_max_mhz */ 6:
                    message.gpuPerformanceManualMaxMhz = reader.int32();
                    break;
                case /* optional bool perf_overlay_is_standalone */ 7:
                    message.perfOverlayIsStandalone = reader.bool();
                    break;
                case /* optional bool is_dynamic_vrs_available */ 8:
                    message.isDynamicVrsAvailable = reader.bool();
                    break;
                case /* optional bool is_manual_display_refresh_rate_available */ 9:
                    message.isManualDisplayRefreshRateAvailable = reader.bool();
                    break;
                case /* repeated int32 gpu_performance_levels_available */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.gpuPerformanceLevelsAvailable.push(reader.int32());
                    else
                        message.gpuPerformanceLevelsAvailable.push(reader.int32());
                    break;
                case /* optional int32 display_refresh_manual_hz_min */ 11:
                    message.displayRefreshManualHzMin = reader.int32();
                    break;
                case /* optional int32 display_refresh_manual_hz_max */ 12:
                    message.displayRefreshManualHzMax = reader.int32();
                    break;
                case /* repeated int32 fps_limit_options */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fpsLimitOptions.push(reader.int32());
                    else
                        message.fpsLimitOptions.push(reader.int32());
                    break;
                case /* optional int32 tdp_limit_min */ 14:
                    message.tdpLimitMin = reader.int32();
                    break;
                case /* optional int32 tdp_limit_max */ 15:
                    message.tdpLimitMax = reader.int32();
                    break;
                case /* optional int32 display_external_refresh_manual_hz_min */ 19:
                    message.displayExternalRefreshManualHzMin = reader.int32();
                    break;
                case /* optional int32 display_external_refresh_manual_hz_max */ 20:
                    message.displayExternalRefreshManualHzMax = reader.int32();
                    break;
                case /* repeated int32 fps_limit_options_external */ 21:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fpsLimitOptionsExternal.push(reader.int32());
                    else
                        message.fpsLimitOptionsExternal.push(reader.int32());
                    break;
                case /* optional bool is_vrr_supported */ 23:
                    message.isVrrSupported = reader.bool();
                    break;
                case /* optional bool is_dynamic_refresh_rate_in_steam_supported */ 24:
                    message.isDynamicRefreshRateInSteamSupported = reader.bool();
                    break;
                case /* repeated int32 split_scaling_filters_available */ 26:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.splitScalingFiltersAvailable.push(reader.int32());
                    else
                        message.splitScalingFiltersAvailable.push(reader.int32());
                    break;
                case /* repeated int32 split_scaling_scalers_available */ 27:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.splitScalingScalersAvailable.push(reader.int32());
                    else
                        message.splitScalingScalersAvailable.push(reader.int32());
                    break;
                case /* optional bool disable_refresh_rate_management */ 30:
                    message.disableRefreshRateManagement = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemPerfLimits, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 cpu_governor_manual_min_mhz = 1; */
        if (message.cpuGovernorManualMinMhz !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cpuGovernorManualMinMhz);
        /* optional int32 cpu_governor_manual_max_mhz = 2; */
        if (message.cpuGovernorManualMaxMhz !== undefined)
            writer.tag(2, WireType.Varint).int32(message.cpuGovernorManualMaxMhz);
        /* optional int32 fsr_sharpness_min = 3; */
        if (message.fsrSharpnessMin !== undefined)
            writer.tag(3, WireType.Varint).int32(message.fsrSharpnessMin);
        /* optional int32 fsr_sharpness_max = 4; */
        if (message.fsrSharpnessMax !== undefined)
            writer.tag(4, WireType.Varint).int32(message.fsrSharpnessMax);
        /* optional int32 gpu_performance_manual_min_mhz = 5; */
        if (message.gpuPerformanceManualMinMhz !== undefined)
            writer.tag(5, WireType.Varint).int32(message.gpuPerformanceManualMinMhz);
        /* optional int32 gpu_performance_manual_max_mhz = 6; */
        if (message.gpuPerformanceManualMaxMhz !== undefined)
            writer.tag(6, WireType.Varint).int32(message.gpuPerformanceManualMaxMhz);
        /* optional bool perf_overlay_is_standalone = 7; */
        if (message.perfOverlayIsStandalone !== undefined)
            writer.tag(7, WireType.Varint).bool(message.perfOverlayIsStandalone);
        /* optional bool is_dynamic_vrs_available = 8; */
        if (message.isDynamicVrsAvailable !== undefined)
            writer.tag(8, WireType.Varint).bool(message.isDynamicVrsAvailable);
        /* optional bool is_manual_display_refresh_rate_available = 9; */
        if (message.isManualDisplayRefreshRateAvailable !== undefined)
            writer.tag(9, WireType.Varint).bool(message.isManualDisplayRefreshRateAvailable);
        /* repeated int32 gpu_performance_levels_available = 10; */
        for (let i = 0; i < message.gpuPerformanceLevelsAvailable.length; i++)
            writer.tag(10, WireType.Varint).int32(message.gpuPerformanceLevelsAvailable[i]);
        /* optional int32 display_refresh_manual_hz_min = 11; */
        if (message.displayRefreshManualHzMin !== undefined)
            writer.tag(11, WireType.Varint).int32(message.displayRefreshManualHzMin);
        /* optional int32 display_refresh_manual_hz_max = 12; */
        if (message.displayRefreshManualHzMax !== undefined)
            writer.tag(12, WireType.Varint).int32(message.displayRefreshManualHzMax);
        /* repeated int32 fps_limit_options = 13; */
        for (let i = 0; i < message.fpsLimitOptions.length; i++)
            writer.tag(13, WireType.Varint).int32(message.fpsLimitOptions[i]);
        /* optional int32 tdp_limit_min = 14; */
        if (message.tdpLimitMin !== undefined)
            writer.tag(14, WireType.Varint).int32(message.tdpLimitMin);
        /* optional int32 tdp_limit_max = 15; */
        if (message.tdpLimitMax !== undefined)
            writer.tag(15, WireType.Varint).int32(message.tdpLimitMax);
        /* optional int32 display_external_refresh_manual_hz_min = 19; */
        if (message.displayExternalRefreshManualHzMin !== undefined)
            writer.tag(19, WireType.Varint).int32(message.displayExternalRefreshManualHzMin);
        /* optional int32 display_external_refresh_manual_hz_max = 20; */
        if (message.displayExternalRefreshManualHzMax !== undefined)
            writer.tag(20, WireType.Varint).int32(message.displayExternalRefreshManualHzMax);
        /* repeated int32 fps_limit_options_external = 21; */
        for (let i = 0; i < message.fpsLimitOptionsExternal.length; i++)
            writer.tag(21, WireType.Varint).int32(message.fpsLimitOptionsExternal[i]);
        /* optional bool is_vrr_supported = 23; */
        if (message.isVrrSupported !== undefined)
            writer.tag(23, WireType.Varint).bool(message.isVrrSupported);
        /* optional bool is_dynamic_refresh_rate_in_steam_supported = 24; */
        if (message.isDynamicRefreshRateInSteamSupported !== undefined)
            writer.tag(24, WireType.Varint).bool(message.isDynamicRefreshRateInSteamSupported);
        /* repeated int32 split_scaling_filters_available = 26; */
        for (let i = 0; i < message.splitScalingFiltersAvailable.length; i++)
            writer.tag(26, WireType.Varint).int32(message.splitScalingFiltersAvailable[i]);
        /* repeated int32 split_scaling_scalers_available = 27; */
        for (let i = 0; i < message.splitScalingScalersAvailable.length; i++)
            writer.tag(27, WireType.Varint).int32(message.splitScalingScalersAvailable[i]);
        /* optional bool disable_refresh_rate_management = 30; */
        if (message.disableRefreshRateManagement !== undefined)
            writer.tag(30, WireType.Varint).bool(message.disableRefreshRateManagement);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemPerfLimits
 */
export const CMsgSystemPerfLimits = new CMsgSystemPerfLimits$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemPerfNetworkInterface$Type extends MessageType<CMsgSystemPerfNetworkInterface> {
    constructor() {
        super("CMsgSystemPerfNetworkInterface", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timestamp", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "tx_bytes_total", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "rx_bytes_total", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "tx_bytes_per_sec", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "rx_bytes_per_sec", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemPerfNetworkInterface>): CMsgSystemPerfNetworkInterface {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemPerfNetworkInterface>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemPerfNetworkInterface): CMsgSystemPerfNetworkInterface {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional double timestamp */ 2:
                    message.timestamp = reader.double();
                    break;
                case /* optional int64 tx_bytes_total */ 3:
                    message.txBytesTotal = reader.int64().toBigInt();
                    break;
                case /* optional int64 rx_bytes_total */ 4:
                    message.rxBytesTotal = reader.int64().toBigInt();
                    break;
                case /* optional int32 tx_bytes_per_sec */ 5:
                    message.txBytesPerSec = reader.int32();
                    break;
                case /* optional int32 rx_bytes_per_sec */ 6:
                    message.rxBytesPerSec = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemPerfNetworkInterface, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional double timestamp = 2; */
        if (message.timestamp !== undefined)
            writer.tag(2, WireType.Bit64).double(message.timestamp);
        /* optional int64 tx_bytes_total = 3; */
        if (message.txBytesTotal !== undefined)
            writer.tag(3, WireType.Varint).int64(message.txBytesTotal);
        /* optional int64 rx_bytes_total = 4; */
        if (message.rxBytesTotal !== undefined)
            writer.tag(4, WireType.Varint).int64(message.rxBytesTotal);
        /* optional int32 tx_bytes_per_sec = 5; */
        if (message.txBytesPerSec !== undefined)
            writer.tag(5, WireType.Varint).int32(message.txBytesPerSec);
        /* optional int32 rx_bytes_per_sec = 6; */
        if (message.rxBytesPerSec !== undefined)
            writer.tag(6, WireType.Varint).int32(message.rxBytesPerSec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemPerfNetworkInterface
 */
export const CMsgSystemPerfNetworkInterface = new CMsgSystemPerfNetworkInterface$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemPerfSettings$Type extends MessageType<CMsgSystemPerfSettings> {
    constructor() {
        super("CMsgSystemPerfSettings", [
            { no: 1, name: "global", kind: "message", T: () => CMsgSystemPerfSettingsGlobal },
            { no: 2, name: "per_app", kind: "message", T: () => CMsgSystemPerfSettingsPerApp }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemPerfSettings>): CMsgSystemPerfSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemPerfSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemPerfSettings): CMsgSystemPerfSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSystemPerfSettingsGlobal global */ 1:
                    message.global = CMsgSystemPerfSettingsGlobal.internalBinaryRead(reader, reader.uint32(), options, message.global);
                    break;
                case /* optional CMsgSystemPerfSettingsPerApp per_app */ 2:
                    message.perApp = CMsgSystemPerfSettingsPerApp.internalBinaryRead(reader, reader.uint32(), options, message.perApp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemPerfSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSystemPerfSettingsGlobal global = 1; */
        if (message.global)
            CMsgSystemPerfSettingsGlobal.internalBinaryWrite(message.global, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSystemPerfSettingsPerApp per_app = 2; */
        if (message.perApp)
            CMsgSystemPerfSettingsPerApp.internalBinaryWrite(message.perApp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemPerfSettings
 */
export const CMsgSystemPerfSettings = new CMsgSystemPerfSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemPerfSettingsGlobal$Type extends MessageType<CMsgSystemPerfSettingsGlobal> {
    constructor() {
        super("CMsgSystemPerfSettingsGlobal", [
            { no: 1, name: "diagnostic_update_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "system_trace_service_state", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 3, name: "graphics_profiling_service_state", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "perf_overlay_service_state", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 5, name: "perf_overlay_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 6, name: "is_show_perf_overlay_over_steam_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "is_advanced_settings_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "allow_external_display_refresh_control", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "hdr_on_sdr_tonemap_operator", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 13, name: "is_hdr_debug_heatmap_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "force_hdr_wide_gammut_for_sdr", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "is_color_management_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "sdr_to_hdr_brightness", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemPerfSettingsGlobal>): CMsgSystemPerfSettingsGlobal {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemPerfSettingsGlobal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemPerfSettingsGlobal): CMsgSystemPerfSettingsGlobal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float diagnostic_update_rate */ 1:
                    message.diagnosticUpdateRate = reader.float();
                    break;
                case /* optional int32 system_trace_service_state */ 2:
                    message.systemTraceServiceState = reader.int32();
                    break;
                case /* optional int32 graphics_profiling_service_state */ 3:
                    message.graphicsProfilingServiceState = reader.int32();
                    break;
                case /* optional int32 perf_overlay_service_state */ 4:
                    message.perfOverlayServiceState = reader.int32();
                    break;
                case /* optional int32 perf_overlay_level */ 5:
                    message.perfOverlayLevel = reader.int32();
                    break;
                case /* optional bool is_show_perf_overlay_over_steam_enabled */ 6:
                    message.isShowPerfOverlayOverSteamEnabled = reader.bool();
                    break;
                case /* optional bool is_advanced_settings_enabled */ 7:
                    message.isAdvancedSettingsEnabled = reader.bool();
                    break;
                case /* optional bool allow_external_display_refresh_control */ 8:
                    message.allowExternalDisplayRefreshControl = reader.bool();
                    break;
                case /* optional int32 hdr_on_sdr_tonemap_operator */ 12:
                    message.hdrOnSdrTonemapOperator = reader.int32();
                    break;
                case /* optional bool is_hdr_debug_heatmap_enabled */ 13:
                    message.isHdrDebugHeatmapEnabled = reader.bool();
                    break;
                case /* optional bool force_hdr_wide_gammut_for_sdr = 15 [default = true] */ 15:
                    message.forceHdrWideGammutForSdr = reader.bool();
                    break;
                case /* optional bool is_color_management_enabled */ 21:
                    message.isColorManagementEnabled = reader.bool();
                    break;
                case /* optional float sdr_to_hdr_brightness */ 22:
                    message.sdrToHdrBrightness = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemPerfSettingsGlobal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float diagnostic_update_rate = 1; */
        if (message.diagnosticUpdateRate !== undefined)
            writer.tag(1, WireType.Bit32).float(message.diagnosticUpdateRate);
        /* optional int32 system_trace_service_state = 2; */
        if (message.systemTraceServiceState !== undefined)
            writer.tag(2, WireType.Varint).int32(message.systemTraceServiceState);
        /* optional int32 graphics_profiling_service_state = 3; */
        if (message.graphicsProfilingServiceState !== undefined)
            writer.tag(3, WireType.Varint).int32(message.graphicsProfilingServiceState);
        /* optional int32 perf_overlay_service_state = 4; */
        if (message.perfOverlayServiceState !== undefined)
            writer.tag(4, WireType.Varint).int32(message.perfOverlayServiceState);
        /* optional int32 perf_overlay_level = 5; */
        if (message.perfOverlayLevel !== undefined)
            writer.tag(5, WireType.Varint).int32(message.perfOverlayLevel);
        /* optional bool is_show_perf_overlay_over_steam_enabled = 6; */
        if (message.isShowPerfOverlayOverSteamEnabled !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isShowPerfOverlayOverSteamEnabled);
        /* optional bool is_advanced_settings_enabled = 7; */
        if (message.isAdvancedSettingsEnabled !== undefined)
            writer.tag(7, WireType.Varint).bool(message.isAdvancedSettingsEnabled);
        /* optional bool allow_external_display_refresh_control = 8; */
        if (message.allowExternalDisplayRefreshControl !== undefined)
            writer.tag(8, WireType.Varint).bool(message.allowExternalDisplayRefreshControl);
        /* optional int32 hdr_on_sdr_tonemap_operator = 12; */
        if (message.hdrOnSdrTonemapOperator !== undefined)
            writer.tag(12, WireType.Varint).int32(message.hdrOnSdrTonemapOperator);
        /* optional bool is_hdr_debug_heatmap_enabled = 13; */
        if (message.isHdrDebugHeatmapEnabled !== undefined)
            writer.tag(13, WireType.Varint).bool(message.isHdrDebugHeatmapEnabled);
        /* optional bool force_hdr_wide_gammut_for_sdr = 15 [default = true]; */
        if (message.forceHdrWideGammutForSdr !== undefined)
            writer.tag(15, WireType.Varint).bool(message.forceHdrWideGammutForSdr);
        /* optional bool is_color_management_enabled = 21; */
        if (message.isColorManagementEnabled !== undefined)
            writer.tag(21, WireType.Varint).bool(message.isColorManagementEnabled);
        /* optional float sdr_to_hdr_brightness = 22; */
        if (message.sdrToHdrBrightness !== undefined)
            writer.tag(22, WireType.Bit32).float(message.sdrToHdrBrightness);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemPerfSettingsGlobal
 */
export const CMsgSystemPerfSettingsGlobal = new CMsgSystemPerfSettingsGlobal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemPerfSettingsPerApp$Type extends MessageType<CMsgSystemPerfSettingsPerApp> {
    constructor() {
        super("CMsgSystemPerfSettingsPerApp", [
            { no: 1, name: "gpu_performance_manual_mhz", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "fps_limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "is_variable_resolution_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_dynamic_refresh_rate_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "tdp_limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "cpu_governor", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 7, name: "cpu_governor_manual_mhz", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "scaling_filter", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "fsr_sharpness", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "is_fps_limit_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "is_tdp_limit_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "is_low_latency_mode_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "display_refresh_manual_hz", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "is_game_perf_profile_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "gpu_performance_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 17, name: "display_external_refresh_manual_hz", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "fps_limit_external", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "is_tearing_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "is_vrr_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "use_dynamic_refresh_rate_in_steam", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "split_scaling_filter", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 25, name: "split_scaling_scaler", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemPerfSettingsPerApp>): CMsgSystemPerfSettingsPerApp {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemPerfSettingsPerApp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemPerfSettingsPerApp): CMsgSystemPerfSettingsPerApp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 gpu_performance_manual_mhz */ 1:
                    message.gpuPerformanceManualMhz = reader.int32();
                    break;
                case /* optional int32 fps_limit */ 2:
                    message.fpsLimit = reader.int32();
                    break;
                case /* optional bool is_variable_resolution_enabled */ 3:
                    message.isVariableResolutionEnabled = reader.bool();
                    break;
                case /* optional bool is_dynamic_refresh_rate_enabled */ 4:
                    message.isDynamicRefreshRateEnabled = reader.bool();
                    break;
                case /* optional int32 tdp_limit */ 5:
                    message.tdpLimit = reader.int32();
                    break;
                case /* optional int32 cpu_governor */ 6:
                    message.cpuGovernor = reader.int32();
                    break;
                case /* optional int32 cpu_governor_manual_mhz */ 7:
                    message.cpuGovernorManualMhz = reader.int32();
                    break;
                case /* optional int32 scaling_filter */ 8:
                    message.scalingFilter = reader.int32();
                    break;
                case /* optional int32 fsr_sharpness */ 9:
                    message.fsrSharpness = reader.int32();
                    break;
                case /* optional bool is_fps_limit_enabled */ 10:
                    message.isFpsLimitEnabled = reader.bool();
                    break;
                case /* optional bool is_tdp_limit_enabled */ 11:
                    message.isTdpLimitEnabled = reader.bool();
                    break;
                case /* optional bool is_low_latency_mode_enabled */ 12:
                    message.isLowLatencyModeEnabled = reader.bool();
                    break;
                case /* optional int32 display_refresh_manual_hz */ 13:
                    message.displayRefreshManualHz = reader.int32();
                    break;
                case /* optional bool is_game_perf_profile_enabled */ 14:
                    message.isGamePerfProfileEnabled = reader.bool();
                    break;
                case /* optional int32 gpu_performance_level */ 15:
                    message.gpuPerformanceLevel = reader.int32();
                    break;
                case /* optional int32 display_external_refresh_manual_hz */ 17:
                    message.displayExternalRefreshManualHz = reader.int32();
                    break;
                case /* optional int32 fps_limit_external */ 18:
                    message.fpsLimitExternal = reader.int32();
                    break;
                case /* optional bool is_tearing_enabled */ 19:
                    message.isTearingEnabled = reader.bool();
                    break;
                case /* optional bool is_vrr_enabled */ 20:
                    message.isVrrEnabled = reader.bool();
                    break;
                case /* optional bool use_dynamic_refresh_rate_in_steam */ 23:
                    message.useDynamicRefreshRateInSteam = reader.bool();
                    break;
                case /* optional int32 split_scaling_filter */ 24:
                    message.splitScalingFilter = reader.int32();
                    break;
                case /* optional int32 split_scaling_scaler */ 25:
                    message.splitScalingScaler = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemPerfSettingsPerApp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 gpu_performance_manual_mhz = 1; */
        if (message.gpuPerformanceManualMhz !== undefined)
            writer.tag(1, WireType.Varint).int32(message.gpuPerformanceManualMhz);
        /* optional int32 fps_limit = 2; */
        if (message.fpsLimit !== undefined)
            writer.tag(2, WireType.Varint).int32(message.fpsLimit);
        /* optional bool is_variable_resolution_enabled = 3; */
        if (message.isVariableResolutionEnabled !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isVariableResolutionEnabled);
        /* optional bool is_dynamic_refresh_rate_enabled = 4; */
        if (message.isDynamicRefreshRateEnabled !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isDynamicRefreshRateEnabled);
        /* optional int32 tdp_limit = 5; */
        if (message.tdpLimit !== undefined)
            writer.tag(5, WireType.Varint).int32(message.tdpLimit);
        /* optional int32 cpu_governor = 6; */
        if (message.cpuGovernor !== undefined)
            writer.tag(6, WireType.Varint).int32(message.cpuGovernor);
        /* optional int32 cpu_governor_manual_mhz = 7; */
        if (message.cpuGovernorManualMhz !== undefined)
            writer.tag(7, WireType.Varint).int32(message.cpuGovernorManualMhz);
        /* optional int32 scaling_filter = 8; */
        if (message.scalingFilter !== undefined)
            writer.tag(8, WireType.Varint).int32(message.scalingFilter);
        /* optional int32 fsr_sharpness = 9; */
        if (message.fsrSharpness !== undefined)
            writer.tag(9, WireType.Varint).int32(message.fsrSharpness);
        /* optional bool is_fps_limit_enabled = 10; */
        if (message.isFpsLimitEnabled !== undefined)
            writer.tag(10, WireType.Varint).bool(message.isFpsLimitEnabled);
        /* optional bool is_tdp_limit_enabled = 11; */
        if (message.isTdpLimitEnabled !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isTdpLimitEnabled);
        /* optional bool is_low_latency_mode_enabled = 12; */
        if (message.isLowLatencyModeEnabled !== undefined)
            writer.tag(12, WireType.Varint).bool(message.isLowLatencyModeEnabled);
        /* optional int32 display_refresh_manual_hz = 13; */
        if (message.displayRefreshManualHz !== undefined)
            writer.tag(13, WireType.Varint).int32(message.displayRefreshManualHz);
        /* optional bool is_game_perf_profile_enabled = 14; */
        if (message.isGamePerfProfileEnabled !== undefined)
            writer.tag(14, WireType.Varint).bool(message.isGamePerfProfileEnabled);
        /* optional int32 gpu_performance_level = 15; */
        if (message.gpuPerformanceLevel !== undefined)
            writer.tag(15, WireType.Varint).int32(message.gpuPerformanceLevel);
        /* optional int32 display_external_refresh_manual_hz = 17; */
        if (message.displayExternalRefreshManualHz !== undefined)
            writer.tag(17, WireType.Varint).int32(message.displayExternalRefreshManualHz);
        /* optional int32 fps_limit_external = 18; */
        if (message.fpsLimitExternal !== undefined)
            writer.tag(18, WireType.Varint).int32(message.fpsLimitExternal);
        /* optional bool is_tearing_enabled = 19; */
        if (message.isTearingEnabled !== undefined)
            writer.tag(19, WireType.Varint).bool(message.isTearingEnabled);
        /* optional bool is_vrr_enabled = 20; */
        if (message.isVrrEnabled !== undefined)
            writer.tag(20, WireType.Varint).bool(message.isVrrEnabled);
        /* optional bool use_dynamic_refresh_rate_in_steam = 23; */
        if (message.useDynamicRefreshRateInSteam !== undefined)
            writer.tag(23, WireType.Varint).bool(message.useDynamicRefreshRateInSteam);
        /* optional int32 split_scaling_filter = 24; */
        if (message.splitScalingFilter !== undefined)
            writer.tag(24, WireType.Varint).int32(message.splitScalingFilter);
        /* optional int32 split_scaling_scaler = 25; */
        if (message.splitScalingScaler !== undefined)
            writer.tag(25, WireType.Varint).int32(message.splitScalingScaler);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemPerfSettingsPerApp
 */
export const CMsgSystemPerfSettingsPerApp = new CMsgSystemPerfSettingsPerApp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemPerfState$Type extends MessageType<CMsgSystemPerfState> {
    constructor() {
        super("CMsgSystemPerfState", [
            { no: 1, name: "limits", kind: "message", T: () => CMsgSystemPerfLimits },
            { no: 2, name: "settings", kind: "message", T: () => CMsgSystemPerfSettings },
            { no: 3, name: "current_game_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "active_profile_game_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemPerfState>): CMsgSystemPerfState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemPerfState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemPerfState): CMsgSystemPerfState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSystemPerfLimits limits */ 1:
                    message.limits = CMsgSystemPerfLimits.internalBinaryRead(reader, reader.uint32(), options, message.limits);
                    break;
                case /* optional CMsgSystemPerfSettings settings */ 2:
                    message.settings = CMsgSystemPerfSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                case /* optional uint64 current_game_id */ 3:
                    message.currentGameId = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 active_profile_game_id */ 4:
                    message.activeProfileGameId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemPerfState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSystemPerfLimits limits = 1; */
        if (message.limits)
            CMsgSystemPerfLimits.internalBinaryWrite(message.limits, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSystemPerfSettings settings = 2; */
        if (message.settings)
            CMsgSystemPerfSettings.internalBinaryWrite(message.settings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 current_game_id = 3; */
        if (message.currentGameId !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.currentGameId);
        /* optional uint64 active_profile_game_id = 4; */
        if (message.activeProfileGameId !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.activeProfileGameId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemPerfState
 */
export const CMsgSystemPerfState = new CMsgSystemPerfState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemPerfUpdateSettings$Type extends MessageType<CMsgSystemPerfUpdateSettings> {
    constructor() {
        super("CMsgSystemPerfUpdateSettings", [
            { no: 1, name: "gameid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "reset_to_default", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "settings_delta", kind: "message", T: () => CMsgSystemPerfSettings },
            { no: 4, name: "skip_storage_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemPerfUpdateSettings>): CMsgSystemPerfUpdateSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemPerfUpdateSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemPerfUpdateSettings): CMsgSystemPerfUpdateSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 gameid */ 1:
                    message.gameid = reader.uint64().toBigInt();
                    break;
                case /* optional bool reset_to_default */ 2:
                    message.resetToDefault = reader.bool();
                    break;
                case /* optional CMsgSystemPerfSettings settings_delta */ 3:
                    message.settingsDelta = CMsgSystemPerfSettings.internalBinaryRead(reader, reader.uint32(), options, message.settingsDelta);
                    break;
                case /* optional bool skip_storage_update */ 4:
                    message.skipStorageUpdate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemPerfUpdateSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 gameid = 1; */
        if (message.gameid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.gameid);
        /* optional bool reset_to_default = 2; */
        if (message.resetToDefault !== undefined)
            writer.tag(2, WireType.Varint).bool(message.resetToDefault);
        /* optional CMsgSystemPerfSettings settings_delta = 3; */
        if (message.settingsDelta)
            CMsgSystemPerfSettings.internalBinaryWrite(message.settingsDelta, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional bool skip_storage_update = 4; */
        if (message.skipStorageUpdate !== undefined)
            writer.tag(4, WireType.Varint).bool(message.skipStorageUpdate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemPerfUpdateSettings
 */
export const CMsgSystemPerfUpdateSettings = new CMsgSystemPerfUpdateSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemUpdateApplyParams$Type extends MessageType<CMsgSystemUpdateApplyParams> {
    constructor() {
        super("CMsgSystemUpdateApplyParams", [
            { no: 1, name: "apply_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemUpdateApplyParams>): CMsgSystemUpdateApplyParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.applyTypes = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemUpdateApplyParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemUpdateApplyParams): CMsgSystemUpdateApplyParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 apply_types */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.applyTypes.push(reader.int32());
                    else
                        message.applyTypes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemUpdateApplyParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 apply_types = 1; */
        for (let i = 0; i < message.applyTypes.length; i++)
            writer.tag(1, WireType.Varint).int32(message.applyTypes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemUpdateApplyParams
 */
export const CMsgSystemUpdateApplyParams = new CMsgSystemUpdateApplyParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemUpdateApplyResult$Type extends MessageType<CMsgSystemUpdateApplyResult> {
    constructor() {
        super("CMsgSystemUpdateApplyResult", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "requires_client_restart", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "requires_system_restart", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemUpdateApplyResult>): CMsgSystemUpdateApplyResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemUpdateApplyResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemUpdateApplyResult): CMsgSystemUpdateApplyResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional uint32 eresult = 2 [default = 2] */ 2:
                    message.eresult = reader.uint32();
                    break;
                case /* optional bool requires_client_restart = 3 [default = false] */ 3:
                    message.requiresClientRestart = reader.bool();
                    break;
                case /* optional bool requires_system_restart = 4 [default = false] */ 4:
                    message.requiresSystemRestart = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemUpdateApplyResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional uint32 eresult = 2 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eresult);
        /* optional bool requires_client_restart = 3 [default = false]; */
        if (message.requiresClientRestart !== undefined)
            writer.tag(3, WireType.Varint).bool(message.requiresClientRestart);
        /* optional bool requires_system_restart = 4 [default = false]; */
        if (message.requiresSystemRestart !== undefined)
            writer.tag(4, WireType.Varint).bool(message.requiresSystemRestart);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemUpdateApplyResult
 */
export const CMsgSystemUpdateApplyResult = new CMsgSystemUpdateApplyResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemUpdateCheckResult$Type extends MessageType<CMsgSystemUpdateCheckResult> {
    constructor() {
        super("CMsgSystemUpdateCheckResult", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "rtime_checked", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "available", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "auto_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "system_restart_pending", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemUpdateCheckResult>): CMsgSystemUpdateCheckResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemUpdateCheckResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemUpdateCheckResult): CMsgSystemUpdateCheckResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional uint32 eresult = 2 [default = 2] */ 2:
                    message.eresult = reader.uint32();
                    break;
                case /* optional fixed32 rtime_checked */ 3:
                    message.rtimeChecked = reader.fixed32();
                    break;
                case /* optional bool available */ 4:
                    message.available = reader.bool();
                    break;
                case /* optional string version */ 5:
                    message.version = reader.string();
                    break;
                case /* optional string auto_message */ 6:
                    message.autoMessage = reader.string();
                    break;
                case /* optional bool system_restart_pending */ 7:
                    message.systemRestartPending = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemUpdateCheckResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional uint32 eresult = 2 [default = 2]; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eresult);
        /* optional fixed32 rtime_checked = 3; */
        if (message.rtimeChecked !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.rtimeChecked);
        /* optional bool available = 4; */
        if (message.available !== undefined)
            writer.tag(4, WireType.Varint).bool(message.available);
        /* optional string version = 5; */
        if (message.version !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* optional string auto_message = 6; */
        if (message.autoMessage !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.autoMessage);
        /* optional bool system_restart_pending = 7; */
        if (message.systemRestartPending !== undefined)
            writer.tag(7, WireType.Varint).bool(message.systemRestartPending);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemUpdateCheckResult
 */
export const CMsgSystemUpdateCheckResult = new CMsgSystemUpdateCheckResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemUpdateProgress$Type extends MessageType<CMsgSystemUpdateProgress> {
    constructor() {
        super("CMsgSystemUpdateProgress", [
            { no: 1, name: "stage_progress", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "stage_size_bytes", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "rtime_estimated_completion", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemUpdateProgress>): CMsgSystemUpdateProgress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemUpdateProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemUpdateProgress): CMsgSystemUpdateProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float stage_progress */ 1:
                    message.stageProgress = reader.float();
                    break;
                case /* optional int64 stage_size_bytes */ 2:
                    message.stageSizeBytes = reader.int64().toBigInt();
                    break;
                case /* optional fixed32 rtime_estimated_completion */ 3:
                    message.rtimeEstimatedCompletion = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemUpdateProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float stage_progress = 1; */
        if (message.stageProgress !== undefined)
            writer.tag(1, WireType.Bit32).float(message.stageProgress);
        /* optional int64 stage_size_bytes = 2; */
        if (message.stageSizeBytes !== undefined)
            writer.tag(2, WireType.Varint).int64(message.stageSizeBytes);
        /* optional fixed32 rtime_estimated_completion = 3; */
        if (message.rtimeEstimatedCompletion !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.rtimeEstimatedCompletion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemUpdateProgress
 */
export const CMsgSystemUpdateProgress = new CMsgSystemUpdateProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSystemUpdateState$Type extends MessageType<CMsgSystemUpdateState> {
    constructor() {
        super("CMsgSystemUpdateState", [
            { no: 1, name: "state", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "progress", kind: "message", T: () => CMsgSystemUpdateProgress },
            { no: 3, name: "update_check_results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemUpdateCheckResult },
            { no: 4, name: "update_apply_results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSystemUpdateApplyResult },
            { no: 5, name: "supports_os_updates", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSystemUpdateState>): CMsgSystemUpdateState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updateCheckResults = [];
        message.updateApplyResults = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSystemUpdateState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSystemUpdateState): CMsgSystemUpdateState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 state */ 1:
                    message.state = reader.int32();
                    break;
                case /* optional CMsgSystemUpdateProgress progress */ 2:
                    message.progress = CMsgSystemUpdateProgress.internalBinaryRead(reader, reader.uint32(), options, message.progress);
                    break;
                case /* repeated CMsgSystemUpdateCheckResult update_check_results */ 3:
                    message.updateCheckResults.push(CMsgSystemUpdateCheckResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSystemUpdateApplyResult update_apply_results */ 4:
                    message.updateApplyResults.push(CMsgSystemUpdateApplyResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool supports_os_updates */ 5:
                    message.supportsOsUpdates = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSystemUpdateState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 state = 1; */
        if (message.state !== undefined)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* optional CMsgSystemUpdateProgress progress = 2; */
        if (message.progress)
            CMsgSystemUpdateProgress.internalBinaryWrite(message.progress, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSystemUpdateCheckResult update_check_results = 3; */
        for (let i = 0; i < message.updateCheckResults.length; i++)
            CMsgSystemUpdateCheckResult.internalBinaryWrite(message.updateCheckResults[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSystemUpdateApplyResult update_apply_results = 4; */
        for (let i = 0; i < message.updateApplyResults.length; i++)
            CMsgSystemUpdateApplyResult.internalBinaryWrite(message.updateApplyResults[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional bool supports_os_updates = 5; */
        if (message.supportsOsUpdates !== undefined)
            writer.tag(5, WireType.Varint).bool(message.supportsOsUpdates);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSystemUpdateState
 */
export const CMsgSystemUpdateState = new CMsgSystemUpdateState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgTrading_CancelTradeRequest$Type extends MessageType<CMsgTrading_CancelTradeRequest> {
    constructor() {
        super("CMsgTrading_CancelTradeRequest", [
            { no: 1, name: "other_steamid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgTrading_CancelTradeRequest>): CMsgTrading_CancelTradeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgTrading_CancelTradeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgTrading_CancelTradeRequest): CMsgTrading_CancelTradeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 other_steamid */ 1:
                    message.otherSteamid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgTrading_CancelTradeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 other_steamid = 1; */
        if (message.otherSteamid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.otherSteamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgTrading_CancelTradeRequest
 */
export const CMsgTrading_CancelTradeRequest = new CMsgTrading_CancelTradeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgTrading_InitiateTradeRequest$Type extends MessageType<CMsgTrading_InitiateTradeRequest> {
    constructor() {
        super("CMsgTrading_InitiateTradeRequest", [
            { no: 1, name: "trade_request_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "other_steamid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "other_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgTrading_InitiateTradeRequest>): CMsgTrading_InitiateTradeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgTrading_InitiateTradeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgTrading_InitiateTradeRequest): CMsgTrading_InitiateTradeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 trade_request_id */ 1:
                    message.tradeRequestId = reader.uint32();
                    break;
                case /* optional uint64 other_steamid */ 2:
                    message.otherSteamid = reader.uint64().toBigInt();
                    break;
                case /* optional string other_name */ 3:
                    message.otherName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgTrading_InitiateTradeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 trade_request_id = 1; */
        if (message.tradeRequestId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.tradeRequestId);
        /* optional uint64 other_steamid = 2; */
        if (message.otherSteamid !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.otherSteamid);
        /* optional string other_name = 3; */
        if (message.otherName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.otherName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgTrading_InitiateTradeRequest
 */
export const CMsgTrading_InitiateTradeRequest = new CMsgTrading_InitiateTradeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgTrading_InitiateTradeResponse$Type extends MessageType<CMsgTrading_InitiateTradeResponse> {
    constructor() {
        super("CMsgTrading_InitiateTradeResponse", [
            { no: 1, name: "response", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "trade_request_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "other_steamid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "steamguard_required_days", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "new_device_cooldown_days", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "default_password_reset_probation_days", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "password_reset_probation_days", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "default_email_change_probation_days", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "email_change_probation_days", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgTrading_InitiateTradeResponse>): CMsgTrading_InitiateTradeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgTrading_InitiateTradeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgTrading_InitiateTradeResponse): CMsgTrading_InitiateTradeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 response */ 1:
                    message.response = reader.uint32();
                    break;
                case /* optional uint32 trade_request_id */ 2:
                    message.tradeRequestId = reader.uint32();
                    break;
                case /* optional uint64 other_steamid */ 3:
                    message.otherSteamid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 steamguard_required_days */ 4:
                    message.steamguardRequiredDays = reader.uint32();
                    break;
                case /* optional uint32 new_device_cooldown_days */ 5:
                    message.newDeviceCooldownDays = reader.uint32();
                    break;
                case /* optional uint32 default_password_reset_probation_days */ 6:
                    message.defaultPasswordResetProbationDays = reader.uint32();
                    break;
                case /* optional uint32 password_reset_probation_days */ 7:
                    message.passwordResetProbationDays = reader.uint32();
                    break;
                case /* optional uint32 default_email_change_probation_days */ 8:
                    message.defaultEmailChangeProbationDays = reader.uint32();
                    break;
                case /* optional uint32 email_change_probation_days */ 9:
                    message.emailChangeProbationDays = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgTrading_InitiateTradeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 response = 1; */
        if (message.response !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.response);
        /* optional uint32 trade_request_id = 2; */
        if (message.tradeRequestId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.tradeRequestId);
        /* optional uint64 other_steamid = 3; */
        if (message.otherSteamid !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.otherSteamid);
        /* optional uint32 steamguard_required_days = 4; */
        if (message.steamguardRequiredDays !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.steamguardRequiredDays);
        /* optional uint32 new_device_cooldown_days = 5; */
        if (message.newDeviceCooldownDays !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.newDeviceCooldownDays);
        /* optional uint32 default_password_reset_probation_days = 6; */
        if (message.defaultPasswordResetProbationDays !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.defaultPasswordResetProbationDays);
        /* optional uint32 password_reset_probation_days = 7; */
        if (message.passwordResetProbationDays !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.passwordResetProbationDays);
        /* optional uint32 default_email_change_probation_days = 8; */
        if (message.defaultEmailChangeProbationDays !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.defaultEmailChangeProbationDays);
        /* optional uint32 email_change_probation_days = 9; */
        if (message.emailChangeProbationDays !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.emailChangeProbationDays);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgTrading_InitiateTradeResponse
 */
export const CMsgTrading_InitiateTradeResponse = new CMsgTrading_InitiateTradeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgTrading_StartSession$Type extends MessageType<CMsgTrading_StartSession> {
    constructor() {
        super("CMsgTrading_StartSession", [
            { no: 1, name: "other_steamid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgTrading_StartSession>): CMsgTrading_StartSession {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgTrading_StartSession>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgTrading_StartSession): CMsgTrading_StartSession {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 other_steamid */ 1:
                    message.otherSteamid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgTrading_StartSession, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 other_steamid = 1; */
        if (message.otherSteamid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.otherSteamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgTrading_StartSession
 */
export const CMsgTrading_StartSession = new CMsgTrading_StartSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgWebUITransportFailure$Type extends MessageType<CMsgWebUITransportFailure> {
    constructor() {
        super("CMsgWebUITransportFailure", [
            { no: 1, name: "connect_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgWebUITransportFailure>): CMsgWebUITransportFailure {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgWebUITransportFailure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgWebUITransportFailure): CMsgWebUITransportFailure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 connect_count */ 1:
                    message.connectCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgWebUITransportFailure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 connect_count = 1; */
        if (message.connectCount !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.connectCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgWebUITransportFailure
 */
export const CMsgWebUITransportFailure = new CMsgWebUITransportFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CProductImpressionsFromClient_Notification$Type extends MessageType<CProductImpressionsFromClient_Notification> {
    constructor() {
        super("CProductImpressionsFromClient_Notification", [
            { no: 1, name: "impressions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CProductImpressionsFromClient_Notification_Impression }
        ]);
    }
    create(value?: PartialMessage<CProductImpressionsFromClient_Notification>): CProductImpressionsFromClient_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.impressions = [];
        if (value !== undefined)
            reflectionMergePartial<CProductImpressionsFromClient_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CProductImpressionsFromClient_Notification): CProductImpressionsFromClient_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CProductImpressionsFromClient_Notification_Impression impressions */ 1:
                    message.impressions.push(CProductImpressionsFromClient_Notification_Impression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CProductImpressionsFromClient_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CProductImpressionsFromClient_Notification_Impression impressions = 1; */
        for (let i = 0; i < message.impressions.length; i++)
            CProductImpressionsFromClient_Notification_Impression.internalBinaryWrite(message.impressions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CProductImpressionsFromClient_Notification
 */
export const CProductImpressionsFromClient_Notification = new CProductImpressionsFromClient_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CProductImpressionsFromClient_Notification_Impression$Type extends MessageType<CProductImpressionsFromClient_Notification_Impression> {
    constructor() {
        super("CProductImpressionsFromClient_Notification_Impression", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "num_impressions", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CProductImpressionsFromClient_Notification_Impression>): CProductImpressionsFromClient_Notification_Impression {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CProductImpressionsFromClient_Notification_Impression>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CProductImpressionsFromClient_Notification_Impression): CProductImpressionsFromClient_Notification_Impression {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional uint32 appid */ 2:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 num_impressions */ 3:
                    message.numImpressions = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CProductImpressionsFromClient_Notification_Impression, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional uint32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appid);
        /* optional uint32 num_impressions = 3; */
        if (message.numImpressions !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.numImpressions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CProductImpressionsFromClient_Notification_Impression
 */
export const CProductImpressionsFromClient_Notification_Impression = new CProductImpressionsFromClient_Notification_Impression$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CRemotePlay_SessionStopped_Notification$Type extends MessageType<CRemotePlay_SessionStopped_Notification> {
    constructor() {
        super("CRemotePlay_SessionStopped_Notification", [
            { no: 1, name: "record_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "used_x264", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "used_h264", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "used_hevc", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CRemotePlay_SessionStopped_Notification>): CRemotePlay_SessionStopped_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CRemotePlay_SessionStopped_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CRemotePlay_SessionStopped_Notification): CRemotePlay_SessionStopped_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 record_id */ 1:
                    message.recordId = reader.fixed64().toBigInt();
                    break;
                case /* optional bool used_x264 */ 2:
                    message.usedX264 = reader.bool();
                    break;
                case /* optional bool used_h264 */ 3:
                    message.usedH264 = reader.bool();
                    break;
                case /* optional bool used_hevc */ 4:
                    message.usedHevc = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CRemotePlay_SessionStopped_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 record_id = 1; */
        if (message.recordId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.recordId);
        /* optional bool used_x264 = 2; */
        if (message.usedX264 !== undefined)
            writer.tag(2, WireType.Varint).bool(message.usedX264);
        /* optional bool used_h264 = 3; */
        if (message.usedH264 !== undefined)
            writer.tag(3, WireType.Varint).bool(message.usedH264);
        /* optional bool used_hevc = 4; */
        if (message.usedHevc !== undefined)
            writer.tag(4, WireType.Varint).bool(message.usedHevc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CRemotePlay_SessionStopped_Notification
 */
export const CRemotePlay_SessionStopped_Notification = new CRemotePlay_SessionStopped_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_AudioSettings_ChangeSettings_Request$Type extends MessageType<CSteamVR_AudioSettings_ChangeSettings_Request> {
    constructor() {
        super("CSteamVR_AudioSettings_ChangeSettings_Request", [
            { no: 1, name: "settings", kind: "message", T: () => CSteamVR_AudioSettings_Settings }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_AudioSettings_ChangeSettings_Request>): CSteamVR_AudioSettings_ChangeSettings_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_AudioSettings_ChangeSettings_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_AudioSettings_ChangeSettings_Request): CSteamVR_AudioSettings_ChangeSettings_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CSteamVR_AudioSettings_Settings settings */ 1:
                    message.settings = CSteamVR_AudioSettings_Settings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_AudioSettings_ChangeSettings_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CSteamVR_AudioSettings_Settings settings = 1; */
        if (message.settings)
            CSteamVR_AudioSettings_Settings.internalBinaryWrite(message.settings, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_AudioSettings_ChangeSettings_Request
 */
export const CSteamVR_AudioSettings_ChangeSettings_Request = new CSteamVR_AudioSettings_ChangeSettings_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_AudioSettings_RegisterForSettings_Request$Type extends MessageType<CSteamVR_AudioSettings_RegisterForSettings_Request> {
    constructor() {
        super("CSteamVR_AudioSettings_RegisterForSettings_Request", []);
    }
    create(value?: PartialMessage<CSteamVR_AudioSettings_RegisterForSettings_Request>): CSteamVR_AudioSettings_RegisterForSettings_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_AudioSettings_RegisterForSettings_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_AudioSettings_RegisterForSettings_Request): CSteamVR_AudioSettings_RegisterForSettings_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_AudioSettings_RegisterForSettings_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_AudioSettings_RegisterForSettings_Request
 */
export const CSteamVR_AudioSettings_RegisterForSettings_Request = new CSteamVR_AudioSettings_RegisterForSettings_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_AudioSettings_Settings$Type extends MessageType<CSteamVR_AudioSettings_Settings> {
    constructor() {
        super("CSteamVR_AudioSettings_Settings", [
            { no: 1, name: "main", kind: "message", T: () => CSteamVR_AudioSettings_Settings_Channel },
            { no: 2, name: "audio_mirror", kind: "message", T: () => CSteamVR_AudioSettings_Settings_Channel },
            { no: 3, name: "microphone", kind: "message", T: () => CSteamVR_AudioSettings_Settings_Channel }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_AudioSettings_Settings>): CSteamVR_AudioSettings_Settings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_AudioSettings_Settings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_AudioSettings_Settings): CSteamVR_AudioSettings_Settings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CSteamVR_AudioSettings_Settings_Channel main */ 1:
                    message.main = CSteamVR_AudioSettings_Settings_Channel.internalBinaryRead(reader, reader.uint32(), options, message.main);
                    break;
                case /* optional CSteamVR_AudioSettings_Settings_Channel audio_mirror */ 2:
                    message.audioMirror = CSteamVR_AudioSettings_Settings_Channel.internalBinaryRead(reader, reader.uint32(), options, message.audioMirror);
                    break;
                case /* optional CSteamVR_AudioSettings_Settings_Channel microphone */ 3:
                    message.microphone = CSteamVR_AudioSettings_Settings_Channel.internalBinaryRead(reader, reader.uint32(), options, message.microphone);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_AudioSettings_Settings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CSteamVR_AudioSettings_Settings_Channel main = 1; */
        if (message.main)
            CSteamVR_AudioSettings_Settings_Channel.internalBinaryWrite(message.main, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CSteamVR_AudioSettings_Settings_Channel audio_mirror = 2; */
        if (message.audioMirror)
            CSteamVR_AudioSettings_Settings_Channel.internalBinaryWrite(message.audioMirror, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional CSteamVR_AudioSettings_Settings_Channel microphone = 3; */
        if (message.microphone)
            CSteamVR_AudioSettings_Settings_Channel.internalBinaryWrite(message.microphone, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_AudioSettings_Settings
 */
export const CSteamVR_AudioSettings_Settings = new CSteamVR_AudioSettings_Settings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_AudioSettings_Settings_Channel$Type extends MessageType<CSteamVR_AudioSettings_Settings_Channel> {
    constructor() {
        super("CSteamVR_AudioSettings_Settings_Channel", [
            { no: 1, name: "available", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "muted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "volume", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_AudioSettings_Settings_Channel>): CSteamVR_AudioSettings_Settings_Channel {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_AudioSettings_Settings_Channel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_AudioSettings_Settings_Channel): CSteamVR_AudioSettings_Settings_Channel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool available */ 1:
                    message.available = reader.bool();
                    break;
                case /* optional bool muted */ 2:
                    message.muted = reader.bool();
                    break;
                case /* optional float volume */ 3:
                    message.volume = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_AudioSettings_Settings_Channel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool available = 1; */
        if (message.available !== undefined)
            writer.tag(1, WireType.Varint).bool(message.available);
        /* optional bool muted = 2; */
        if (message.muted !== undefined)
            writer.tag(2, WireType.Varint).bool(message.muted);
        /* optional float volume = 3; */
        if (message.volume !== undefined)
            writer.tag(3, WireType.Bit32).float(message.volume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_AudioSettings_Settings_Channel
 */
export const CSteamVR_AudioSettings_Settings_Channel = new CSteamVR_AudioSettings_Settings_Channel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_AudioSettings_SettingsChanged_Notification$Type extends MessageType<CSteamVR_AudioSettings_SettingsChanged_Notification> {
    constructor() {
        super("CSteamVR_AudioSettings_SettingsChanged_Notification", [
            { no: 1, name: "settings", kind: "message", T: () => CSteamVR_AudioSettings_Settings }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_AudioSettings_SettingsChanged_Notification>): CSteamVR_AudioSettings_SettingsChanged_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_AudioSettings_SettingsChanged_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_AudioSettings_SettingsChanged_Notification): CSteamVR_AudioSettings_SettingsChanged_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CSteamVR_AudioSettings_Settings settings */ 1:
                    message.settings = CSteamVR_AudioSettings_Settings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_AudioSettings_SettingsChanged_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CSteamVR_AudioSettings_Settings settings = 1; */
        if (message.settings)
            CSteamVR_AudioSettings_Settings.internalBinaryWrite(message.settings, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_AudioSettings_SettingsChanged_Notification
 */
export const CSteamVR_AudioSettings_SettingsChanged_Notification = new CSteamVR_AudioSettings_SettingsChanged_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_Header$Type extends MessageType<CSteamVR_Header> {
    constructor() {
        super("CSteamVR_Header", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_Header>): CSteamVR_Header {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_Header): CSteamVR_Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional uint32 id */ 2:
                    message.id = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional uint32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_Header
 */
export const CSteamVR_Header = new CSteamVR_Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_Settings_SetValue_Request$Type extends MessageType<CSteamVR_Settings_SetValue_Request> {
    constructor() {
        super("CSteamVR_Settings_SetValue_Request", [
            { no: 1, name: "section", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settings_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bool", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "int", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_Settings_SetValue_Request>): CSteamVR_Settings_SetValue_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_Settings_SetValue_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_Settings_SetValue_Request): CSteamVR_Settings_SetValue_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string section */ 1:
                    message.section = reader.string();
                    break;
                case /* optional string settings_key */ 2:
                    message.settingsKey = reader.string();
                    break;
                case /* optional bool bool */ 3:
                    message.bool = reader.bool();
                    break;
                case /* optional int32 int */ 4:
                    message.int = reader.int32();
                    break;
                case /* optional float float */ 5:
                    message.float = reader.float();
                    break;
                case /* optional string string */ 6:
                    message.string = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_Settings_SetValue_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string section = 1; */
        if (message.section !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.section);
        /* optional string settings_key = 2; */
        if (message.settingsKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.settingsKey);
        /* optional bool bool = 3; */
        if (message.bool !== undefined)
            writer.tag(3, WireType.Varint).bool(message.bool);
        /* optional int32 int = 4; */
        if (message.int !== undefined)
            writer.tag(4, WireType.Varint).int32(message.int);
        /* optional float float = 5; */
        if (message.float !== undefined)
            writer.tag(5, WireType.Bit32).float(message.float);
        /* optional string string = 6; */
        if (message.string !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.string);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_Settings_SetValue_Request
 */
export const CSteamVR_Settings_SetValue_Request = new CSteamVR_Settings_SetValue_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_Active_Notification$Type extends MessageType<CSteamVR_VoiceChat_Active_Notification> {
    constructor() {
        super("CSteamVR_VoiceChat_Active_Notification", []);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_Active_Notification>): CSteamVR_VoiceChat_Active_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_Active_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_Active_Notification): CSteamVR_VoiceChat_Active_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_Active_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_Active_Notification
 */
export const CSteamVR_VoiceChat_Active_Notification = new CSteamVR_VoiceChat_Active_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_ConfigureVideo_Request$Type extends MessageType<CSteamVR_VoiceChat_ConfigureVideo_Request> {
    constructor() {
        super("CSteamVR_VoiceChat_ConfigureVideo_Request", [
            { no: 1, name: "send", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "receive", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_ConfigureVideo_Request>): CSteamVR_VoiceChat_ConfigureVideo_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_ConfigureVideo_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_ConfigureVideo_Request): CSteamVR_VoiceChat_ConfigureVideo_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool send */ 1:
                    message.send = reader.bool();
                    break;
                case /* optional bool receive */ 2:
                    message.receive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_ConfigureVideo_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool send = 1; */
        if (message.send !== undefined)
            writer.tag(1, WireType.Varint).bool(message.send);
        /* optional bool receive = 2; */
        if (message.receive !== undefined)
            writer.tag(2, WireType.Varint).bool(message.receive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_ConfigureVideo_Request
 */
export const CSteamVR_VoiceChat_ConfigureVideo_Request = new CSteamVR_VoiceChat_ConfigureVideo_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_ConfigureVideo_Response$Type extends MessageType<CSteamVR_VoiceChat_ConfigureVideo_Response> {
    constructor() {
        super("CSteamVR_VoiceChat_ConfigureVideo_Response", []);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_ConfigureVideo_Response>): CSteamVR_VoiceChat_ConfigureVideo_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_ConfigureVideo_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_ConfigureVideo_Response): CSteamVR_VoiceChat_ConfigureVideo_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_ConfigureVideo_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_ConfigureVideo_Response
 */
export const CSteamVR_VoiceChat_ConfigureVideo_Response = new CSteamVR_VoiceChat_ConfigureVideo_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_ExitRoomChat_Request$Type extends MessageType<CSteamVR_VoiceChat_ExitRoomChat_Request> {
    constructor() {
        super("CSteamVR_VoiceChat_ExitRoomChat_Request", [
            { no: 1, name: "chat_group_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "chat_room_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_ExitRoomChat_Request>): CSteamVR_VoiceChat_ExitRoomChat_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_ExitRoomChat_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_ExitRoomChat_Request): CSteamVR_VoiceChat_ExitRoomChat_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 chat_group_id */ 1:
                    message.chatGroupId = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 chat_room_id */ 2:
                    message.chatRoomId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_ExitRoomChat_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 chat_group_id = 1; */
        if (message.chatGroupId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.chatGroupId);
        /* optional uint64 chat_room_id = 2; */
        if (message.chatRoomId !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.chatRoomId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_ExitRoomChat_Request
 */
export const CSteamVR_VoiceChat_ExitRoomChat_Request = new CSteamVR_VoiceChat_ExitRoomChat_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_ExitRoomChat_Response$Type extends MessageType<CSteamVR_VoiceChat_ExitRoomChat_Response> {
    constructor() {
        super("CSteamVR_VoiceChat_ExitRoomChat_Response", []);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_ExitRoomChat_Response>): CSteamVR_VoiceChat_ExitRoomChat_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_ExitRoomChat_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_ExitRoomChat_Response): CSteamVR_VoiceChat_ExitRoomChat_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_ExitRoomChat_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_ExitRoomChat_Response
 */
export const CSteamVR_VoiceChat_ExitRoomChat_Response = new CSteamVR_VoiceChat_ExitRoomChat_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_GetAvatarUrl_Request$Type extends MessageType<CSteamVR_VoiceChat_GetAvatarUrl_Request> {
    constructor() {
        super("CSteamVR_VoiceChat_GetAvatarUrl_Request", [
            { no: 1, name: "profile_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "avatar_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_GetAvatarUrl_Request>): CSteamVR_VoiceChat_GetAvatarUrl_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_GetAvatarUrl_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_GetAvatarUrl_Request): CSteamVR_VoiceChat_GetAvatarUrl_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 profile_steamid */ 1:
                    message.profileSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 avatar_type */ 2:
                    message.avatarType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_GetAvatarUrl_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 profile_steamid = 1; */
        if (message.profileSteamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.profileSteamid);
        /* optional int32 avatar_type = 2; */
        if (message.avatarType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.avatarType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_GetAvatarUrl_Request
 */
export const CSteamVR_VoiceChat_GetAvatarUrl_Request = new CSteamVR_VoiceChat_GetAvatarUrl_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_GetAvatarUrl_Response$Type extends MessageType<CSteamVR_VoiceChat_GetAvatarUrl_Response> {
    constructor() {
        super("CSteamVR_VoiceChat_GetAvatarUrl_Response", [
            { no: 1, name: "profile_avatar_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_GetAvatarUrl_Response>): CSteamVR_VoiceChat_GetAvatarUrl_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_GetAvatarUrl_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_GetAvatarUrl_Response): CSteamVR_VoiceChat_GetAvatarUrl_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string profile_avatar_url */ 1:
                    message.profileAvatarUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_GetAvatarUrl_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string profile_avatar_url = 1; */
        if (message.profileAvatarUrl !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.profileAvatarUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_GetAvatarUrl_Response
 */
export const CSteamVR_VoiceChat_GetAvatarUrl_Response = new CSteamVR_VoiceChat_GetAvatarUrl_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_GroupName_Notification$Type extends MessageType<CSteamVR_VoiceChat_GroupName_Notification> {
    constructor() {
        super("CSteamVR_VoiceChat_GroupName_Notification", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_GroupName_Notification>): CSteamVR_VoiceChat_GroupName_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_GroupName_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_GroupName_Notification): CSteamVR_VoiceChat_GroupName_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_GroupName_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_GroupName_Notification
 */
export const CSteamVR_VoiceChat_GroupName_Notification = new CSteamVR_VoiceChat_GroupName_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_Inactive_Notification$Type extends MessageType<CSteamVR_VoiceChat_Inactive_Notification> {
    constructor() {
        super("CSteamVR_VoiceChat_Inactive_Notification", []);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_Inactive_Notification>): CSteamVR_VoiceChat_Inactive_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_Inactive_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_Inactive_Notification): CSteamVR_VoiceChat_Inactive_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_Inactive_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_Inactive_Notification
 */
export const CSteamVR_VoiceChat_Inactive_Notification = new CSteamVR_VoiceChat_Inactive_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_InitiateRoomChat_Request$Type extends MessageType<CSteamVR_VoiceChat_InitiateRoomChat_Request> {
    constructor() {
        super("CSteamVR_VoiceChat_InitiateRoomChat_Request", [
            { no: 1, name: "chat_group_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "chat_room_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_InitiateRoomChat_Request>): CSteamVR_VoiceChat_InitiateRoomChat_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_InitiateRoomChat_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_InitiateRoomChat_Request): CSteamVR_VoiceChat_InitiateRoomChat_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 chat_group_id */ 1:
                    message.chatGroupId = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 chat_room_id */ 2:
                    message.chatRoomId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_InitiateRoomChat_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 chat_group_id = 1; */
        if (message.chatGroupId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.chatGroupId);
        /* optional uint64 chat_room_id = 2; */
        if (message.chatRoomId !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.chatRoomId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_InitiateRoomChat_Request
 */
export const CSteamVR_VoiceChat_InitiateRoomChat_Request = new CSteamVR_VoiceChat_InitiateRoomChat_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_InitiateRoomChat_Response$Type extends MessageType<CSteamVR_VoiceChat_InitiateRoomChat_Response> {
    constructor() {
        super("CSteamVR_VoiceChat_InitiateRoomChat_Response", []);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_InitiateRoomChat_Response>): CSteamVR_VoiceChat_InitiateRoomChat_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_InitiateRoomChat_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_InitiateRoomChat_Response): CSteamVR_VoiceChat_InitiateRoomChat_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_InitiateRoomChat_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_InitiateRoomChat_Response
 */
export const CSteamVR_VoiceChat_InitiateRoomChat_Response = new CSteamVR_VoiceChat_InitiateRoomChat_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification$Type extends MessageType<CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification> {
    constructor() {
        super("CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification", [
            { no: 1, name: "chat_group_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "chat_room_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "sender_accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "timestamp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "ordinal", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification>): CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification): CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 chat_group_id */ 1:
                    message.chatGroupId = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 chat_room_id */ 2:
                    message.chatRoomId = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 sender_accountid */ 3:
                    message.senderAccountid = reader.uint32();
                    break;
                case /* optional uint32 timestamp */ 4:
                    message.timestamp = reader.uint32();
                    break;
                case /* optional uint32 ordinal */ 5:
                    message.ordinal = reader.uint32();
                    break;
                case /* optional string message */ 6:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 chat_group_id = 1; */
        if (message.chatGroupId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.chatGroupId);
        /* optional uint64 chat_room_id = 2; */
        if (message.chatRoomId !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.chatRoomId);
        /* optional uint32 sender_accountid = 3; */
        if (message.senderAccountid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.senderAccountid);
        /* optional uint32 timestamp = 4; */
        if (message.timestamp !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.timestamp);
        /* optional uint32 ordinal = 5; */
        if (message.ordinal !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.ordinal);
        /* optional string message = 6; */
        if (message.message !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification
 */
export const CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification = new CSteamVR_VoiceChat_NewGroupChatMsgAdded_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_PerUserGainValue_Notification$Type extends MessageType<CSteamVR_VoiceChat_PerUserGainValue_Notification> {
    constructor() {
        super("CSteamVR_VoiceChat_PerUserGainValue_Notification", [
            { no: 1, name: "accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "muted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "gain", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_PerUserGainValue_Notification>): CSteamVR_VoiceChat_PerUserGainValue_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_PerUserGainValue_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_PerUserGainValue_Notification): CSteamVR_VoiceChat_PerUserGainValue_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 accountid */ 1:
                    message.accountid = reader.uint32();
                    break;
                case /* optional bool muted */ 2:
                    message.muted = reader.bool();
                    break;
                case /* optional float gain */ 3:
                    message.gain = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_PerUserGainValue_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 accountid = 1; */
        if (message.accountid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.accountid);
        /* optional bool muted = 2; */
        if (message.muted !== undefined)
            writer.tag(2, WireType.Varint).bool(message.muted);
        /* optional float gain = 3; */
        if (message.gain !== undefined)
            writer.tag(3, WireType.Bit32).float(message.gain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_PerUserGainValue_Notification
 */
export const CSteamVR_VoiceChat_PerUserGainValue_Notification = new CSteamVR_VoiceChat_PerUserGainValue_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_PerUserVoiceStatus_Notification$Type extends MessageType<CSteamVR_VoiceChat_PerUserVoiceStatus_Notification> {
    constructor() {
        super("CSteamVR_VoiceChat_PerUserVoiceStatus_Notification", [
            { no: 1, name: "accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "mic_muted_locally", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "output_muted_locally", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_PerUserVoiceStatus_Notification>): CSteamVR_VoiceChat_PerUserVoiceStatus_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_PerUserVoiceStatus_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_PerUserVoiceStatus_Notification): CSteamVR_VoiceChat_PerUserVoiceStatus_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 accountid */ 1:
                    message.accountid = reader.uint32();
                    break;
                case /* optional bool mic_muted_locally */ 2:
                    message.micMutedLocally = reader.bool();
                    break;
                case /* optional bool output_muted_locally */ 3:
                    message.outputMutedLocally = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_PerUserVoiceStatus_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 accountid = 1; */
        if (message.accountid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.accountid);
        /* optional bool mic_muted_locally = 2; */
        if (message.micMutedLocally !== undefined)
            writer.tag(2, WireType.Varint).bool(message.micMutedLocally);
        /* optional bool output_muted_locally = 3; */
        if (message.outputMutedLocally !== undefined)
            writer.tag(3, WireType.Varint).bool(message.outputMutedLocally);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_PerUserVoiceStatus_Notification
 */
export const CSteamVR_VoiceChat_PerUserVoiceStatus_Notification = new CSteamVR_VoiceChat_PerUserVoiceStatus_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_Ready_Notification$Type extends MessageType<CSteamVR_VoiceChat_Ready_Notification> {
    constructor() {
        super("CSteamVR_VoiceChat_Ready_Notification", []);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_Ready_Notification>): CSteamVR_VoiceChat_Ready_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_Ready_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_Ready_Notification): CSteamVR_VoiceChat_Ready_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_Ready_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_Ready_Notification
 */
export const CSteamVR_VoiceChat_Ready_Notification = new CSteamVR_VoiceChat_Ready_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_SendGroupChatMessage_Request$Type extends MessageType<CSteamVR_VoiceChat_SendGroupChatMessage_Request> {
    constructor() {
        super("CSteamVR_VoiceChat_SendGroupChatMessage_Request", [
            { no: 1, name: "message_with_bbcode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_SendGroupChatMessage_Request>): CSteamVR_VoiceChat_SendGroupChatMessage_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_SendGroupChatMessage_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_SendGroupChatMessage_Request): CSteamVR_VoiceChat_SendGroupChatMessage_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string message_with_bbcode */ 1:
                    message.messageWithBbcode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_SendGroupChatMessage_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string message_with_bbcode = 1; */
        if (message.messageWithBbcode !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.messageWithBbcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_SendGroupChatMessage_Request
 */
export const CSteamVR_VoiceChat_SendGroupChatMessage_Request = new CSteamVR_VoiceChat_SendGroupChatMessage_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_SendGroupChatMessage_Response$Type extends MessageType<CSteamVR_VoiceChat_SendGroupChatMessage_Response> {
    constructor() {
        super("CSteamVR_VoiceChat_SendGroupChatMessage_Response", []);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_SendGroupChatMessage_Response>): CSteamVR_VoiceChat_SendGroupChatMessage_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_SendGroupChatMessage_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_SendGroupChatMessage_Response): CSteamVR_VoiceChat_SendGroupChatMessage_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_SendGroupChatMessage_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_SendGroupChatMessage_Response
 */
export const CSteamVR_VoiceChat_SendGroupChatMessage_Response = new CSteamVR_VoiceChat_SendGroupChatMessage_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_SetDefaultSession_Notification$Type extends MessageType<CSteamVR_VoiceChat_SetDefaultSession_Notification> {
    constructor() {
        super("CSteamVR_VoiceChat_SetDefaultSession_Notification", [
            { no: 1, name: "chat_group_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "chat_room_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_SetDefaultSession_Notification>): CSteamVR_VoiceChat_SetDefaultSession_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_SetDefaultSession_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_SetDefaultSession_Notification): CSteamVR_VoiceChat_SetDefaultSession_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 chat_group_id */ 1:
                    message.chatGroupId = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 chat_room_id */ 2:
                    message.chatRoomId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_SetDefaultSession_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 chat_group_id = 1; */
        if (message.chatGroupId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.chatGroupId);
        /* optional uint64 chat_room_id = 2; */
        if (message.chatRoomId !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.chatRoomId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_SetDefaultSession_Notification
 */
export const CSteamVR_VoiceChat_SetDefaultSession_Notification = new CSteamVR_VoiceChat_SetDefaultSession_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_SetPerUserMuting_Request$Type extends MessageType<CSteamVR_VoiceChat_SetPerUserMuting_Request> {
    constructor() {
        super("CSteamVR_VoiceChat_SetPerUserMuting_Request", [
            { no: 1, name: "accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "muted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_SetPerUserMuting_Request>): CSteamVR_VoiceChat_SetPerUserMuting_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_SetPerUserMuting_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_SetPerUserMuting_Request): CSteamVR_VoiceChat_SetPerUserMuting_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 accountid */ 1:
                    message.accountid = reader.uint32();
                    break;
                case /* optional bool muted */ 2:
                    message.muted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_SetPerUserMuting_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 accountid = 1; */
        if (message.accountid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.accountid);
        /* optional bool muted = 2; */
        if (message.muted !== undefined)
            writer.tag(2, WireType.Varint).bool(message.muted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_SetPerUserMuting_Request
 */
export const CSteamVR_VoiceChat_SetPerUserMuting_Request = new CSteamVR_VoiceChat_SetPerUserMuting_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_SetPerUserMuting_Response$Type extends MessageType<CSteamVR_VoiceChat_SetPerUserMuting_Response> {
    constructor() {
        super("CSteamVR_VoiceChat_SetPerUserMuting_Response", []);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_SetPerUserMuting_Response>): CSteamVR_VoiceChat_SetPerUserMuting_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_SetPerUserMuting_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_SetPerUserMuting_Response): CSteamVR_VoiceChat_SetPerUserMuting_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_SetPerUserMuting_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_SetPerUserMuting_Response
 */
export const CSteamVR_VoiceChat_SetPerUserMuting_Response = new CSteamVR_VoiceChat_SetPerUserMuting_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_SetPerUserVideo_Request$Type extends MessageType<CSteamVR_VoiceChat_SetPerUserVideo_Request> {
    constructor() {
        super("CSteamVR_VoiceChat_SetPerUserVideo_Request", [
            { no: 1, name: "accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "receive", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_SetPerUserVideo_Request>): CSteamVR_VoiceChat_SetPerUserVideo_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_SetPerUserVideo_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_SetPerUserVideo_Request): CSteamVR_VoiceChat_SetPerUserVideo_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 accountid */ 1:
                    message.accountid = reader.uint32();
                    break;
                case /* optional bool receive */ 2:
                    message.receive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_SetPerUserVideo_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 accountid = 1; */
        if (message.accountid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.accountid);
        /* optional bool receive = 2; */
        if (message.receive !== undefined)
            writer.tag(2, WireType.Varint).bool(message.receive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_SetPerUserVideo_Request
 */
export const CSteamVR_VoiceChat_SetPerUserVideo_Request = new CSteamVR_VoiceChat_SetPerUserVideo_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VoiceChat_SetPerUserVideo_Response$Type extends MessageType<CSteamVR_VoiceChat_SetPerUserVideo_Response> {
    constructor() {
        super("CSteamVR_VoiceChat_SetPerUserVideo_Response", []);
    }
    create(value?: PartialMessage<CSteamVR_VoiceChat_SetPerUserVideo_Response>): CSteamVR_VoiceChat_SetPerUserVideo_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VoiceChat_SetPerUserVideo_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VoiceChat_SetPerUserVideo_Response): CSteamVR_VoiceChat_SetPerUserVideo_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VoiceChat_SetPerUserVideo_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VoiceChat_SetPerUserVideo_Response
 */
export const CSteamVR_VoiceChat_SetPerUserVideo_Response = new CSteamVR_VoiceChat_SetPerUserVideo_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_VRGamepadUI_Message$Type extends MessageType<CSteamVR_VRGamepadUI_Message> {
    constructor() {
        super("CSteamVR_VRGamepadUI_Message", [
            { no: 1, name: "header", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "payload", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_VRGamepadUI_Message>): CSteamVR_VRGamepadUI_Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_VRGamepadUI_Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_VRGamepadUI_Message): CSteamVR_VRGamepadUI_Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes header */ 1:
                    message.header = reader.bytes();
                    break;
                case /* optional bytes payload */ 2:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_VRGamepadUI_Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes header = 1; */
        if (message.header !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.header);
        /* optional bytes payload = 2; */
        if (message.payload !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_VRGamepadUI_Message
 */
export const CSteamVR_VRGamepadUI_Message = new CSteamVR_VRGamepadUI_Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_Active_Notification$Type extends MessageType<CSteamVR_WebRTC_Active_Notification> {
    constructor() {
        super("CSteamVR_WebRTC_Active_Notification", []);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_Active_Notification>): CSteamVR_WebRTC_Active_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_Active_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_Active_Notification): CSteamVR_WebRTC_Active_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_Active_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_Active_Notification
 */
export const CSteamVR_WebRTC_Active_Notification = new CSteamVR_WebRTC_Active_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_CloseDataChannel_Request$Type extends MessageType<CSteamVR_WebRTC_CloseDataChannel_Request> {
    constructor() {
        super("CSteamVR_WebRTC_CloseDataChannel_Request", [
            { no: 1, name: "channel_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_CloseDataChannel_Request>): CSteamVR_WebRTC_CloseDataChannel_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_CloseDataChannel_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_CloseDataChannel_Request): CSteamVR_WebRTC_CloseDataChannel_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 channel_id */ 1:
                    message.channelId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_CloseDataChannel_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 channel_id = 1; */
        if (message.channelId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.channelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_CloseDataChannel_Request
 */
export const CSteamVR_WebRTC_CloseDataChannel_Request = new CSteamVR_WebRTC_CloseDataChannel_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_CloseDataChannel_Response$Type extends MessageType<CSteamVR_WebRTC_CloseDataChannel_Response> {
    constructor() {
        super("CSteamVR_WebRTC_CloseDataChannel_Response", []);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_CloseDataChannel_Response>): CSteamVR_WebRTC_CloseDataChannel_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_CloseDataChannel_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_CloseDataChannel_Response): CSteamVR_WebRTC_CloseDataChannel_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_CloseDataChannel_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_CloseDataChannel_Response
 */
export const CSteamVR_WebRTC_CloseDataChannel_Response = new CSteamVR_WebRTC_CloseDataChannel_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_CreateDataChannel_Request$Type extends MessageType<CSteamVR_WebRTC_CreateDataChannel_Request> {
    constructor() {
        super("CSteamVR_WebRTC_CreateDataChannel_Request", [
            { no: 1, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ordered", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "max_retransmits", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "max_packet_life_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_CreateDataChannel_Request>): CSteamVR_WebRTC_CreateDataChannel_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_CreateDataChannel_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_CreateDataChannel_Request): CSteamVR_WebRTC_CreateDataChannel_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string label */ 1:
                    message.label = reader.string();
                    break;
                case /* optional bool ordered */ 2:
                    message.ordered = reader.bool();
                    break;
                case /* optional uint32 max_retransmits */ 3:
                    message.maxRetransmits = reader.uint32();
                    break;
                case /* optional uint32 max_packet_life_time */ 4:
                    message.maxPacketLifeTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_CreateDataChannel_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string label = 1; */
        if (message.label !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* optional bool ordered = 2; */
        if (message.ordered !== undefined)
            writer.tag(2, WireType.Varint).bool(message.ordered);
        /* optional uint32 max_retransmits = 3; */
        if (message.maxRetransmits !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.maxRetransmits);
        /* optional uint32 max_packet_life_time = 4; */
        if (message.maxPacketLifeTime !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.maxPacketLifeTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_CreateDataChannel_Request
 */
export const CSteamVR_WebRTC_CreateDataChannel_Request = new CSteamVR_WebRTC_CreateDataChannel_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_CreateDataChannel_Response$Type extends MessageType<CSteamVR_WebRTC_CreateDataChannel_Response> {
    constructor() {
        super("CSteamVR_WebRTC_CreateDataChannel_Response", [
            { no: 1, name: "channel_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_CreateDataChannel_Response>): CSteamVR_WebRTC_CreateDataChannel_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_CreateDataChannel_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_CreateDataChannel_Response): CSteamVR_WebRTC_CreateDataChannel_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 channel_id */ 1:
                    message.channelId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_CreateDataChannel_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 channel_id = 1; */
        if (message.channelId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.channelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_CreateDataChannel_Response
 */
export const CSteamVR_WebRTC_CreateDataChannel_Response = new CSteamVR_WebRTC_CreateDataChannel_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_DataChannel_Close_Notification$Type extends MessageType<CSteamVR_WebRTC_DataChannel_Close_Notification> {
    constructor() {
        super("CSteamVR_WebRTC_DataChannel_Close_Notification", [
            { no: 1, name: "channel_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_DataChannel_Close_Notification>): CSteamVR_WebRTC_DataChannel_Close_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_DataChannel_Close_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_DataChannel_Close_Notification): CSteamVR_WebRTC_DataChannel_Close_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 channel_id */ 1:
                    message.channelId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_DataChannel_Close_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 channel_id = 1; */
        if (message.channelId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.channelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_DataChannel_Close_Notification
 */
export const CSteamVR_WebRTC_DataChannel_Close_Notification = new CSteamVR_WebRTC_DataChannel_Close_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_DataChannel_Error_Notification$Type extends MessageType<CSteamVR_WebRTC_DataChannel_Error_Notification> {
    constructor() {
        super("CSteamVR_WebRTC_DataChannel_Error_Notification", [
            { no: 1, name: "channel_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "reason", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_DataChannel_Error_Notification>): CSteamVR_WebRTC_DataChannel_Error_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_DataChannel_Error_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_DataChannel_Error_Notification): CSteamVR_WebRTC_DataChannel_Error_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 channel_id */ 1:
                    message.channelId = reader.uint32();
                    break;
                case /* optional string reason */ 2:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_DataChannel_Error_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 channel_id = 1; */
        if (message.channelId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.channelId);
        /* optional string reason = 2; */
        if (message.reason !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_DataChannel_Error_Notification
 */
export const CSteamVR_WebRTC_DataChannel_Error_Notification = new CSteamVR_WebRTC_DataChannel_Error_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_DataChannel_Message_Notification$Type extends MessageType<CSteamVR_WebRTC_DataChannel_Message_Notification> {
    constructor() {
        super("CSteamVR_WebRTC_DataChannel_Message_Notification", [
            { no: 1, name: "channel_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_DataChannel_Message_Notification>): CSteamVR_WebRTC_DataChannel_Message_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_DataChannel_Message_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_DataChannel_Message_Notification): CSteamVR_WebRTC_DataChannel_Message_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 channel_id */ 1:
                    message.channelId = reader.uint32();
                    break;
                case /* optional bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_DataChannel_Message_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 channel_id = 1; */
        if (message.channelId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.channelId);
        /* optional bytes data = 2; */
        if (message.data !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_DataChannel_Message_Notification
 */
export const CSteamVR_WebRTC_DataChannel_Message_Notification = new CSteamVR_WebRTC_DataChannel_Message_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_DataChannel_Open_Notification$Type extends MessageType<CSteamVR_WebRTC_DataChannel_Open_Notification> {
    constructor() {
        super("CSteamVR_WebRTC_DataChannel_Open_Notification", [
            { no: 1, name: "channel_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_DataChannel_Open_Notification>): CSteamVR_WebRTC_DataChannel_Open_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_DataChannel_Open_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_DataChannel_Open_Notification): CSteamVR_WebRTC_DataChannel_Open_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 channel_id */ 1:
                    message.channelId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_DataChannel_Open_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 channel_id = 1; */
        if (message.channelId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.channelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_DataChannel_Open_Notification
 */
export const CSteamVR_WebRTC_DataChannel_Open_Notification = new CSteamVR_WebRTC_DataChannel_Open_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_Inactive_Notification$Type extends MessageType<CSteamVR_WebRTC_Inactive_Notification> {
    constructor() {
        super("CSteamVR_WebRTC_Inactive_Notification", []);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_Inactive_Notification>): CSteamVR_WebRTC_Inactive_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_Inactive_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_Inactive_Notification): CSteamVR_WebRTC_Inactive_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_Inactive_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_Inactive_Notification
 */
export const CSteamVR_WebRTC_Inactive_Notification = new CSteamVR_WebRTC_Inactive_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSteamVR_WebRTC_OnDataChannel_Notification$Type extends MessageType<CSteamVR_WebRTC_OnDataChannel_Notification> {
    constructor() {
        super("CSteamVR_WebRTC_OnDataChannel_Notification", [
            { no: 1, name: "source_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "channel_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSteamVR_WebRTC_OnDataChannel_Notification>): CSteamVR_WebRTC_OnDataChannel_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSteamVR_WebRTC_OnDataChannel_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSteamVR_WebRTC_OnDataChannel_Notification): CSteamVR_WebRTC_OnDataChannel_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 source_steamid */ 1:
                    message.sourceSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 channel_id */ 2:
                    message.channelId = reader.uint32();
                    break;
                case /* optional string label */ 3:
                    message.label = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSteamVR_WebRTC_OnDataChannel_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 source_steamid = 1; */
        if (message.sourceSteamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.sourceSteamid);
        /* optional uint32 channel_id = 2; */
        if (message.channelId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.channelId);
        /* optional string label = 3; */
        if (message.label !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.label);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSteamVR_WebRTC_OnDataChannel_Notification
 */
export const CSteamVR_WebRTC_OnDataChannel_Notification = new CSteamVR_WebRTC_OnDataChannel_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStoreBrowse_GetItems_Request$Type extends MessageType<CStoreBrowse_GetItems_Request> {
    constructor() {
        super("CStoreBrowse_GetItems_Request", [
            { no: 1, name: "ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItemID },
            { no: 2, name: "context", kind: "message", T: () => StoreBrowseContext },
            { no: 3, name: "data_request", kind: "message", T: () => StoreBrowseItemDataRequest }
        ]);
    }
    create(value?: PartialMessage<CStoreBrowse_GetItems_Request>): CStoreBrowse_GetItems_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<CStoreBrowse_GetItems_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStoreBrowse_GetItems_Request): CStoreBrowse_GetItems_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated StoreItemID ids */ 1:
                    message.ids.push(StoreItemID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional StoreBrowseContext context */ 2:
                    message.context = StoreBrowseContext.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* optional StoreBrowseItemDataRequest data_request */ 3:
                    message.dataRequest = StoreBrowseItemDataRequest.internalBinaryRead(reader, reader.uint32(), options, message.dataRequest);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStoreBrowse_GetItems_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated StoreItemID ids = 1; */
        for (let i = 0; i < message.ids.length; i++)
            StoreItemID.internalBinaryWrite(message.ids[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreBrowseContext context = 2; */
        if (message.context)
            StoreBrowseContext.internalBinaryWrite(message.context, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreBrowseItemDataRequest data_request = 3; */
        if (message.dataRequest)
            StoreBrowseItemDataRequest.internalBinaryWrite(message.dataRequest, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStoreBrowse_GetItems_Request
 */
export const CStoreBrowse_GetItems_Request = new CStoreBrowse_GetItems_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStoreBrowse_GetItems_Response$Type extends MessageType<CStoreBrowse_GetItems_Response> {
    constructor() {
        super("CStoreBrowse_GetItems_Response", [
            { no: 1, name: "store_items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem }
        ]);
    }
    create(value?: PartialMessage<CStoreBrowse_GetItems_Response>): CStoreBrowse_GetItems_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.storeItems = [];
        if (value !== undefined)
            reflectionMergePartial<CStoreBrowse_GetItems_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStoreBrowse_GetItems_Response): CStoreBrowse_GetItems_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated StoreItem store_items */ 1:
                    message.storeItems.push(StoreItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStoreBrowse_GetItems_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated StoreItem store_items = 1; */
        for (let i = 0; i < message.storeItems.length; i++)
            StoreItem.internalBinaryWrite(message.storeItems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStoreBrowse_GetItems_Response
 */
export const CStoreBrowse_GetItems_Response = new CStoreBrowse_GetItems_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStorePageFilter$Type extends MessageType<CStorePageFilter> {
    constructor() {
        super("CStorePageFilter", [
            { no: 1, name: "sale_filter", kind: "message", T: () => CStorePageFilter_SalePageFilter },
            { no: 2, name: "content_hub_filter", kind: "message", T: () => CStorePageFilter_ContentHubFilter },
            { no: 3, name: "store_filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CStorePageFilter_StoreFilter }
        ]);
    }
    create(value?: PartialMessage<CStorePageFilter>): CStorePageFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.storeFilters = [];
        if (value !== undefined)
            reflectionMergePartial<CStorePageFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStorePageFilter): CStorePageFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CStorePageFilter_SalePageFilter sale_filter */ 1:
                    message.saleFilter = CStorePageFilter_SalePageFilter.internalBinaryRead(reader, reader.uint32(), options, message.saleFilter);
                    break;
                case /* optional CStorePageFilter_ContentHubFilter content_hub_filter */ 2:
                    message.contentHubFilter = CStorePageFilter_ContentHubFilter.internalBinaryRead(reader, reader.uint32(), options, message.contentHubFilter);
                    break;
                case /* repeated CStorePageFilter_StoreFilter store_filters */ 3:
                    message.storeFilters.push(CStorePageFilter_StoreFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStorePageFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CStorePageFilter_SalePageFilter sale_filter = 1; */
        if (message.saleFilter)
            CStorePageFilter_SalePageFilter.internalBinaryWrite(message.saleFilter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CStorePageFilter_ContentHubFilter content_hub_filter = 2; */
        if (message.contentHubFilter)
            CStorePageFilter_ContentHubFilter.internalBinaryWrite(message.contentHubFilter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CStorePageFilter_StoreFilter store_filters = 3; */
        for (let i = 0; i < message.storeFilters.length; i++)
            CStorePageFilter_StoreFilter.internalBinaryWrite(message.storeFilters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStorePageFilter
 */
export const CStorePageFilter = new CStorePageFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStorePageFilter_ContentHubFilter$Type extends MessageType<CStorePageFilter_ContentHubFilter> {
    constructor() {
        super("CStorePageFilter_ContentHubFilter", [
            { no: 1, name: "hub_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hub_category", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hub_tagid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "discount_filter", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 5, name: "optin", kind: "message", T: () => CStorePageFilter_ContentHubFilter_OptInInfo }
        ]);
    }
    create(value?: PartialMessage<CStorePageFilter_ContentHubFilter>): CStorePageFilter_ContentHubFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CStorePageFilter_ContentHubFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStorePageFilter_ContentHubFilter): CStorePageFilter_ContentHubFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string hub_type */ 1:
                    message.hubType = reader.string();
                    break;
                case /* optional string hub_category */ 2:
                    message.hubCategory = reader.string();
                    break;
                case /* optional uint32 hub_tagid */ 3:
                    message.hubTagid = reader.uint32();
                    break;
                case /* optional int32 discount_filter */ 4:
                    message.discountFilter = reader.int32();
                    break;
                case /* optional CStorePageFilter_ContentHubFilter_OptInInfo optin */ 5:
                    message.optin = CStorePageFilter_ContentHubFilter_OptInInfo.internalBinaryRead(reader, reader.uint32(), options, message.optin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStorePageFilter_ContentHubFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string hub_type = 1; */
        if (message.hubType !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.hubType);
        /* optional string hub_category = 2; */
        if (message.hubCategory !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.hubCategory);
        /* optional uint32 hub_tagid = 3; */
        if (message.hubTagid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.hubTagid);
        /* optional int32 discount_filter = 4; */
        if (message.discountFilter !== undefined)
            writer.tag(4, WireType.Varint).int32(message.discountFilter);
        /* optional CStorePageFilter_ContentHubFilter_OptInInfo optin = 5; */
        if (message.optin)
            CStorePageFilter_ContentHubFilter_OptInInfo.internalBinaryWrite(message.optin, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStorePageFilter_ContentHubFilter
 */
export const CStorePageFilter_ContentHubFilter = new CStorePageFilter_ContentHubFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStorePageFilter_ContentHubFilter_OptInInfo$Type extends MessageType<CStorePageFilter_ContentHubFilter_OptInInfo> {
    constructor() {
        super("CStorePageFilter_ContentHubFilter_OptInInfo", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "optin_tagid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "prune_tagid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "optin_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CStorePageFilter_ContentHubFilter_OptInInfo>): CStorePageFilter_ContentHubFilter_OptInInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CStorePageFilter_ContentHubFilter_OptInInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStorePageFilter_ContentHubFilter_OptInInfo): CStorePageFilter_ContentHubFilter_OptInInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional uint32 optin_tagid */ 2:
                    message.optinTagid = reader.uint32();
                    break;
                case /* optional uint32 prune_tagid */ 3:
                    message.pruneTagid = reader.uint32();
                    break;
                case /* optional bool optin_only */ 4:
                    message.optinOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStorePageFilter_ContentHubFilter_OptInInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional uint32 optin_tagid = 2; */
        if (message.optinTagid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.optinTagid);
        /* optional uint32 prune_tagid = 3; */
        if (message.pruneTagid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.pruneTagid);
        /* optional bool optin_only = 4; */
        if (message.optinOnly !== undefined)
            writer.tag(4, WireType.Varint).bool(message.optinOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStorePageFilter_ContentHubFilter_OptInInfo
 */
export const CStorePageFilter_ContentHubFilter_OptInInfo = new CStorePageFilter_ContentHubFilter_OptInInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStorePageFilter_SalePageFilter$Type extends MessageType<CStorePageFilter_SalePageFilter> {
    constructor() {
        super("CStorePageFilter_SalePageFilter", [
            { no: 1, name: "sale_tagid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CStorePageFilter_SalePageFilter>): CStorePageFilter_SalePageFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CStorePageFilter_SalePageFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStorePageFilter_SalePageFilter): CStorePageFilter_SalePageFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 sale_tagid */ 1:
                    message.saleTagid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStorePageFilter_SalePageFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 sale_tagid = 1; */
        if (message.saleTagid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.saleTagid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStorePageFilter_SalePageFilter
 */
export const CStorePageFilter_SalePageFilter = new CStorePageFilter_SalePageFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStorePageFilter_StoreFilter$Type extends MessageType<CStorePageFilter_StoreFilter> {
    constructor() {
        super("CStorePageFilter_StoreFilter", [
            { no: 1, name: "filter_json", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cache_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CStorePageFilter_StoreFilter>): CStorePageFilter_StoreFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CStorePageFilter_StoreFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStorePageFilter_StoreFilter): CStorePageFilter_StoreFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string filter_json */ 1:
                    message.filterJson = reader.string();
                    break;
                case /* optional string cache_key */ 2:
                    message.cacheKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStorePageFilter_StoreFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string filter_json = 1; */
        if (message.filterJson !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.filterJson);
        /* optional string cache_key = 2; */
        if (message.cacheKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.cacheKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStorePageFilter_StoreFilter
 */
export const CStorePageFilter_StoreFilter = new CStorePageFilter_StoreFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStreamingClientConfig$Type extends MessageType<CStreamingClientConfig> {
    constructor() {
        super("CStreamingClientConfig", [
            { no: 1, name: "quality", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "desired_resolution_x", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "desired_resolution_y", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "desired_framerate_numerator", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "desired_framerate_denominator", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "desired_bitrate_kbps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "enable_hardware_decoding", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "enable_performance_overlay", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "enable_video_streaming", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "enable_audio_streaming", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "enable_input_streaming", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "audio_channels", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "enable_video_hevc", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "enable_performance_icons", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "enable_microphone_streaming", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "controller_overlay_hotkey", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "enable_touch_controller_OBSOLETE", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "p2p_scope", kind: "scalar", jsonName: "p2pScope", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 20, name: "enable_audio_uncompressed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "display_limit", kind: "message", T: () => CStreamVideoLimit },
            { no: 22, name: "quality_limit", kind: "message", T: () => CStreamVideoLimit },
            { no: 23, name: "runtime_limit", kind: "message", T: () => CStreamVideoLimit },
            { no: 24, name: "decoder_limit", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CStreamVideoLimit },
            { no: 25, name: "enable_unreliable_fec", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "enable_video_av1", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CStreamingClientConfig>): CStreamingClientConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.decoderLimit = [];
        if (value !== undefined)
            reflectionMergePartial<CStreamingClientConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStreamingClientConfig): CStreamingClientConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 quality = 1 [default = 2] */ 1:
                    message.quality = reader.int32();
                    break;
                case /* optional uint32 desired_resolution_x */ 2:
                    message.desiredResolutionX = reader.uint32();
                    break;
                case /* optional uint32 desired_resolution_y */ 3:
                    message.desiredResolutionY = reader.uint32();
                    break;
                case /* optional uint32 desired_framerate_numerator */ 4:
                    message.desiredFramerateNumerator = reader.uint32();
                    break;
                case /* optional uint32 desired_framerate_denominator */ 5:
                    message.desiredFramerateDenominator = reader.uint32();
                    break;
                case /* optional int32 desired_bitrate_kbps = 6 [default = -1] */ 6:
                    message.desiredBitrateKbps = reader.int32();
                    break;
                case /* optional bool enable_hardware_decoding = 7 [default = true] */ 7:
                    message.enableHardwareDecoding = reader.bool();
                    break;
                case /* optional bool enable_performance_overlay = 8 [default = false] */ 8:
                    message.enablePerformanceOverlay = reader.bool();
                    break;
                case /* optional bool enable_video_streaming = 9 [default = true] */ 9:
                    message.enableVideoStreaming = reader.bool();
                    break;
                case /* optional bool enable_audio_streaming = 10 [default = true] */ 10:
                    message.enableAudioStreaming = reader.bool();
                    break;
                case /* optional bool enable_input_streaming = 11 [default = true] */ 11:
                    message.enableInputStreaming = reader.bool();
                    break;
                case /* optional int32 audio_channels = 12 [default = 2] */ 12:
                    message.audioChannels = reader.int32();
                    break;
                case /* optional bool enable_video_hevc = 13 [default = false] */ 13:
                    message.enableVideoHevc = reader.bool();
                    break;
                case /* optional bool enable_performance_icons = 14 [default = true] */ 14:
                    message.enablePerformanceIcons = reader.bool();
                    break;
                case /* optional bool enable_microphone_streaming = 15 [default = false] */ 15:
                    message.enableMicrophoneStreaming = reader.bool();
                    break;
                case /* optional string controller_overlay_hotkey */ 16:
                    message.controllerOverlayHotkey = reader.string();
                    break;
                case /* optional bool enable_touch_controller_OBSOLETE = 17 [default = false] */ 17:
                    message.enableTouchControllerOBSOLETE = reader.bool();
                    break;
                case /* optional int32 p2p_scope = 19 [default = 0] */ 19:
                    message.p2PScope = reader.int32();
                    break;
                case /* optional bool enable_audio_uncompressed = 20 [default = false] */ 20:
                    message.enableAudioUncompressed = reader.bool();
                    break;
                case /* optional CStreamVideoLimit display_limit */ 21:
                    message.displayLimit = CStreamVideoLimit.internalBinaryRead(reader, reader.uint32(), options, message.displayLimit);
                    break;
                case /* optional CStreamVideoLimit quality_limit */ 22:
                    message.qualityLimit = CStreamVideoLimit.internalBinaryRead(reader, reader.uint32(), options, message.qualityLimit);
                    break;
                case /* optional CStreamVideoLimit runtime_limit */ 23:
                    message.runtimeLimit = CStreamVideoLimit.internalBinaryRead(reader, reader.uint32(), options, message.runtimeLimit);
                    break;
                case /* repeated CStreamVideoLimit decoder_limit */ 24:
                    message.decoderLimit.push(CStreamVideoLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool enable_unreliable_fec = 25 [default = false] */ 25:
                    message.enableUnreliableFec = reader.bool();
                    break;
                case /* optional bool enable_video_av1 = 26 [default = false] */ 26:
                    message.enableVideoAv1 = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStreamingClientConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 quality = 1 [default = 2]; */
        if (message.quality !== undefined)
            writer.tag(1, WireType.Varint).int32(message.quality);
        /* optional uint32 desired_resolution_x = 2; */
        if (message.desiredResolutionX !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.desiredResolutionX);
        /* optional uint32 desired_resolution_y = 3; */
        if (message.desiredResolutionY !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.desiredResolutionY);
        /* optional uint32 desired_framerate_numerator = 4; */
        if (message.desiredFramerateNumerator !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.desiredFramerateNumerator);
        /* optional uint32 desired_framerate_denominator = 5; */
        if (message.desiredFramerateDenominator !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.desiredFramerateDenominator);
        /* optional int32 desired_bitrate_kbps = 6 [default = -1]; */
        if (message.desiredBitrateKbps !== undefined)
            writer.tag(6, WireType.Varint).int32(message.desiredBitrateKbps);
        /* optional bool enable_hardware_decoding = 7 [default = true]; */
        if (message.enableHardwareDecoding !== undefined)
            writer.tag(7, WireType.Varint).bool(message.enableHardwareDecoding);
        /* optional bool enable_performance_overlay = 8 [default = false]; */
        if (message.enablePerformanceOverlay !== undefined)
            writer.tag(8, WireType.Varint).bool(message.enablePerformanceOverlay);
        /* optional bool enable_video_streaming = 9 [default = true]; */
        if (message.enableVideoStreaming !== undefined)
            writer.tag(9, WireType.Varint).bool(message.enableVideoStreaming);
        /* optional bool enable_audio_streaming = 10 [default = true]; */
        if (message.enableAudioStreaming !== undefined)
            writer.tag(10, WireType.Varint).bool(message.enableAudioStreaming);
        /* optional bool enable_input_streaming = 11 [default = true]; */
        if (message.enableInputStreaming !== undefined)
            writer.tag(11, WireType.Varint).bool(message.enableInputStreaming);
        /* optional int32 audio_channels = 12 [default = 2]; */
        if (message.audioChannels !== undefined)
            writer.tag(12, WireType.Varint).int32(message.audioChannels);
        /* optional bool enable_video_hevc = 13 [default = false]; */
        if (message.enableVideoHevc !== undefined)
            writer.tag(13, WireType.Varint).bool(message.enableVideoHevc);
        /* optional bool enable_performance_icons = 14 [default = true]; */
        if (message.enablePerformanceIcons !== undefined)
            writer.tag(14, WireType.Varint).bool(message.enablePerformanceIcons);
        /* optional bool enable_microphone_streaming = 15 [default = false]; */
        if (message.enableMicrophoneStreaming !== undefined)
            writer.tag(15, WireType.Varint).bool(message.enableMicrophoneStreaming);
        /* optional string controller_overlay_hotkey = 16; */
        if (message.controllerOverlayHotkey !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.controllerOverlayHotkey);
        /* optional bool enable_touch_controller_OBSOLETE = 17 [default = false]; */
        if (message.enableTouchControllerOBSOLETE !== undefined)
            writer.tag(17, WireType.Varint).bool(message.enableTouchControllerOBSOLETE);
        /* optional int32 p2p_scope = 19 [default = 0]; */
        if (message.p2PScope !== undefined)
            writer.tag(19, WireType.Varint).int32(message.p2PScope);
        /* optional bool enable_audio_uncompressed = 20 [default = false]; */
        if (message.enableAudioUncompressed !== undefined)
            writer.tag(20, WireType.Varint).bool(message.enableAudioUncompressed);
        /* optional CStreamVideoLimit display_limit = 21; */
        if (message.displayLimit)
            CStreamVideoLimit.internalBinaryWrite(message.displayLimit, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* optional CStreamVideoLimit quality_limit = 22; */
        if (message.qualityLimit)
            CStreamVideoLimit.internalBinaryWrite(message.qualityLimit, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* optional CStreamVideoLimit runtime_limit = 23; */
        if (message.runtimeLimit)
            CStreamVideoLimit.internalBinaryWrite(message.runtimeLimit, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* repeated CStreamVideoLimit decoder_limit = 24; */
        for (let i = 0; i < message.decoderLimit.length; i++)
            CStreamVideoLimit.internalBinaryWrite(message.decoderLimit[i], writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* optional bool enable_unreliable_fec = 25 [default = false]; */
        if (message.enableUnreliableFec !== undefined)
            writer.tag(25, WireType.Varint).bool(message.enableUnreliableFec);
        /* optional bool enable_video_av1 = 26 [default = false]; */
        if (message.enableVideoAv1 !== undefined)
            writer.tag(26, WireType.Varint).bool(message.enableVideoAv1);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStreamingClientConfig
 */
export const CStreamingClientConfig = new CStreamingClientConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStreamingServerConfig$Type extends MessageType<CStreamingServerConfig> {
    constructor() {
        super("CStreamingServerConfig", [
            { no: 1, name: "change_desktop_resolution", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "dynamically_adjust_resolution_OBSOLETE", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "enable_capture_nvfbc", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "enable_hardware_encoding_nvidia_OBSOLETE", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "enable_hardware_encoding_amd_OBSOLETE", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "enable_hardware_encoding_intel_OBSOLETE", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "software_encoding_threads", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "enable_traffic_priority", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "host_play_audio", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 10, name: "enable_hardware_encoding", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CStreamingServerConfig>): CStreamingServerConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CStreamingServerConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStreamingServerConfig): CStreamingServerConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool change_desktop_resolution */ 1:
                    message.changeDesktopResolution = reader.bool();
                    break;
                case /* optional bool dynamically_adjust_resolution_OBSOLETE */ 2:
                    message.dynamicallyAdjustResolutionOBSOLETE = reader.bool();
                    break;
                case /* optional bool enable_capture_nvfbc */ 3:
                    message.enableCaptureNvfbc = reader.bool();
                    break;
                case /* optional bool enable_hardware_encoding_nvidia_OBSOLETE */ 4:
                    message.enableHardwareEncodingNvidiaOBSOLETE = reader.bool();
                    break;
                case /* optional bool enable_hardware_encoding_amd_OBSOLETE */ 5:
                    message.enableHardwareEncodingAmdOBSOLETE = reader.bool();
                    break;
                case /* optional bool enable_hardware_encoding_intel_OBSOLETE */ 6:
                    message.enableHardwareEncodingIntelOBSOLETE = reader.bool();
                    break;
                case /* optional int32 software_encoding_threads */ 7:
                    message.softwareEncodingThreads = reader.int32();
                    break;
                case /* optional bool enable_traffic_priority */ 8:
                    message.enableTrafficPriority = reader.bool();
                    break;
                case /* optional int32 host_play_audio = 9 [default = 0] */ 9:
                    message.hostPlayAudio = reader.int32();
                    break;
                case /* optional bool enable_hardware_encoding */ 10:
                    message.enableHardwareEncoding = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStreamingServerConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool change_desktop_resolution = 1; */
        if (message.changeDesktopResolution !== undefined)
            writer.tag(1, WireType.Varint).bool(message.changeDesktopResolution);
        /* optional bool dynamically_adjust_resolution_OBSOLETE = 2; */
        if (message.dynamicallyAdjustResolutionOBSOLETE !== undefined)
            writer.tag(2, WireType.Varint).bool(message.dynamicallyAdjustResolutionOBSOLETE);
        /* optional bool enable_capture_nvfbc = 3; */
        if (message.enableCaptureNvfbc !== undefined)
            writer.tag(3, WireType.Varint).bool(message.enableCaptureNvfbc);
        /* optional bool enable_hardware_encoding_nvidia_OBSOLETE = 4; */
        if (message.enableHardwareEncodingNvidiaOBSOLETE !== undefined)
            writer.tag(4, WireType.Varint).bool(message.enableHardwareEncodingNvidiaOBSOLETE);
        /* optional bool enable_hardware_encoding_amd_OBSOLETE = 5; */
        if (message.enableHardwareEncodingAmdOBSOLETE !== undefined)
            writer.tag(5, WireType.Varint).bool(message.enableHardwareEncodingAmdOBSOLETE);
        /* optional bool enable_hardware_encoding_intel_OBSOLETE = 6; */
        if (message.enableHardwareEncodingIntelOBSOLETE !== undefined)
            writer.tag(6, WireType.Varint).bool(message.enableHardwareEncodingIntelOBSOLETE);
        /* optional int32 software_encoding_threads = 7; */
        if (message.softwareEncodingThreads !== undefined)
            writer.tag(7, WireType.Varint).int32(message.softwareEncodingThreads);
        /* optional bool enable_traffic_priority = 8; */
        if (message.enableTrafficPriority !== undefined)
            writer.tag(8, WireType.Varint).bool(message.enableTrafficPriority);
        /* optional int32 host_play_audio = 9 [default = 0]; */
        if (message.hostPlayAudio !== undefined)
            writer.tag(9, WireType.Varint).int32(message.hostPlayAudio);
        /* optional bool enable_hardware_encoding = 10; */
        if (message.enableHardwareEncoding !== undefined)
            writer.tag(10, WireType.Varint).bool(message.enableHardwareEncoding);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStreamingServerConfig
 */
export const CStreamingServerConfig = new CStreamingServerConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStreamVideoLimit$Type extends MessageType<CStreamVideoLimit> {
    constructor() {
        super("CStreamVideoLimit", [
            { no: 1, name: "codec", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "mode", kind: "message", T: () => CStreamVideoMode },
            { no: 3, name: "bitrate_kbps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "burst_bitrate_kbps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CStreamVideoLimit>): CStreamVideoLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CStreamVideoLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStreamVideoLimit): CStreamVideoLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 codec */ 1:
                    message.codec = reader.int32();
                    break;
                case /* optional CStreamVideoMode mode */ 2:
                    message.mode = CStreamVideoMode.internalBinaryRead(reader, reader.uint32(), options, message.mode);
                    break;
                case /* optional int32 bitrate_kbps */ 3:
                    message.bitrateKbps = reader.int32();
                    break;
                case /* optional int32 burst_bitrate_kbps */ 4:
                    message.burstBitrateKbps = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStreamVideoLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 codec = 1; */
        if (message.codec !== undefined)
            writer.tag(1, WireType.Varint).int32(message.codec);
        /* optional CStreamVideoMode mode = 2; */
        if (message.mode)
            CStreamVideoMode.internalBinaryWrite(message.mode, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 bitrate_kbps = 3; */
        if (message.bitrateKbps !== undefined)
            writer.tag(3, WireType.Varint).int32(message.bitrateKbps);
        /* optional int32 burst_bitrate_kbps = 4; */
        if (message.burstBitrateKbps !== undefined)
            writer.tag(4, WireType.Varint).int32(message.burstBitrateKbps);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStreamVideoLimit
 */
export const CStreamVideoLimit = new CStreamVideoLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CStreamVideoMode$Type extends MessageType<CStreamVideoMode> {
    constructor() {
        super("CStreamVideoMode", [
            { no: 1, name: "width", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "height", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "refresh_rate", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "refresh_rate_numerator", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "refresh_rate_denominator", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CStreamVideoMode>): CStreamVideoMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CStreamVideoMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CStreamVideoMode): CStreamVideoMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 width */ 1:
                    message.width = reader.uint32();
                    break;
                case /* optional uint32 height */ 2:
                    message.height = reader.uint32();
                    break;
                case /* optional uint32 refresh_rate */ 3:
                    message.refreshRate = reader.uint32();
                    break;
                case /* optional uint32 refresh_rate_numerator */ 4:
                    message.refreshRateNumerator = reader.uint32();
                    break;
                case /* optional uint32 refresh_rate_denominator */ 5:
                    message.refreshRateDenominator = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CStreamVideoMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 width = 1; */
        if (message.width !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.width);
        /* optional uint32 height = 2; */
        if (message.height !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.height);
        /* optional uint32 refresh_rate = 3; */
        if (message.refreshRate !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.refreshRate);
        /* optional uint32 refresh_rate_numerator = 4; */
        if (message.refreshRateNumerator !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.refreshRateNumerator);
        /* optional uint32 refresh_rate_denominator = 5; */
        if (message.refreshRateDenominator !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.refreshRateDenominator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CStreamVideoMode
 */
export const CStreamVideoMode = new CStreamVideoMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CTransportValidation_AppendToString_Request$Type extends MessageType<CTransportValidation_AppendToString_Request> {
    constructor() {
        super("CTransportValidation_AppendToString_Request", [
            { no: 1, name: "append_strings", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CTransportValidation_AppendToString_Request>): CTransportValidation_AppendToString_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appendStrings = [];
        if (value !== undefined)
            reflectionMergePartial<CTransportValidation_AppendToString_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CTransportValidation_AppendToString_Request): CTransportValidation_AppendToString_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string append_strings */ 1:
                    message.appendStrings.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CTransportValidation_AppendToString_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string append_strings = 1; */
        for (let i = 0; i < message.appendStrings.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.appendStrings[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CTransportValidation_AppendToString_Request
 */
export const CTransportValidation_AppendToString_Request = new CTransportValidation_AppendToString_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CTransportValidation_AppendToString_Response$Type extends MessageType<CTransportValidation_AppendToString_Response> {
    constructor() {
        super("CTransportValidation_AppendToString_Response", [
            { no: 1, name: "combined_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CTransportValidation_AppendToString_Response>): CTransportValidation_AppendToString_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CTransportValidation_AppendToString_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CTransportValidation_AppendToString_Response): CTransportValidation_AppendToString_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string combined_text */ 1:
                    message.combinedText = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CTransportValidation_AppendToString_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string combined_text = 1; */
        if (message.combinedText !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.combinedText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CTransportValidation_AppendToString_Response
 */
export const CTransportValidation_AppendToString_Response = new CTransportValidation_AppendToString_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CUserInterface_CuratorData$Type extends MessageType<CUserInterface_CuratorData> {
    constructor() {
        super("CUserInterface_CuratorData", [
            { no: 1, name: "clanid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "listid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CUserInterface_CuratorData>): CUserInterface_CuratorData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CUserInterface_CuratorData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CUserInterface_CuratorData): CUserInterface_CuratorData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 clanid */ 1:
                    message.clanid = reader.uint32();
                    break;
                case /* optional uint64 listid */ 2:
                    message.listid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CUserInterface_CuratorData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 clanid = 1; */
        if (message.clanid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.clanid);
        /* optional uint64 listid = 2; */
        if (message.listid !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.listid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CUserInterface_CuratorData
 */
export const CUserInterface_CuratorData = new CUserInterface_CuratorData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CUserInterface_NavData$Type extends MessageType<CUserInterface_NavData> {
    constructor() {
        super("CUserInterface_NavData", [
            { no: 1, name: "domain", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "controller", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "method", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "submethod", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "feature", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "depth", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "countrycode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "webkey", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "is_client", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "curator_data", kind: "message", T: () => CUserInterface_CuratorData },
            { no: 11, name: "is_likely_bot", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "is_utm", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CUserInterface_NavData>): CUserInterface_NavData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CUserInterface_NavData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CUserInterface_NavData): CUserInterface_NavData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* optional string controller */ 2:
                    message.controller = reader.string();
                    break;
                case /* optional string method */ 3:
                    message.method = reader.string();
                    break;
                case /* optional string submethod */ 4:
                    message.submethod = reader.string();
                    break;
                case /* optional string feature */ 5:
                    message.feature = reader.string();
                    break;
                case /* optional uint32 depth */ 6:
                    message.depth = reader.uint32();
                    break;
                case /* optional string countrycode */ 7:
                    message.countrycode = reader.string();
                    break;
                case /* optional uint64 webkey */ 8:
                    message.webkey = reader.uint64().toBigInt();
                    break;
                case /* optional bool is_client */ 9:
                    message.isClient = reader.bool();
                    break;
                case /* optional CUserInterface_CuratorData curator_data */ 10:
                    message.curatorData = CUserInterface_CuratorData.internalBinaryRead(reader, reader.uint32(), options, message.curatorData);
                    break;
                case /* optional bool is_likely_bot */ 11:
                    message.isLikelyBot = reader.bool();
                    break;
                case /* optional bool is_utm */ 12:
                    message.isUtm = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CUserInterface_NavData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string domain = 1; */
        if (message.domain !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* optional string controller = 2; */
        if (message.controller !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.controller);
        /* optional string method = 3; */
        if (message.method !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.method);
        /* optional string submethod = 4; */
        if (message.submethod !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.submethod);
        /* optional string feature = 5; */
        if (message.feature !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.feature);
        /* optional uint32 depth = 6; */
        if (message.depth !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.depth);
        /* optional string countrycode = 7; */
        if (message.countrycode !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.countrycode);
        /* optional uint64 webkey = 8; */
        if (message.webkey !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.webkey);
        /* optional bool is_client = 9; */
        if (message.isClient !== undefined)
            writer.tag(9, WireType.Varint).bool(message.isClient);
        /* optional CUserInterface_CuratorData curator_data = 10; */
        if (message.curatorData)
            CUserInterface_CuratorData.internalBinaryWrite(message.curatorData, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_likely_bot = 11; */
        if (message.isLikelyBot !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isLikelyBot);
        /* optional bool is_utm = 12; */
        if (message.isUtm !== undefined)
            writer.tag(12, WireType.Varint).bool(message.isUtm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CUserInterface_NavData
 */
export const CUserInterface_NavData = new CUserInterface_NavData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVideo_GameRecordingSegmentInfo$Type extends MessageType<CVideo_GameRecordingSegmentInfo> {
    constructor() {
        super("CVideo_GameRecordingSegmentInfo", [
            { no: 1, name: "segment_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "segment_size_bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "component_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "representation_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CVideo_GameRecordingSegmentInfo>): CVideo_GameRecordingSegmentInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVideo_GameRecordingSegmentInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVideo_GameRecordingSegmentInfo): CVideo_GameRecordingSegmentInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 segment_number */ 1:
                    message.segmentNumber = reader.uint32();
                    break;
                case /* optional uint64 segment_size_bytes */ 2:
                    message.segmentSizeBytes = reader.uint64().toBigInt();
                    break;
                case /* optional string component_name */ 3:
                    message.componentName = reader.string();
                    break;
                case /* optional string representation_name */ 4:
                    message.representationName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVideo_GameRecordingSegmentInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 segment_number = 1; */
        if (message.segmentNumber !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.segmentNumber);
        /* optional uint64 segment_size_bytes = 2; */
        if (message.segmentSizeBytes !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.segmentSizeBytes);
        /* optional string component_name = 3; */
        if (message.componentName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.componentName);
        /* optional string representation_name = 4; */
        if (message.representationName !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.representationName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVideo_GameRecordingSegmentInfo
 */
export const CVideo_GameRecordingSegmentInfo = new CVideo_GameRecordingSegmentInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVirtualMenuCreateDestroy$Type extends MessageType<CVirtualMenuCreateDestroy> {
    constructor() {
        super("CVirtualMenuCreateDestroy", [
            { no: 1, name: "created", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "controller_idx", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "menu_idx", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "source", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "x_position", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "y_position", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "show_labels", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "force_on", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "appID", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "menu_style", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "popup_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CVirtualMenuCreateDestroy_TouchMenuKey }
        ]);
    }
    create(value?: PartialMessage<CVirtualMenuCreateDestroy>): CVirtualMenuCreateDestroy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.popupKeys = [];
        if (value !== undefined)
            reflectionMergePartial<CVirtualMenuCreateDestroy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVirtualMenuCreateDestroy): CVirtualMenuCreateDestroy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool created */ 1:
                    message.created = reader.bool();
                    break;
                case /* optional uint32 controller_idx */ 2:
                    message.controllerIdx = reader.uint32();
                    break;
                case /* optional uint32 menu_idx */ 3:
                    message.menuIdx = reader.uint32();
                    break;
                case /* optional uint32 source */ 4:
                    message.source = reader.uint32();
                    break;
                case /* optional float x_position */ 5:
                    message.xPosition = reader.float();
                    break;
                case /* optional float y_position */ 6:
                    message.yPosition = reader.float();
                    break;
                case /* optional float opacity */ 7:
                    message.opacity = reader.float();
                    break;
                case /* optional float scale */ 8:
                    message.scale = reader.float();
                    break;
                case /* optional bool show_labels */ 9:
                    message.showLabels = reader.bool();
                    break;
                case /* optional bool force_on */ 10:
                    message.forceOn = reader.bool();
                    break;
                case /* optional uint32 appID */ 11:
                    message.appID = reader.uint32();
                    break;
                case /* optional uint32 menu_style */ 12:
                    message.menuStyle = reader.uint32();
                    break;
                case /* repeated CVirtualMenuCreateDestroy_TouchMenuKey popup_keys */ 13:
                    message.popupKeys.push(CVirtualMenuCreateDestroy_TouchMenuKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVirtualMenuCreateDestroy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool created = 1; */
        if (message.created !== undefined)
            writer.tag(1, WireType.Varint).bool(message.created);
        /* optional uint32 controller_idx = 2; */
        if (message.controllerIdx !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.controllerIdx);
        /* optional uint32 menu_idx = 3; */
        if (message.menuIdx !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.menuIdx);
        /* optional uint32 source = 4; */
        if (message.source !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.source);
        /* optional float x_position = 5; */
        if (message.xPosition !== undefined)
            writer.tag(5, WireType.Bit32).float(message.xPosition);
        /* optional float y_position = 6; */
        if (message.yPosition !== undefined)
            writer.tag(6, WireType.Bit32).float(message.yPosition);
        /* optional float opacity = 7; */
        if (message.opacity !== undefined)
            writer.tag(7, WireType.Bit32).float(message.opacity);
        /* optional float scale = 8; */
        if (message.scale !== undefined)
            writer.tag(8, WireType.Bit32).float(message.scale);
        /* optional bool show_labels = 9; */
        if (message.showLabels !== undefined)
            writer.tag(9, WireType.Varint).bool(message.showLabels);
        /* optional bool force_on = 10; */
        if (message.forceOn !== undefined)
            writer.tag(10, WireType.Varint).bool(message.forceOn);
        /* optional uint32 appID = 11; */
        if (message.appID !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.appID);
        /* optional uint32 menu_style = 12; */
        if (message.menuStyle !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.menuStyle);
        /* repeated CVirtualMenuCreateDestroy_TouchMenuKey popup_keys = 13; */
        for (let i = 0; i < message.popupKeys.length; i++)
            CVirtualMenuCreateDestroy_TouchMenuKey.internalBinaryWrite(message.popupKeys[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVirtualMenuCreateDestroy
 */
export const CVirtualMenuCreateDestroy = new CVirtualMenuCreateDestroy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVirtualMenuCreateDestroy_TouchMenuKey$Type extends MessageType<CVirtualMenuCreateDestroy_TouchMenuKey> {
    constructor() {
        super("CVirtualMenuCreateDestroy_TouchMenuKey", [
            { no: 1, name: "key_idx", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "bound", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "placeholder", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "binding_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "height", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "glyph_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "icon_filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "color_foreground", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "color_background", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "quandrants", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CVirtualMenuCreateDestroy_TouchMenuKey>): CVirtualMenuCreateDestroy_TouchMenuKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVirtualMenuCreateDestroy_TouchMenuKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVirtualMenuCreateDestroy_TouchMenuKey): CVirtualMenuCreateDestroy_TouchMenuKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 key_idx */ 1:
                    message.keyIdx = reader.uint32();
                    break;
                case /* optional bool bound */ 2:
                    message.bound = reader.bool();
                    break;
                case /* optional bool placeholder */ 3:
                    message.placeholder = reader.bool();
                    break;
                case /* optional uint32 binding_type */ 4:
                    message.bindingType = reader.uint32();
                    break;
                case /* optional float x */ 5:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 6:
                    message.y = reader.float();
                    break;
                case /* optional float width */ 7:
                    message.width = reader.float();
                    break;
                case /* optional float height */ 8:
                    message.height = reader.float();
                    break;
                case /* optional string description */ 9:
                    message.description = reader.string();
                    break;
                case /* optional string label */ 10:
                    message.label = reader.string();
                    break;
                case /* optional string glyph_path */ 11:
                    message.glyphPath = reader.string();
                    break;
                case /* optional string icon_filename */ 12:
                    message.iconFilename = reader.string();
                    break;
                case /* optional string color_foreground */ 13:
                    message.colorForeground = reader.string();
                    break;
                case /* optional string color_background */ 14:
                    message.colorBackground = reader.string();
                    break;
                case /* optional uint32 quandrants */ 15:
                    message.quandrants = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVirtualMenuCreateDestroy_TouchMenuKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 key_idx = 1; */
        if (message.keyIdx !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.keyIdx);
        /* optional bool bound = 2; */
        if (message.bound !== undefined)
            writer.tag(2, WireType.Varint).bool(message.bound);
        /* optional bool placeholder = 3; */
        if (message.placeholder !== undefined)
            writer.tag(3, WireType.Varint).bool(message.placeholder);
        /* optional uint32 binding_type = 4; */
        if (message.bindingType !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.bindingType);
        /* optional float x = 5; */
        if (message.x !== undefined)
            writer.tag(5, WireType.Bit32).float(message.x);
        /* optional float y = 6; */
        if (message.y !== undefined)
            writer.tag(6, WireType.Bit32).float(message.y);
        /* optional float width = 7; */
        if (message.width !== undefined)
            writer.tag(7, WireType.Bit32).float(message.width);
        /* optional float height = 8; */
        if (message.height !== undefined)
            writer.tag(8, WireType.Bit32).float(message.height);
        /* optional string description = 9; */
        if (message.description !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.description);
        /* optional string label = 10; */
        if (message.label !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.label);
        /* optional string glyph_path = 11; */
        if (message.glyphPath !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.glyphPath);
        /* optional string icon_filename = 12; */
        if (message.iconFilename !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.iconFilename);
        /* optional string color_foreground = 13; */
        if (message.colorForeground !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.colorForeground);
        /* optional string color_background = 14; */
        if (message.colorBackground !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.colorBackground);
        /* optional uint32 quandrants = 15; */
        if (message.quandrants !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.quandrants);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVirtualMenuCreateDestroy_TouchMenuKey
 */
export const CVirtualMenuCreateDestroy_TouchMenuKey = new CVirtualMenuCreateDestroy_TouchMenuKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVirtualMenuKey$Type extends MessageType<CVirtualMenuKey> {
    constructor() {
        super("CVirtualMenuKey", [
            { no: 1, name: "key_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "bound", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "height", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "glyph_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "icon_filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "color_foreground", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "color_background", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "quadrants", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "binding_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CVirtualMenuKey>): CVirtualMenuKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVirtualMenuKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVirtualMenuKey): CVirtualMenuKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 key_index */ 1:
                    message.keyIndex = reader.uint32();
                    break;
                case /* optional bool bound */ 2:
                    message.bound = reader.bool();
                    break;
                case /* optional float x */ 3:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 4:
                    message.y = reader.float();
                    break;
                case /* optional float width */ 5:
                    message.width = reader.float();
                    break;
                case /* optional float height */ 6:
                    message.height = reader.float();
                    break;
                case /* optional string description */ 7:
                    message.description = reader.string();
                    break;
                case /* optional string label */ 8:
                    message.label = reader.string();
                    break;
                case /* optional string glyph_path */ 9:
                    message.glyphPath = reader.string();
                    break;
                case /* optional string icon_filename */ 10:
                    message.iconFilename = reader.string();
                    break;
                case /* optional string color_foreground */ 11:
                    message.colorForeground = reader.string();
                    break;
                case /* optional string color_background */ 12:
                    message.colorBackground = reader.string();
                    break;
                case /* optional uint32 quadrants */ 13:
                    message.quadrants = reader.uint32();
                    break;
                case /* optional uint32 binding_type */ 14:
                    message.bindingType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVirtualMenuKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 key_index = 1; */
        if (message.keyIndex !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.keyIndex);
        /* optional bool bound = 2; */
        if (message.bound !== undefined)
            writer.tag(2, WireType.Varint).bool(message.bound);
        /* optional float x = 3; */
        if (message.x !== undefined)
            writer.tag(3, WireType.Bit32).float(message.x);
        /* optional float y = 4; */
        if (message.y !== undefined)
            writer.tag(4, WireType.Bit32).float(message.y);
        /* optional float width = 5; */
        if (message.width !== undefined)
            writer.tag(5, WireType.Bit32).float(message.width);
        /* optional float height = 6; */
        if (message.height !== undefined)
            writer.tag(6, WireType.Bit32).float(message.height);
        /* optional string description = 7; */
        if (message.description !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.description);
        /* optional string label = 8; */
        if (message.label !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.label);
        /* optional string glyph_path = 9; */
        if (message.glyphPath !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.glyphPath);
        /* optional string icon_filename = 10; */
        if (message.iconFilename !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.iconFilename);
        /* optional string color_foreground = 11; */
        if (message.colorForeground !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.colorForeground);
        /* optional string color_background = 12; */
        if (message.colorBackground !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.colorBackground);
        /* optional uint32 quadrants = 13; */
        if (message.quadrants !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.quadrants);
        /* optional uint32 binding_type = 14; */
        if (message.bindingType !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.bindingType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVirtualMenuKey
 */
export const CVirtualMenuKey = new CVirtualMenuKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_DashboardActionInvoked_Request$Type extends MessageType<CVRGamepadUI_Message_DashboardActionInvoked_Request> {
    constructor() {
        super("CVRGamepadUI_Message_DashboardActionInvoked_Request", [
            { no: 1, name: "action_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "toggle_value", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_DashboardActionInvoked_Request>): CVRGamepadUI_Message_DashboardActionInvoked_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_DashboardActionInvoked_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_DashboardActionInvoked_Request): CVRGamepadUI_Message_DashboardActionInvoked_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 action_id */ 1:
                    message.actionId = reader.uint32();
                    break;
                case /* optional bool toggle_value */ 2:
                    message.toggleValue = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_DashboardActionInvoked_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 action_id = 1; */
        if (message.actionId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.actionId);
        /* optional bool toggle_value = 2; */
        if (message.toggleValue !== undefined)
            writer.tag(2, WireType.Varint).bool(message.toggleValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_DashboardActionInvoked_Request
 */
export const CVRGamepadUI_Message_DashboardActionInvoked_Request = new CVRGamepadUI_Message_DashboardActionInvoked_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_DashboardActionInvoked_Response$Type extends MessageType<CVRGamepadUI_Message_DashboardActionInvoked_Response> {
    constructor() {
        super("CVRGamepadUI_Message_DashboardActionInvoked_Response", []);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_DashboardActionInvoked_Response>): CVRGamepadUI_Message_DashboardActionInvoked_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_DashboardActionInvoked_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_DashboardActionInvoked_Response): CVRGamepadUI_Message_DashboardActionInvoked_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_DashboardActionInvoked_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_DashboardActionInvoked_Response
 */
export const CVRGamepadUI_Message_DashboardActionInvoked_Response = new CVRGamepadUI_Message_DashboardActionInvoked_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request$Type extends MessageType<CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request> {
    constructor() {
        super("CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request", [
            { no: 1, name: "window_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request>): CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request): CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 window_id */ 1:
                    message.windowId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 window_id = 1; */
        if (message.windowId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.windowId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request
 */
export const CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request = new CVRGamepadUI_Message_DashboardDesktopWindowClicked_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response$Type extends MessageType<CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response> {
    constructor() {
        super("CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response", []);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response>): CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response): CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response
 */
export const CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response = new CVRGamepadUI_Message_DashboardDesktopWindowClicked_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_DashboardTabClicked_Request$Type extends MessageType<CVRGamepadUI_Message_DashboardTabClicked_Request> {
    constructor() {
        super("CVRGamepadUI_Message_DashboardTabClicked_Request", [
            { no: 1, name: "tab_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_DashboardTabClicked_Request>): CVRGamepadUI_Message_DashboardTabClicked_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_DashboardTabClicked_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_DashboardTabClicked_Request): CVRGamepadUI_Message_DashboardTabClicked_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 tab_id */ 1:
                    message.tabId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_DashboardTabClicked_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 tab_id = 1; */
        if (message.tabId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.tabId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_DashboardTabClicked_Request
 */
export const CVRGamepadUI_Message_DashboardTabClicked_Request = new CVRGamepadUI_Message_DashboardTabClicked_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_DashboardTabClicked_Response$Type extends MessageType<CVRGamepadUI_Message_DashboardTabClicked_Response> {
    constructor() {
        super("CVRGamepadUI_Message_DashboardTabClicked_Response", []);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_DashboardTabClicked_Response>): CVRGamepadUI_Message_DashboardTabClicked_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_DashboardTabClicked_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_DashboardTabClicked_Response): CVRGamepadUI_Message_DashboardTabClicked_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_DashboardTabClicked_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_DashboardTabClicked_Response
 */
export const CVRGamepadUI_Message_DashboardTabClicked_Response = new CVRGamepadUI_Message_DashboardTabClicked_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_Error_Response$Type extends MessageType<CVRGamepadUI_Message_Error_Response> {
    constructor() {
        super("CVRGamepadUI_Message_Error_Response", [
            { no: 1, name: "error", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "origin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_Error_Response>): CVRGamepadUI_Message_Error_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_Error_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_Error_Response): CVRGamepadUI_Message_Error_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 error */ 1:
                    message.error = reader.int32();
                    break;
                case /* optional string description */ 2:
                    message.description = reader.string();
                    break;
                case /* optional int32 origin */ 3:
                    message.origin = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_Error_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 error = 1; */
        if (message.error !== undefined)
            writer.tag(1, WireType.Varint).int32(message.error);
        /* optional string description = 2; */
        if (message.description !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* optional int32 origin = 3; */
        if (message.origin !== undefined)
            writer.tag(3, WireType.Varint).int32(message.origin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_Error_Response
 */
export const CVRGamepadUI_Message_Error_Response = new CVRGamepadUI_Message_Error_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ExecuteSteamURL_Request$Type extends MessageType<CVRGamepadUI_Message_ExecuteSteamURL_Request> {
    constructor() {
        super("CVRGamepadUI_Message_ExecuteSteamURL_Request", [
            { no: 1, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ExecuteSteamURL_Request>): CVRGamepadUI_Message_ExecuteSteamURL_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ExecuteSteamURL_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ExecuteSteamURL_Request): CVRGamepadUI_Message_ExecuteSteamURL_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ExecuteSteamURL_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string url = 1; */
        if (message.url !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ExecuteSteamURL_Request
 */
export const CVRGamepadUI_Message_ExecuteSteamURL_Request = new CVRGamepadUI_Message_ExecuteSteamURL_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ExecuteSteamURL_Response$Type extends MessageType<CVRGamepadUI_Message_ExecuteSteamURL_Response> {
    constructor() {
        super("CVRGamepadUI_Message_ExecuteSteamURL_Response", []);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ExecuteSteamURL_Response>): CVRGamepadUI_Message_ExecuteSteamURL_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ExecuteSteamURL_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ExecuteSteamURL_Response): CVRGamepadUI_Message_ExecuteSteamURL_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ExecuteSteamURL_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ExecuteSteamURL_Response
 */
export const CVRGamepadUI_Message_ExecuteSteamURL_Response = new CVRGamepadUI_Message_ExecuteSteamURL_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_Header$Type extends MessageType<CVRGamepadUI_Message_Header> {
    constructor() {
        super("CVRGamepadUI_Message_Header", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "response_to_message_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_error_response", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_Header>): CVRGamepadUI_Message_Header {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_Header): CVRGamepadUI_Message_Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional uint32 message_id */ 2:
                    message.messageId = reader.uint32();
                    break;
                case /* optional uint32 response_to_message_id */ 3:
                    message.responseToMessageId = reader.uint32();
                    break;
                case /* optional bool is_error_response */ 4:
                    message.isErrorResponse = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional uint32 message_id = 2; */
        if (message.messageId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.messageId);
        /* optional uint32 response_to_message_id = 3; */
        if (message.responseToMessageId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.responseToMessageId);
        /* optional bool is_error_response = 4; */
        if (message.isErrorResponse !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isErrorResponse);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_Header
 */
export const CVRGamepadUI_Message_Header = new CVRGamepadUI_Message_Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_HideDashboardPopup_Request$Type extends MessageType<CVRGamepadUI_Message_HideDashboardPopup_Request> {
    constructor() {
        super("CVRGamepadUI_Message_HideDashboardPopup_Request", [
            { no: 1, name: "dashboard_popup_request_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_HideDashboardPopup_Request>): CVRGamepadUI_Message_HideDashboardPopup_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_HideDashboardPopup_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_HideDashboardPopup_Request): CVRGamepadUI_Message_HideDashboardPopup_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 dashboard_popup_request_id */ 1:
                    message.dashboardPopupRequestId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_HideDashboardPopup_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 dashboard_popup_request_id = 1; */
        if (message.dashboardPopupRequestId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.dashboardPopupRequestId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_HideDashboardPopup_Request
 */
export const CVRGamepadUI_Message_HideDashboardPopup_Request = new CVRGamepadUI_Message_HideDashboardPopup_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_HideDashboardPopup_Response$Type extends MessageType<CVRGamepadUI_Message_HideDashboardPopup_Response> {
    constructor() {
        super("CVRGamepadUI_Message_HideDashboardPopup_Response", []);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_HideDashboardPopup_Response>): CVRGamepadUI_Message_HideDashboardPopup_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_HideDashboardPopup_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_HideDashboardPopup_Response): CVRGamepadUI_Message_HideDashboardPopup_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_HideDashboardPopup_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_HideDashboardPopup_Response
 */
export const CVRGamepadUI_Message_HideDashboardPopup_Response = new CVRGamepadUI_Message_HideDashboardPopup_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_RemoteVideoStream_Request$Type extends MessageType<CVRGamepadUI_Message_RemoteVideoStream_Request> {
    constructor() {
        super("CVRGamepadUI_Message_RemoteVideoStream_Request", [
            { no: 1, name: "source_accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "video_uniqueid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_RemoteVideoStream_Request>): CVRGamepadUI_Message_RemoteVideoStream_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_RemoteVideoStream_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_RemoteVideoStream_Request): CVRGamepadUI_Message_RemoteVideoStream_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 source_accountid */ 1:
                    message.sourceAccountid = reader.uint32();
                    break;
                case /* optional string video_uniqueid */ 2:
                    message.videoUniqueid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_RemoteVideoStream_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 source_accountid = 1; */
        if (message.sourceAccountid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.sourceAccountid);
        /* optional string video_uniqueid = 2; */
        if (message.videoUniqueid !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.videoUniqueid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_RemoteVideoStream_Request
 */
export const CVRGamepadUI_Message_RemoteVideoStream_Request = new CVRGamepadUI_Message_RemoteVideoStream_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_RemoteVideoStream_Response$Type extends MessageType<CVRGamepadUI_Message_RemoteVideoStream_Response> {
    constructor() {
        super("CVRGamepadUI_Message_RemoteVideoStream_Response", []);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_RemoteVideoStream_Response>): CVRGamepadUI_Message_RemoteVideoStream_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_RemoteVideoStream_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_RemoteVideoStream_Response): CVRGamepadUI_Message_RemoteVideoStream_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_RemoteVideoStream_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_RemoteVideoStream_Response
 */
export const CVRGamepadUI_Message_RemoteVideoStream_Response = new CVRGamepadUI_Message_RemoteVideoStream_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ShowDashboardPopup_Request$Type extends MessageType<CVRGamepadUI_Message_ShowDashboardPopup_Request> {
    constructor() {
        super("CVRGamepadUI_Message_ShowDashboardPopup_Request", [
            { no: 1, name: "dashboard_popup_request_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "popup_overlay_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parent_overlay_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "origin_on_parent", kind: "message", T: () => CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition },
            { no: 5, name: "origin_on_popup", kind: "message", T: () => CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition },
            { no: 6, name: "offset", kind: "message", T: () => CVRGamepadUI_Message_ShowDashboardPopup_Request_Position },
            { no: 7, name: "rotation", kind: "message", T: () => CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation },
            { no: 8, name: "inherit_parent_pitch", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "inherit_parent_curvature", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "clip_rect", kind: "message", T: () => CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect },
            { no: 11, name: "interactive", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "requires_laser", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "parent_device_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "sort_order", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 15, name: "parent_enum", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ShowDashboardPopup_Request>): CVRGamepadUI_Message_ShowDashboardPopup_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ShowDashboardPopup_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ShowDashboardPopup_Request): CVRGamepadUI_Message_ShowDashboardPopup_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 dashboard_popup_request_id */ 1:
                    message.dashboardPopupRequestId = reader.uint32();
                    break;
                case /* optional string popup_overlay_key */ 2:
                    message.popupOverlayKey = reader.string();
                    break;
                case /* optional string parent_overlay_key */ 3:
                    message.parentOverlayKey = reader.string();
                    break;
                case /* optional CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition origin_on_parent */ 4:
                    message.originOnParent = CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition.internalBinaryRead(reader, reader.uint32(), options, message.originOnParent);
                    break;
                case /* optional CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition origin_on_popup */ 5:
                    message.originOnPopup = CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition.internalBinaryRead(reader, reader.uint32(), options, message.originOnPopup);
                    break;
                case /* optional CVRGamepadUI_Message_ShowDashboardPopup_Request_Position offset */ 6:
                    message.offset = CVRGamepadUI_Message_ShowDashboardPopup_Request_Position.internalBinaryRead(reader, reader.uint32(), options, message.offset);
                    break;
                case /* optional CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation rotation */ 7:
                    message.rotation = CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation.internalBinaryRead(reader, reader.uint32(), options, message.rotation);
                    break;
                case /* optional bool inherit_parent_pitch */ 8:
                    message.inheritParentPitch = reader.bool();
                    break;
                case /* optional bool inherit_parent_curvature */ 9:
                    message.inheritParentCurvature = reader.bool();
                    break;
                case /* optional CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect clip_rect */ 10:
                    message.clipRect = CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect.internalBinaryRead(reader, reader.uint32(), options, message.clipRect);
                    break;
                case /* optional bool interactive */ 11:
                    message.interactive = reader.bool();
                    break;
                case /* optional bool requires_laser */ 12:
                    message.requiresLaser = reader.bool();
                    break;
                case /* optional string parent_device_path */ 13:
                    message.parentDevicePath = reader.string();
                    break;
                case /* optional int32 sort_order */ 14:
                    message.sortOrder = reader.int32();
                    break;
                case /* optional int32 parent_enum */ 15:
                    message.parentEnum = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ShowDashboardPopup_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 dashboard_popup_request_id = 1; */
        if (message.dashboardPopupRequestId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.dashboardPopupRequestId);
        /* optional string popup_overlay_key = 2; */
        if (message.popupOverlayKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.popupOverlayKey);
        /* optional string parent_overlay_key = 3; */
        if (message.parentOverlayKey !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.parentOverlayKey);
        /* optional CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition origin_on_parent = 4; */
        if (message.originOnParent)
            CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition.internalBinaryWrite(message.originOnParent, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition origin_on_popup = 5; */
        if (message.originOnPopup)
            CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition.internalBinaryWrite(message.originOnPopup, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CVRGamepadUI_Message_ShowDashboardPopup_Request_Position offset = 6; */
        if (message.offset)
            CVRGamepadUI_Message_ShowDashboardPopup_Request_Position.internalBinaryWrite(message.offset, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation rotation = 7; */
        if (message.rotation)
            CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation.internalBinaryWrite(message.rotation, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional bool inherit_parent_pitch = 8; */
        if (message.inheritParentPitch !== undefined)
            writer.tag(8, WireType.Varint).bool(message.inheritParentPitch);
        /* optional bool inherit_parent_curvature = 9; */
        if (message.inheritParentCurvature !== undefined)
            writer.tag(9, WireType.Varint).bool(message.inheritParentCurvature);
        /* optional CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect clip_rect = 10; */
        if (message.clipRect)
            CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect.internalBinaryWrite(message.clipRect, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional bool interactive = 11; */
        if (message.interactive !== undefined)
            writer.tag(11, WireType.Varint).bool(message.interactive);
        /* optional bool requires_laser = 12; */
        if (message.requiresLaser !== undefined)
            writer.tag(12, WireType.Varint).bool(message.requiresLaser);
        /* optional string parent_device_path = 13; */
        if (message.parentDevicePath !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.parentDevicePath);
        /* optional int32 sort_order = 14; */
        if (message.sortOrder !== undefined)
            writer.tag(14, WireType.Varint).int32(message.sortOrder);
        /* optional int32 parent_enum = 15; */
        if (message.parentEnum !== undefined)
            writer.tag(15, WireType.Varint).int32(message.parentEnum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Request
 */
export const CVRGamepadUI_Message_ShowDashboardPopup_Request = new CVRGamepadUI_Message_ShowDashboardPopup_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition$Type extends MessageType<CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition> {
    constructor() {
        super("CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition>): CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition): CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition
 */
export const CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition = new CVRGamepadUI_Message_ShowDashboardPopup_Request_NormalizedPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ShowDashboardPopup_Request_Position$Type extends MessageType<CVRGamepadUI_Message_ShowDashboardPopup_Request_Position> {
    constructor() {
        super("CVRGamepadUI_Message_ShowDashboardPopup_Request_Position", [
            { no: 1, name: "x_pixels", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y_pixels", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z_pixels", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "x_meters", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "y_meters", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "z_meters", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ShowDashboardPopup_Request_Position>): CVRGamepadUI_Message_ShowDashboardPopup_Request_Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ShowDashboardPopup_Request_Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ShowDashboardPopup_Request_Position): CVRGamepadUI_Message_ShowDashboardPopup_Request_Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x_pixels */ 1:
                    message.xPixels = reader.float();
                    break;
                case /* optional float y_pixels */ 2:
                    message.yPixels = reader.float();
                    break;
                case /* optional float z_pixels */ 3:
                    message.zPixels = reader.float();
                    break;
                case /* optional float x_meters */ 4:
                    message.xMeters = reader.float();
                    break;
                case /* optional float y_meters */ 5:
                    message.yMeters = reader.float();
                    break;
                case /* optional float z_meters */ 6:
                    message.zMeters = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ShowDashboardPopup_Request_Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x_pixels = 1; */
        if (message.xPixels !== undefined)
            writer.tag(1, WireType.Bit32).float(message.xPixels);
        /* optional float y_pixels = 2; */
        if (message.yPixels !== undefined)
            writer.tag(2, WireType.Bit32).float(message.yPixels);
        /* optional float z_pixels = 3; */
        if (message.zPixels !== undefined)
            writer.tag(3, WireType.Bit32).float(message.zPixels);
        /* optional float x_meters = 4; */
        if (message.xMeters !== undefined)
            writer.tag(4, WireType.Bit32).float(message.xMeters);
        /* optional float y_meters = 5; */
        if (message.yMeters !== undefined)
            writer.tag(5, WireType.Bit32).float(message.yMeters);
        /* optional float z_meters = 6; */
        if (message.zMeters !== undefined)
            writer.tag(6, WireType.Bit32).float(message.zMeters);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Request_Position
 */
export const CVRGamepadUI_Message_ShowDashboardPopup_Request_Position = new CVRGamepadUI_Message_ShowDashboardPopup_Request_Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect$Type extends MessageType<CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect> {
    constructor() {
        super("CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect", [
            { no: 1, name: "u_min", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "v_min", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "u_max", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "v_max", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect>): CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect): CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float u_min */ 1:
                    message.uMin = reader.float();
                    break;
                case /* optional float v_min */ 2:
                    message.vMin = reader.float();
                    break;
                case /* optional float u_max */ 3:
                    message.uMax = reader.float();
                    break;
                case /* optional float v_max */ 4:
                    message.vMax = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float u_min = 1; */
        if (message.uMin !== undefined)
            writer.tag(1, WireType.Bit32).float(message.uMin);
        /* optional float v_min = 2; */
        if (message.vMin !== undefined)
            writer.tag(2, WireType.Bit32).float(message.vMin);
        /* optional float u_max = 3; */
        if (message.uMax !== undefined)
            writer.tag(3, WireType.Bit32).float(message.uMax);
        /* optional float v_max = 4; */
        if (message.vMax !== undefined)
            writer.tag(4, WireType.Bit32).float(message.vMax);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect
 */
export const CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect = new CVRGamepadUI_Message_ShowDashboardPopup_Request_Rect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation$Type extends MessageType<CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation> {
    constructor() {
        super("CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation", [
            { no: 1, name: "pitch_degrees", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "yaw_degrees", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation>): CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation): CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float pitch_degrees */ 1:
                    message.pitchDegrees = reader.float();
                    break;
                case /* optional float yaw_degrees */ 2:
                    message.yawDegrees = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float pitch_degrees = 1; */
        if (message.pitchDegrees !== undefined)
            writer.tag(1, WireType.Bit32).float(message.pitchDegrees);
        /* optional float yaw_degrees = 2; */
        if (message.yawDegrees !== undefined)
            writer.tag(2, WireType.Bit32).float(message.yawDegrees);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation
 */
export const CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation = new CVRGamepadUI_Message_ShowDashboardPopup_Request_Rotation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ShowDashboardPopup_Response$Type extends MessageType<CVRGamepadUI_Message_ShowDashboardPopup_Response> {
    constructor() {
        super("CVRGamepadUI_Message_ShowDashboardPopup_Response", []);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ShowDashboardPopup_Response>): CVRGamepadUI_Message_ShowDashboardPopup_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ShowDashboardPopup_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ShowDashboardPopup_Response): CVRGamepadUI_Message_ShowDashboardPopup_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ShowDashboardPopup_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ShowDashboardPopup_Response
 */
export const CVRGamepadUI_Message_ShowDashboardPopup_Response = new CVRGamepadUI_Message_ShowDashboardPopup_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ShowGame_Request$Type extends MessageType<CVRGamepadUI_Message_ShowGame_Request> {
    constructor() {
        super("CVRGamepadUI_Message_ShowGame_Request", [
            { no: 1, name: "overlay_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ShowGame_Request>): CVRGamepadUI_Message_ShowGame_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ShowGame_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ShowGame_Request): CVRGamepadUI_Message_ShowGame_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string overlay_key */ 1:
                    message.overlayKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ShowGame_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string overlay_key = 1; */
        if (message.overlayKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.overlayKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ShowGame_Request
 */
export const CVRGamepadUI_Message_ShowGame_Request = new CVRGamepadUI_Message_ShowGame_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ShowGame_Response$Type extends MessageType<CVRGamepadUI_Message_ShowGame_Response> {
    constructor() {
        super("CVRGamepadUI_Message_ShowGame_Response", []);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ShowGame_Response>): CVRGamepadUI_Message_ShowGame_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ShowGame_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ShowGame_Response): CVRGamepadUI_Message_ShowGame_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ShowGame_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ShowGame_Response
 */
export const CVRGamepadUI_Message_ShowGame_Response = new CVRGamepadUI_Message_ShowGame_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ShowOverlay_Request$Type extends MessageType<CVRGamepadUI_Message_ShowOverlay_Request> {
    constructor() {
        super("CVRGamepadUI_Message_ShowOverlay_Request", [
            { no: 1, name: "overlay_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ShowOverlay_Request>): CVRGamepadUI_Message_ShowOverlay_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ShowOverlay_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ShowOverlay_Request): CVRGamepadUI_Message_ShowOverlay_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string overlay_key */ 1:
                    message.overlayKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ShowOverlay_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string overlay_key = 1; */
        if (message.overlayKey !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.overlayKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ShowOverlay_Request
 */
export const CVRGamepadUI_Message_ShowOverlay_Request = new CVRGamepadUI_Message_ShowOverlay_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUI_Message_ShowOverlay_Response$Type extends MessageType<CVRGamepadUI_Message_ShowOverlay_Response> {
    constructor() {
        super("CVRGamepadUI_Message_ShowOverlay_Response", []);
    }
    create(value?: PartialMessage<CVRGamepadUI_Message_ShowOverlay_Response>): CVRGamepadUI_Message_ShowOverlay_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUI_Message_ShowOverlay_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUI_Message_ShowOverlay_Response): CVRGamepadUI_Message_ShowOverlay_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUI_Message_ShowOverlay_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUI_Message_ShowOverlay_Response
 */
export const CVRGamepadUI_Message_ShowOverlay_Response = new CVRGamepadUI_Message_ShowOverlay_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUIShared_DashboardAction$Type extends MessageType<CVRGamepadUIShared_DashboardAction> {
    constructor() {
        super("CVRGamepadUIShared_DashboardAction", [
            { no: 1, name: "action_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "visible_in_dashboard_bar", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "message", T: () => CVRGamepadUIShared_DashboardActionIcon },
            { no: 6, name: "icon_active", kind: "message", T: () => CVRGamepadUIShared_DashboardActionIcon },
            { no: 7, name: "invocation", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 8, name: "active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "special_invocation", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 10, name: "visible_in_menu", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "is_menu", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "parent_menu_action_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUIShared_DashboardAction>): CVRGamepadUIShared_DashboardAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUIShared_DashboardAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUIShared_DashboardAction): CVRGamepadUIShared_DashboardAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 action_id */ 1:
                    message.actionId = reader.uint32();
                    break;
                case /* optional bool visible_in_dashboard_bar */ 2:
                    message.visibleInDashboardBar = reader.bool();
                    break;
                case /* optional bool enabled */ 3:
                    message.enabled = reader.bool();
                    break;
                case /* optional string display_name */ 4:
                    message.displayName = reader.string();
                    break;
                case /* optional CVRGamepadUIShared_DashboardActionIcon icon */ 5:
                    message.icon = CVRGamepadUIShared_DashboardActionIcon.internalBinaryRead(reader, reader.uint32(), options, message.icon);
                    break;
                case /* optional CVRGamepadUIShared_DashboardActionIcon icon_active */ 6:
                    message.iconActive = CVRGamepadUIShared_DashboardActionIcon.internalBinaryRead(reader, reader.uint32(), options, message.iconActive);
                    break;
                case /* optional int32 invocation = 7 [default = 1] */ 7:
                    message.invocation = reader.int32();
                    break;
                case /* optional bool active */ 8:
                    message.active = reader.bool();
                    break;
                case /* optional int32 special_invocation */ 9:
                    message.specialInvocation = reader.int32();
                    break;
                case /* optional bool visible_in_menu */ 10:
                    message.visibleInMenu = reader.bool();
                    break;
                case /* optional bool is_menu */ 11:
                    message.isMenu = reader.bool();
                    break;
                case /* optional uint32 parent_menu_action_id */ 12:
                    message.parentMenuActionId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUIShared_DashboardAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 action_id = 1; */
        if (message.actionId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.actionId);
        /* optional bool visible_in_dashboard_bar = 2; */
        if (message.visibleInDashboardBar !== undefined)
            writer.tag(2, WireType.Varint).bool(message.visibleInDashboardBar);
        /* optional bool enabled = 3; */
        if (message.enabled !== undefined)
            writer.tag(3, WireType.Varint).bool(message.enabled);
        /* optional string display_name = 4; */
        if (message.displayName !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.displayName);
        /* optional CVRGamepadUIShared_DashboardActionIcon icon = 5; */
        if (message.icon)
            CVRGamepadUIShared_DashboardActionIcon.internalBinaryWrite(message.icon, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CVRGamepadUIShared_DashboardActionIcon icon_active = 6; */
        if (message.iconActive)
            CVRGamepadUIShared_DashboardActionIcon.internalBinaryWrite(message.iconActive, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 invocation = 7 [default = 1]; */
        if (message.invocation !== undefined)
            writer.tag(7, WireType.Varint).int32(message.invocation);
        /* optional bool active = 8; */
        if (message.active !== undefined)
            writer.tag(8, WireType.Varint).bool(message.active);
        /* optional int32 special_invocation = 9; */
        if (message.specialInvocation !== undefined)
            writer.tag(9, WireType.Varint).int32(message.specialInvocation);
        /* optional bool visible_in_menu = 10; */
        if (message.visibleInMenu !== undefined)
            writer.tag(10, WireType.Varint).bool(message.visibleInMenu);
        /* optional bool is_menu = 11; */
        if (message.isMenu !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isMenu);
        /* optional uint32 parent_menu_action_id = 12; */
        if (message.parentMenuActionId !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.parentMenuActionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUIShared_DashboardAction
 */
export const CVRGamepadUIShared_DashboardAction = new CVRGamepadUIShared_DashboardAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUIShared_DashboardActionIcon$Type extends MessageType<CVRGamepadUIShared_DashboardActionIcon> {
    constructor() {
        super("CVRGamepadUIShared_DashboardActionIcon", [
            { no: 1, name: "enum", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUIShared_DashboardActionIcon>): CVRGamepadUIShared_DashboardActionIcon {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUIShared_DashboardActionIcon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUIShared_DashboardActionIcon): CVRGamepadUIShared_DashboardActionIcon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 enum */ 1:
                    message.enum = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUIShared_DashboardActionIcon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 enum = 1; */
        if (message.enum !== undefined)
            writer.tag(1, WireType.Varint).int32(message.enum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUIShared_DashboardActionIcon
 */
export const CVRGamepadUIShared_DashboardActionIcon = new CVRGamepadUIShared_DashboardActionIcon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUIShared_DashboardTabIcon$Type extends MessageType<CVRGamepadUIShared_DashboardTabIcon> {
    constructor() {
        super("CVRGamepadUIShared_DashboardTabIcon", [
            { no: 1, name: "enum", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "overlay", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "hwnd", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUIShared_DashboardTabIcon>): CVRGamepadUIShared_DashboardTabIcon {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUIShared_DashboardTabIcon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUIShared_DashboardTabIcon): CVRGamepadUIShared_DashboardTabIcon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 enum */ 1:
                    message.enum = reader.int32();
                    break;
                case /* optional uint32 appid */ 2:
                    message.appid = reader.uint32();
                    break;
                case /* optional string overlay */ 3:
                    message.overlay = reader.string();
                    break;
                case /* optional uint32 hwnd */ 4:
                    message.hwnd = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUIShared_DashboardTabIcon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 enum = 1; */
        if (message.enum !== undefined)
            writer.tag(1, WireType.Varint).int32(message.enum);
        /* optional uint32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appid);
        /* optional string overlay = 3; */
        if (message.overlay !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.overlay);
        /* optional uint32 hwnd = 4; */
        if (message.hwnd !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.hwnd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUIShared_DashboardTabIcon
 */
export const CVRGamepadUIShared_DashboardTabIcon = new CVRGamepadUIShared_DashboardTabIcon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUIShared_PathProperty_DashboardActions$Type extends MessageType<CVRGamepadUIShared_PathProperty_DashboardActions> {
    constructor() {
        super("CVRGamepadUIShared_PathProperty_DashboardActions", [
            { no: 1, name: "actions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CVRGamepadUIShared_DashboardAction }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUIShared_PathProperty_DashboardActions>): CVRGamepadUIShared_PathProperty_DashboardActions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actions = [];
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUIShared_PathProperty_DashboardActions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUIShared_PathProperty_DashboardActions): CVRGamepadUIShared_PathProperty_DashboardActions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CVRGamepadUIShared_DashboardAction actions */ 1:
                    message.actions.push(CVRGamepadUIShared_DashboardAction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUIShared_PathProperty_DashboardActions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CVRGamepadUIShared_DashboardAction actions = 1; */
        for (let i = 0; i < message.actions.length; i++)
            CVRGamepadUIShared_DashboardAction.internalBinaryWrite(message.actions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUIShared_PathProperty_DashboardActions
 */
export const CVRGamepadUIShared_PathProperty_DashboardActions = new CVRGamepadUIShared_PathProperty_DashboardActions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUIShared_PathProperty_DashboardTabs$Type extends MessageType<CVRGamepadUIShared_PathProperty_DashboardTabs> {
    constructor() {
        super("CVRGamepadUIShared_PathProperty_DashboardTabs", [
            { no: 1, name: "tabs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CVRGamepadUIShared_PathProperty_DashboardTabs_Tab },
            { no: 2, name: "selected_tab_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "vr_settings_tab_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "vr_steam_tab_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUIShared_PathProperty_DashboardTabs>): CVRGamepadUIShared_PathProperty_DashboardTabs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tabs = [];
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUIShared_PathProperty_DashboardTabs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUIShared_PathProperty_DashboardTabs): CVRGamepadUIShared_PathProperty_DashboardTabs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CVRGamepadUIShared_PathProperty_DashboardTabs_Tab tabs */ 1:
                    message.tabs.push(CVRGamepadUIShared_PathProperty_DashboardTabs_Tab.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 selected_tab_id */ 2:
                    message.selectedTabId = reader.uint32();
                    break;
                case /* optional uint32 vr_settings_tab_id */ 3:
                    message.vrSettingsTabId = reader.uint32();
                    break;
                case /* optional uint32 vr_steam_tab_id */ 4:
                    message.vrSteamTabId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUIShared_PathProperty_DashboardTabs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CVRGamepadUIShared_PathProperty_DashboardTabs_Tab tabs = 1; */
        for (let i = 0; i < message.tabs.length; i++)
            CVRGamepadUIShared_PathProperty_DashboardTabs_Tab.internalBinaryWrite(message.tabs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 selected_tab_id = 2; */
        if (message.selectedTabId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.selectedTabId);
        /* optional uint32 vr_settings_tab_id = 3; */
        if (message.vrSettingsTabId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.vrSettingsTabId);
        /* optional uint32 vr_steam_tab_id = 4; */
        if (message.vrSteamTabId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.vrSteamTabId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUIShared_PathProperty_DashboardTabs
 */
export const CVRGamepadUIShared_PathProperty_DashboardTabs = new CVRGamepadUIShared_PathProperty_DashboardTabs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUIShared_PathProperty_DashboardTabs_Tab$Type extends MessageType<CVRGamepadUIShared_PathProperty_DashboardTabs_Tab> {
    constructor() {
        super("CVRGamepadUIShared_PathProperty_DashboardTabs_Tab", [
            { no: 1, name: "tab_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "visible_in_dashboard_bar", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "display_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "icon", kind: "message", T: () => CVRGamepadUIShared_DashboardTabIcon },
            { no: 5, name: "visible_in_dashboard_menu", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUIShared_PathProperty_DashboardTabs_Tab>): CVRGamepadUIShared_PathProperty_DashboardTabs_Tab {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUIShared_PathProperty_DashboardTabs_Tab>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUIShared_PathProperty_DashboardTabs_Tab): CVRGamepadUIShared_PathProperty_DashboardTabs_Tab {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 tab_id */ 1:
                    message.tabId = reader.uint32();
                    break;
                case /* optional bool visible_in_dashboard_bar */ 2:
                    message.visibleInDashboardBar = reader.bool();
                    break;
                case /* optional string display_name */ 3:
                    message.displayName = reader.string();
                    break;
                case /* optional CVRGamepadUIShared_DashboardTabIcon icon */ 4:
                    message.icon = CVRGamepadUIShared_DashboardTabIcon.internalBinaryRead(reader, reader.uint32(), options, message.icon);
                    break;
                case /* optional bool visible_in_dashboard_menu */ 5:
                    message.visibleInDashboardMenu = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUIShared_PathProperty_DashboardTabs_Tab, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 tab_id = 1; */
        if (message.tabId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.tabId);
        /* optional bool visible_in_dashboard_bar = 2; */
        if (message.visibleInDashboardBar !== undefined)
            writer.tag(2, WireType.Varint).bool(message.visibleInDashboardBar);
        /* optional string display_name = 3; */
        if (message.displayName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        /* optional CVRGamepadUIShared_DashboardTabIcon icon = 4; */
        if (message.icon)
            CVRGamepadUIShared_DashboardTabIcon.internalBinaryWrite(message.icon, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional bool visible_in_dashboard_menu = 5; */
        if (message.visibleInDashboardMenu !== undefined)
            writer.tag(5, WireType.Varint).bool(message.visibleInDashboardMenu);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUIShared_PathProperty_DashboardTabs_Tab
 */
export const CVRGamepadUIShared_PathProperty_DashboardTabs_Tab = new CVRGamepadUIShared_PathProperty_DashboardTabs_Tab$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUIShared_PathProperty_DesktopWindows$Type extends MessageType<CVRGamepadUIShared_PathProperty_DesktopWindows> {
    constructor() {
        super("CVRGamepadUIShared_PathProperty_DesktopWindows", [
            { no: 1, name: "windows", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CVRGamepadUIShared_PathProperty_DesktopWindows_Window }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUIShared_PathProperty_DesktopWindows>): CVRGamepadUIShared_PathProperty_DesktopWindows {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.windows = [];
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUIShared_PathProperty_DesktopWindows>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUIShared_PathProperty_DesktopWindows): CVRGamepadUIShared_PathProperty_DesktopWindows {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CVRGamepadUIShared_PathProperty_DesktopWindows_Window windows */ 1:
                    message.windows.push(CVRGamepadUIShared_PathProperty_DesktopWindows_Window.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUIShared_PathProperty_DesktopWindows, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CVRGamepadUIShared_PathProperty_DesktopWindows_Window windows = 1; */
        for (let i = 0; i < message.windows.length; i++)
            CVRGamepadUIShared_PathProperty_DesktopWindows_Window.internalBinaryWrite(message.windows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUIShared_PathProperty_DesktopWindows
 */
export const CVRGamepadUIShared_PathProperty_DesktopWindows = new CVRGamepadUIShared_PathProperty_DesktopWindows$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUIShared_PathProperty_DesktopWindows_Window$Type extends MessageType<CVRGamepadUIShared_PathProperty_DesktopWindows_Window> {
    constructor() {
        super("CVRGamepadUIShared_PathProperty_DesktopWindows_Window", [
            { no: 1, name: "window_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "hwnd", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tab_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUIShared_PathProperty_DesktopWindows_Window>): CVRGamepadUIShared_PathProperty_DesktopWindows_Window {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUIShared_PathProperty_DesktopWindows_Window>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUIShared_PathProperty_DesktopWindows_Window): CVRGamepadUIShared_PathProperty_DesktopWindows_Window {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 window_id */ 1:
                    message.windowId = reader.uint32();
                    break;
                case /* optional uint32 hwnd */ 2:
                    message.hwnd = reader.uint32();
                    break;
                case /* optional string title */ 3:
                    message.title = reader.string();
                    break;
                case /* optional uint32 tab_id */ 4:
                    message.tabId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUIShared_PathProperty_DesktopWindows_Window, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 window_id = 1; */
        if (message.windowId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.windowId);
        /* optional uint32 hwnd = 2; */
        if (message.hwnd !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.hwnd);
        /* optional string title = 3; */
        if (message.title !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.title);
        /* optional uint32 tab_id = 4; */
        if (message.tabId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.tabId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUIShared_PathProperty_DesktopWindows_Window
 */
export const CVRGamepadUIShared_PathProperty_DesktopWindows_Window = new CVRGamepadUIShared_PathProperty_DesktopWindows_Window$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUIShared_PathProperty_PowerOptions$Type extends MessageType<CVRGamepadUIShared_PathProperty_PowerOptions> {
    constructor() {
        super("CVRGamepadUIShared_PathProperty_PowerOptions", [
            { no: 1, name: "can_sleep", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "can_shutdown", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "can_restart_system", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "can_exitvr", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUIShared_PathProperty_PowerOptions>): CVRGamepadUIShared_PathProperty_PowerOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUIShared_PathProperty_PowerOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUIShared_PathProperty_PowerOptions): CVRGamepadUIShared_PathProperty_PowerOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool can_sleep */ 1:
                    message.canSleep = reader.bool();
                    break;
                case /* optional bool can_shutdown */ 2:
                    message.canShutdown = reader.bool();
                    break;
                case /* optional bool can_restart_system */ 3:
                    message.canRestartSystem = reader.bool();
                    break;
                case /* optional bool can_exitvr */ 4:
                    message.canExitvr = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUIShared_PathProperty_PowerOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool can_sleep = 1; */
        if (message.canSleep !== undefined)
            writer.tag(1, WireType.Varint).bool(message.canSleep);
        /* optional bool can_shutdown = 2; */
        if (message.canShutdown !== undefined)
            writer.tag(2, WireType.Varint).bool(message.canShutdown);
        /* optional bool can_restart_system = 3; */
        if (message.canRestartSystem !== undefined)
            writer.tag(3, WireType.Varint).bool(message.canRestartSystem);
        /* optional bool can_exitvr = 4; */
        if (message.canExitvr !== undefined)
            writer.tag(4, WireType.Varint).bool(message.canExitvr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUIShared_PathProperty_PowerOptions
 */
export const CVRGamepadUIShared_PathProperty_PowerOptions = new CVRGamepadUIShared_PathProperty_PowerOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CVRGamepadUIShared_PathProperty_VRVersionInfo$Type extends MessageType<CVRGamepadUIShared_PathProperty_VRVersionInfo> {
    constructor() {
        super("CVRGamepadUIShared_PathProperty_VRVersionInfo", [
            { no: 1, name: "version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "webpack_build_timestamp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CVRGamepadUIShared_PathProperty_VRVersionInfo>): CVRGamepadUIShared_PathProperty_VRVersionInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CVRGamepadUIShared_PathProperty_VRVersionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CVRGamepadUIShared_PathProperty_VRVersionInfo): CVRGamepadUIShared_PathProperty_VRVersionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string version */ 1:
                    message.version = reader.string();
                    break;
                case /* optional uint32 webpack_build_timestamp */ 2:
                    message.webpackBuildTimestamp = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CVRGamepadUIShared_PathProperty_VRVersionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string version = 1; */
        if (message.version !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* optional uint32 webpack_build_timestamp = 2; */
        if (message.webpackBuildTimestamp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.webpackBuildTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CVRGamepadUIShared_PathProperty_VRVersionInfo
 */
export const CVRGamepadUIShared_PathProperty_VRVersionInfo = new CVRGamepadUIShared_PathProperty_VRVersionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptedAppTicket$Type extends MessageType<EncryptedAppTicket> {
    constructor() {
        super("EncryptedAppTicket", [
            { no: 1, name: "ticket_version_no", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "crc_encryptedticket", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cb_encrypteduserdata", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cb_encrypted_appownershipticket", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "encrypted_ticket", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<EncryptedAppTicket>): EncryptedAppTicket {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EncryptedAppTicket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncryptedAppTicket): EncryptedAppTicket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 ticket_version_no */ 1:
                    message.ticketVersionNo = reader.uint32();
                    break;
                case /* optional uint32 crc_encryptedticket */ 2:
                    message.crcEncryptedticket = reader.uint32();
                    break;
                case /* optional uint32 cb_encrypteduserdata */ 3:
                    message.cbEncrypteduserdata = reader.uint32();
                    break;
                case /* optional uint32 cb_encrypted_appownershipticket */ 4:
                    message.cbEncryptedAppownershipticket = reader.uint32();
                    break;
                case /* optional bytes encrypted_ticket */ 5:
                    message.encryptedTicket = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncryptedAppTicket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 ticket_version_no = 1; */
        if (message.ticketVersionNo !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.ticketVersionNo);
        /* optional uint32 crc_encryptedticket = 2; */
        if (message.crcEncryptedticket !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.crcEncryptedticket);
        /* optional uint32 cb_encrypteduserdata = 3; */
        if (message.cbEncrypteduserdata !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.cbEncrypteduserdata);
        /* optional uint32 cb_encrypted_appownershipticket = 4; */
        if (message.cbEncryptedAppownershipticket !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.cbEncryptedAppownershipticket);
        /* optional bytes encrypted_ticket = 5; */
        if (message.encryptedTicket !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.encryptedTicket);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EncryptedAppTicket
 */
export const EncryptedAppTicket = new EncryptedAppTicket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoyaltyRewardDefinition$Type extends MessageType<LoyaltyRewardDefinition> {
    constructor() {
        super("LoyaltyRewardDefinition", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "defid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "community_item_class", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "community_item_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "point_cost", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "timestamp_created", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "timestamp_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "timestamp_available", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "quantity", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "internal_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "community_item_data", kind: "message", T: () => LoyaltyRewardDefinition_CommunityItemData },
            { no: 14, name: "timestamp_available_end", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "bundle_defids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "usable_duration", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "bundle_discount", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "timestamp_free_until", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LoyaltyRewardDefinition>): LoyaltyRewardDefinition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bundleDefids = [];
        if (value !== undefined)
            reflectionMergePartial<LoyaltyRewardDefinition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoyaltyRewardDefinition): LoyaltyRewardDefinition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 defid */ 2:
                    message.defid = reader.uint32();
                    break;
                case /* optional int32 type */ 3:
                    message.type = reader.int32();
                    break;
                case /* optional int32 community_item_class */ 4:
                    message.communityItemClass = reader.int32();
                    break;
                case /* optional uint32 community_item_type */ 5:
                    message.communityItemType = reader.uint32();
                    break;
                case /* optional int64 point_cost */ 6:
                    message.pointCost = reader.int64().toBigInt();
                    break;
                case /* optional uint32 timestamp_created */ 7:
                    message.timestampCreated = reader.uint32();
                    break;
                case /* optional uint32 timestamp_updated */ 8:
                    message.timestampUpdated = reader.uint32();
                    break;
                case /* optional uint32 timestamp_available */ 9:
                    message.timestampAvailable = reader.uint32();
                    break;
                case /* optional int64 quantity */ 10:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* optional string internal_description */ 11:
                    message.internalDescription = reader.string();
                    break;
                case /* optional bool active */ 12:
                    message.active = reader.bool();
                    break;
                case /* optional LoyaltyRewardDefinition_CommunityItemData community_item_data */ 13:
                    message.communityItemData = LoyaltyRewardDefinition_CommunityItemData.internalBinaryRead(reader, reader.uint32(), options, message.communityItemData);
                    break;
                case /* optional uint32 timestamp_available_end */ 14:
                    message.timestampAvailableEnd = reader.uint32();
                    break;
                case /* repeated uint32 bundle_defids */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bundleDefids.push(reader.uint32());
                    else
                        message.bundleDefids.push(reader.uint32());
                    break;
                case /* optional uint32 usable_duration */ 16:
                    message.usableDuration = reader.uint32();
                    break;
                case /* optional uint32 bundle_discount */ 17:
                    message.bundleDiscount = reader.uint32();
                    break;
                case /* optional uint32 timestamp_free_until */ 18:
                    message.timestampFreeUntil = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoyaltyRewardDefinition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 defid = 2; */
        if (message.defid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.defid);
        /* optional int32 type = 3; */
        if (message.type !== undefined)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* optional int32 community_item_class = 4; */
        if (message.communityItemClass !== undefined)
            writer.tag(4, WireType.Varint).int32(message.communityItemClass);
        /* optional uint32 community_item_type = 5; */
        if (message.communityItemType !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.communityItemType);
        /* optional int64 point_cost = 6; */
        if (message.pointCost !== undefined)
            writer.tag(6, WireType.Varint).int64(message.pointCost);
        /* optional uint32 timestamp_created = 7; */
        if (message.timestampCreated !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.timestampCreated);
        /* optional uint32 timestamp_updated = 8; */
        if (message.timestampUpdated !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.timestampUpdated);
        /* optional uint32 timestamp_available = 9; */
        if (message.timestampAvailable !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.timestampAvailable);
        /* optional int64 quantity = 10; */
        if (message.quantity !== undefined)
            writer.tag(10, WireType.Varint).int64(message.quantity);
        /* optional string internal_description = 11; */
        if (message.internalDescription !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.internalDescription);
        /* optional bool active = 12; */
        if (message.active !== undefined)
            writer.tag(12, WireType.Varint).bool(message.active);
        /* optional LoyaltyRewardDefinition_CommunityItemData community_item_data = 13; */
        if (message.communityItemData)
            LoyaltyRewardDefinition_CommunityItemData.internalBinaryWrite(message.communityItemData, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 timestamp_available_end = 14; */
        if (message.timestampAvailableEnd !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.timestampAvailableEnd);
        /* repeated uint32 bundle_defids = 15; */
        for (let i = 0; i < message.bundleDefids.length; i++)
            writer.tag(15, WireType.Varint).uint32(message.bundleDefids[i]);
        /* optional uint32 usable_duration = 16; */
        if (message.usableDuration !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.usableDuration);
        /* optional uint32 bundle_discount = 17; */
        if (message.bundleDiscount !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.bundleDiscount);
        /* optional uint32 timestamp_free_until = 18; */
        if (message.timestampFreeUntil !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.timestampFreeUntil);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LoyaltyRewardDefinition
 */
export const LoyaltyRewardDefinition = new LoyaltyRewardDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoyaltyRewardDefinition_BadgeData$Type extends MessageType<LoyaltyRewardDefinition_BadgeData> {
    constructor() {
        super("LoyaltyRewardDefinition_BadgeData", [
            { no: 1, name: "level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "image", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoyaltyRewardDefinition_BadgeData>): LoyaltyRewardDefinition_BadgeData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LoyaltyRewardDefinition_BadgeData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoyaltyRewardDefinition_BadgeData): LoyaltyRewardDefinition_BadgeData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 level */ 1:
                    message.level = reader.int32();
                    break;
                case /* optional string image */ 2:
                    message.image = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoyaltyRewardDefinition_BadgeData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 level = 1; */
        if (message.level !== undefined)
            writer.tag(1, WireType.Varint).int32(message.level);
        /* optional string image = 2; */
        if (message.image !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.image);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LoyaltyRewardDefinition_BadgeData
 */
export const LoyaltyRewardDefinition_BadgeData = new LoyaltyRewardDefinition_BadgeData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoyaltyRewardDefinition_CommunityItemData$Type extends MessageType<LoyaltyRewardDefinition_CommunityItemData> {
    constructor() {
        super("LoyaltyRewardDefinition_CommunityItemData", [
            { no: 1, name: "item_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "item_title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "item_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "item_image_small", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "item_image_large", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "item_movie_webm", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "item_movie_mp4", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "animated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "badge_data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LoyaltyRewardDefinition_BadgeData },
            { no: 10, name: "item_movie_webm_small", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "item_movie_mp4_small", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "profile_theme_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "tiled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LoyaltyRewardDefinition_CommunityItemData>): LoyaltyRewardDefinition_CommunityItemData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.badgeData = [];
        if (value !== undefined)
            reflectionMergePartial<LoyaltyRewardDefinition_CommunityItemData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoyaltyRewardDefinition_CommunityItemData): LoyaltyRewardDefinition_CommunityItemData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string item_name */ 1:
                    message.itemName = reader.string();
                    break;
                case /* optional string item_title */ 2:
                    message.itemTitle = reader.string();
                    break;
                case /* optional string item_description */ 3:
                    message.itemDescription = reader.string();
                    break;
                case /* optional string item_image_small */ 4:
                    message.itemImageSmall = reader.string();
                    break;
                case /* optional string item_image_large */ 5:
                    message.itemImageLarge = reader.string();
                    break;
                case /* optional string item_movie_webm */ 6:
                    message.itemMovieWebm = reader.string();
                    break;
                case /* optional string item_movie_mp4 */ 7:
                    message.itemMovieMp4 = reader.string();
                    break;
                case /* optional bool animated */ 8:
                    message.animated = reader.bool();
                    break;
                case /* repeated LoyaltyRewardDefinition_BadgeData badge_data */ 9:
                    message.badgeData.push(LoyaltyRewardDefinition_BadgeData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string item_movie_webm_small */ 10:
                    message.itemMovieWebmSmall = reader.string();
                    break;
                case /* optional string item_movie_mp4_small */ 11:
                    message.itemMovieMp4Small = reader.string();
                    break;
                case /* optional string profile_theme_id */ 12:
                    message.profileThemeId = reader.string();
                    break;
                case /* optional bool tiled */ 13:
                    message.tiled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoyaltyRewardDefinition_CommunityItemData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string item_name = 1; */
        if (message.itemName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.itemName);
        /* optional string item_title = 2; */
        if (message.itemTitle !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.itemTitle);
        /* optional string item_description = 3; */
        if (message.itemDescription !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.itemDescription);
        /* optional string item_image_small = 4; */
        if (message.itemImageSmall !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.itemImageSmall);
        /* optional string item_image_large = 5; */
        if (message.itemImageLarge !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.itemImageLarge);
        /* optional string item_movie_webm = 6; */
        if (message.itemMovieWebm !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.itemMovieWebm);
        /* optional string item_movie_mp4 = 7; */
        if (message.itemMovieMp4 !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.itemMovieMp4);
        /* optional bool animated = 8; */
        if (message.animated !== undefined)
            writer.tag(8, WireType.Varint).bool(message.animated);
        /* repeated LoyaltyRewardDefinition_BadgeData badge_data = 9; */
        for (let i = 0; i < message.badgeData.length; i++)
            LoyaltyRewardDefinition_BadgeData.internalBinaryWrite(message.badgeData[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional string item_movie_webm_small = 10; */
        if (message.itemMovieWebmSmall !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.itemMovieWebmSmall);
        /* optional string item_movie_mp4_small = 11; */
        if (message.itemMovieMp4Small !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.itemMovieMp4Small);
        /* optional string profile_theme_id = 12; */
        if (message.profileThemeId !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.profileThemeId);
        /* optional bool tiled = 13; */
        if (message.tiled !== undefined)
            writer.tag(13, WireType.Varint).bool(message.tiled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LoyaltyRewardDefinition_CommunityItemData
 */
export const LoyaltyRewardDefinition_CommunityItemData = new LoyaltyRewardDefinition_CommunityItemData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreBrowseContext$Type extends MessageType<StoreBrowseContext> {
    constructor() {
        super("StoreBrowseContext", [
            { no: 1, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "elanguage", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "steam_realm", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreBrowseContext>): StoreBrowseContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreBrowseContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreBrowseContext): StoreBrowseContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string language */ 1:
                    message.language = reader.string();
                    break;
                case /* optional int32 elanguage */ 2:
                    message.elanguage = reader.int32();
                    break;
                case /* optional string country_code */ 3:
                    message.countryCode = reader.string();
                    break;
                case /* optional int32 steam_realm */ 4:
                    message.steamRealm = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreBrowseContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string language = 1; */
        if (message.language !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.language);
        /* optional int32 elanguage = 2; */
        if (message.elanguage !== undefined)
            writer.tag(2, WireType.Varint).int32(message.elanguage);
        /* optional string country_code = 3; */
        if (message.countryCode !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.countryCode);
        /* optional int32 steam_realm = 4; */
        if (message.steamRealm !== undefined)
            writer.tag(4, WireType.Varint).int32(message.steamRealm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreBrowseContext
 */
export const StoreBrowseContext = new StoreBrowseContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreBrowseFilterFailure$Type extends MessageType<StoreBrowseFilterFailure> {
    constructor() {
        super("StoreBrowseFilterFailure", [
            { no: 1, name: "filter_failure", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 5, name: "already_owned", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "on_wishlist", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "ignored", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "not_in_users_language", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "not_on_users_platform", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "demo_for_owned_game", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "dlc_for_unowned_game", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "nonpreferred_product_type", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "excluded_tagids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 30, name: "excluded_content_descriptorids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<StoreBrowseFilterFailure>): StoreBrowseFilterFailure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.excludedTagids = [];
        message.excludedContentDescriptorids = [];
        if (value !== undefined)
            reflectionMergePartial<StoreBrowseFilterFailure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreBrowseFilterFailure): StoreBrowseFilterFailure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 filter_failure = 1 [default = 0] */ 1:
                    message.filterFailure = reader.int32();
                    break;
                case /* optional bool already_owned */ 5:
                    message.alreadyOwned = reader.bool();
                    break;
                case /* optional bool on_wishlist */ 6:
                    message.onWishlist = reader.bool();
                    break;
                case /* optional bool ignored */ 7:
                    message.ignored = reader.bool();
                    break;
                case /* optional bool not_in_users_language */ 10:
                    message.notInUsersLanguage = reader.bool();
                    break;
                case /* optional bool not_on_users_platform */ 11:
                    message.notOnUsersPlatform = reader.bool();
                    break;
                case /* optional bool demo_for_owned_game */ 12:
                    message.demoForOwnedGame = reader.bool();
                    break;
                case /* optional bool dlc_for_unowned_game */ 13:
                    message.dlcForUnownedGame = reader.bool();
                    break;
                case /* optional bool nonpreferred_product_type */ 20:
                    message.nonpreferredProductType = reader.bool();
                    break;
                case /* repeated uint32 excluded_tagids */ 21:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.excludedTagids.push(reader.uint32());
                    else
                        message.excludedTagids.push(reader.uint32());
                    break;
                case /* repeated int32 excluded_content_descriptorids */ 30:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.excludedContentDescriptorids.push(reader.int32());
                    else
                        message.excludedContentDescriptorids.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreBrowseFilterFailure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 filter_failure = 1 [default = 0]; */
        if (message.filterFailure !== undefined)
            writer.tag(1, WireType.Varint).int32(message.filterFailure);
        /* optional bool already_owned = 5; */
        if (message.alreadyOwned !== undefined)
            writer.tag(5, WireType.Varint).bool(message.alreadyOwned);
        /* optional bool on_wishlist = 6; */
        if (message.onWishlist !== undefined)
            writer.tag(6, WireType.Varint).bool(message.onWishlist);
        /* optional bool ignored = 7; */
        if (message.ignored !== undefined)
            writer.tag(7, WireType.Varint).bool(message.ignored);
        /* optional bool not_in_users_language = 10; */
        if (message.notInUsersLanguage !== undefined)
            writer.tag(10, WireType.Varint).bool(message.notInUsersLanguage);
        /* optional bool not_on_users_platform = 11; */
        if (message.notOnUsersPlatform !== undefined)
            writer.tag(11, WireType.Varint).bool(message.notOnUsersPlatform);
        /* optional bool demo_for_owned_game = 12; */
        if (message.demoForOwnedGame !== undefined)
            writer.tag(12, WireType.Varint).bool(message.demoForOwnedGame);
        /* optional bool dlc_for_unowned_game = 13; */
        if (message.dlcForUnownedGame !== undefined)
            writer.tag(13, WireType.Varint).bool(message.dlcForUnownedGame);
        /* optional bool nonpreferred_product_type = 20; */
        if (message.nonpreferredProductType !== undefined)
            writer.tag(20, WireType.Varint).bool(message.nonpreferredProductType);
        /* repeated uint32 excluded_tagids = 21; */
        for (let i = 0; i < message.excludedTagids.length; i++)
            writer.tag(21, WireType.Varint).uint32(message.excludedTagids[i]);
        /* repeated int32 excluded_content_descriptorids = 30; */
        for (let i = 0; i < message.excludedContentDescriptorids.length; i++)
            writer.tag(30, WireType.Varint).int32(message.excludedContentDescriptorids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreBrowseFilterFailure
 */
export const StoreBrowseFilterFailure = new StoreBrowseFilterFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreBrowseItemDataRequest$Type extends MessageType<StoreBrowseItemDataRequest> {
    constructor() {
        super("StoreBrowseItemDataRequest", [
            { no: 1, name: "include_assets", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_release", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "include_platforms", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_all_purchase_options", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "include_screenshots", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "include_trailers", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "include_ratings", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "include_tag_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "include_reviews", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "include_basic_info", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "include_supported_languages", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "include_full_description", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "include_included_items", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "included_item_data_request", kind: "message", T: () => StoreBrowseItemDataRequest },
            { no: 15, name: "include_assets_without_overrides", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "apply_user_filters", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "include_links", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StoreBrowseItemDataRequest>): StoreBrowseItemDataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreBrowseItemDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreBrowseItemDataRequest): StoreBrowseItemDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool include_assets */ 1:
                    message.includeAssets = reader.bool();
                    break;
                case /* optional bool include_release */ 2:
                    message.includeRelease = reader.bool();
                    break;
                case /* optional bool include_platforms */ 3:
                    message.includePlatforms = reader.bool();
                    break;
                case /* optional bool include_all_purchase_options */ 4:
                    message.includeAllPurchaseOptions = reader.bool();
                    break;
                case /* optional bool include_screenshots */ 5:
                    message.includeScreenshots = reader.bool();
                    break;
                case /* optional bool include_trailers */ 6:
                    message.includeTrailers = reader.bool();
                    break;
                case /* optional bool include_ratings */ 7:
                    message.includeRatings = reader.bool();
                    break;
                case /* optional int32 include_tag_count */ 8:
                    message.includeTagCount = reader.int32();
                    break;
                case /* optional bool include_reviews */ 9:
                    message.includeReviews = reader.bool();
                    break;
                case /* optional bool include_basic_info */ 10:
                    message.includeBasicInfo = reader.bool();
                    break;
                case /* optional bool include_supported_languages */ 11:
                    message.includeSupportedLanguages = reader.bool();
                    break;
                case /* optional bool include_full_description */ 12:
                    message.includeFullDescription = reader.bool();
                    break;
                case /* optional bool include_included_items */ 13:
                    message.includeIncludedItems = reader.bool();
                    break;
                case /* optional StoreBrowseItemDataRequest included_item_data_request */ 14:
                    message.includedItemDataRequest = StoreBrowseItemDataRequest.internalBinaryRead(reader, reader.uint32(), options, message.includedItemDataRequest);
                    break;
                case /* optional bool include_assets_without_overrides */ 15:
                    message.includeAssetsWithoutOverrides = reader.bool();
                    break;
                case /* optional bool apply_user_filters */ 16:
                    message.applyUserFilters = reader.bool();
                    break;
                case /* optional bool include_links */ 17:
                    message.includeLinks = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreBrowseItemDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool include_assets = 1; */
        if (message.includeAssets !== undefined)
            writer.tag(1, WireType.Varint).bool(message.includeAssets);
        /* optional bool include_release = 2; */
        if (message.includeRelease !== undefined)
            writer.tag(2, WireType.Varint).bool(message.includeRelease);
        /* optional bool include_platforms = 3; */
        if (message.includePlatforms !== undefined)
            writer.tag(3, WireType.Varint).bool(message.includePlatforms);
        /* optional bool include_all_purchase_options = 4; */
        if (message.includeAllPurchaseOptions !== undefined)
            writer.tag(4, WireType.Varint).bool(message.includeAllPurchaseOptions);
        /* optional bool include_screenshots = 5; */
        if (message.includeScreenshots !== undefined)
            writer.tag(5, WireType.Varint).bool(message.includeScreenshots);
        /* optional bool include_trailers = 6; */
        if (message.includeTrailers !== undefined)
            writer.tag(6, WireType.Varint).bool(message.includeTrailers);
        /* optional bool include_ratings = 7; */
        if (message.includeRatings !== undefined)
            writer.tag(7, WireType.Varint).bool(message.includeRatings);
        /* optional int32 include_tag_count = 8; */
        if (message.includeTagCount !== undefined)
            writer.tag(8, WireType.Varint).int32(message.includeTagCount);
        /* optional bool include_reviews = 9; */
        if (message.includeReviews !== undefined)
            writer.tag(9, WireType.Varint).bool(message.includeReviews);
        /* optional bool include_basic_info = 10; */
        if (message.includeBasicInfo !== undefined)
            writer.tag(10, WireType.Varint).bool(message.includeBasicInfo);
        /* optional bool include_supported_languages = 11; */
        if (message.includeSupportedLanguages !== undefined)
            writer.tag(11, WireType.Varint).bool(message.includeSupportedLanguages);
        /* optional bool include_full_description = 12; */
        if (message.includeFullDescription !== undefined)
            writer.tag(12, WireType.Varint).bool(message.includeFullDescription);
        /* optional bool include_included_items = 13; */
        if (message.includeIncludedItems !== undefined)
            writer.tag(13, WireType.Varint).bool(message.includeIncludedItems);
        /* optional StoreBrowseItemDataRequest included_item_data_request = 14; */
        if (message.includedItemDataRequest)
            StoreBrowseItemDataRequest.internalBinaryWrite(message.includedItemDataRequest, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional bool include_assets_without_overrides = 15; */
        if (message.includeAssetsWithoutOverrides !== undefined)
            writer.tag(15, WireType.Varint).bool(message.includeAssetsWithoutOverrides);
        /* optional bool apply_user_filters = 16; */
        if (message.applyUserFilters !== undefined)
            writer.tag(16, WireType.Varint).bool(message.applyUserFilters);
        /* optional bool include_links = 17; */
        if (message.includeLinks !== undefined)
            writer.tag(17, WireType.Varint).bool(message.includeLinks);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreBrowseItemDataRequest
 */
export const StoreBrowseItemDataRequest = new StoreBrowseItemDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreGameRating$Type extends MessageType<StoreGameRating> {
    constructor() {
        super("StoreGameRating", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rating", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "descriptors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "interactive_elements", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "required_age", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "use_age_gate", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "image_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "image_target", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreGameRating>): StoreGameRating {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptors = [];
        if (value !== undefined)
            reflectionMergePartial<StoreGameRating>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreGameRating): StoreGameRating {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string type */ 1:
                    message.type = reader.string();
                    break;
                case /* optional string rating */ 2:
                    message.rating = reader.string();
                    break;
                case /* repeated string descriptors */ 3:
                    message.descriptors.push(reader.string());
                    break;
                case /* optional string interactive_elements */ 4:
                    message.interactiveElements = reader.string();
                    break;
                case /* optional int32 required_age */ 10:
                    message.requiredAge = reader.int32();
                    break;
                case /* optional bool use_age_gate */ 11:
                    message.useAgeGate = reader.bool();
                    break;
                case /* optional string image_url */ 20:
                    message.imageUrl = reader.string();
                    break;
                case /* optional string image_target */ 21:
                    message.imageTarget = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreGameRating, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* optional string rating = 2; */
        if (message.rating !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.rating);
        /* repeated string descriptors = 3; */
        for (let i = 0; i < message.descriptors.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.descriptors[i]);
        /* optional string interactive_elements = 4; */
        if (message.interactiveElements !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.interactiveElements);
        /* optional int32 required_age = 10; */
        if (message.requiredAge !== undefined)
            writer.tag(10, WireType.Varint).int32(message.requiredAge);
        /* optional bool use_age_gate = 11; */
        if (message.useAgeGate !== undefined)
            writer.tag(11, WireType.Varint).bool(message.useAgeGate);
        /* optional string image_url = 20; */
        if (message.imageUrl !== undefined)
            writer.tag(20, WireType.LengthDelimited).string(message.imageUrl);
        /* optional string image_target = 21; */
        if (message.imageTarget !== undefined)
            writer.tag(21, WireType.LengthDelimited).string(message.imageTarget);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreGameRating
 */
export const StoreGameRating = new StoreGameRating$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem$Type extends MessageType<StoreItem> {
    constructor() {
        super("StoreItem", [
            { no: 1, name: "item_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "success", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "unvailable_for_country_restriction", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "store_url_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 11, name: "included_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 12, name: "included_appids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "is_free", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "is_early_access", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "related_items", kind: "message", T: () => StoreItem_RelatedItems },
            { no: 16, name: "included_items", kind: "message", T: () => StoreItem_IncludedItems },
            { no: 20, name: "content_descriptorids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 21, name: "tagids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "categories", kind: "message", T: () => StoreItem_Categories },
            { no: 23, name: "reviews", kind: "message", T: () => StoreItem_Reviews },
            { no: 24, name: "basic_info", kind: "message", T: () => StoreItem_BasicInfo },
            { no: 25, name: "tags", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_Tag },
            { no: 30, name: "assets", kind: "message", T: () => StoreItem_Assets },
            { no: 31, name: "release", kind: "message", T: () => StoreItem_ReleaseInfo },
            { no: 32, name: "platforms", kind: "message", T: () => StoreItem_Platforms },
            { no: 33, name: "game_rating", kind: "message", T: () => StoreGameRating },
            { no: 34, name: "is_coming_soon", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 40, name: "best_purchase_option", kind: "message", T: () => StoreItem_PurchaseOption },
            { no: 41, name: "purchase_options", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_PurchaseOption },
            { no: 42, name: "accessories", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_PurchaseOption },
            { no: 43, name: "self_purchase_option", kind: "message", T: () => StoreItem_PurchaseOption },
            { no: 50, name: "screenshots", kind: "message", T: () => StoreItem_Screenshots },
            { no: 51, name: "trailers", kind: "message", T: () => StoreItem_Trailers },
            { no: 52, name: "supported_languages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_SupportedLanguage },
            { no: 53, name: "store_url_path_override", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 54, name: "free_weekend", kind: "message", T: () => StoreItem_FreeWeekend },
            { no: 55, name: "unlisted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 56, name: "game_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 57, name: "internal_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 58, name: "full_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 59, name: "is_free_temporarily", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 60, name: "assets_without_overrides", kind: "message", T: () => StoreItem_Assets },
            { no: 70, name: "user_filter_failure", kind: "message", T: () => StoreBrowseFilterFailure },
            { no: 71, name: "links", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_Link }
        ]);
    }
    create(value?: PartialMessage<StoreItem>): StoreItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.includedTypes = [];
        message.includedAppids = [];
        message.contentDescriptorids = [];
        message.tagids = [];
        message.tags = [];
        message.purchaseOptions = [];
        message.accessories = [];
        message.supportedLanguages = [];
        message.links = [];
        if (value !== undefined)
            reflectionMergePartial<StoreItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem): StoreItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 item_type */ 1:
                    message.itemType = reader.int32();
                    break;
                case /* optional uint32 id */ 2:
                    message.id = reader.uint32();
                    break;
                case /* optional uint32 success */ 3:
                    message.success = reader.uint32();
                    break;
                case /* optional bool visible */ 4:
                    message.visible = reader.bool();
                    break;
                case /* optional bool unvailable_for_country_restriction */ 5:
                    message.unvailableForCountryRestriction = reader.bool();
                    break;
                case /* optional string name */ 6:
                    message.name = reader.string();
                    break;
                case /* optional string store_url_path */ 7:
                    message.storeUrlPath = reader.string();
                    break;
                case /* optional uint32 appid */ 9:
                    message.appid = reader.uint32();
                    break;
                case /* optional int32 type */ 10:
                    message.type = reader.int32();
                    break;
                case /* repeated int32 included_types */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.includedTypes.push(reader.int32());
                    else
                        message.includedTypes.push(reader.int32());
                    break;
                case /* repeated uint32 included_appids */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.includedAppids.push(reader.uint32());
                    else
                        message.includedAppids.push(reader.uint32());
                    break;
                case /* optional bool is_free */ 13:
                    message.isFree = reader.bool();
                    break;
                case /* optional bool is_early_access */ 14:
                    message.isEarlyAccess = reader.bool();
                    break;
                case /* optional StoreItem_RelatedItems related_items */ 15:
                    message.relatedItems = StoreItem_RelatedItems.internalBinaryRead(reader, reader.uint32(), options, message.relatedItems);
                    break;
                case /* optional StoreItem_IncludedItems included_items */ 16:
                    message.includedItems = StoreItem_IncludedItems.internalBinaryRead(reader, reader.uint32(), options, message.includedItems);
                    break;
                case /* repeated int32 content_descriptorids */ 20:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.contentDescriptorids.push(reader.int32());
                    else
                        message.contentDescriptorids.push(reader.int32());
                    break;
                case /* repeated uint32 tagids */ 21:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tagids.push(reader.uint32());
                    else
                        message.tagids.push(reader.uint32());
                    break;
                case /* optional StoreItem_Categories categories */ 22:
                    message.categories = StoreItem_Categories.internalBinaryRead(reader, reader.uint32(), options, message.categories);
                    break;
                case /* optional StoreItem_Reviews reviews */ 23:
                    message.reviews = StoreItem_Reviews.internalBinaryRead(reader, reader.uint32(), options, message.reviews);
                    break;
                case /* optional StoreItem_BasicInfo basic_info */ 24:
                    message.basicInfo = StoreItem_BasicInfo.internalBinaryRead(reader, reader.uint32(), options, message.basicInfo);
                    break;
                case /* repeated StoreItem_Tag tags */ 25:
                    message.tags.push(StoreItem_Tag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional StoreItem_Assets assets */ 30:
                    message.assets = StoreItem_Assets.internalBinaryRead(reader, reader.uint32(), options, message.assets);
                    break;
                case /* optional StoreItem_ReleaseInfo release */ 31:
                    message.release = StoreItem_ReleaseInfo.internalBinaryRead(reader, reader.uint32(), options, message.release);
                    break;
                case /* optional StoreItem_Platforms platforms */ 32:
                    message.platforms = StoreItem_Platforms.internalBinaryRead(reader, reader.uint32(), options, message.platforms);
                    break;
                case /* optional StoreGameRating game_rating */ 33:
                    message.gameRating = StoreGameRating.internalBinaryRead(reader, reader.uint32(), options, message.gameRating);
                    break;
                case /* optional bool is_coming_soon */ 34:
                    message.isComingSoon = reader.bool();
                    break;
                case /* optional StoreItem_PurchaseOption best_purchase_option */ 40:
                    message.bestPurchaseOption = StoreItem_PurchaseOption.internalBinaryRead(reader, reader.uint32(), options, message.bestPurchaseOption);
                    break;
                case /* repeated StoreItem_PurchaseOption purchase_options */ 41:
                    message.purchaseOptions.push(StoreItem_PurchaseOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated StoreItem_PurchaseOption accessories */ 42:
                    message.accessories.push(StoreItem_PurchaseOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional StoreItem_PurchaseOption self_purchase_option */ 43:
                    message.selfPurchaseOption = StoreItem_PurchaseOption.internalBinaryRead(reader, reader.uint32(), options, message.selfPurchaseOption);
                    break;
                case /* optional StoreItem_Screenshots screenshots */ 50:
                    message.screenshots = StoreItem_Screenshots.internalBinaryRead(reader, reader.uint32(), options, message.screenshots);
                    break;
                case /* optional StoreItem_Trailers trailers */ 51:
                    message.trailers = StoreItem_Trailers.internalBinaryRead(reader, reader.uint32(), options, message.trailers);
                    break;
                case /* repeated StoreItem_SupportedLanguage supported_languages */ 52:
                    message.supportedLanguages.push(StoreItem_SupportedLanguage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string store_url_path_override */ 53:
                    message.storeUrlPathOverride = reader.string();
                    break;
                case /* optional StoreItem_FreeWeekend free_weekend */ 54:
                    message.freeWeekend = StoreItem_FreeWeekend.internalBinaryRead(reader, reader.uint32(), options, message.freeWeekend);
                    break;
                case /* optional bool unlisted */ 55:
                    message.unlisted = reader.bool();
                    break;
                case /* optional uint32 game_count */ 56:
                    message.gameCount = reader.uint32();
                    break;
                case /* optional string internal_name */ 57:
                    message.internalName = reader.string();
                    break;
                case /* optional string full_description */ 58:
                    message.fullDescription = reader.string();
                    break;
                case /* optional bool is_free_temporarily */ 59:
                    message.isFreeTemporarily = reader.bool();
                    break;
                case /* optional StoreItem_Assets assets_without_overrides */ 60:
                    message.assetsWithoutOverrides = StoreItem_Assets.internalBinaryRead(reader, reader.uint32(), options, message.assetsWithoutOverrides);
                    break;
                case /* optional StoreBrowseFilterFailure user_filter_failure */ 70:
                    message.userFilterFailure = StoreBrowseFilterFailure.internalBinaryRead(reader, reader.uint32(), options, message.userFilterFailure);
                    break;
                case /* repeated StoreItem_Link links */ 71:
                    message.links.push(StoreItem_Link.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 item_type = 1; */
        if (message.itemType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.itemType);
        /* optional uint32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.id);
        /* optional uint32 success = 3; */
        if (message.success !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.success);
        /* optional bool visible = 4; */
        if (message.visible !== undefined)
            writer.tag(4, WireType.Varint).bool(message.visible);
        /* optional bool unvailable_for_country_restriction = 5; */
        if (message.unvailableForCountryRestriction !== undefined)
            writer.tag(5, WireType.Varint).bool(message.unvailableForCountryRestriction);
        /* optional string name = 6; */
        if (message.name !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.name);
        /* optional string store_url_path = 7; */
        if (message.storeUrlPath !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.storeUrlPath);
        /* optional uint32 appid = 9; */
        if (message.appid !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.appid);
        /* optional int32 type = 10; */
        if (message.type !== undefined)
            writer.tag(10, WireType.Varint).int32(message.type);
        /* repeated int32 included_types = 11; */
        for (let i = 0; i < message.includedTypes.length; i++)
            writer.tag(11, WireType.Varint).int32(message.includedTypes[i]);
        /* repeated uint32 included_appids = 12; */
        for (let i = 0; i < message.includedAppids.length; i++)
            writer.tag(12, WireType.Varint).uint32(message.includedAppids[i]);
        /* optional bool is_free = 13; */
        if (message.isFree !== undefined)
            writer.tag(13, WireType.Varint).bool(message.isFree);
        /* optional bool is_early_access = 14; */
        if (message.isEarlyAccess !== undefined)
            writer.tag(14, WireType.Varint).bool(message.isEarlyAccess);
        /* optional StoreItem_RelatedItems related_items = 15; */
        if (message.relatedItems)
            StoreItem_RelatedItems.internalBinaryWrite(message.relatedItems, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreItem_IncludedItems included_items = 16; */
        if (message.includedItems)
            StoreItem_IncludedItems.internalBinaryWrite(message.includedItems, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 content_descriptorids = 20; */
        for (let i = 0; i < message.contentDescriptorids.length; i++)
            writer.tag(20, WireType.Varint).int32(message.contentDescriptorids[i]);
        /* repeated uint32 tagids = 21; */
        for (let i = 0; i < message.tagids.length; i++)
            writer.tag(21, WireType.Varint).uint32(message.tagids[i]);
        /* optional StoreItem_Categories categories = 22; */
        if (message.categories)
            StoreItem_Categories.internalBinaryWrite(message.categories, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreItem_Reviews reviews = 23; */
        if (message.reviews)
            StoreItem_Reviews.internalBinaryWrite(message.reviews, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreItem_BasicInfo basic_info = 24; */
        if (message.basicInfo)
            StoreItem_BasicInfo.internalBinaryWrite(message.basicInfo, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_Tag tags = 25; */
        for (let i = 0; i < message.tags.length; i++)
            StoreItem_Tag.internalBinaryWrite(message.tags[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreItem_Assets assets = 30; */
        if (message.assets)
            StoreItem_Assets.internalBinaryWrite(message.assets, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreItem_ReleaseInfo release = 31; */
        if (message.release)
            StoreItem_ReleaseInfo.internalBinaryWrite(message.release, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreItem_Platforms platforms = 32; */
        if (message.platforms)
            StoreItem_Platforms.internalBinaryWrite(message.platforms, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreGameRating game_rating = 33; */
        if (message.gameRating)
            StoreGameRating.internalBinaryWrite(message.gameRating, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_coming_soon = 34; */
        if (message.isComingSoon !== undefined)
            writer.tag(34, WireType.Varint).bool(message.isComingSoon);
        /* optional StoreItem_PurchaseOption best_purchase_option = 40; */
        if (message.bestPurchaseOption)
            StoreItem_PurchaseOption.internalBinaryWrite(message.bestPurchaseOption, writer.tag(40, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_PurchaseOption purchase_options = 41; */
        for (let i = 0; i < message.purchaseOptions.length; i++)
            StoreItem_PurchaseOption.internalBinaryWrite(message.purchaseOptions[i], writer.tag(41, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_PurchaseOption accessories = 42; */
        for (let i = 0; i < message.accessories.length; i++)
            StoreItem_PurchaseOption.internalBinaryWrite(message.accessories[i], writer.tag(42, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreItem_PurchaseOption self_purchase_option = 43; */
        if (message.selfPurchaseOption)
            StoreItem_PurchaseOption.internalBinaryWrite(message.selfPurchaseOption, writer.tag(43, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreItem_Screenshots screenshots = 50; */
        if (message.screenshots)
            StoreItem_Screenshots.internalBinaryWrite(message.screenshots, writer.tag(50, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreItem_Trailers trailers = 51; */
        if (message.trailers)
            StoreItem_Trailers.internalBinaryWrite(message.trailers, writer.tag(51, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_SupportedLanguage supported_languages = 52; */
        for (let i = 0; i < message.supportedLanguages.length; i++)
            StoreItem_SupportedLanguage.internalBinaryWrite(message.supportedLanguages[i], writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* optional string store_url_path_override = 53; */
        if (message.storeUrlPathOverride !== undefined)
            writer.tag(53, WireType.LengthDelimited).string(message.storeUrlPathOverride);
        /* optional StoreItem_FreeWeekend free_weekend = 54; */
        if (message.freeWeekend)
            StoreItem_FreeWeekend.internalBinaryWrite(message.freeWeekend, writer.tag(54, WireType.LengthDelimited).fork(), options).join();
        /* optional bool unlisted = 55; */
        if (message.unlisted !== undefined)
            writer.tag(55, WireType.Varint).bool(message.unlisted);
        /* optional uint32 game_count = 56; */
        if (message.gameCount !== undefined)
            writer.tag(56, WireType.Varint).uint32(message.gameCount);
        /* optional string internal_name = 57; */
        if (message.internalName !== undefined)
            writer.tag(57, WireType.LengthDelimited).string(message.internalName);
        /* optional string full_description = 58; */
        if (message.fullDescription !== undefined)
            writer.tag(58, WireType.LengthDelimited).string(message.fullDescription);
        /* optional bool is_free_temporarily = 59; */
        if (message.isFreeTemporarily !== undefined)
            writer.tag(59, WireType.Varint).bool(message.isFreeTemporarily);
        /* optional StoreItem_Assets assets_without_overrides = 60; */
        if (message.assetsWithoutOverrides)
            StoreItem_Assets.internalBinaryWrite(message.assetsWithoutOverrides, writer.tag(60, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreBrowseFilterFailure user_filter_failure = 70; */
        if (message.userFilterFailure)
            StoreBrowseFilterFailure.internalBinaryWrite(message.userFilterFailure, writer.tag(70, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_Link links = 71; */
        for (let i = 0; i < message.links.length; i++)
            StoreItem_Link.internalBinaryWrite(message.links[i], writer.tag(71, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem
 */
export const StoreItem = new StoreItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Assets$Type extends MessageType<StoreItem_Assets> {
    constructor() {
        super("StoreItem_Assets", [
            { no: 1, name: "asset_url_format", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "main_capsule", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "small_capsule", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "header", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "package_header", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "page_background", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "hero_capsule", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "hero_capsule_2x", kind: "scalar", jsonName: "heroCapsule2x", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "library_capsule", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "library_capsule_2x", kind: "scalar", jsonName: "libraryCapsule2x", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "library_hero", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "library_hero_2x", kind: "scalar", jsonName: "libraryHero2x", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "community_icon", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "clan_avatar", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "page_background_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "raw_page_background", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Assets>): StoreItem_Assets {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Assets>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Assets): StoreItem_Assets {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string asset_url_format */ 1:
                    message.assetUrlFormat = reader.string();
                    break;
                case /* optional string main_capsule */ 2:
                    message.mainCapsule = reader.string();
                    break;
                case /* optional string small_capsule */ 3:
                    message.smallCapsule = reader.string();
                    break;
                case /* optional string header */ 4:
                    message.header = reader.string();
                    break;
                case /* optional string package_header */ 5:
                    message.packageHeader = reader.string();
                    break;
                case /* optional string page_background */ 6:
                    message.pageBackground = reader.string();
                    break;
                case /* optional string hero_capsule */ 7:
                    message.heroCapsule = reader.string();
                    break;
                case /* optional string hero_capsule_2x */ 8:
                    message.heroCapsule2X = reader.string();
                    break;
                case /* optional string library_capsule */ 9:
                    message.libraryCapsule = reader.string();
                    break;
                case /* optional string library_capsule_2x */ 10:
                    message.libraryCapsule2X = reader.string();
                    break;
                case /* optional string library_hero */ 11:
                    message.libraryHero = reader.string();
                    break;
                case /* optional string library_hero_2x */ 12:
                    message.libraryHero2X = reader.string();
                    break;
                case /* optional string community_icon */ 13:
                    message.communityIcon = reader.string();
                    break;
                case /* optional string clan_avatar */ 14:
                    message.clanAvatar = reader.string();
                    break;
                case /* optional string page_background_path */ 15:
                    message.pageBackgroundPath = reader.string();
                    break;
                case /* optional string raw_page_background */ 16:
                    message.rawPageBackground = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Assets, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string asset_url_format = 1; */
        if (message.assetUrlFormat !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.assetUrlFormat);
        /* optional string main_capsule = 2; */
        if (message.mainCapsule !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.mainCapsule);
        /* optional string small_capsule = 3; */
        if (message.smallCapsule !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.smallCapsule);
        /* optional string header = 4; */
        if (message.header !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.header);
        /* optional string package_header = 5; */
        if (message.packageHeader !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.packageHeader);
        /* optional string page_background = 6; */
        if (message.pageBackground !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.pageBackground);
        /* optional string hero_capsule = 7; */
        if (message.heroCapsule !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.heroCapsule);
        /* optional string hero_capsule_2x = 8; */
        if (message.heroCapsule2X !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.heroCapsule2X);
        /* optional string library_capsule = 9; */
        if (message.libraryCapsule !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.libraryCapsule);
        /* optional string library_capsule_2x = 10; */
        if (message.libraryCapsule2X !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.libraryCapsule2X);
        /* optional string library_hero = 11; */
        if (message.libraryHero !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.libraryHero);
        /* optional string library_hero_2x = 12; */
        if (message.libraryHero2X !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.libraryHero2X);
        /* optional string community_icon = 13; */
        if (message.communityIcon !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.communityIcon);
        /* optional string clan_avatar = 14; */
        if (message.clanAvatar !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.clanAvatar);
        /* optional string page_background_path = 15; */
        if (message.pageBackgroundPath !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.pageBackgroundPath);
        /* optional string raw_page_background = 16; */
        if (message.rawPageBackground !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.rawPageBackground);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Assets
 */
export const StoreItem_Assets = new StoreItem_Assets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_BasicInfo$Type extends MessageType<StoreItem_BasicInfo> {
    constructor() {
        super("StoreItem_BasicInfo", [
            { no: 1, name: "short_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "publishers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_BasicInfo_CreatorHomeLink },
            { no: 3, name: "developers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_BasicInfo_CreatorHomeLink },
            { no: 4, name: "franchises", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_BasicInfo_CreatorHomeLink },
            { no: 5, name: "capsule_headline", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_BasicInfo>): StoreItem_BasicInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishers = [];
        message.developers = [];
        message.franchises = [];
        if (value !== undefined)
            reflectionMergePartial<StoreItem_BasicInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_BasicInfo): StoreItem_BasicInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string short_description */ 1:
                    message.shortDescription = reader.string();
                    break;
                case /* repeated StoreItem_BasicInfo_CreatorHomeLink publishers */ 2:
                    message.publishers.push(StoreItem_BasicInfo_CreatorHomeLink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated StoreItem_BasicInfo_CreatorHomeLink developers */ 3:
                    message.developers.push(StoreItem_BasicInfo_CreatorHomeLink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated StoreItem_BasicInfo_CreatorHomeLink franchises */ 4:
                    message.franchises.push(StoreItem_BasicInfo_CreatorHomeLink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string capsule_headline */ 5:
                    message.capsuleHeadline = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_BasicInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string short_description = 1; */
        if (message.shortDescription !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.shortDescription);
        /* repeated StoreItem_BasicInfo_CreatorHomeLink publishers = 2; */
        for (let i = 0; i < message.publishers.length; i++)
            StoreItem_BasicInfo_CreatorHomeLink.internalBinaryWrite(message.publishers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_BasicInfo_CreatorHomeLink developers = 3; */
        for (let i = 0; i < message.developers.length; i++)
            StoreItem_BasicInfo_CreatorHomeLink.internalBinaryWrite(message.developers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_BasicInfo_CreatorHomeLink franchises = 4; */
        for (let i = 0; i < message.franchises.length; i++)
            StoreItem_BasicInfo_CreatorHomeLink.internalBinaryWrite(message.franchises[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string capsule_headline = 5; */
        if (message.capsuleHeadline !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.capsuleHeadline);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_BasicInfo
 */
export const StoreItem_BasicInfo = new StoreItem_BasicInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_BasicInfo_CreatorHomeLink$Type extends MessageType<StoreItem_BasicInfo_CreatorHomeLink> {
    constructor() {
        super("StoreItem_BasicInfo_CreatorHomeLink", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "creator_clan_account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_BasicInfo_CreatorHomeLink>): StoreItem_BasicInfo_CreatorHomeLink {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_BasicInfo_CreatorHomeLink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_BasicInfo_CreatorHomeLink): StoreItem_BasicInfo_CreatorHomeLink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional uint32 creator_clan_account_id */ 2:
                    message.creatorClanAccountId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_BasicInfo_CreatorHomeLink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional uint32 creator_clan_account_id = 2; */
        if (message.creatorClanAccountId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.creatorClanAccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_BasicInfo_CreatorHomeLink
 */
export const StoreItem_BasicInfo_CreatorHomeLink = new StoreItem_BasicInfo_CreatorHomeLink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Categories$Type extends MessageType<StoreItem_Categories> {
    constructor() {
        super("StoreItem_Categories", [
            { no: 2, name: "supported_player_categoryids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "feature_categoryids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "controller_categoryids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Categories>): StoreItem_Categories {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.supportedPlayerCategoryids = [];
        message.featureCategoryids = [];
        message.controllerCategoryids = [];
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Categories>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Categories): StoreItem_Categories {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 supported_player_categoryids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedPlayerCategoryids.push(reader.uint32());
                    else
                        message.supportedPlayerCategoryids.push(reader.uint32());
                    break;
                case /* repeated uint32 feature_categoryids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.featureCategoryids.push(reader.uint32());
                    else
                        message.featureCategoryids.push(reader.uint32());
                    break;
                case /* repeated uint32 controller_categoryids */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.controllerCategoryids.push(reader.uint32());
                    else
                        message.controllerCategoryids.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Categories, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 supported_player_categoryids = 2; */
        for (let i = 0; i < message.supportedPlayerCategoryids.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.supportedPlayerCategoryids[i]);
        /* repeated uint32 feature_categoryids = 3; */
        for (let i = 0; i < message.featureCategoryids.length; i++)
            writer.tag(3, WireType.Varint).uint32(message.featureCategoryids[i]);
        /* repeated uint32 controller_categoryids = 4; */
        for (let i = 0; i < message.controllerCategoryids.length; i++)
            writer.tag(4, WireType.Varint).uint32(message.controllerCategoryids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Categories
 */
export const StoreItem_Categories = new StoreItem_Categories$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_FreeWeekend$Type extends MessageType<StoreItem_FreeWeekend> {
    constructor() {
        super("StoreItem_FreeWeekend", [
            { no: 1, name: "start_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "end_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_FreeWeekend>): StoreItem_FreeWeekend {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_FreeWeekend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_FreeWeekend): StoreItem_FreeWeekend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 start_time */ 1:
                    message.startTime = reader.uint32();
                    break;
                case /* optional uint32 end_time */ 2:
                    message.endTime = reader.uint32();
                    break;
                case /* optional string text */ 3:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_FreeWeekend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 start_time = 1; */
        if (message.startTime !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.startTime);
        /* optional uint32 end_time = 2; */
        if (message.endTime !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.endTime);
        /* optional string text = 3; */
        if (message.text !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_FreeWeekend
 */
export const StoreItem_FreeWeekend = new StoreItem_FreeWeekend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_IncludedItems$Type extends MessageType<StoreItem_IncludedItems> {
    constructor() {
        super("StoreItem_IncludedItems", [
            { no: 1, name: "included_apps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem },
            { no: 2, name: "included_packages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem }
        ]);
    }
    create(value?: PartialMessage<StoreItem_IncludedItems>): StoreItem_IncludedItems {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.includedApps = [];
        message.includedPackages = [];
        if (value !== undefined)
            reflectionMergePartial<StoreItem_IncludedItems>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_IncludedItems): StoreItem_IncludedItems {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated StoreItem included_apps */ 1:
                    message.includedApps.push(StoreItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated StoreItem included_packages */ 2:
                    message.includedPackages.push(StoreItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_IncludedItems, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated StoreItem included_apps = 1; */
        for (let i = 0; i < message.includedApps.length; i++)
            StoreItem.internalBinaryWrite(message.includedApps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem included_packages = 2; */
        for (let i = 0; i < message.includedPackages.length; i++)
            StoreItem.internalBinaryWrite(message.includedPackages[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_IncludedItems
 */
export const StoreItem_IncludedItems = new StoreItem_IncludedItems$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Link$Type extends MessageType<StoreItem_Link> {
    constructor() {
        super("StoreItem_Link", [
            { no: 1, name: "link_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 2, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Link>): StoreItem_Link {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Link>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Link): StoreItem_Link {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 link_type */ 1:
                    message.linkType = reader.int32();
                    break;
                case /* optional string url */ 2:
                    message.url = reader.string();
                    break;
                case /* optional string text */ 3:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Link, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 link_type = 1; */
        if (message.linkType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.linkType);
        /* optional string url = 2; */
        if (message.url !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* optional string text = 3; */
        if (message.text !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Link
 */
export const StoreItem_Link = new StoreItem_Link$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Platforms$Type extends MessageType<StoreItem_Platforms> {
    constructor() {
        super("StoreItem_Platforms", [
            { no: 1, name: "windows", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "mac", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "linux", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "vr_support", kind: "message", T: () => StoreItem_Platforms_VRSupport },
            { no: 11, name: "steam_deck_compat_category", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 12, name: "steam_os_compat_category", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Platforms>): StoreItem_Platforms {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Platforms>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Platforms): StoreItem_Platforms {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool windows */ 1:
                    message.windows = reader.bool();
                    break;
                case /* optional bool mac */ 2:
                    message.mac = reader.bool();
                    break;
                case /* optional bool linux */ 3:
                    message.linux = reader.bool();
                    break;
                case /* optional StoreItem_Platforms_VRSupport vr_support */ 10:
                    message.vrSupport = StoreItem_Platforms_VRSupport.internalBinaryRead(reader, reader.uint32(), options, message.vrSupport);
                    break;
                case /* optional int32 steam_deck_compat_category */ 11:
                    message.steamDeckCompatCategory = reader.int32();
                    break;
                case /* optional int32 steam_os_compat_category */ 12:
                    message.steamOsCompatCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Platforms, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool windows = 1; */
        if (message.windows !== undefined)
            writer.tag(1, WireType.Varint).bool(message.windows);
        /* optional bool mac = 2; */
        if (message.mac !== undefined)
            writer.tag(2, WireType.Varint).bool(message.mac);
        /* optional bool linux = 3; */
        if (message.linux !== undefined)
            writer.tag(3, WireType.Varint).bool(message.linux);
        /* optional StoreItem_Platforms_VRSupport vr_support = 10; */
        if (message.vrSupport)
            StoreItem_Platforms_VRSupport.internalBinaryWrite(message.vrSupport, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 steam_deck_compat_category = 11; */
        if (message.steamDeckCompatCategory !== undefined)
            writer.tag(11, WireType.Varint).int32(message.steamDeckCompatCategory);
        /* optional int32 steam_os_compat_category = 12; */
        if (message.steamOsCompatCategory !== undefined)
            writer.tag(12, WireType.Varint).int32(message.steamOsCompatCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Platforms
 */
export const StoreItem_Platforms = new StoreItem_Platforms$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Platforms_VRSupport$Type extends MessageType<StoreItem_Platforms_VRSupport> {
    constructor() {
        super("StoreItem_Platforms_VRSupport", [
            { no: 1, name: "vrhmd", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "vrhmd_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 40, name: "htc_vive", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 41, name: "oculus_rift", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 42, name: "windows_mr", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 43, name: "valve_index", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Platforms_VRSupport>): StoreItem_Platforms_VRSupport {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Platforms_VRSupport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Platforms_VRSupport): StoreItem_Platforms_VRSupport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool vrhmd */ 1:
                    message.vrhmd = reader.bool();
                    break;
                case /* optional bool vrhmd_only */ 2:
                    message.vrhmdOnly = reader.bool();
                    break;
                case /* optional bool htc_vive */ 40:
                    message.htcVive = reader.bool();
                    break;
                case /* optional bool oculus_rift */ 41:
                    message.oculusRift = reader.bool();
                    break;
                case /* optional bool windows_mr */ 42:
                    message.windowsMr = reader.bool();
                    break;
                case /* optional bool valve_index */ 43:
                    message.valveIndex = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Platforms_VRSupport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool vrhmd = 1; */
        if (message.vrhmd !== undefined)
            writer.tag(1, WireType.Varint).bool(message.vrhmd);
        /* optional bool vrhmd_only = 2; */
        if (message.vrhmdOnly !== undefined)
            writer.tag(2, WireType.Varint).bool(message.vrhmdOnly);
        /* optional bool htc_vive = 40; */
        if (message.htcVive !== undefined)
            writer.tag(40, WireType.Varint).bool(message.htcVive);
        /* optional bool oculus_rift = 41; */
        if (message.oculusRift !== undefined)
            writer.tag(41, WireType.Varint).bool(message.oculusRift);
        /* optional bool windows_mr = 42; */
        if (message.windowsMr !== undefined)
            writer.tag(42, WireType.Varint).bool(message.windowsMr);
        /* optional bool valve_index = 43; */
        if (message.valveIndex !== undefined)
            writer.tag(43, WireType.Varint).bool(message.valveIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Platforms_VRSupport
 */
export const StoreItem_Platforms_VRSupport = new StoreItem_Platforms_VRSupport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_PurchaseOption$Type extends MessageType<StoreItem_PurchaseOption> {
    constructor() {
        super("StoreItem_PurchaseOption", [
            { no: 1, name: "packageid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "bundleid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "purchase_option_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "final_price_in_cents", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "original_price_in_cents", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "user_final_price_in_cents", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "formatted_final_price", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "formatted_original_price", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "discount_pct", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "user_discount_pct", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "bundle_discount_pct", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "is_free_to_keep", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "price_before_bundle_discount", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "formatted_price_before_bundle_discount", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "active_discounts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_PurchaseOption_Discount },
            { no: 21, name: "user_active_discounts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_PurchaseOption_Discount },
            { no: 22, name: "inactive_discounts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_PurchaseOption_Discount },
            { no: 30, name: "user_can_purchase", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 31, name: "user_can_purchase_as_gift", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 40, name: "is_commercial_license", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 41, name: "should_suppress_discount_pct", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 42, name: "hide_discount_pct_for_compliance", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 43, name: "included_game_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 44, name: "lowest_recent_price_in_cents", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 45, name: "requires_shipping", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 46, name: "recurrence_info", kind: "message", T: () => StoreItem_PurchaseOption_RecurrenceInfo },
            { no: 47, name: "free_to_keep_ends", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_PurchaseOption>): StoreItem_PurchaseOption {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activeDiscounts = [];
        message.userActiveDiscounts = [];
        message.inactiveDiscounts = [];
        if (value !== undefined)
            reflectionMergePartial<StoreItem_PurchaseOption>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_PurchaseOption): StoreItem_PurchaseOption {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 packageid */ 1:
                    message.packageid = reader.int32();
                    break;
                case /* optional int32 bundleid */ 2:
                    message.bundleid = reader.int32();
                    break;
                case /* optional string purchase_option_name */ 3:
                    message.purchaseOptionName = reader.string();
                    break;
                case /* optional int64 final_price_in_cents */ 5:
                    message.finalPriceInCents = reader.int64().toBigInt();
                    break;
                case /* optional int64 original_price_in_cents */ 6:
                    message.originalPriceInCents = reader.int64().toBigInt();
                    break;
                case /* optional int64 user_final_price_in_cents */ 7:
                    message.userFinalPriceInCents = reader.int64().toBigInt();
                    break;
                case /* optional string formatted_final_price */ 8:
                    message.formattedFinalPrice = reader.string();
                    break;
                case /* optional string formatted_original_price */ 9:
                    message.formattedOriginalPrice = reader.string();
                    break;
                case /* optional int32 discount_pct */ 10:
                    message.discountPct = reader.int32();
                    break;
                case /* optional int32 user_discount_pct */ 11:
                    message.userDiscountPct = reader.int32();
                    break;
                case /* optional int32 bundle_discount_pct */ 12:
                    message.bundleDiscountPct = reader.int32();
                    break;
                case /* optional bool is_free_to_keep */ 13:
                    message.isFreeToKeep = reader.bool();
                    break;
                case /* optional int64 price_before_bundle_discount */ 14:
                    message.priceBeforeBundleDiscount = reader.int64().toBigInt();
                    break;
                case /* optional string formatted_price_before_bundle_discount */ 15:
                    message.formattedPriceBeforeBundleDiscount = reader.string();
                    break;
                case /* repeated StoreItem_PurchaseOption_Discount active_discounts */ 20:
                    message.activeDiscounts.push(StoreItem_PurchaseOption_Discount.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated StoreItem_PurchaseOption_Discount user_active_discounts */ 21:
                    message.userActiveDiscounts.push(StoreItem_PurchaseOption_Discount.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated StoreItem_PurchaseOption_Discount inactive_discounts */ 22:
                    message.inactiveDiscounts.push(StoreItem_PurchaseOption_Discount.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool user_can_purchase */ 30:
                    message.userCanPurchase = reader.bool();
                    break;
                case /* optional bool user_can_purchase_as_gift */ 31:
                    message.userCanPurchaseAsGift = reader.bool();
                    break;
                case /* optional bool is_commercial_license */ 40:
                    message.isCommercialLicense = reader.bool();
                    break;
                case /* optional bool should_suppress_discount_pct */ 41:
                    message.shouldSuppressDiscountPct = reader.bool();
                    break;
                case /* optional bool hide_discount_pct_for_compliance = 42 [default = false] */ 42:
                    message.hideDiscountPctForCompliance = reader.bool();
                    break;
                case /* optional int32 included_game_count = 43 [default = 1] */ 43:
                    message.includedGameCount = reader.int32();
                    break;
                case /* optional int64 lowest_recent_price_in_cents */ 44:
                    message.lowestRecentPriceInCents = reader.int64().toBigInt();
                    break;
                case /* optional bool requires_shipping */ 45:
                    message.requiresShipping = reader.bool();
                    break;
                case /* optional StoreItem_PurchaseOption_RecurrenceInfo recurrence_info */ 46:
                    message.recurrenceInfo = StoreItem_PurchaseOption_RecurrenceInfo.internalBinaryRead(reader, reader.uint32(), options, message.recurrenceInfo);
                    break;
                case /* optional uint32 free_to_keep_ends */ 47:
                    message.freeToKeepEnds = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_PurchaseOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 packageid = 1; */
        if (message.packageid !== undefined)
            writer.tag(1, WireType.Varint).int32(message.packageid);
        /* optional int32 bundleid = 2; */
        if (message.bundleid !== undefined)
            writer.tag(2, WireType.Varint).int32(message.bundleid);
        /* optional string purchase_option_name = 3; */
        if (message.purchaseOptionName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.purchaseOptionName);
        /* optional int64 final_price_in_cents = 5; */
        if (message.finalPriceInCents !== undefined)
            writer.tag(5, WireType.Varint).int64(message.finalPriceInCents);
        /* optional int64 original_price_in_cents = 6; */
        if (message.originalPriceInCents !== undefined)
            writer.tag(6, WireType.Varint).int64(message.originalPriceInCents);
        /* optional int64 user_final_price_in_cents = 7; */
        if (message.userFinalPriceInCents !== undefined)
            writer.tag(7, WireType.Varint).int64(message.userFinalPriceInCents);
        /* optional string formatted_final_price = 8; */
        if (message.formattedFinalPrice !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.formattedFinalPrice);
        /* optional string formatted_original_price = 9; */
        if (message.formattedOriginalPrice !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.formattedOriginalPrice);
        /* optional int32 discount_pct = 10; */
        if (message.discountPct !== undefined)
            writer.tag(10, WireType.Varint).int32(message.discountPct);
        /* optional int32 user_discount_pct = 11; */
        if (message.userDiscountPct !== undefined)
            writer.tag(11, WireType.Varint).int32(message.userDiscountPct);
        /* optional int32 bundle_discount_pct = 12; */
        if (message.bundleDiscountPct !== undefined)
            writer.tag(12, WireType.Varint).int32(message.bundleDiscountPct);
        /* optional bool is_free_to_keep = 13; */
        if (message.isFreeToKeep !== undefined)
            writer.tag(13, WireType.Varint).bool(message.isFreeToKeep);
        /* optional int64 price_before_bundle_discount = 14; */
        if (message.priceBeforeBundleDiscount !== undefined)
            writer.tag(14, WireType.Varint).int64(message.priceBeforeBundleDiscount);
        /* optional string formatted_price_before_bundle_discount = 15; */
        if (message.formattedPriceBeforeBundleDiscount !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.formattedPriceBeforeBundleDiscount);
        /* repeated StoreItem_PurchaseOption_Discount active_discounts = 20; */
        for (let i = 0; i < message.activeDiscounts.length; i++)
            StoreItem_PurchaseOption_Discount.internalBinaryWrite(message.activeDiscounts[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_PurchaseOption_Discount user_active_discounts = 21; */
        for (let i = 0; i < message.userActiveDiscounts.length; i++)
            StoreItem_PurchaseOption_Discount.internalBinaryWrite(message.userActiveDiscounts[i], writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_PurchaseOption_Discount inactive_discounts = 22; */
        for (let i = 0; i < message.inactiveDiscounts.length; i++)
            StoreItem_PurchaseOption_Discount.internalBinaryWrite(message.inactiveDiscounts[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* optional bool user_can_purchase = 30; */
        if (message.userCanPurchase !== undefined)
            writer.tag(30, WireType.Varint).bool(message.userCanPurchase);
        /* optional bool user_can_purchase_as_gift = 31; */
        if (message.userCanPurchaseAsGift !== undefined)
            writer.tag(31, WireType.Varint).bool(message.userCanPurchaseAsGift);
        /* optional bool is_commercial_license = 40; */
        if (message.isCommercialLicense !== undefined)
            writer.tag(40, WireType.Varint).bool(message.isCommercialLicense);
        /* optional bool should_suppress_discount_pct = 41; */
        if (message.shouldSuppressDiscountPct !== undefined)
            writer.tag(41, WireType.Varint).bool(message.shouldSuppressDiscountPct);
        /* optional bool hide_discount_pct_for_compliance = 42 [default = false]; */
        if (message.hideDiscountPctForCompliance !== undefined)
            writer.tag(42, WireType.Varint).bool(message.hideDiscountPctForCompliance);
        /* optional int32 included_game_count = 43 [default = 1]; */
        if (message.includedGameCount !== undefined)
            writer.tag(43, WireType.Varint).int32(message.includedGameCount);
        /* optional int64 lowest_recent_price_in_cents = 44; */
        if (message.lowestRecentPriceInCents !== undefined)
            writer.tag(44, WireType.Varint).int64(message.lowestRecentPriceInCents);
        /* optional bool requires_shipping = 45; */
        if (message.requiresShipping !== undefined)
            writer.tag(45, WireType.Varint).bool(message.requiresShipping);
        /* optional StoreItem_PurchaseOption_RecurrenceInfo recurrence_info = 46; */
        if (message.recurrenceInfo)
            StoreItem_PurchaseOption_RecurrenceInfo.internalBinaryWrite(message.recurrenceInfo, writer.tag(46, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 free_to_keep_ends = 47; */
        if (message.freeToKeepEnds !== undefined)
            writer.tag(47, WireType.Varint).uint32(message.freeToKeepEnds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_PurchaseOption
 */
export const StoreItem_PurchaseOption = new StoreItem_PurchaseOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_PurchaseOption_Discount$Type extends MessageType<StoreItem_PurchaseOption_Discount> {
    constructor() {
        super("StoreItem_PurchaseOption_Discount", [
            { no: 1, name: "discount_amount", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "discount_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "discount_end_date", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_PurchaseOption_Discount>): StoreItem_PurchaseOption_Discount {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_PurchaseOption_Discount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_PurchaseOption_Discount): StoreItem_PurchaseOption_Discount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 discount_amount */ 1:
                    message.discountAmount = reader.int64().toBigInt();
                    break;
                case /* optional string discount_description */ 2:
                    message.discountDescription = reader.string();
                    break;
                case /* optional uint32 discount_end_date */ 3:
                    message.discountEndDate = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_PurchaseOption_Discount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 discount_amount = 1; */
        if (message.discountAmount !== undefined)
            writer.tag(1, WireType.Varint).int64(message.discountAmount);
        /* optional string discount_description = 2; */
        if (message.discountDescription !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.discountDescription);
        /* optional uint32 discount_end_date = 3; */
        if (message.discountEndDate !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.discountEndDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_PurchaseOption_Discount
 */
export const StoreItem_PurchaseOption_Discount = new StoreItem_PurchaseOption_Discount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_PurchaseOption_RecurrenceInfo$Type extends MessageType<StoreItem_PurchaseOption_RecurrenceInfo> {
    constructor() {
        super("StoreItem_PurchaseOption_RecurrenceInfo", [
            { no: 1, name: "packageid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "billing_agreement_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "renewal_time_unit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "renewal_time_period", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "renewal_price_in_cents", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "formatted_renewal_price", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_PurchaseOption_RecurrenceInfo>): StoreItem_PurchaseOption_RecurrenceInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_PurchaseOption_RecurrenceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_PurchaseOption_RecurrenceInfo): StoreItem_PurchaseOption_RecurrenceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 packageid */ 1:
                    message.packageid = reader.int32();
                    break;
                case /* optional int32 billing_agreement_type */ 2:
                    message.billingAgreementType = reader.int32();
                    break;
                case /* optional int32 renewal_time_unit */ 3:
                    message.renewalTimeUnit = reader.int32();
                    break;
                case /* optional int32 renewal_time_period */ 4:
                    message.renewalTimePeriod = reader.int32();
                    break;
                case /* optional int64 renewal_price_in_cents */ 5:
                    message.renewalPriceInCents = reader.int64().toBigInt();
                    break;
                case /* optional string formatted_renewal_price */ 6:
                    message.formattedRenewalPrice = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_PurchaseOption_RecurrenceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 packageid = 1; */
        if (message.packageid !== undefined)
            writer.tag(1, WireType.Varint).int32(message.packageid);
        /* optional int32 billing_agreement_type = 2; */
        if (message.billingAgreementType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.billingAgreementType);
        /* optional int32 renewal_time_unit = 3; */
        if (message.renewalTimeUnit !== undefined)
            writer.tag(3, WireType.Varint).int32(message.renewalTimeUnit);
        /* optional int32 renewal_time_period = 4; */
        if (message.renewalTimePeriod !== undefined)
            writer.tag(4, WireType.Varint).int32(message.renewalTimePeriod);
        /* optional int64 renewal_price_in_cents = 5; */
        if (message.renewalPriceInCents !== undefined)
            writer.tag(5, WireType.Varint).int64(message.renewalPriceInCents);
        /* optional string formatted_renewal_price = 6; */
        if (message.formattedRenewalPrice !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.formattedRenewalPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_PurchaseOption_RecurrenceInfo
 */
export const StoreItem_PurchaseOption_RecurrenceInfo = new StoreItem_PurchaseOption_RecurrenceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_RelatedItems$Type extends MessageType<StoreItem_RelatedItems> {
    constructor() {
        super("StoreItem_RelatedItems", [
            { no: 1, name: "parent_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "demo_appid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "standalone_demo_appid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_RelatedItems>): StoreItem_RelatedItems {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.demoAppid = [];
        message.standaloneDemoAppid = [];
        if (value !== undefined)
            reflectionMergePartial<StoreItem_RelatedItems>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_RelatedItems): StoreItem_RelatedItems {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 parent_appid */ 1:
                    message.parentAppid = reader.uint32();
                    break;
                case /* repeated uint32 demo_appid */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.demoAppid.push(reader.uint32());
                    else
                        message.demoAppid.push(reader.uint32());
                    break;
                case /* repeated uint32 standalone_demo_appid */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.standaloneDemoAppid.push(reader.uint32());
                    else
                        message.standaloneDemoAppid.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_RelatedItems, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 parent_appid = 1; */
        if (message.parentAppid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.parentAppid);
        /* repeated uint32 demo_appid = 2; */
        for (let i = 0; i < message.demoAppid.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.demoAppid[i]);
        /* repeated uint32 standalone_demo_appid = 3; */
        for (let i = 0; i < message.standaloneDemoAppid.length; i++)
            writer.tag(3, WireType.Varint).uint32(message.standaloneDemoAppid[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_RelatedItems
 */
export const StoreItem_RelatedItems = new StoreItem_RelatedItems$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_ReleaseInfo$Type extends MessageType<StoreItem_ReleaseInfo> {
    constructor() {
        super("StoreItem_ReleaseInfo", [
            { no: 1, name: "steam_release_date", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "original_release_date", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "original_steam_release_date", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_coming_soon", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_preload", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "custom_release_date_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "is_abridged_release_date", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "coming_soon_display", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "is_early_access", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "mac_release_date", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "linux_release_date", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "limited_launch_active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_ReleaseInfo>): StoreItem_ReleaseInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_ReleaseInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_ReleaseInfo): StoreItem_ReleaseInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 steam_release_date */ 1:
                    message.steamReleaseDate = reader.uint32();
                    break;
                case /* optional uint32 original_release_date */ 2:
                    message.originalReleaseDate = reader.uint32();
                    break;
                case /* optional uint32 original_steam_release_date */ 3:
                    message.originalSteamReleaseDate = reader.uint32();
                    break;
                case /* optional bool is_coming_soon */ 4:
                    message.isComingSoon = reader.bool();
                    break;
                case /* optional bool is_preload */ 5:
                    message.isPreload = reader.bool();
                    break;
                case /* optional string custom_release_date_message */ 6:
                    message.customReleaseDateMessage = reader.string();
                    break;
                case /* optional bool is_abridged_release_date */ 7:
                    message.isAbridgedReleaseDate = reader.bool();
                    break;
                case /* optional string coming_soon_display */ 8:
                    message.comingSoonDisplay = reader.string();
                    break;
                case /* optional bool is_early_access */ 10:
                    message.isEarlyAccess = reader.bool();
                    break;
                case /* optional uint32 mac_release_date */ 20:
                    message.macReleaseDate = reader.uint32();
                    break;
                case /* optional uint32 linux_release_date */ 21:
                    message.linuxReleaseDate = reader.uint32();
                    break;
                case /* optional bool limited_launch_active */ 22:
                    message.limitedLaunchActive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_ReleaseInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 steam_release_date = 1; */
        if (message.steamReleaseDate !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.steamReleaseDate);
        /* optional uint32 original_release_date = 2; */
        if (message.originalReleaseDate !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.originalReleaseDate);
        /* optional uint32 original_steam_release_date = 3; */
        if (message.originalSteamReleaseDate !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.originalSteamReleaseDate);
        /* optional bool is_coming_soon = 4; */
        if (message.isComingSoon !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isComingSoon);
        /* optional bool is_preload = 5; */
        if (message.isPreload !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isPreload);
        /* optional string custom_release_date_message = 6; */
        if (message.customReleaseDateMessage !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.customReleaseDateMessage);
        /* optional bool is_abridged_release_date = 7; */
        if (message.isAbridgedReleaseDate !== undefined)
            writer.tag(7, WireType.Varint).bool(message.isAbridgedReleaseDate);
        /* optional string coming_soon_display = 8; */
        if (message.comingSoonDisplay !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.comingSoonDisplay);
        /* optional bool is_early_access = 10; */
        if (message.isEarlyAccess !== undefined)
            writer.tag(10, WireType.Varint).bool(message.isEarlyAccess);
        /* optional uint32 mac_release_date = 20; */
        if (message.macReleaseDate !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.macReleaseDate);
        /* optional uint32 linux_release_date = 21; */
        if (message.linuxReleaseDate !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.linuxReleaseDate);
        /* optional bool limited_launch_active = 22; */
        if (message.limitedLaunchActive !== undefined)
            writer.tag(22, WireType.Varint).bool(message.limitedLaunchActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_ReleaseInfo
 */
export const StoreItem_ReleaseInfo = new StoreItem_ReleaseInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Reviews$Type extends MessageType<StoreItem_Reviews> {
    constructor() {
        super("StoreItem_Reviews", [
            { no: 1, name: "summary_filtered", kind: "message", T: () => StoreItem_Reviews_StoreReviewSummary },
            { no: 2, name: "summary_unfiltered", kind: "message", T: () => StoreItem_Reviews_StoreReviewSummary }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Reviews>): StoreItem_Reviews {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Reviews>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Reviews): StoreItem_Reviews {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional StoreItem_Reviews_StoreReviewSummary summary_filtered */ 1:
                    message.summaryFiltered = StoreItem_Reviews_StoreReviewSummary.internalBinaryRead(reader, reader.uint32(), options, message.summaryFiltered);
                    break;
                case /* optional StoreItem_Reviews_StoreReviewSummary summary_unfiltered */ 2:
                    message.summaryUnfiltered = StoreItem_Reviews_StoreReviewSummary.internalBinaryRead(reader, reader.uint32(), options, message.summaryUnfiltered);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Reviews, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional StoreItem_Reviews_StoreReviewSummary summary_filtered = 1; */
        if (message.summaryFiltered)
            StoreItem_Reviews_StoreReviewSummary.internalBinaryWrite(message.summaryFiltered, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional StoreItem_Reviews_StoreReviewSummary summary_unfiltered = 2; */
        if (message.summaryUnfiltered)
            StoreItem_Reviews_StoreReviewSummary.internalBinaryWrite(message.summaryUnfiltered, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Reviews
 */
export const StoreItem_Reviews = new StoreItem_Reviews$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Reviews_StoreReviewSummary$Type extends MessageType<StoreItem_Reviews_StoreReviewSummary> {
    constructor() {
        super("StoreItem_Reviews_StoreReviewSummary", [
            { no: 1, name: "review_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "percent_positive", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "review_score", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 4, name: "review_score_label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Reviews_StoreReviewSummary>): StoreItem_Reviews_StoreReviewSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Reviews_StoreReviewSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Reviews_StoreReviewSummary): StoreItem_Reviews_StoreReviewSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 review_count */ 1:
                    message.reviewCount = reader.uint32();
                    break;
                case /* optional int32 percent_positive */ 2:
                    message.percentPositive = reader.int32();
                    break;
                case /* optional int32 review_score */ 3:
                    message.reviewScore = reader.int32();
                    break;
                case /* optional string review_score_label */ 4:
                    message.reviewScoreLabel = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Reviews_StoreReviewSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 review_count = 1; */
        if (message.reviewCount !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.reviewCount);
        /* optional int32 percent_positive = 2; */
        if (message.percentPositive !== undefined)
            writer.tag(2, WireType.Varint).int32(message.percentPositive);
        /* optional int32 review_score = 3; */
        if (message.reviewScore !== undefined)
            writer.tag(3, WireType.Varint).int32(message.reviewScore);
        /* optional string review_score_label = 4; */
        if (message.reviewScoreLabel !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.reviewScoreLabel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Reviews_StoreReviewSummary
 */
export const StoreItem_Reviews_StoreReviewSummary = new StoreItem_Reviews_StoreReviewSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Screenshots$Type extends MessageType<StoreItem_Screenshots> {
    constructor() {
        super("StoreItem_Screenshots", [
            { no: 2, name: "all_ages_screenshots", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_Screenshots_Screenshot },
            { no: 3, name: "mature_content_screenshots", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_Screenshots_Screenshot }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Screenshots>): StoreItem_Screenshots {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allAgesScreenshots = [];
        message.matureContentScreenshots = [];
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Screenshots>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Screenshots): StoreItem_Screenshots {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated StoreItem_Screenshots_Screenshot all_ages_screenshots */ 2:
                    message.allAgesScreenshots.push(StoreItem_Screenshots_Screenshot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated StoreItem_Screenshots_Screenshot mature_content_screenshots */ 3:
                    message.matureContentScreenshots.push(StoreItem_Screenshots_Screenshot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Screenshots, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated StoreItem_Screenshots_Screenshot all_ages_screenshots = 2; */
        for (let i = 0; i < message.allAgesScreenshots.length; i++)
            StoreItem_Screenshots_Screenshot.internalBinaryWrite(message.allAgesScreenshots[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_Screenshots_Screenshot mature_content_screenshots = 3; */
        for (let i = 0; i < message.matureContentScreenshots.length; i++)
            StoreItem_Screenshots_Screenshot.internalBinaryWrite(message.matureContentScreenshots[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Screenshots
 */
export const StoreItem_Screenshots = new StoreItem_Screenshots$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Screenshots_Screenshot$Type extends MessageType<StoreItem_Screenshots_Screenshot> {
    constructor() {
        super("StoreItem_Screenshots_Screenshot", [
            { no: 1, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ordinal", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Screenshots_Screenshot>): StoreItem_Screenshots_Screenshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Screenshots_Screenshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Screenshots_Screenshot): StoreItem_Screenshots_Screenshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string filename */ 1:
                    message.filename = reader.string();
                    break;
                case /* optional int32 ordinal */ 2:
                    message.ordinal = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Screenshots_Screenshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string filename = 1; */
        if (message.filename !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.filename);
        /* optional int32 ordinal = 2; */
        if (message.ordinal !== undefined)
            writer.tag(2, WireType.Varint).int32(message.ordinal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Screenshots_Screenshot
 */
export const StoreItem_Screenshots_Screenshot = new StoreItem_Screenshots_Screenshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_SupportedLanguage$Type extends MessageType<StoreItem_SupportedLanguage> {
    constructor() {
        super("StoreItem_SupportedLanguage", [
            { no: 1, name: "elanguage", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "supported", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "full_audio", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "subtitles", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "eadditionallanguage", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_SupportedLanguage>): StoreItem_SupportedLanguage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_SupportedLanguage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_SupportedLanguage): StoreItem_SupportedLanguage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 elanguage = 1 [default = -1] */ 1:
                    message.elanguage = reader.int32();
                    break;
                case /* optional bool supported */ 2:
                    message.supported = reader.bool();
                    break;
                case /* optional bool full_audio */ 3:
                    message.fullAudio = reader.bool();
                    break;
                case /* optional bool subtitles */ 4:
                    message.subtitles = reader.bool();
                    break;
                case /* optional int32 eadditionallanguage = 5 [default = -1] */ 5:
                    message.eadditionallanguage = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_SupportedLanguage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 elanguage = 1 [default = -1]; */
        if (message.elanguage !== undefined)
            writer.tag(1, WireType.Varint).int32(message.elanguage);
        /* optional bool supported = 2; */
        if (message.supported !== undefined)
            writer.tag(2, WireType.Varint).bool(message.supported);
        /* optional bool full_audio = 3; */
        if (message.fullAudio !== undefined)
            writer.tag(3, WireType.Varint).bool(message.fullAudio);
        /* optional bool subtitles = 4; */
        if (message.subtitles !== undefined)
            writer.tag(4, WireType.Varint).bool(message.subtitles);
        /* optional int32 eadditionallanguage = 5 [default = -1]; */
        if (message.eadditionallanguage !== undefined)
            writer.tag(5, WireType.Varint).int32(message.eadditionallanguage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_SupportedLanguage
 */
export const StoreItem_SupportedLanguage = new StoreItem_SupportedLanguage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Tag$Type extends MessageType<StoreItem_Tag> {
    constructor() {
        super("StoreItem_Tag", [
            { no: 1, name: "tagid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "weight", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Tag>): StoreItem_Tag {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Tag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Tag): StoreItem_Tag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 tagid */ 1:
                    message.tagid = reader.uint32();
                    break;
                case /* optional uint32 weight */ 2:
                    message.weight = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Tag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 tagid = 1; */
        if (message.tagid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.tagid);
        /* optional uint32 weight = 2; */
        if (message.weight !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.weight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Tag
 */
export const StoreItem_Tag = new StoreItem_Tag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Trailers$Type extends MessageType<StoreItem_Trailers> {
    constructor() {
        super("StoreItem_Trailers", [
            { no: 1, name: "highlights", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_Trailers_Trailer },
            { no: 2, name: "other_trailers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_Trailers_Trailer }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Trailers>): StoreItem_Trailers {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.highlights = [];
        message.otherTrailers = [];
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Trailers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Trailers): StoreItem_Trailers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated StoreItem_Trailers_Trailer highlights */ 1:
                    message.highlights.push(StoreItem_Trailers_Trailer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated StoreItem_Trailers_Trailer other_trailers */ 2:
                    message.otherTrailers.push(StoreItem_Trailers_Trailer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Trailers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated StoreItem_Trailers_Trailer highlights = 1; */
        for (let i = 0; i < message.highlights.length; i++)
            StoreItem_Trailers_Trailer.internalBinaryWrite(message.highlights[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_Trailers_Trailer other_trailers = 2; */
        for (let i = 0; i < message.otherTrailers.length; i++)
            StoreItem_Trailers_Trailer.internalBinaryWrite(message.otherTrailers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Trailers
 */
export const StoreItem_Trailers = new StoreItem_Trailers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Trailers_Trailer$Type extends MessageType<StoreItem_Trailers_Trailer> {
    constructor() {
        super("StoreItem_Trailers_Trailer", [
            { no: 1, name: "trailer_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "trailer_url_format", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "trailer_480p", kind: "message", jsonName: "trailer480p", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_Trailers_VideoSource },
            { no: 4, name: "trailer_max", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_Trailers_VideoSource },
            { no: 5, name: "microtrailer", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StoreItem_Trailers_VideoSource },
            { no: 10, name: "screenshot_medium", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "screenshot_full", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "trailer_base_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "trailer_category", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/, options: { description: "enum" } },
            { no: 14, name: "all_ages", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Trailers_Trailer>): StoreItem_Trailers_Trailer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trailer480P = [];
        message.trailerMax = [];
        message.microtrailer = [];
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Trailers_Trailer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Trailers_Trailer): StoreItem_Trailers_Trailer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string trailer_name */ 1:
                    message.trailerName = reader.string();
                    break;
                case /* optional string trailer_url_format */ 2:
                    message.trailerUrlFormat = reader.string();
                    break;
                case /* repeated StoreItem_Trailers_VideoSource trailer_480p */ 3:
                    message.trailer480P.push(StoreItem_Trailers_VideoSource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated StoreItem_Trailers_VideoSource trailer_max */ 4:
                    message.trailerMax.push(StoreItem_Trailers_VideoSource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated StoreItem_Trailers_VideoSource microtrailer */ 5:
                    message.microtrailer.push(StoreItem_Trailers_VideoSource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string screenshot_medium */ 10:
                    message.screenshotMedium = reader.string();
                    break;
                case /* optional string screenshot_full */ 11:
                    message.screenshotFull = reader.string();
                    break;
                case /* optional int32 trailer_base_id */ 12:
                    message.trailerBaseId = reader.int32();
                    break;
                case /* optional int32 trailer_category */ 13:
                    message.trailerCategory = reader.int32();
                    break;
                case /* optional bool all_ages */ 14:
                    message.allAges = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Trailers_Trailer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string trailer_name = 1; */
        if (message.trailerName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.trailerName);
        /* optional string trailer_url_format = 2; */
        if (message.trailerUrlFormat !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.trailerUrlFormat);
        /* repeated StoreItem_Trailers_VideoSource trailer_480p = 3; */
        for (let i = 0; i < message.trailer480P.length; i++)
            StoreItem_Trailers_VideoSource.internalBinaryWrite(message.trailer480P[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_Trailers_VideoSource trailer_max = 4; */
        for (let i = 0; i < message.trailerMax.length; i++)
            StoreItem_Trailers_VideoSource.internalBinaryWrite(message.trailerMax[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated StoreItem_Trailers_VideoSource microtrailer = 5; */
        for (let i = 0; i < message.microtrailer.length; i++)
            StoreItem_Trailers_VideoSource.internalBinaryWrite(message.microtrailer[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional string screenshot_medium = 10; */
        if (message.screenshotMedium !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.screenshotMedium);
        /* optional string screenshot_full = 11; */
        if (message.screenshotFull !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.screenshotFull);
        /* optional int32 trailer_base_id = 12; */
        if (message.trailerBaseId !== undefined)
            writer.tag(12, WireType.Varint).int32(message.trailerBaseId);
        /* optional int32 trailer_category = 13; */
        if (message.trailerCategory !== undefined)
            writer.tag(13, WireType.Varint).int32(message.trailerCategory);
        /* optional bool all_ages = 14; */
        if (message.allAges !== undefined)
            writer.tag(14, WireType.Varint).bool(message.allAges);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Trailers_Trailer
 */
export const StoreItem_Trailers_Trailer = new StoreItem_Trailers_Trailer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItem_Trailers_VideoSource$Type extends MessageType<StoreItem_Trailers_VideoSource> {
    constructor() {
        super("StoreItem_Trailers_VideoSource", [
            { no: 1, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItem_Trailers_VideoSource>): StoreItem_Trailers_VideoSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItem_Trailers_VideoSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItem_Trailers_VideoSource): StoreItem_Trailers_VideoSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string filename */ 1:
                    message.filename = reader.string();
                    break;
                case /* optional string type */ 2:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItem_Trailers_VideoSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string filename = 1; */
        if (message.filename !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.filename);
        /* optional string type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItem_Trailers_VideoSource
 */
export const StoreItem_Trailers_VideoSource = new StoreItem_Trailers_VideoSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItemID$Type extends MessageType<StoreItemID> {
    constructor() {
        super("StoreItemID", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "packageid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "bundleid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "tagid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "creatorid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "hubcategoryid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItemID>): StoreItemID {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StoreItemID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItemID): StoreItemID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 packageid */ 2:
                    message.packageid = reader.uint32();
                    break;
                case /* optional uint32 bundleid */ 3:
                    message.bundleid = reader.uint32();
                    break;
                case /* optional uint32 tagid */ 4:
                    message.tagid = reader.uint32();
                    break;
                case /* optional uint32 creatorid */ 5:
                    message.creatorid = reader.uint32();
                    break;
                case /* optional uint32 hubcategoryid */ 6:
                    message.hubcategoryid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItemID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 packageid = 2; */
        if (message.packageid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.packageid);
        /* optional uint32 bundleid = 3; */
        if (message.bundleid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.bundleid);
        /* optional uint32 tagid = 4; */
        if (message.tagid !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.tagid);
        /* optional uint32 creatorid = 5; */
        if (message.creatorid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.creatorid);
        /* optional uint32 hubcategoryid = 6; */
        if (message.hubcategoryid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.hubcategoryid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItemID
 */
export const StoreItemID = new StoreItemID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserContentDescriptorPreferences$Type extends MessageType<UserContentDescriptorPreferences> {
    constructor() {
        super("UserContentDescriptorPreferences", [
            { no: 1, name: "content_descriptors_to_exclude", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserContentDescriptorPreferences_ContentDescriptor }
        ]);
    }
    create(value?: PartialMessage<UserContentDescriptorPreferences>): UserContentDescriptorPreferences {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contentDescriptorsToExclude = [];
        if (value !== undefined)
            reflectionMergePartial<UserContentDescriptorPreferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserContentDescriptorPreferences): UserContentDescriptorPreferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated UserContentDescriptorPreferences_ContentDescriptor content_descriptors_to_exclude */ 1:
                    message.contentDescriptorsToExclude.push(UserContentDescriptorPreferences_ContentDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserContentDescriptorPreferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated UserContentDescriptorPreferences_ContentDescriptor content_descriptors_to_exclude = 1; */
        for (let i = 0; i < message.contentDescriptorsToExclude.length; i++)
            UserContentDescriptorPreferences_ContentDescriptor.internalBinaryWrite(message.contentDescriptorsToExclude[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UserContentDescriptorPreferences
 */
export const UserContentDescriptorPreferences = new UserContentDescriptorPreferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserContentDescriptorPreferences_ContentDescriptor$Type extends MessageType<UserContentDescriptorPreferences_ContentDescriptor> {
    constructor() {
        super("UserContentDescriptorPreferences_ContentDescriptor", [
            { no: 1, name: "content_descriptorid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "timestamp_added", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UserContentDescriptorPreferences_ContentDescriptor>): UserContentDescriptorPreferences_ContentDescriptor {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserContentDescriptorPreferences_ContentDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserContentDescriptorPreferences_ContentDescriptor): UserContentDescriptorPreferences_ContentDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 content_descriptorid */ 1:
                    message.contentDescriptorid = reader.uint32();
                    break;
                case /* optional uint32 timestamp_added */ 2:
                    message.timestampAdded = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserContentDescriptorPreferences_ContentDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 content_descriptorid = 1; */
        if (message.contentDescriptorid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.contentDescriptorid);
        /* optional uint32 timestamp_added = 2; */
        if (message.timestampAdded !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.timestampAdded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UserContentDescriptorPreferences_ContentDescriptor
 */
export const UserContentDescriptorPreferences_ContentDescriptor = new UserContentDescriptorPreferences_ContentDescriptor$Type();
